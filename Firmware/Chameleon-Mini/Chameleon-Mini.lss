
Chameleon-Mini.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .flashdata    00010000  00010000  00010000  00010506  2**1
                  CONTENTS, READONLY
  1 .spmhelper    00000014  00021fe0  00021fe0  00020506  2**0
                  CONTENTS, READONLY
  2 .text         0000ff62  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         0000048c  00802000  0000ff62  00010016  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00001349  0080248c  0080248c  000104a2  2**0
                  ALLOC
  5 .eeprom       00000064  00810000  00810000  000104a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .comment      0000005c  00000000  00000000  0002051a  2**0
                  CONTENTS, READONLY
  7 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00020578  2**2
                  CONTENTS, READONLY
  8 .debug_aranges 00001008  00000000  00000000  000205b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00039011  00000000  00000000  000215c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000a148  00000000  00000000  0005a5d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000124a4  00000000  00000000  00064719  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  0000308c  00000000  00000000  00076bc0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0000b8e0  00000000  00000000  00079c4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00016020  00000000  00000000  0008552c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001448  00000000  00000000  0009b550  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ee 0c 	jmp	0x19dc	; 0x19dc <__ctors_end>
       4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
       8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
       c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      10:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      14:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      18:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      1c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      20:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      24:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      28:	0c 94 df 0f 	jmp	0x1fbe	; 0x1fbe <__vector_10>
      2c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      30:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      34:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      38:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      3c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      40:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      44:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      48:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      4c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      50:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      54:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      58:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      5c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      60:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      64:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      68:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      6c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      70:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      74:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      78:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      7c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      80:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      84:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      88:	0c 94 14 0d 	jmp	0x1a28	; 0x1a28 <__vector_34>
      8c:	0c 94 55 30 	jmp	0x60aa	; 0x60aa <__vector_35>
      90:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      94:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      98:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      9c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      a0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      a4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      a8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      ac:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      b0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      b4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      b8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      bc:	0c 94 ee 27 	jmp	0x4fdc	; 0x4fdc <__vector_47>
      c0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      c4:	0c 94 84 2b 	jmp	0x5708	; 0x5708 <__vector_49>
      c8:	0c 94 c3 31 	jmp	0x6386	; 0x6386 <__vector_50>
      cc:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      d0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      d4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      d8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      dc:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      e0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      e4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      e8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      ec:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      f0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      f4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      f8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
      fc:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     100:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     104:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     108:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     10c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     110:	0c 94 9c 31 	jmp	0x6338	; 0x6338 <__vector_68>
     114:	0c 94 5f 2b 	jmp	0x56be	; 0x56be <__vector_69>
     118:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     11c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     120:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     124:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     128:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     12c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     130:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     134:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     138:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     13c:	0c 94 57 27 	jmp	0x4eae	; 0x4eae <__vector_79>
     140:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__vector_80>
     144:	0c 94 1e 0d 	jmp	0x1a3c	; 0x1a3c <__vector_81>
     148:	0c 94 81 30 	jmp	0x6102	; 0x6102 <__vector_82>
     14c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     150:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     154:	0c 94 d6 2a 	jmp	0x55ac	; 0x55ac <__vector_85>
     158:	0c 94 f9 31 	jmp	0x63f2	; 0x63f2 <__vector_86>
     15c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     160:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     164:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     168:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     16c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     170:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     174:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     178:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     17c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     180:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     184:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     188:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     18c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     190:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     194:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     198:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     19c:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1a0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1a4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1a8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1ac:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1b0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1b4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1b8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1bc:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1c0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1c4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1c8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1cc:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1d0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1d4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1d8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1dc:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1e0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1e4:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1e8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1ec:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1f0:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>
     1f4:	0c 94 ec 73 	jmp	0xe7d8	; 0xe7d8 <__vector_125>
     1f8:	0c 94 13 0d 	jmp	0x1a26	; 0x1a26 <__bad_interrupt>

000001fc <__trampolines_end>:
     1fc:	63 64       	ori	r22, 0x43	; 67
     1fe:	69 6e       	ori	r22, 0xE9	; 233
     200:	6f 70       	andi	r22, 0x0F	; 15
     202:	73 75       	andi	r23, 0x53	; 83
     204:	78 58       	subi	r23, 0x88	; 136
     206:	5b 00       	.word	0x005b	; ????

00000208 <ProductString>:
     208:	1e 03 43 00 68 00 61 00 6d 00 65 00 6c 00 65 00     ..C.h.a.m.e.l.e.
     218:	6f 00 6e 00 2d 00 4d 00 69 00 6e 00 69 00 00 00     o.n.-.M.i.n.i...

00000228 <ManufacturerString>:
     228:	2a 03 4b 00 61 00 73 00 70 00 65 00 72 00 20 00     *.K.a.s.p.e.r. .
     238:	26 00 20 00 4f 00 73 00 77 00 61 00 6c 00 64 00     &. .O.s.w.a.l.d.
     248:	20 00 47 00 6d 00 62 00 48 00 00 00                  .G.m.b.H...

00000254 <LanguageString>:
     254:	04 03 09 04                                         ....

00000258 <ConfigurationDescriptor>:
     258:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     268:	01 00 05 24 00 10 01 04 24 02 06 05 24 06 00 01     ...$....$...$...
     278:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     288:	07 05 04 02 10 00 05 07 05 83 02 10 00 05           ..............

00000296 <DeviceDescriptor>:
     296:	12 01 10 01 02 00 00 08 d0 16 b2 04 01 00 01 02     ................
     2a6:	dc 01                                               ..

000002a8 <ConfigurationTable>:
     2a8:	8f 10 90 10 91 10 92 10 93 10 94 10 89 10 8a 10     ................
     2b8:	8e 10 8d 10 00 00 00 01 00 af 28 30 29 4f 29 61     ..........(0)O)a
     2c8:	35 7d 35 87 35 89 10 88 35 97 39 aa 39 40 00 07     5}5.5...5.9.9@..
     2d8:	00 01 af 28 30 29 4f 29 eb 34 81 35 87 35 89 10     ...(0)O).4.5.5..
     2e8:	88 35 97 39 aa 39 c0 00 07 00 01 af 28 30 29 4f     .5.9.9......(0)O
     2f8:	29 75 35 7d 35 87 35 89 10 88 35 97 39 aa 39 50     )u5}5.5...5.9.9P
     308:	00 07 00 01 af 28 30 29 4f 29 79 35 7d 35 87 35     .....(0)O)y5}5.5
     318:	89 10 88 35 97 39 aa 39 a4 00 07 00 01 af 28 30     ...5.9.9......(0
     328:	29 4f 29 ea 39 35 3a 39 3a 89 10 3a 3a 1b 41 37     )O).95:9:..::.A7
     338:	41 40 01 04 00 01 af 28 30 29 4f 29 f9 39 35 3a     A@.....(0)O).95:
     348:	39 3a 89 10 3a 3a 1b 41 37 41 00 04 04 00 01 af     9:..::.A7A......
     358:	28 30 29 4f 29 08 3a 35 3a 39 3a 89 10 3a 3a 1b     (0)O).:5:9:..::.
     368:	41 37 41 00 04 07 00 01 af 28 30 29 4f 29 17 3a     A7A......(0)O).:
     378:	35 3a 39 3a 89 10 3a 3a 1b 41 37 41 00 10 04 00     5:9:..::.A7A....
     388:	01 af 28 30 29 4f 29 26 3a 35 3a 39 3a 89 10 3a     ..(0)O)&:5:9:..:
     398:	3a 1b 41 37 41 00 10 07 00 01 b3 32 72 33 93 33     :.A7A......2r3.3
     3a8:	1e 58 2c 58 31 58 32 58 34 58 8e 10 8d 10 00 00     .X,X1X2X4X......
     3b8:	00 01 00 2a 2a b2 2a 20 2c 12 50 15 50 22 50 23     ...**.* ,.P.P"P#
     3c8:	50 c2 52 8e 10 8d 10 00 00 00 00 00 af 28 30 29     P.R..........(0)
     3d8:	4f 29 19 5d 3d 5d 41 5d 89 10 42 5d c5 5f d8 5f     O).]=]A]..B]._._
     3e8:	1c 02 07 00 00 df 62 62 63 95 63 29 64 2c 64 2f     ......bbc.c)d,d/
     3f8:	64 30 64 31 64 15 65 1c 65 00 20 08 00 05 df 62     d0d1d.e.e. ....b
     408:	62 63 95 63 92 10 93 10 94 10 89 10 8a 10 8e 10     bc.c............
     418:	8d 10 00 00 00 01 00 df 62 62 63 95 63 23 65 26     ........bbc.c#e&
     428:	65 29 65 2a 65 2b 65 25 67 2c 67 00 20 08 00 05     e)e*e+e%g,g. ...
     438:	df 62 62 63 95 63 33 67 51 67 5f 67 60 67 80 67     .bbc.c3gQg_g`g.g
     448:	72 67 d1 68 2c 00 08 00 05 af 28 30 29 4f 29 c2     rg.h,.....(0)O).
     458:	59 d6 59 da 59 89 10 dc 5a 8e 10 8d 10 40 00 07     Y.Y.Y...Z....@..
     468:	00 01 df 62 62 63 95 63 fd 69 14 6a 24 6a 25 6a     ...bbc.c.i.j$j%j
     478:	d9 6d 6b 6d f6 6e d0 00 08 00 05                    .mkm.n.....

00000483 <ConfigurationMap>:
     483:	00 4e 4f 4e 45 00 00 00 00 00 00 00 00 00 00 00     .NONE...........
     493:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     4a3:	00 01 4d 46 5f 55 4c 54 52 41 4c 49 47 48 54 00     ..MF_ULTRALIGHT.
     4b3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     4c3:	00 00 03 4d 46 5f 55 4c 54 52 41 4c 49 47 48 54     ...MF_ULTRALIGHT
     4d3:	5f 45 56 31 5f 38 30 42 00 00 00 00 00 00 00 00     _EV1_80B........
     4e3:	00 00 00 04 4d 46 5f 55 4c 54 52 41 4c 49 47 48     ....MF_ULTRALIGH
     4f3:	54 5f 45 56 31 5f 31 36 34 42 00 00 00 00 00 00     T_EV1_164B......
     503:	00 00 00 00 02 4d 46 5f 55 4c 54 52 41 4c 49 47     .....MF_ULTRALIG
     513:	48 54 5f 43 00 00 00 00 00 00 00 00 00 00 00 00     HT_C............
     523:	00 00 00 00 00 05 4d 46 5f 43 4c 41 53 53 49 43     ......MF_CLASSIC
     533:	5f 4d 49 4e 49 5f 34 42 00 00 00 00 00 00 00 00     _MINI_4B........
     543:	00 00 00 00 00 00 06 4d 46 5f 43 4c 41 53 53 49     .......MF_CLASSI
     553:	43 5f 31 4b 00 00 00 00 00 00 00 00 00 00 00 00     C_1K............
     563:	00 00 00 00 00 00 00 07 4d 46 5f 43 4c 41 53 53     ........MF_CLASS
     573:	49 43 5f 31 4b 5f 37 42 00 00 00 00 00 00 00 00     IC_1K_7B........
     583:	00 00 00 00 00 00 00 00 08 4d 46 5f 43 4c 41 53     .........MF_CLAS
     593:	53 49 43 5f 34 4b 00 00 00 00 00 00 00 00 00 00     SIC_4K..........
     5a3:	00 00 00 00 00 00 00 00 00 09 4d 46 5f 43 4c 41     ..........MF_CLA
     5b3:	53 53 49 43 5f 34 4b 5f 37 42 00 00 00 00 00 00     SSIC_4K_7B......
     5c3:	00 00 00 00 00 00 00 00 00 00 0a 49 53 4f 31 34     ...........ISO14
     5d3:	34 34 33 41 5f 53 4e 49 46 46 00 00 00 00 00 00     443A_SNIFF......
     5e3:	00 00 00 00 00 00 00 00 00 00 00 0b 49 53 4f 31     ............ISO1
     5f3:	34 34 34 33 41 5f 52 45 41 44 45 52 00 00 00 00     4443A_READER....
     603:	00 00 00 00 00 00 00 00 00 00 00 00 0c 4e 54 41     .............NTA
     613:	47 32 31 35 00 00 00 00 00 00 00 00 00 00 00 00     G215............
     623:	00 00 00 00 00 00 00 00 00 00 00 00 00 0d 56 49     ..............VI
     633:	43 49 4e 49 54 59 00 00 00 00 00 00 00 00 00 00     CINITY..........
     643:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0e 49     ...............I
     653:	53 4f 31 35 36 39 33 5f 53 4e 49 46 46 00 00 00     SO15693_SNIFF...
     663:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0f     ................
     673:	53 4c 32 53 32 30 30 32 00 00 00 00 00 00 00 00     SL2S2002........
     683:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     693:	10 54 49 54 41 47 49 54 53 54 41 4e 44 41 52 44     .TITAGITSTANDARD
     6a3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6b3:	00 12 45 4d 34 32 33 33 00 00 00 00 00 00 00 00     ..EM4233........
     6c3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6d3:	00 00 11 4e 46 43 5f 43 4f 4d 4d 41 4e 44 00 00     ...NFC_COMMAND..
     6e3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6f3:	00 00 00                                            ...

000006f6 <OddParityByteTable>:
     6f6:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     706:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     716:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     726:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     736:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     746:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     756:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     766:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     776:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     786:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     796:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     7a6:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     7b6:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     7c6:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     7d6:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     7e6:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................

000007f6 <BitReverseByteTable>:
     7f6:	00 80 40 c0 20 a0 60 e0 10 90 50 d0 30 b0 70 f0     ..@. .`...P.0.p.
     806:	08 88 48 c8 28 a8 68 e8 18 98 58 d8 38 b8 78 f8     ..H.(.h...X.8.x.
     816:	04 84 44 c4 24 a4 64 e4 14 94 54 d4 34 b4 74 f4     ..D.$.d...T.4.t.
     826:	0c 8c 4c cc 2c ac 6c ec 1c 9c 5c dc 3c bc 7c fc     ..L.,.l...\.<.|.
     836:	02 82 42 c2 22 a2 62 e2 12 92 52 d2 32 b2 72 f2     ..B.".b...R.2.r.
     846:	0a 8a 4a ca 2a aa 6a ea 1a 9a 5a da 3a ba 7a fa     ..J.*.j...Z.:.z.
     856:	06 86 46 c6 26 a6 66 e6 16 96 56 d6 36 b6 76 f6     ..F.&.f...V.6.v.
     866:	0e 8e 4e ce 2e ae 6e ee 1e 9e 5e de 3e be 7e fe     ..N...n...^.>.~.
     876:	01 81 41 c1 21 a1 61 e1 11 91 51 d1 31 b1 71 f1     ..A.!.a...Q.1.q.
     886:	09 89 49 c9 29 a9 69 e9 19 99 59 d9 39 b9 79 f9     ..I.).i...Y.9.y.
     896:	05 85 45 c5 25 a5 65 e5 15 95 55 d5 35 b5 75 f5     ..E.%.e...U.5.u.
     8a6:	0d 8d 4d cd 2d ad 6d ed 1d 9d 5d dd 3d bd 7d fd     ..M.-.m...].=.}.
     8b6:	03 83 43 c3 23 a3 63 e3 13 93 53 d3 33 b3 73 f3     ..C.#.c...S.3.s.
     8c6:	0b 8b 4b cb 2b ab 6b eb 1b 9b 5b db 3b bb 7b fb     ..K.+.k...[.;.{.
     8d6:	07 87 47 c7 27 a7 67 e7 17 97 57 d7 37 b7 77 f7     ..G.'.g...W.7.w.
     8e6:	0f 8f 4f cf 2f af 6f ef 1f 9f 5f df 3f bf 7f ff     ..O./.o..._.?...

000008f6 <ButtonActionMap>:
     8f6:	00 4e 4f 4e 45 00 00 00 00 00 00 00 00 00 00 00     .NONE...........
     906:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     916:	00 01 55 49 44 5f 52 41 4e 44 4f 4d 00 00 00 00     ..UID_RANDOM....
     926:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     936:	00 00 02 55 49 44 5f 4c 45 46 54 5f 49 4e 43 52     ...UID_LEFT_INCR
     946:	45 4d 45 4e 54 00 00 00 00 00 00 00 00 00 00 00     EMENT...........
     956:	00 00 00 03 55 49 44 5f 52 49 47 48 54 5f 49 4e     ....UID_RIGHT_IN
     966:	43 52 45 4d 45 4e 54 00 00 00 00 00 00 00 00 00     CREMENT.........
     976:	00 00 00 00 04 55 49 44 5f 4c 45 46 54 5f 44 45     .....UID_LEFT_DE
     986:	43 52 45 4d 45 4e 54 00 00 00 00 00 00 00 00 00     CREMENT.........
     996:	00 00 00 00 00 05 55 49 44 5f 52 49 47 48 54 5f     ......UID_RIGHT_
     9a6:	44 45 43 52 45 4d 45 4e 54 00 00 00 00 00 00 00     DECREMENT.......
     9b6:	00 00 00 00 00 00 06 43 59 43 4c 45 5f 53 45 54     .......CYCLE_SET
     9c6:	54 49 4e 47 53 00 00 00 00 00 00 00 00 00 00 00     TINGS...........
     9d6:	00 00 00 00 00 00 00 07 53 54 4f 52 45 5f 4d 45     ........STORE_ME
     9e6:	4d 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     M...............
     9f6:	00 00 00 00 00 00 00 00 08 52 45 43 41 4c 4c 5f     .........RECALL_
     a06:	4d 45 4d 00 00 00 00 00 00 00 00 00 00 00 00 00     MEM.............
     a16:	00 00 00 00 00 00 00 00 00 09 54 4f 47 47 4c 45     ..........TOGGLE
     a26:	5f 46 49 45 4c 44 00 00 00 00 00 00 00 00 00 00     _FIELD..........
     a36:	00 00 00 00 00 00 00 00 00 00 0a 53 54 4f 52 45     ...........STORE
     a46:	5f 4c 4f 47 00 00 00 00 00 00 00 00 00 00 00 00     _LOG............
     a56:	00 00 00 00 00 00 00 00 00 00 00 0b 43 4c 4f 4e     ............CLON
     a66:	45 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     E...............
     a76:	00 00 00 00 00 00 00 00 00 00 00 00 0c 43 4c 4f     .............CLO
     a86:	4e 45 5f 4d 46 55 00 00 00 00 00 00 00 00 00 00     NE_MFU..........
     a96:	00 00 00 00 00 00 00 00 00 00 00 00 00              .............

00000aa3 <LogModeMap>:
     aa3:	00 4f 46 46 00 00 00 00 00 00 00 00 00 00 00 00     .OFF............
     ab3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     ac3:	00 01 4d 45 4d 4f 52 59 00 00 00 00 00 00 00 00     ..MEMORY........
     ad3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     ae3:	00 00 02 4c 49 56 45 00 00 00 00 00 00 00 00 00     ...LIVE.........
     af3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b03:	00 00 00                                            ...

00000b06 <LEDFunctionMap>:
     b06:	00 4e 4f 4e 45 00 00 00 00 00 00 00 00 00 00 00     .NONE...........
     b16:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b26:	00 01 50 4f 57 45 52 45 44 00 00 00 00 00 00 00     ..POWERED.......
     b36:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b46:	00 00 02 54 45 52 4d 49 4e 41 4c 5f 43 4f 4e 4e     ...TERMINAL_CONN
     b56:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b66:	00 00 00 03 54 45 52 4d 49 4e 41 4c 5f 52 58 54     ....TERMINAL_RXT
     b76:	58 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     X...............
     b86:	00 00 00 00 04 53 45 54 54 49 4e 47 5f 43 48 41     .....SETTING_CHA
     b96:	4e 47 45 00 00 00 00 00 00 00 00 00 00 00 00 00     NGE.............
     ba6:	00 00 00 00 00 05 4d 45 4d 4f 52 59 5f 53 54 4f     ......MEMORY_STO
     bb6:	52 45 44 00 00 00 00 00 00 00 00 00 00 00 00 00     RED.............
     bc6:	00 00 00 00 00 00 06 4d 45 4d 4f 52 59 5f 43 48     .......MEMORY_CH
     bd6:	41 4e 47 45 44 00 00 00 00 00 00 00 00 00 00 00     ANGED...........
     be6:	00 00 00 00 00 00 00 08 43 4f 44 45 43 5f 52 58     ........CODEC_RX
     bf6:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     c06:	00 00 00 00 00 00 00 00 09 43 4f 44 45 43 5f 54     .........CODEC_T
     c16:	58 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     X...............
     c26:	00 00 00 00 00 00 00 00 00 07 46 49 45 4c 44 5f     ..........FIELD_
     c36:	44 45 54 45 43 54 45 44 00 00 00 00 00 00 00 00     DETECTED........
     c46:	00 00 00 00 00 00 00 00 00 00 0a 4c 4f 47 4d 45     ...........LOGME
     c56:	4d 5f 46 55 4c 4c 00 00 00 00 00 00 00 00 00 00     M_FULL..........
     c66:	00 00 00 00 00 00 00 00 00 00 00                    ...........

00000c71 <__c.7494>:
     c71:	54 45 53 54 21 20 2d 2d 2d 20 48 65 6c 6c 6f 20     TEST! --- Hello 
     c81:	57 6f 72 6c 64 0a 0d 00                             World...

00000c89 <__c.7480>:
     c89:	25 63 2c 25 63 00                                   %c,%c.

00000c8f <__c.7474>:
     c8f:	25 35 64 00                                         %5d.

00000c93 <__c.7471>:
     c93:	41 6e 79 20 69 6e 74 65 67 65 72 20 66 72 6f 6d     Any integer from
     ca3:	20 30 20 74 6f 20 25 75 2e 20 52 65 66 65 72 65      0 to %u. Refere
     cb3:	6e 63 65 20 76 6f 6c 74 61 67 65 20 77 69 6c 6c     nce voltage will
     cc3:	20 62 65 20 28 56 43 43 20 2a 20 54 48 52 45 53      be (VCC * THRES
     cd3:	48 4f 4c 44 20 2f 20 34 30 39 35 29 20 6d 56 2e     HOLD / 4095) mV.
     ce3:	00                                                  .

00000ce4 <__c.7465>:
     ce4:	25 75 00                                            %u.

00000ce7 <__c.7460>:
     ce7:	25 35 64 00                                         %5d.

00000ceb <__c.7457>:
     ceb:	30 20 3d 20 6e 6f 20 74 69 6d 65 6f 75 74 0d 0a     0 = no timeout..
     cfb:	31 2d 36 30 30 20 3d 20 31 30 30 20 6d 73 20 2d     1-600 = 100 ms -
     d0b:	20 36 30 30 30 30 20 6d 73 20 74 69 6d 65 6f 75      60000 ms timeou
     d1b:	74 00                                               t.

00000d1d <__c.7451>:
     d1d:	25 75 20 6d 73 00                                   %u ms.

00000d23 <__c.7420>:
     d23:	25 34 2e 34 58 00                                   %4.4X.

00000d29 <__c.7415>:
     d29:	25 35 75 20 6d 56 00                                %5u mV.

00000d30 <__c.7366>:
     d30:	25 75 20 28 66 72 6f 6d 20 77 68 69 63 68 20 25     %u (from which %
     d40:	75 20 6e 6f 6e 2d 76 6f 6c 61 74 69 6c 65 29 00     u non-volatile).

00000d50 <__c.7311>:
     d50:	25 75 00                                            %u.

00000d53 <__c.7306>:
     d53:	25 75 00                                            %u.

00000d56 <__c.7289>:
     d56:	25 63 2c 25 63 00                                   %c,%c.

00000d5c <__c.7276>:
     d5c:	52 41 4e 44 4f 4d 00                                RANDOM.

00000d63 <__c.7268>:
     d63:	4e 4f 20 55 49 44 2e 00                             NO UID..

00000d6b <__c.7246>:
     d6b:	43 68 61 6d 65 6c 65 6f 6e 4d 69 6e 69 20 52 65     ChameleonMini Re
     d7b:	76 47 20 25 53 20 75 73 69 6e 67 20 4c 55 46 41     vG %S using LUFA
     d8b:	20 25 53 20 63 6f 6d 70 69 6c 65 64 20 77 69 74      %S compiled wit
     d9b:	68 20 41 56 52 2d 47 43 43 20 25 53 2e 20 42 61     h AVR-GCC %S. Ba
     dab:	73 65 64 20 6f 6e 20 74 68 65 20 6f 70 65 6e 2d     sed on the open-
     dbb:	73 6f 75 72 63 65 20 4e 46 43 20 74 6f 6f 6c 20     source NFC tool 
     dcb:	43 68 61 6d 65 6c 65 6f 6e 4d 69 6e 69 2e 20 68     ChameleonMini. h
     ddb:	74 74 70 73 3a 2f 2f 67 69 74 68 75 62 2e 63 6f     ttps://github.co
     deb:	6d 2f 65 6d 73 65 63 2f 43 68 61 6d 65 6c 65 6f     m/emsec/Chameleo
     dfb:	6e 4d 69 6e 69 20 63 6f 6d 6d 69 74 20 25 53 00     nMini commit %S.

00000e0b <__c.7248>:
     e0b:	00                                                  .

00000e0c <__c.7250>:
     e0c:	31 35 31 31 31 35 00                                151115.

00000e13 <__c.7252>:
     e13:	35 2e 34 2e 30 00                                   5.4.0.

00000e19 <__c.7254>:
     e19:	38 38 38 37 32 31 33 00                             8887213.

00000e21 <__c.7306>:
     e21:	0d 0a 00                                            ...

00000e24 <__c.7294>:
     e24:	0d 0a 00                                            ...

00000e27 <__c.7292>:
     e27:	0d 0a 00                                            ...

00000e2a <__c.7280>:
     e2a:	0d 0a 00                                            ...

00000e2d <__c.7269>:
     e2d:	0d 0a 00                                            ...

00000e30 <__c.7267>:
     e30:	0d 0a 00                                            ...

00000e33 <StatusTable>:
     e33:	64 31 30 30 3a 4f 4b 00 00 00 00 00 00 00 00 00     d100:OK.........
     e43:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     e53:	00 65 31 30 31 3a 4f 4b 20 57 49 54 48 20 54 45     .e101:OK WITH TE
     e63:	58 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00     XT..............
     e73:	00 00 6e 31 31 30 3a 57 41 49 54 49 4e 47 20 46     ..n110:WAITING F
     e83:	4f 52 20 58 4d 4f 44 45 4d 00 00 00 00 00 00 00     OR XMODEM.......
     e93:	00 00 00 c8 32 30 30 3a 55 4e 4b 4e 4f 57 4e 20     ....200:UNKNOWN 
     ea3:	43 4f 4d 4d 41 4e 44 00 00 00 00 00 00 00 00 00     COMMAND.........
     eb3:	00 00 00 00 c9 32 30 31 3a 49 4e 56 41 4c 49 44     .....201:INVALID
     ec3:	20 43 4f 4d 4d 41 4e 44 20 55 53 41 47 45 00 00      COMMAND USAGE..
     ed3:	00 00 00 00 00 ca 32 30 32 3a 49 4e 56 41 4c 49     ......202:INVALI
     ee3:	44 20 50 41 52 41 4d 45 54 45 52 00 00 00 00 00     D PARAMETER.....
     ef3:	00 00 00 00 00 00 78 31 32 30 3a 46 41 4c 53 45     ......x120:FALSE
     f03:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     f13:	00 00 00 00 00 00 00 79 31 32 31 3a 54 52 55 45     .......y121:TRUE
     f23:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     f33:	00 00 00 00 00 00 00 00 cb 32 30 33 3a 54 49 4d     .........203:TIM
     f43:	45 4f 55 54 00 00 00 00 00 00 00 00 00 00 00 00     EOUT............
     f53:	00 00 00 00 00 00 00 00 00                          .........

00000f5c <CommandTable>:
     f5c:	56 45 52 53 49 4f 4e 00 00 00 00 00 00 00 00 00     VERSION.........
     f6c:	00 00 00 00 00 00 8b 1c 43 4f 4e 46 49 47 00 00     ........CONFIG..
     f7c:	00 00 00 00 00 00 00 00 00 00 00 00 b3 1c ad 1c     ................
     f8c:	55 49 44 00 00 00 00 00 00 00 00 00 00 00 00 00     UID.............
     f9c:	00 00 00 00 14 1d d5 1c 52 45 41 44 4f 4e 4c 59     ........READONLY
     fac:	00 00 00 00 00 00 00 00 00 00 00 00 79 1d 6d 1d     ............y.m.
     fbc:	55 50 4c 4f 41 44 00 00 00 00 00 00 00 00 00 00     UPLOAD..........
     fcc:	a6 1d 00 00 00 00 00 00 44 4f 57 4e 4c 4f 41 44     ........DOWNLOAD
     fdc:	00 00 00 00 00 00 00 00 ab 1d 00 00 00 00 00 00     ................
     fec:	52 45 53 45 54 00 00 00 00 00 00 00 00 00 00 00     RESET...........
     ffc:	b0 1d 00 00 00 00 00 00 55 50 47 52 41 44 45 00     ........UPGRADE.
    100c:	00 00 00 00 00 00 00 00 bb 1d 00 00 00 00 00 00     ................
    101c:	4d 45 4d 53 49 5a 45 00 00 00 00 00 00 00 00 00     MEMSIZE.........
    102c:	00 00 00 00 00 00 c6 1d 55 49 44 53 49 5a 45 00     ........UIDSIZE.
    103c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 de 1d     ................
    104c:	52 42 55 54 54 4f 4e 00 00 00 00 00 00 00 00 00     RBUTTON.........
    105c:	00 00 00 00 fb 1d f4 1d 52 42 55 54 54 4f 4e 5f     ........RBUTTON_
    106c:	4c 4f 4e 47 00 00 00 00 00 00 00 00 17 1e 10 1e     LONG............
    107c:	4c 42 55 54 54 4f 4e 00 00 00 00 00 00 00 00 00     LBUTTON.........
    108c:	00 00 00 00 33 1e 2c 1e 4c 42 55 54 54 4f 4e 5f     ....3.,.LBUTTON_
    109c:	4c 4f 4e 47 00 00 00 00 00 00 00 00 4f 1e 48 1e     LONG........O.H.
    10ac:	4c 45 44 47 52 45 45 4e 00 00 00 00 00 00 00 00     LEDGREEN........
    10bc:	00 00 00 00 6b 1e 64 1e 4c 45 44 52 45 44 00 00     ....k.d.LEDRED..
    10cc:	00 00 00 00 00 00 00 00 00 00 00 00 87 1e 80 1e     ................
    10dc:	4c 4f 47 4d 4f 44 45 00 00 00 00 00 00 00 00 00     LOGMODE.........
    10ec:	00 00 00 00 a1 1e 9c 1e 4c 4f 47 4d 45 4d 00 00     ........LOGMEM..
    10fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 b6 1e     ................
    110c:	4c 4f 47 44 4f 57 4e 4c 4f 41 44 00 00 00 00 00     LOGDOWNLOAD.....
    111c:	db 1e 00 00 00 00 00 00 4c 4f 47 53 54 4f 52 45     ........LOGSTORE
    112c:	00 00 00 00 00 00 00 00 e0 1e 00 00 00 00 00 00     ................
    113c:	4c 4f 47 43 4c 45 41 52 00 00 00 00 00 00 00 00     LOGCLEAR........
    114c:	e3 1e 00 00 00 00 00 00 53 45 54 54 49 4e 47 00     ........SETTING.
    115c:	00 00 00 00 00 00 00 00 00 00 00 00 eb 1e e6 1e     ................
    116c:	43 4c 45 41 52 00 00 00 00 00 00 00 00 00 00 00     CLEAR...........
    117c:	f3 1e 00 00 00 00 00 00 53 54 4f 52 45 00 00 00     ........STORE...
    118c:	00 00 00 00 00 00 00 00 f7 1e 00 00 00 00 00 00     ................
    119c:	52 45 43 41 4c 4c 00 00 00 00 00 00 00 00 00 00     RECALL..........
    11ac:	fb 1e 00 00 00 00 00 00 43 48 41 52 47 49 4e 47     ........CHARGING
    11bc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff 1e     ................
    11cc:	48 45 4c 50 00 00 00 00 00 00 00 00 00 00 00 00     HELP............
    11dc:	07 1f 00 00 00 00 00 00 52 53 53 49 00 00 00 00     ........RSSI....
    11ec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 43 1f     ..............C.
    11fc:	53 59 53 54 49 43 4b 00 00 00 00 00 00 00 00 00     SYSTICK.........
    120c:	00 00 00 00 00 00 76 1f 53 45 4e 44 5f 52 41 57     ......v.SEND_RAW
    121c:	00 00 00 00 00 00 00 00 00 00 1c 20 00 00 00 00     ........... ....
    122c:	53 45 4e 44 00 00 00 00 00 00 00 00 00 00 00 00     SEND............
    123c:	00 00 92 1f 00 00 00 00 47 45 54 55 49 44 00 00     ........GETUID..
    124c:	00 00 00 00 00 00 00 00 ef 20 00 00 00 00 00 00     ......... ......
    125c:	44 55 4d 50 5f 4d 46 55 00 00 00 00 00 00 00 00     DUMP_MFU........
    126c:	bb 20 00 00 00 00 00 00 43 4c 4f 4e 45 5f 4d 46     . ......CLONE_MF
    127c:	55 00 00 00 00 00 00 00 d8 20 00 00 00 00 00 00     U........ ......
    128c:	49 44 45 4e 54 49 46 59 00 00 00 00 00 00 00 00     IDENTIFY........
    129c:	0c 21 00 00 00 00 00 00 54 49 4d 45 4f 55 54 00     .!......TIMEOUT.
    12ac:	00 00 00 00 00 00 00 00 00 00 00 00 49 21 29 21     ............I!)!
    12bc:	54 48 52 45 53 48 4f 4c 44 00 00 00 00 00 00 00     THRESHOLD.......
    12cc:	00 00 00 00 b6 21 9c 21 41 55 54 4f 43 41 4c 49     .....!.!AUTOCALI
    12dc:	42 52 41 54 45 00 00 00 49 22 00 00 00 00 00 00     BRATE...I"......
    12ec:	46 49 45 4c 44 00 00 00 00 00 00 00 00 00 00 00     FIELD...........
    12fc:	00 00 00 00 0b 22 35 22 43 4c 4f 4e 45 00 00 00     ....."5"CLONE...
    130c:	00 00 00 00 00 00 00 00 75 22 00 00 00 00 00 00     ........u"......
    131c:	54 45 53 54 00 00 00 00 00 00 00 00 00 00 00 00     TEST............
    132c:	00 00 00 00 00 00 8c 22 00 00 00 00 00 00 00 00     ......."........
    133c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................

0000134c <__c.7491>:
    134c:	53 41 4b 3a 09 00                                   SAK:..

00001352 <__c.7489>:
    1352:	55 49 44 3a 09 00                                   UID:..

00001358 <__c.7487>:
    1358:	41 54 51 41 3a 09 00                                ATQA:..

0000135f <__c.7485>:
    135f:	54 68 65 72 65 20 69 73 20 61 74 20 6c 65 61 73     There is at leas
    136f:	74 20 6f 6e 65 20 6d 6f 72 65 20 63 61 72 64 20     t one more card 
    137f:	74 79 70 65 20 63 61 6e 64 69 64 61 74 65 2c 20     type candidate, 
    138f:	62 75 74 20 74 68 65 72 65 20 77 61 73 20 6e 6f     but there was no
    139f:	74 20 65 6e 6f 75 67 68 20 74 65 72 6d 69 6e 61     t enough termina
    13af:	6c 20 62 75 66 66 65 72 20 73 70 61 63 65 2e 0d     l buffer space..
    13bf:	0a 00                                               ..

000013c1 <__c.7456>:
    13c1:	0d 0a 00                                            ...

000013c4 <__c.7427>:
    13c4:	42 75 66 66 65 72 20 3d 3d 3d 20 25 64 00           Buffer === %d.

000013d2 <CardIdentificationList>:
    13d2:	04 00 01 09 01 00 00 00 00 00 00 00 00 00 00 00     ................
    13e2:	00 00 00 00 00 00 00 4e 58 50 00 00 00 00 00 00     .......NXP......
    13f2:	00 00 00 00 00 00 00 4d 49 46 41 52 45 20 4d 69     .......MIFARE Mi
    1402:	6e 69 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ni..............
    1412:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1422:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1432:	00 00 00 00 00 00 00 04 00 01 08 01 00 00 00 00     ................
    1442:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 4e 58     ..............NX
    1452:	50 00 00 00 00 00 00 00 00 00 00 00 00 00 4d 49     P.............MI
    1462:	46 41 52 45 20 43 6c 61 73 73 69 63 20 31 6b 00     FARE Classic 1k.
    1472:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1482:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1492:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00     ................
    14a2:	01 18 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    14b2:	00 00 00 00 00 4e 58 50 00 00 00 00 00 00 00 00     .....NXP........
    14c2:	00 00 00 00 00 4d 49 46 41 52 45 20 43 6c 61 73     .....MIFARE Clas
    14d2:	73 69 63 20 34 6b 00 00 00 00 00 00 00 00 00 00     sic 4k..........
    14e2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    14f2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1502:	00 00 00 00 00 44 00 01 00 01 00 00 00 00 00 00     .....D..........
    1512:	00 00 00 00 00 00 00 00 00 00 00 00 4e 58 50 00     ............NXP.
    1522:	00 00 00 00 00 00 00 00 00 00 00 00 4d 49 46 41     ............MIFA
    1532:	52 45 20 55 6c 74 72 61 6c 69 67 68 74 00 00 00     RE Ultralight...
    1542:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1552:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1562:	00 00 00 00 00 00 00 00 00 00 00 00 44 03 01 20     ............D.. 
    1572:	01 75 77 81 02 80 00 00 00 00 00 00 00 00 00 00     .uw.............
    1582:	00 05 00 4e 58 50 00 00 00 00 00 00 00 00 00 00     ...NXP..........
    1592:	00 00 00 4d 49 46 41 52 45 20 44 45 53 46 69 72     ...MIFARE DESFir
    15a2:	65 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     e...............
    15b2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    15c2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    15d2:	00 00 00 44 03 01 20 01 75 77 81 02 80 00 00 00     ...D.. .uw......
    15e2:	00 00 00 00 00 00 00 00 05 00 4e 58 50 00 00 00     ..........NXP...
    15f2:	00 00 00 00 00 00 00 00 00 00 4d 49 46 41 52 45     ..........MIFARE
    1602:	20 44 45 53 46 69 72 65 20 45 56 31 00 00 00 00      DESFire EV1....
    1612:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1622:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1632:	00 00 00 00 00 00 00 00 00 00 04 03 01 28 01 38     .............(.8
    1642:	77 b1 4a 43 4f 50 33 31 00 00 00 00 00 00 00 09     w.JCOP31........
    1652:	01 49 42 4d 00 00 00 00 00 00 00 00 00 00 00 00     .IBM............
    1662:	00 4a 43 4f 50 33 31 00 00 00 00 00 00 00 00 00     .JCOP31.........
    1672:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1682:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1692:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    16a2:	00 48 00 01 20 01 78 77 b1 02 4a 43 4f 50 76 32     .H.. .xw..JCOPv2
    16b2:	34 31 00 00 00 00 0c 01 49 42 4d 00 00 00 00 00     41......IBM.....
    16c2:	00 00 00 00 00 00 00 00 4a 43 4f 50 33 31 20 76     ........JCOP31 v
    16d2:	32 2e 34 2e 31 00 00 00 00 00 00 00 00 00 00 00     2.4.1...........
    16e2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    16f2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1702:	00 00 00 00 00 00 00 00 48 00 01 20 01 38 33 b1     ........H.. .83.
    1712:	4a 43 4f 50 34 31 56 32 32 00 00 00 00 0c 01 49     JCOP41V22......I
    1722:	42 4d 00 00 00 00 00 00 00 00 00 00 00 00 00 4a     BM.............J
    1732:	43 4f 50 34 31 20 76 32 2e 32 00 00 00 00 00 00     COP41 v2.2......
    1742:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1752:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1762:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04     ................
    1772:	00 01 28 01 38 33 b1 4a 43 4f 50 34 31 56 32 33     ..(.83.JCOP41V23
    1782:	31 00 00 00 0d 01 49 42 4d 00 00 00 00 00 00 00     1.....IBM.......
    1792:	00 00 00 00 00 00 4a 43 4f 50 34 31 20 76 32 2e     ......JCOP41 v2.
    17a2:	33 2e 31 00 00 00 00 00 00 00 00 00 00 00 00 00     3.1.............
    17b2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    17c2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    17d2:	00 00 00 00 00 00 04 00 01 88 01 00 00 00 00 00     ................
    17e2:	00 00 00 00 00 00 00 00 00 00 00 00 00 49 6e 66     .............Inf
    17f2:	69 6e 65 6f 6e 00 00 00 00 00 00 00 00 4d 49 46     ineon........MIF
    1802:	41 52 45 20 43 6c 61 73 73 69 63 20 31 6b 00 00     ARE Classic 1k..
    1812:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1822:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1832:	00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 01     ................
    1842:	98 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1852:	00 00 00 00 47 65 6d 70 6c 75 73 00 00 00 00 00     ....Gemplus.....
    1862:	00 00 00 00 4d 50 43 4f 53 00 00 00 00 00 00 00     ....MPCOS.......
    1872:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1882:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1892:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    18a2:	00 00 00 00 00 0c 01 00 00 00 00 00 00 00 00 00     ................
    18b2:	00 00 00 00 00 00 00 00 00 00 00 49 6e 6e 6f 76     ...........Innov
    18c2:	69 73 69 6f 6e 20 52 26 54 00 00 4a 65 77 65 6c     ision R&T..Jewel
    18d2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    18e2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    18f2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1902:	00 00 00 00 00 00 00 00 00 00 00 02 00 01 38 01     ..............8.
    1912:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1922:	00 00 4e 6f 6b 69 61 00 00 00 00 00 00 00 00 00     ..Nokia.........
    1932:	00 00 4d 49 46 41 52 45 20 43 6c 61 73 73 69 63     ..MIFARE Classic
    1942:	20 34 6b 20 2d 20 65 6d 75 6c 61 74 65 64 20 28      4k - emulated (
    1952:	36 32 31 32 20 43 6c 61 73 73 69 63 29 00 00 00     6212 Classic)...
    1962:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1972:	00 00 08 00 01 38 01 00 00 00 00 00 00 00 00 00     .....8..........
    1982:	00 00 00 00 00 00 00 00 00 4e 6f 6b 69 61 00 00     .........Nokia..
    1992:	00 00 00 00 00 00 00 00 00 4d 49 46 41 52 45 20     .........MIFARE 
    19a2:	43 6c 61 73 73 69 63 20 34 6b 20 2d 20 65 6d 75     Classic 4k - emu
    19b2:	6c 61 74 65 64 20 28 36 31 33 31 20 4e 46 43 29     lated (6131 NFC)
    19c2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    19d2:	00 00 00 00 00 00 00 00 00 00                       ..........

000019dc <__ctors_end>:
    19dc:	11 24       	eor	r1, r1
    19de:	1f be       	out	0x3f, r1	; 63
    19e0:	cf ef       	ldi	r28, 0xFF	; 255
    19e2:	cd bf       	out	0x3d, r28	; 61
    19e4:	df e3       	ldi	r29, 0x3F	; 63
    19e6:	de bf       	out	0x3e, r29	; 62
    19e8:	00 e0       	ldi	r16, 0x00	; 0
    19ea:	0c bf       	out	0x3c, r16	; 60
    19ec:	18 be       	out	0x38, r1	; 56
    19ee:	19 be       	out	0x39, r1	; 57
    19f0:	1a be       	out	0x3a, r1	; 58
    19f2:	1b be       	out	0x3b, r1	; 59

000019f4 <__do_copy_data>:
    19f4:	14 e2       	ldi	r17, 0x24	; 36
    19f6:	a0 e0       	ldi	r26, 0x00	; 0
    19f8:	b0 e2       	ldi	r27, 0x20	; 32
    19fa:	e2 e6       	ldi	r30, 0x62	; 98
    19fc:	ff ef       	ldi	r31, 0xFF	; 255
    19fe:	00 e0       	ldi	r16, 0x00	; 0
    1a00:	0b bf       	out	0x3b, r16	; 59
    1a02:	02 c0       	rjmp	.+4      	; 0x1a08 <__do_copy_data+0x14>
    1a04:	07 90       	elpm	r0, Z+
    1a06:	0d 92       	st	X+, r0
    1a08:	ac 38       	cpi	r26, 0x8C	; 140
    1a0a:	b1 07       	cpc	r27, r17
    1a0c:	d9 f7       	brne	.-10     	; 0x1a04 <__do_copy_data+0x10>
    1a0e:	1b be       	out	0x3b, r1	; 59

00001a10 <__do_clear_bss>:
    1a10:	27 e3       	ldi	r18, 0x37	; 55
    1a12:	ac e8       	ldi	r26, 0x8C	; 140
    1a14:	b4 e2       	ldi	r27, 0x24	; 36
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <.do_clear_bss_start>

00001a18 <.do_clear_bss_loop>:
    1a18:	1d 92       	st	X+, r1

00001a1a <.do_clear_bss_start>:
    1a1a:	a5 3d       	cpi	r26, 0xD5	; 213
    1a1c:	b2 07       	cpc	r27, r18
    1a1e:	e1 f7       	brne	.-8      	; 0x1a18 <.do_clear_bss_loop>
    1a20:	d3 d1       	rcall	.+934    	; 0x1dc8 <main>
    1a22:	0c 94 af 7f 	jmp	0xff5e	; 0xff5e <_exit>

00001a26 <__bad_interrupt>:
    1a26:	c2 c2       	rjmp	.+1412   	; 0x1fac <__vector_default>

00001a28 <__vector_34>:
.endm

; Find first pause and start sampling
.global CODEC_DEMOD_IN_INT0_VECT
CODEC_DEMOD_IN_INT0_VECT:
    call_isr isr_func_CODEC_DEMOD_IN_INT0_VECT
    1a28:	ef 93       	push	r30
    1a2a:	ff 93       	push	r31
    1a2c:	e0 91 b9 2f 	lds	r30, 0x2FB9	; 0x802fb9 <isr_func_CODEC_DEMOD_IN_INT0_VECT>
    1a30:	f0 91 ba 2f 	lds	r31, 0x2FBA	; 0x802fba <isr_func_CODEC_DEMOD_IN_INT0_VECT+0x1>
    1a34:	09 95       	icall
    1a36:	ff 91       	pop	r31
    1a38:	ef 91       	pop	r30
    1a3a:	18 95       	reti

00001a3c <__vector_81>:

; Frame Delay Time PCD to PICC ends
.global CODEC_TIMER_SAMPLING_CCC_VECT
CODEC_TIMER_SAMPLING_CCC_VECT:
    call_isr isr_func_TCD0_CCC_vect
    1a3c:	ef 93       	push	r30
    1a3e:	ff 93       	push	r31
    1a40:	e0 91 b7 2e 	lds	r30, 0x2EB7	; 0x802eb7 <isr_func_TCD0_CCC_vect>
    1a44:	f0 91 b8 2e 	lds	r31, 0x2EB8	; 0x802eb8 <isr_func_TCD0_CCC_vect+0x1>
    1a48:	09 95       	icall
    1a4a:	ff 91       	pop	r31
    1a4c:	ef 91       	pop	r30
    1a4e:	18 95       	reti

00001a50 <FlashReadWord>:
; Returns:
;     R25:R24 - Read word.
.section .text
.global FlashReadWord
FlashReadWord:
    in	r19, RAMPZ      ; Save RAMPZ.
    1a50:	3b b7       	in	r19, 0x3b	; 59
    out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
    1a52:	8b bf       	out	0x3b, r24	; 59
    movw	ZL, r22     ; Move the low bytes to the Z pointer
    1a54:	fb 01       	movw	r30, r22
    elpm	r24, Z+     ; Extended load byte from address pointed to by Z.
    1a56:	87 91       	elpm	r24, Z+
    elpm	r25, Z      ; Extended load byte from address pointed to by Z.
    1a58:	96 91       	elpm	r25, Z
    out	RAMPZ, r19      ; Restore RAMPZ register.
    1a5a:	3b bf       	out	0x3b, r19	; 59
    ret
    1a5c:	08 95       	ret

00001a5e <FlashEraseApplicationPage>:
; Returns:
;     Nothing.
.section .text
.global FlashEraseApplicationPage
FlashEraseApplicationPage:
    in	r19, RAMPZ                      ; Save RAMPZ, which is restored in FlashCommonSPM.
    1a5e:	3b b7       	in	r19, 0x3b	; 59
    out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
    1a60:	8b bf       	out	0x3b, r24	; 59
    movw    r24, r22                    ; Move low bytes for ZH:ZL to R25:R24
    1a62:	cb 01       	movw	r24, r22
    ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
    1a64:	42 e2       	ldi	r20, 0x22	; 34
    jmp	FlashCommonSPM                  ; Jump to common SPM code.
    1a66:	0d 94 f0 0f 	jmp	0x21fe0	; 0x21fe0 <FlashCommonSPM>

00001a6a <FlashLoadFlashWord>:
; Returns:
;     Nothing.
.section .text
.global FlashLoadFlashWord
FlashLoadFlashWord:
    in	r19, RAMPZ                         ; Save RAMPZ, which is restored in FlashCommonSPM.
    1a6a:	3b b7       	in	r19, 0x3b	; 59
    movw	r0, r22                        ; Prepare flash word in R1:R0.
    1a6c:	0b 01       	movw	r0, r22
    ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
    1a6e:	43 e2       	ldi	r20, 0x23	; 35
    jmp	FlashCommonSPM                     ; Jump to common SPM code.
    1a70:	0d 94 f0 0f 	jmp	0x21fe0	; 0x21fe0 <FlashCommonSPM>

00001a74 <FlashEraseWriteApplicationPage>:
; Returns:
;     Nothing.
.section .text
.global FlashEraseWriteApplicationPage
FlashEraseWriteApplicationPage:
    in	r19, RAMPZ                            ; Save RAMPZ, which is restored in FlashCommonSPM.
    1a74:	3b b7       	in	r19, 0x3b	; 59
    out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
    1a76:	8b bf       	out	0x3b, r24	; 59
    movw	r24, r22                          ; Move low bytes of address to ZH:ZL from R23:R22
    1a78:	cb 01       	movw	r24, r22
    ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
    1a7a:	45 e2       	ldi	r20, 0x25	; 37
    jmp	FlashCommonSPM                        ; Jump to common SPM code.
    1a7c:	0d 94 f0 0f 	jmp	0x21fe0	; 0x21fe0 <FlashCommonSPM>

00001a80 <FlashEraseFlashBuffer>:
; Returns:
;     Nothing.
.section .text
.global FlashEraseFlashBuffer
FlashEraseFlashBuffer:
    in	r19, RAMPZ                          ; Save RAMPZ, which is restored in FlashCommonSPM.
    1a80:	3b b7       	in	r19, 0x3b	; 59
    ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
    1a82:	46 e2       	ldi	r20, 0x26	; 38
    ;jmp	FlashCommonSPM                  ; Jump to common SPM code.
    jmp	FlashCommonCMD
    1a84:	08 c0       	rjmp	.+16     	; 0x1a96 <FlashCommonCMD>

00001a86 <FlashWaitForSPM>:
; Returns:
;     Nothing.
.section .text
.global FlashWaitForSPM
FlashWaitForSPM:
    lds	r18, NVM_STATUS     ; Load the NVM Status register.
    1a86:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7001cf>
    sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
    1a8a:	27 fd       	sbrc	r18, 7
    rjmp	FlashWaitForSPM       ; Repeat check if bit is not cleared.
    1a8c:	fc cf       	rjmp	.-8      	; 0x1a86 <FlashWaitForSPM>
    clr	r18
    1a8e:	22 27       	eor	r18, r18
    sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
    1a90:	20 93 ca 01 	sts	0x01CA, r18	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
    ret
    1a94:	08 95       	ret

00001a96 <FlashCommonCMD>:
;
; Returns:
;     R25:R24:R23:R22 - 32-bit result from NVM operation.
.section .text
FlashCommonCMD:
    sts	NVM_CMD, r20        ; Load command into NVM Command register.
    1a96:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
    ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
    1a9a:	28 ed       	ldi	r18, 0xD8	; 216
    ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
    1a9c:	31 e0       	ldi	r19, 0x01	; 1
    sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
    1a9e:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
    sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
    1aa2:	30 93 cb 01 	sts	0x01CB, r19	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7001cb>
    lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
    1aa6:	60 91 c4 01 	lds	r22, 0x01C4	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
    lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
    1aaa:	70 91 c5 01 	lds	r23, 0x01C5	; 0x8001c5 <__TEXT_REGION_LENGTH__+0x7001c5>
    lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
    1aae:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <__TEXT_REGION_LENGTH__+0x7001c6>
    clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
    1ab2:	99 27       	eor	r25, r25
    ret
    1ab4:	08 95       	ret

00001ab6 <FlashCommonLPM>:
;
; Returns:
;     R24     - Result from LPM operation.
.section .text
FlashCommonLPM:
    movw	ZL, r24         ; Load index into Z.
    1ab6:	fc 01       	movw	r30, r24
    sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
    1ab8:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
    lpm	r24,Z
    1abc:	84 91       	lpm	r24, Z
    ret
    1abe:	08 95       	ret

00001ac0 <__vector_80>:
#define CODEC_READER_TIMER__CTRLA   0x0800

; For sending reader bits to cards
.global TCD0_CCB_vect, Reader14443AMillerEOC
TCD0_CCB_vect:
push Zero                                                   ; 1
    1ac0:	0f 92       	push	r0
eor Zero, Zero                                              ; 1
    1ac2:	00 24       	eor	r0, r0
push Tmp                                                    ; 1
    1ac4:	0f 93       	push	r16
push BitCountL                                              ; 1
    1ac6:	2f 93       	push	r18
push BitCountH                                              ; 1
    1ac8:	3f 93       	push	r19
push NewLoad                                                ; 1
    1aca:	4f 93       	push	r20
push SampleRegister                                         ; 1
    1acc:	5f 93       	push	r21
in Tmp, 0x3f ; SREG                                         ; 1
    1ace:	0f b7       	in	r16, 0x3f	; 63
push Tmp                                                    ; 1
    1ad0:	0f 93       	push	r16
push ZL                                                     ; 1
    1ad2:	ef 93       	push	r30
push ZH                                                     ; 1
    1ad4:	ff 93       	push	r31
                                                            ; SUM: 8
in ZL, CodecBufferPtrL
    1ad6:	ea b1       	in	r30, 0x0a	; 10
in ZH, CodecBufferPtrH
    1ad8:	fb b1       	in	r31, 0x0b	; 11
ld SampleRegister, Z+
    1ada:	51 91       	ld	r21, Z+
clr NewLoad
    1adc:	44 27       	eor	r20, r20

in BitCountH, GPIORBitCountH
    1ade:	35 b1       	in	r19, 0x05	; 5
in BitCountL, GPIORBitCountL
    1ae0:	24 b1       	in	r18, 0x04	; 4

00001ae2 <LOOP>:



LOOP:
; POINT ZERO
lsr SampleRegister                                          ; 1
    1ae2:	56 95       	lsr	r21
brcc NO_TURNOFF_COMPENSATION                                ; 1 / 2
    1ae4:	78 f4       	brcc	.+30     	; 0x1b04 <NO_TURNOFF_COMPENSATION>

    sts AWEXC__OUTOVEN, Zero ; turn off field               ; 2
    1ae6:	00 92 8c 08 	sts	0x088C, r0	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>
    sts CODEC_READER_TIMER__CTRLA, Zero                     ; 2
    1aea:	00 92 00 08 	sts	0x0800, r0	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>

    ldi Tmp, 0x16                                           ; 1
    1aee:	06 e1       	ldi	r16, 0x16	; 22

00001af0 <TURNOFF_LOOP>:
    TURNOFF_LOOP:
        dec Tmp                                             ; 1
    1af0:	0a 95       	dec	r16
    brne TURNOFF_LOOP                                       ; 1 / 2 ; sums up to 21 * 3 + 2
    1af2:	f1 f7       	brne	.-4      	; 0x1af0 <TURNOFF_LOOP>
    rjmp .+0 ; double nop                                   ; 2
    1af4:	00 c0       	rjmp	.+0      	; 0x1af6 <TURNOFF_LOOP+0x6>

    ldi Tmp, 0x01                                           ; 1
    1af6:	01 e0       	ldi	r16, 0x01	; 1
    sts CODEC_READER_TIMER__CTRLA, Tmp  ; turn on field     ; 2
    1af8:	00 93 00 08 	sts	0x0800, r16	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    ldi Tmp, 0x03                                           ; 1
    1afc:	03 e0       	ldi	r16, 0x03	; 3
    sts AWEXC__OUTOVEN, Tmp                                 ; 2
    1afe:	00 93 8c 08 	sts	0x088C, r16	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>

    rjmp NO_TURNOFF                                         ; 2
    1b02:	04 c0       	rjmp	.+8      	; 0x1b0c <NO_TURNOFF>

00001b04 <NO_TURNOFF_COMPENSATION>:
                                                            ; SUM: 82 until now


NO_TURNOFF_COMPENSATION:
ldi Tmp, 26                                                 ; 1
    1b04:	0a e1       	ldi	r16, 0x1A	; 26

00001b06 <NO_TURNOFF_COMPENSATION_LOOP>:
NO_TURNOFF_COMPENSATION_LOOP:
    dec Tmp                                                 ; 1
    1b06:	0a 95       	dec	r16
    brne NO_TURNOFF_COMPENSATION_LOOP                       ; 1 / 2 sums up to 25 * 3 + 2
    1b08:	f1 f7       	brne	.-4      	; 0x1b06 <NO_TURNOFF_COMPENSATION_LOOP>
nop                                                         ; 1
    1b0a:	00 00       	nop

00001b0c <NO_TURNOFF>:
NO_TURNOFF:                                                 ; 82 at this point
subi BitCountL, 1 ; decrement BitCount                      ; 1
    1b0c:	21 50       	subi	r18, 0x01	; 1
sbci BitCountH, 0                                           ; 1
    1b0e:	30 40       	sbci	r19, 0x00	; 0
brne NO_EOC                                                 ; 1 / 2
    1b10:	19 f4       	brne	.+6      	; 0x1b18 <NO_EOC>

    ; EOC:
    call Reader14443AMillerEOC
    1b12:	0e 94 c4 2a 	call	0x5588	; 0x5588 <Reader14443AMillerEOC>
    rjmp RETURN
    1b16:	0c c0       	rjmp	.+24     	; 0x1b30 <RETURN>

00001b18 <NO_EOC>:

NO_EOC:                                                     ; 86 at this point
subi NewLoad, 0xFF                                          ; 1
    1b18:	4f 5f       	subi	r20, 0xFF	; 255
andi NewLoad, 0x07                                          ; 1
    1b1a:	47 70       	andi	r20, 0x07	; 7
brne LOAD_COMPENSATION                                      ; 1 / 2
    1b1c:	11 f4       	brne	.+4      	; 0x1b22 <LOAD_COMPENSATION>
                                                            ; SUM: 4
    ld SampleRegister, Z+                                   ; 3
    1b1e:	51 91       	ld	r21, Z+
    rjmp NOP_LOOP_INIT                                      ; 2
    1b20:	02 c0       	rjmp	.+4      	; 0x1b26 <NOP_LOOP_INIT>

00001b22 <LOAD_COMPENSATION>:

LOAD_COMPENSATION: ; 90 at this point
rjmp .+0 ; double nop                                       ; 2
    1b22:	00 c0       	rjmp	.+0      	; 0x1b24 <LOAD_COMPENSATION+0x2>
rjmp .+0 ; double nop                                       ; 2
    1b24:	00 c0       	rjmp	.+0      	; 0x1b26 <NOP_LOOP_INIT>

00001b26 <NOP_LOOP_INIT>:
NOP_LOOP_INIT:
ldi Tmp, 10                                                 ; 1
    1b26:	0a e0       	ldi	r16, 0x0A	; 10

00001b28 <NOP_LOOP>:
NOP_LOOP:
    dec Tmp                                                 ; 1
    1b28:	0a 95       	dec	r16
    brne NOP_LOOP                                           ; 1 / 2 sums up to 9 * 3 + 2
    1b2a:	f1 f7       	brne	.-4      	; 0x1b28 <NOP_LOOP>
rjmp .+0                                                    ; 2
    1b2c:	00 c0       	rjmp	.+0      	; 0x1b2e <NOP_LOOP+0x6>
rjmp LOOP                                                   ; 2
    1b2e:	d9 cf       	rjmp	.-78     	; 0x1ae2 <LOOP>

00001b30 <RETURN>:

RETURN:
pop ZH
    1b30:	ff 91       	pop	r31
pop ZL
    1b32:	ef 91       	pop	r30
pop Tmp
    1b34:	0f 91       	pop	r16
out 0x3f, Tmp ; SREG
    1b36:	0f bf       	out	0x3f, r16	; 63
pop SampleRegister
    1b38:	5f 91       	pop	r21
pop NewLoad
    1b3a:	4f 91       	pop	r20
pop BitCountH
    1b3c:	3f 91       	pop	r19
pop BitCountL
    1b3e:	2f 91       	pop	r18
pop Tmp
    1b40:	0f 91       	pop	r16
pop Zero
    1b42:	0f 90       	pop	r0
reti                                                        ; 2
    1b44:	18 95       	reti

00001b46 <_LoadKeyAndRunDEA>:
;     SREG:H  - Set to decipher, clear to encipher.
;
; Returns:
;     R7:R0   - Result of en/deciphering, LSB in R0
_LoadKeyAndRunDEA:
    ld      r15, Z+
    1b46:	f1 90       	ld	r15, Z+
    ld      r14, Z+
    1b48:	e1 90       	ld	r14, Z+
    ld      r13, Z+
    1b4a:	d1 90       	ld	r13, Z+
    ld      r12, Z+
    1b4c:	c1 90       	ld	r12, Z+
    ld      r11, Z+
    1b4e:	b1 90       	ld	r11, Z+
    ld      r10, Z+
    1b50:	a1 90       	ld	r10, Z+
    ld      r9,  Z+
    1b52:	91 90       	ld	r9, Z+
    ld      r8,  Z+
    1b54:	81 90       	ld	r8, Z+
    des     0
    1b56:	0b 94       	des	0
    des     1
    1b58:	1b 94       	des	1
    des     2
    1b5a:	2b 94       	des	2
    des     3
    1b5c:	3b 94       	des	3
    des     4
    1b5e:	4b 94       	des	4
    des     5
    1b60:	5b 94       	des	5
    des     6
    1b62:	6b 94       	des	6
    des     7
    1b64:	7b 94       	des	7
    des     8
    1b66:	8b 94       	des	8
    des     9
    1b68:	9b 94       	des	9
    des     10
    1b6a:	ab 94       	des	10
    des     11
    1b6c:	bb 94       	des	11
    des     12
    1b6e:	cb 94       	des	12
    des     13
    1b70:	db 94       	des	13
    des     14
    1b72:	eb 94       	des	14
    des     15
    1b74:	fb 94       	des	15
    ret
    1b76:	08 95       	ret

00001b78 <_Encrypt3KTDEA>:
;
; Returns:
;     R7:R0   - Result of enciphering, LSB in R0
_Encrypt3KTDEA:
    ; Reload Z with the key block pointer
    movw    r30, r16
    1b78:	f8 01       	movw	r30, r16
    ; Encipher
    clh
    1b7a:	d8 94       	clh
    rcall   _LoadKeyAndRunDEA
    1b7c:	e4 df       	rcall	.-56     	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Z now points to K2
    ; Decipher
    seh
    1b7e:	58 94       	seh
    rcall   _LoadKeyAndRunDEA
    1b80:	e2 df       	rcall	.-60     	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Z now points to K3
    ; Encipher
    clh
    1b82:	d8 94       	clh
    rjmp    _LoadKeyAndRunDEA
    1b84:	e0 cf       	rjmp	.-64     	; 0x1b46 <_LoadKeyAndRunDEA>

00001b86 <_Encrypt2KTDEA>:
;
; Returns:
;     R7:R0   - Result of enciphering, LSB in R0
_Encrypt2KTDEA:
    ; Reload Z with the key block pointer
    movw    r30, r16
    1b86:	f8 01       	movw	r30, r16
    ; Encipher
    clh
    1b88:	d8 94       	clh
    rcall   _LoadKeyAndRunDEA
    1b8a:	dd df       	rcall	.-70     	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Z now points to K2
    ; Decipher
    seh
    1b8c:	58 94       	seh
    rcall   _LoadKeyAndRunDEA
    1b8e:	db df       	rcall	.-74     	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Reload Z with the key block pointer
    movw    r30, r16
    1b90:	f8 01       	movw	r30, r16
    ; Encipher
    clh
    1b92:	d8 94       	clh
    rjmp    _LoadKeyAndRunDEA
    1b94:	d8 cf       	rjmp	.-80     	; 0x1b46 <_LoadKeyAndRunDEA>

00001b96 <_EncryptDEA>:
;
; Returns:
;     R7:R0   - Result of enciphering, LSB in R0
_EncryptDEA:
	; Reload Z with the key block pointer
	movw    r30, r16
    1b96:	f8 01       	movw	r30, r16
    ; Encipher
    clh
    1b98:	d8 94       	clh
    rjmp    _LoadKeyAndRunDEA
    1b9a:	d5 cf       	rjmp	.-86     	; 0x1b46 <_LoadKeyAndRunDEA>

00001b9c <_DecryptDEA>:
;
; Returns:
;     R7:R0   - Result of enciphering, LSB in R0
_DecryptDEA:
	; Reload Z with the key block pointer
	movw    r30, r16
    1b9c:	f8 01       	movw	r30, r16
    ; Encipher
    seh
    1b9e:	58 94       	seh
    rjmp    _LoadKeyAndRunDEA
    1ba0:	d2 cf       	rjmp	.-92     	; 0x1b46 <_LoadKeyAndRunDEA>

00001ba2 <_Decrypt3KTDEA>:
;
; Returns:
;     R7:R0   - Result of enciphering, LSB in R0
_Decrypt3KTDEA:
    ; Reload Z with the key block pointer and adjust to point to K3
    movw    r30, r16
    1ba2:	f8 01       	movw	r30, r16
    adiw    r30, 16
    1ba4:	70 96       	adiw	r30, 0x10	; 16
    ; Decipher
    seh
    1ba6:	58 94       	seh
    rcall   _LoadKeyAndRunDEA
    1ba8:	ce df       	rcall	.-100    	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Reload Z with the key block pointer and adjust to point to K2
    movw    r30, r16
    1baa:	f8 01       	movw	r30, r16
    adiw    r30, 8
    1bac:	38 96       	adiw	r30, 0x08	; 8
    ; Encipher
    clh
    1bae:	d8 94       	clh
    rcall   _LoadKeyAndRunDEA
    1bb0:	ca df       	rcall	.-108    	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Reload Z with the key block pointer
    movw    r30, r16
    1bb2:	f8 01       	movw	r30, r16
    ; Decipher
    seh
    1bb4:	58 94       	seh
    rjmp    _LoadKeyAndRunDEA
    1bb6:	c7 cf       	rjmp	.-114    	; 0x1b46 <_LoadKeyAndRunDEA>

00001bb8 <_Decrypt2KTDEA>:
;
; Returns:
;     R7:R0   - Result of enciphering, LSB in R0
_Decrypt2KTDEA:
    ; Reload Z with the key block pointer
    movw    r30, r16
    1bb8:	f8 01       	movw	r30, r16
    ; Decipher
    seh
    1bba:	58 94       	seh
    rcall   _LoadKeyAndRunDEA
    1bbc:	c4 df       	rcall	.-120    	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Z now points to K2
    ; Encipher
    clh
    1bbe:	d8 94       	clh
    rcall   _LoadKeyAndRunDEA
    1bc0:	c2 df       	rcall	.-124    	; 0x1b46 <_LoadKeyAndRunDEA>

    ; Reload Z with the key block pointer
    movw    r30, r16
    1bc2:	f8 01       	movw	r30, r16
    ; Decipher
    seh
    1bc4:	58 94       	seh
    rjmp    _LoadKeyAndRunDEA
    1bc6:	bf cf       	rjmp	.-130    	; 0x1b46 <_LoadKeyAndRunDEA>

00001bc8 <_CommonEpilogue>:
;
; Common prologue and epilogue code
;

_CommonEpilogue:
    pop     r15
    1bc8:	ff 90       	pop	r15
    pop     r14
    1bca:	ef 90       	pop	r14
    pop     r13
    1bcc:	df 90       	pop	r13
    pop     r12
    1bce:	cf 90       	pop	r12
    pop     r11
    1bd0:	bf 90       	pop	r11
    pop     r10
    1bd2:	af 90       	pop	r10
    pop     r9
    1bd4:	9f 90       	pop	r9
    pop     r8
    1bd6:	8f 90       	pop	r8
    pop     r7
    1bd8:	7f 90       	pop	r7
    pop     r6
    1bda:	6f 90       	pop	r6
    pop     r5
    1bdc:	5f 90       	pop	r5
    pop     r4
    1bde:	4f 90       	pop	r4
    pop     r3
    1be0:	3f 90       	pop	r3
    pop     r2
    1be2:	2f 90       	pop	r2
    eor     r1, r1
    1be4:	11 24       	eor	r1, r1
    ret
    1be6:	08 95       	ret

00001be8 <CryptoDecrypt2KTDEA>:
; Returns:
;     Nothing.
.global CryptoDecrypt2KTDEA
CryptoDecrypt2KTDEA:
    ; Preserve the clobbered regs
    push    r2
    1be8:	2f 92       	push	r2
    push    r3
    1bea:	3f 92       	push	r3
    push    r4
    1bec:	4f 92       	push	r4
    push    r5
    1bee:	5f 92       	push	r5
    push    r6
    1bf0:	6f 92       	push	r6
    push    r7
    1bf2:	7f 92       	push	r7
    push    r8
    1bf4:	8f 92       	push	r8
    push    r9
    1bf6:	9f 92       	push	r9
    push    r10
    1bf8:	af 92       	push	r10
    push    r11
    1bfa:	bf 92       	push	r11
    push    r12
    1bfc:	cf 92       	push	r12
    push    r13
    1bfe:	df 92       	push	r13
    push    r14
    1c00:	ef 92       	push	r14
    push    r15
    1c02:	ff 92       	push	r15
    push    r16
    1c04:	0f 93       	push	r16
    push    r17
    1c06:	1f 93       	push	r17

    ; Load the plaintext pointer to Z and fetch data
    movw    r30, r22
    1c08:	fb 01       	movw	r30, r22
    ld      r7, Z+
    1c0a:	71 90       	ld	r7, Z+
    ld      r6, Z+
    1c0c:	61 90       	ld	r6, Z+
    ld      r5, Z+
    1c0e:	51 90       	ld	r5, Z+
    ld      r4, Z+
    1c10:	41 90       	ld	r4, Z+
    ld      r3, Z+
    1c12:	31 90       	ld	r3, Z+
    ld      r2, Z+
    1c14:	21 90       	ld	r2, Z+
    ld      r1, Z+
    1c16:	11 90       	ld	r1, Z+
    ld      r0, Z+
    1c18:	01 90       	ld	r0, Z+
    ; Encrypt
    movw    r16, r20
    1c1a:	8a 01       	movw	r16, r20
    rcall   _Decrypt2KTDEA
    1c1c:	cd df       	rcall	.-102    	; 0x1bb8 <_Decrypt2KTDEA>
    ; Store the ciphertext
    movw    r30, r24
    1c1e:	fc 01       	movw	r30, r24
    st      Z+, r7
    1c20:	71 92       	st	Z+, r7
    st      Z+, r6
    1c22:	61 92       	st	Z+, r6
    st      Z+, r5
    1c24:	51 92       	st	Z+, r5
    st      Z+, r4
    1c26:	41 92       	st	Z+, r4
    st      Z+, r3
    1c28:	31 92       	st	Z+, r3
    st      Z+, r2
    1c2a:	21 92       	st	Z+, r2
    st      Z+, r1
    1c2c:	11 92       	st	Z+, r1
    st      Z+, r0
    1c2e:	01 92       	st	Z+, r0

    ; Restore clobbered regs
    pop     r17
    1c30:	1f 91       	pop	r17
    pop     r16
    1c32:	0f 91       	pop	r16
    ; Reuse epilogue code
    rjmp    _CommonEpilogue
    1c34:	c9 cf       	rjmp	.-110    	; 0x1bc8 <_CommonEpilogue>

00001c36 <CryptoEncrypt2KTDEA>:
; Returns:
;     Nothing.
.global CryptoEncrypt2KTDEA
CryptoEncrypt2KTDEA:
    ; Preserve the clobbered regs
    push    r2
    1c36:	2f 92       	push	r2
    push    r3
    1c38:	3f 92       	push	r3
    push    r4
    1c3a:	4f 92       	push	r4
    push    r5
    1c3c:	5f 92       	push	r5
    push    r6
    1c3e:	6f 92       	push	r6
    push    r7
    1c40:	7f 92       	push	r7
    push    r8
    1c42:	8f 92       	push	r8
    push    r9
    1c44:	9f 92       	push	r9
    push    r10
    1c46:	af 92       	push	r10
    push    r11
    1c48:	bf 92       	push	r11
    push    r12
    1c4a:	cf 92       	push	r12
    push    r13
    1c4c:	df 92       	push	r13
    push    r14
    1c4e:	ef 92       	push	r14
    push    r15
    1c50:	ff 92       	push	r15
    push    r16
    1c52:	0f 93       	push	r16
    push    r17
    1c54:	1f 93       	push	r17

    ; Load the plaintext pointer to Z and fetch data
    movw    r30, r24
    1c56:	fc 01       	movw	r30, r24
    ld      r7, Z+
    1c58:	71 90       	ld	r7, Z+
    ld      r6, Z+
    1c5a:	61 90       	ld	r6, Z+
    ld      r5, Z+
    1c5c:	51 90       	ld	r5, Z+
    ld      r4, Z+
    1c5e:	41 90       	ld	r4, Z+
    ld      r3, Z+
    1c60:	31 90       	ld	r3, Z+
    ld      r2, Z+
    1c62:	21 90       	ld	r2, Z+
    ld      r1, Z+
    1c64:	11 90       	ld	r1, Z+
    ld      r0, Z+
    1c66:	01 90       	ld	r0, Z+
    ; Encrypt
    movw    r16, r20
    1c68:	8a 01       	movw	r16, r20
    rcall   _Encrypt2KTDEA
    1c6a:	8d df       	rcall	.-230    	; 0x1b86 <_Encrypt2KTDEA>
    ; Store the ciphertext
    movw    r30, r22
    1c6c:	fb 01       	movw	r30, r22
    st      Z+, r7
    1c6e:	71 92       	st	Z+, r7
    st      Z+, r6
    1c70:	61 92       	st	Z+, r6
    st      Z+, r5
    1c72:	51 92       	st	Z+, r5
    st      Z+, r4
    1c74:	41 92       	st	Z+, r4
    st      Z+, r3
    1c76:	31 92       	st	Z+, r3
    st      Z+, r2
    1c78:	21 92       	st	Z+, r2
    st      Z+, r1
    1c7a:	11 92       	st	Z+, r1
    st      Z+, r0
    1c7c:	01 92       	st	Z+, r0

    ; Restore clobbered regs
    pop     r17
    1c7e:	1f 91       	pop	r17
    pop     r16
    1c80:	0f 91       	pop	r16
    ; Reuse epilogue code
    rjmp    _CommonEpilogue
    1c82:	a2 cf       	rjmp	.-188    	; 0x1bc8 <_CommonEpilogue>

00001c84 <_DEACBCSend>:
; Returns:
;     Nothing.
;
_DEACBCSend:
    ; Preserve the clobbered regs
    push    r2
    1c84:	2f 92       	push	r2
    push    r3
    1c86:	3f 92       	push	r3
    push    r4
    1c88:	4f 92       	push	r4
    push    r5
    1c8a:	5f 92       	push	r5
    push    r6
    1c8c:	6f 92       	push	r6
    push    r7
    1c8e:	7f 92       	push	r7
    push    r8
    1c90:	8f 92       	push	r8
    push    r9
    1c92:	9f 92       	push	r9
    push    r10
    1c94:	af 92       	push	r10
    push    r11
    1c96:	bf 92       	push	r11
    push    r12
    1c98:	cf 92       	push	r12
    push    r13
    1c9a:	df 92       	push	r13
    push    r14
    1c9c:	ef 92       	push	r14
    push    r15
    1c9e:	ff 92       	push	r15
    push    r28
    1ca0:	cf 93       	push	r28
    push    r29
    1ca2:	df 93       	push	r29

    ; Load the plaintext pointer to Y
    movw    r28, r22
    1ca4:	eb 01       	movw	r28, r22
    ; Load the ciphertext pointer to X
    movw    r26, r20
    1ca6:	da 01       	movw	r26, r20
    ; Store the crypto primitive pointer in r23:r22
    movw    r22, r30
    1ca8:	bf 01       	movw	r22, r30

    ; Load the IV pointer to Z
    movw    r30, r18
    1caa:	f9 01       	movw	r30, r18
    ; Load the IV
    ld      r7, Z+
    1cac:	71 90       	ld	r7, Z+
    ld      r6, Z+
    1cae:	61 90       	ld	r6, Z+
    ld      r5, Z+
    1cb0:	51 90       	ld	r5, Z+
    ld      r4, Z+
    1cb2:	41 90       	ld	r4, Z+
    ld      r3, Z+
    1cb4:	31 90       	ld	r3, Z+
    ld      r2, Z+
    1cb6:	21 90       	ld	r2, Z+
    ld      r1, Z+
    1cb8:	11 90       	ld	r1, Z+
    ld      r0, Z+
    1cba:	01 90       	ld	r0, Z+

1:
    ; Load the plaintext block
    ld      r15, Y+
    1cbc:	f9 90       	ld	r15, Y+
    ld      r14, Y+
    1cbe:	e9 90       	ld	r14, Y+
    ld      r13, Y+
    1cc0:	d9 90       	ld	r13, Y+
    ld      r12, Y+
    1cc2:	c9 90       	ld	r12, Y+
    ld      r11, Y+
    1cc4:	b9 90       	ld	r11, Y+
    ld      r10, Y+
    1cc6:	a9 90       	ld	r10, Y+
    ld      r9, Y+
    1cc8:	99 90       	ld	r9, Y+
    ld      r8, Y+
    1cca:	89 90       	ld	r8, Y+
    ; XOR the plaintext with the IV
    eor     r7, r15
    1ccc:	7f 24       	eor	r7, r15
    eor     r6, r14
    1cce:	6e 24       	eor	r6, r14
    eor     r5, r13
    1cd0:	5d 24       	eor	r5, r13
    eor     r4, r12
    1cd2:	4c 24       	eor	r4, r12
    eor     r3, r11
    1cd4:	3b 24       	eor	r3, r11
    eor     r2, r10
    1cd6:	2a 24       	eor	r2, r10
    eor     r1, r9
    1cd8:	19 24       	eor	r1, r9
    eor     r0, r8
    1cda:	08 24       	eor	r0, r8

    ; Call the primitive
    movw    r30, r22
    1cdc:	fb 01       	movw	r30, r22
    icall
    1cde:	09 95       	icall

    ; Store the ciphertext
    ; It will be reused as the IV for the next block, if any
    st      X+, r7
    1ce0:	7d 92       	st	X+, r7
    st      X+, r6
    1ce2:	6d 92       	st	X+, r6
    st      X+, r5
    1ce4:	5d 92       	st	X+, r5
    st      X+, r4
    1ce6:	4d 92       	st	X+, r4
    st      X+, r3
    1ce8:	3d 92       	st	X+, r3
    st      X+, r2
    1cea:	2d 92       	st	X+, r2
    st      X+, r1
    1cec:	1d 92       	st	X+, r1
    st      X+, r0
    1cee:	0d 92       	st	X+, r0

    ; Decrement the counter, repeat if more blocks.
    sbiw    r24, 1
    1cf0:	01 97       	sbiw	r24, 0x01	; 1
    brne    1b
    1cf2:	21 f7       	brne	.-56     	; 0x1cbc <_DEACBCSend+0x38>

    ; Load the IV pointer to X
    movw    r26, r18
    1cf4:	d9 01       	movw	r26, r18
    ; Store the updated IV
    st      X+, r7
    1cf6:	7d 92       	st	X+, r7
    st      X+, r6
    1cf8:	6d 92       	st	X+, r6
    st      X+, r5
    1cfa:	5d 92       	st	X+, r5
    st      X+, r4
    1cfc:	4d 92       	st	X+, r4
    st      X+, r3
    1cfe:	3d 92       	st	X+, r3
    st      X+, r2
    1d00:	2d 92       	st	X+, r2
    st      X+, r1
    1d02:	1d 92       	st	X+, r1
    st      X+, r0
    1d04:	0d 92       	st	X+, r0

    ; Restore clobbered regs
    pop     r29
    1d06:	df 91       	pop	r29
    pop     r28
    1d08:	cf 91       	pop	r28
    rjmp    _CommonEpilogue
    1d0a:	5e cf       	rjmp	.-324    	; 0x1bc8 <_CommonEpilogue>

00001d0c <_DEACBCReceive>:
; Returns:
;     Nothing.
;
_DEACBCReceive:
    ; Preserve the clobbered regs
    push    r2
    1d0c:	2f 92       	push	r2
    push    r3
    1d0e:	3f 92       	push	r3
    push    r4
    1d10:	4f 92       	push	r4
    push    r5
    1d12:	5f 92       	push	r5
    push    r6
    1d14:	6f 92       	push	r6
    push    r7
    1d16:	7f 92       	push	r7
    push    r8
    1d18:	8f 92       	push	r8
    push    r9
    1d1a:	9f 92       	push	r9
    push    r10
    1d1c:	af 92       	push	r10
    push    r11
    1d1e:	bf 92       	push	r11
    push    r12
    1d20:	cf 92       	push	r12
    push    r13
    1d22:	df 92       	push	r13
    push    r14
    1d24:	ef 92       	push	r14
    push    r15
    1d26:	ff 92       	push	r15
    push    r28
    1d28:	cf 93       	push	r28
    push    r29
    1d2a:	df 93       	push	r29

    ; Load the plaintext pointer to Y
    movw    r28, r22
    1d2c:	eb 01       	movw	r28, r22
    ; Load the ciphertext pointer to X
    movw    r26, r20
    1d2e:	da 01       	movw	r26, r20
    ; Store the crypto primitive pointer in r23:r22
    movw    r22, r30
    1d30:	bf 01       	movw	r22, r30

1:
    ; Load the plaintext block
    ldd     r7, Y+0
    1d32:	78 80       	ld	r7, Y
    ldd     r6, Y+1
    1d34:	69 80       	ldd	r6, Y+1	; 0x01
    ldd     r5, Y+2
    1d36:	5a 80       	ldd	r5, Y+2	; 0x02
    ldd     r4, Y+3
    1d38:	4b 80       	ldd	r4, Y+3	; 0x03
    ldd     r3, Y+4
    1d3a:	3c 80       	ldd	r3, Y+4	; 0x04
    ldd     r2, Y+5
    1d3c:	2d 80       	ldd	r2, Y+5	; 0x05
    ldd     r1, Y+6
    1d3e:	1e 80       	ldd	r1, Y+6	; 0x06
    ldd     r0, Y+7
    1d40:	0f 80       	ldd	r0, Y+7	; 0x07

    ; Call the primitive
    movw    r30, r22
    1d42:	fb 01       	movw	r30, r22
    icall
    1d44:	09 95       	icall
    
    ; Load the IV block
    movw    r30, r18
    1d46:	f9 01       	movw	r30, r18
    ld      r15, Z+
    1d48:	f1 90       	ld	r15, Z+
    ld      r14, Z+
    1d4a:	e1 90       	ld	r14, Z+
    ld      r13, Z+
    1d4c:	d1 90       	ld	r13, Z+
    ld      r12, Z+
    1d4e:	c1 90       	ld	r12, Z+
    ld      r11, Z+
    1d50:	b1 90       	ld	r11, Z+
    ld      r10, Z+
    1d52:	a1 90       	ld	r10, Z+
    ld      r9, Z+
    1d54:	91 90       	ld	r9, Z+
    ld      r8, Z+
    1d56:	81 90       	ld	r8, Z+
    ; XOR the ciphertext with the IV
    eor     r7, r15
    1d58:	7f 24       	eor	r7, r15
    eor     r6, r14
    1d5a:	6e 24       	eor	r6, r14
    eor     r5, r13
    1d5c:	5d 24       	eor	r5, r13
    eor     r4, r12
    1d5e:	4c 24       	eor	r4, r12
    eor     r3, r11
    1d60:	3b 24       	eor	r3, r11
    eor     r2, r10
    1d62:	2a 24       	eor	r2, r10
    eor     r1, r9
    1d64:	19 24       	eor	r1, r9
    eor     r0, r8
    1d66:	08 24       	eor	r0, r8
    ; Reload the plaintext block
    ld      r15, Y+
    1d68:	f9 90       	ld	r15, Y+
    ld      r14, Y+
    1d6a:	e9 90       	ld	r14, Y+
    ld      r13, Y+
    1d6c:	d9 90       	ld	r13, Y+
    ld      r12, Y+
    1d6e:	c9 90       	ld	r12, Y+
    ld      r11, Y+
    1d70:	b9 90       	ld	r11, Y+
    ld      r10, Y+
    1d72:	a9 90       	ld	r10, Y+
    ld      r9, Y+
    1d74:	99 90       	ld	r9, Y+
    ld      r8, Y+
    1d76:	89 90       	ld	r8, Y+
    ; Store the new IV before it gets potentially overwritten
    movw    r30, r18
    1d78:	f9 01       	movw	r30, r18
    st      Z+, r15
    1d7a:	f1 92       	st	Z+, r15
    st      Z+, r14
    1d7c:	e1 92       	st	Z+, r14
    st      Z+, r13
    1d7e:	d1 92       	st	Z+, r13
    st      Z+, r12
    1d80:	c1 92       	st	Z+, r12
    st      Z+, r11
    1d82:	b1 92       	st	Z+, r11
    st      Z+, r10
    1d84:	a1 92       	st	Z+, r10
    st      Z+, r9
    1d86:	91 92       	st	Z+, r9
    st      Z+, r8
    1d88:	81 92       	st	Z+, r8
    ; Store the ciphertext
    st      X+, r7
    1d8a:	7d 92       	st	X+, r7
    st      X+, r6
    1d8c:	6d 92       	st	X+, r6
    st      X+, r5
    1d8e:	5d 92       	st	X+, r5
    st      X+, r4
    1d90:	4d 92       	st	X+, r4
    st      X+, r3
    1d92:	3d 92       	st	X+, r3
    st      X+, r2
    1d94:	2d 92       	st	X+, r2
    st      X+, r1
    1d96:	1d 92       	st	X+, r1
    st      X+, r0
    1d98:	0d 92       	st	X+, r0

    ; Decrement the counter, repeat if more blocks.
    sbiw    r24, 1
    1d9a:	01 97       	sbiw	r24, 0x01	; 1
    brne    1b
    1d9c:	51 f6       	brne	.-108    	; 0x1d32 <_DEACBCReceive+0x26>

    ; Restore clobbered regs
    pop     r29
    1d9e:	df 91       	pop	r29
    pop     r28
    1da0:	cf 91       	pop	r28
    rjmp    _CommonEpilogue
    1da2:	12 cf       	rjmp	.-476    	; 0x1bc8 <_CommonEpilogue>

00001da4 <CryptoEncrypt2KTDEA_CBCSend>:
;
; Returns:
;     Nothing.
.global CryptoEncrypt2KTDEA_CBCSend
CryptoEncrypt2KTDEA_CBCSend:
    ldi     r31, pm_hi8(_Encrypt2KTDEA)
    1da4:	fd e0       	ldi	r31, 0x0D	; 13
    ldi     r30, pm_lo8(_Encrypt2KTDEA)
    1da6:	e3 ec       	ldi	r30, 0xC3	; 195
    rjmp    _DEACBCSend
    1da8:	6d cf       	rjmp	.-294    	; 0x1c84 <_DEACBCSend>

00001daa <CryptoEncrypt2KTDEA_CBCReceive>:
;
; Returns:
;     Nothing.
.global CryptoEncrypt2KTDEA_CBCReceive
CryptoEncrypt2KTDEA_CBCReceive:
    ldi     r31, pm_hi8(_Encrypt2KTDEA)
    1daa:	fd e0       	ldi	r31, 0x0D	; 13
    ldi     r30, pm_lo8(_Encrypt2KTDEA)
    1dac:	e3 ec       	ldi	r30, 0xC3	; 195
    rjmp    _DEACBCReceive
    1dae:	ae cf       	rjmp	.-164    	; 0x1d0c <_DEACBCReceive>

00001db0 <CryptoDecrypt2KTDEA_CBCSend>:
;
; Returns:
;     Nothing.
.global CryptoDecrypt2KTDEA_CBCSend
CryptoDecrypt2KTDEA_CBCSend:
    ldi     r31, pm_hi8(_Decrypt2KTDEA)
    1db0:	fd e0       	ldi	r31, 0x0D	; 13
    ldi     r30, pm_lo8(_Decrypt2KTDEA)
    1db2:	ec ed       	ldi	r30, 0xDC	; 220
    rjmp    _DEACBCSend
    1db4:	67 cf       	rjmp	.-306    	; 0x1c84 <_DEACBCSend>

00001db6 <CryptoDecrypt2KTDEA_CBCReceive>:
;
; Returns:
;     Nothing.
.global CryptoDecrypt2KTDEA_CBCReceive
CryptoDecrypt2KTDEA_CBCReceive:
    ldi     r31, pm_hi8(_Decrypt2KTDEA)
    1db6:	fd e0       	ldi	r31, 0x0D	; 13
    ldi     r30, pm_lo8(_Decrypt2KTDEA)
    1db8:	ec ed       	ldi	r30, 0xDC	; 220
    rjmp    _DEACBCReceive
    1dba:	a8 cf       	rjmp	.-176    	; 0x1d0c <_DEACBCReceive>

00001dbc <CryptoEncrypt3KTDEA_CBCSend>:
;
; Returns:
;     Nothing.
.global CryptoEncrypt3KTDEA_CBCSend
CryptoEncrypt3KTDEA_CBCSend:
    ldi     r31, pm_hi8(_Encrypt3KTDEA)
    1dbc:	fd e0       	ldi	r31, 0x0D	; 13
    ldi     r30, pm_lo8(_Encrypt3KTDEA)
    1dbe:	ec eb       	ldi	r30, 0xBC	; 188
    rjmp    _DEACBCSend
    1dc0:	61 cf       	rjmp	.-318    	; 0x1c84 <_DEACBCSend>

00001dc2 <CryptoEncrypt3KTDEA_CBCReceive>:
;
; Returns:
;     Nothing.
.global CryptoEncrypt3KTDEA_CBCReceive
CryptoEncrypt3KTDEA_CBCReceive:
    ldi     r31, pm_hi8(_Decrypt3KTDEA)
    1dc2:	fd e0       	ldi	r31, 0x0D	; 13
    ldi     r30, pm_lo8(_Decrypt3KTDEA)
    1dc4:	e1 ed       	ldi	r30, 0xD1	; 209
    rjmp    _DEACBCReceive
    1dc6:	a2 cf       	rjmp	.-188    	; 0x1d0c <_DEACBCReceive>

00001dc8 <main>:
#include "Chameleon-Mini.h"

int main(void) {
    SystemInit();
    1dc8:	13 d1       	rcall	.+550    	; 0x1ff0 <SystemInit>
    SettingsLoad();
    1dca:	0e 94 b0 19 	call	0x3360	; 0x3360 <SettingsLoad>
    LEDInit();
    1dce:	0e 94 4c 1a 	call	0x3498	; 0x3498 <LEDInit>
    MemoryInit();
    1dd2:	ad d2       	rcall	.+1370   	; 0x232e <MemoryInit>
INLINE void CodecInitCommon(void) {
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    1dd4:	10 92 52 06 	sts	0x0652, r1	; 0x800652 <__TEXT_REGION_LENGTH__+0x700652>
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    1dd8:	84 e0       	ldi	r24, 0x04	; 4
    1dda:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    1dde:	82 e6       	ldi	r24, 0x62	; 98
    1de0:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <__TEXT_REGION_LENGTH__+0x700186>

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    1de4:	c1 e0       	ldi	r28, 0x01	; 1
    1de6:	c0 93 26 06 	sts	0x0626, r28	; 0x800626 <__TEXT_REGION_LENGTH__+0x700626>
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    1dea:	c0 93 21 06 	sts	0x0621, r28	; 0x800621 <__TEXT_REGION_LENGTH__+0x700621>
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    1dee:	86 e0       	ldi	r24, 0x06	; 6
    1df0:	80 93 22 06 	sts	0x0622, r24	; 0x800622 <__TEXT_REGION_LENGTH__+0x700622>
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    1df4:	c0 93 31 06 	sts	0x0631, r28	; 0x800631 <__TEXT_REGION_LENGTH__+0x700631>
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    1df8:	12 e0       	ldi	r17, 0x02	; 2
    1dfa:	10 93 32 06 	sts	0x0632, r17	; 0x800632 <__TEXT_REGION_LENGTH__+0x700632>
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    1dfe:	10 92 2a 06 	sts	0x062A, r1	; 0x80062a <__TEXT_REGION_LENGTH__+0x70062a>
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    1e02:	10 92 2b 06 	sts	0x062B, r1	; 0x80062b <__TEXT_REGION_LENGTH__+0x70062b>
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    1e06:	8f e0       	ldi	r24, 0x0F	; 15
    1e08:	80 93 29 06 	sts	0x0629, r24	; 0x800629 <__TEXT_REGION_LENGTH__+0x700629>
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    1e0c:	89 e5       	ldi	r24, 0x59	; 89
    1e0e:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    1e12:	9a e5       	ldi	r25, 0x5A	; 90
    1e14:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <__TEXT_REGION_LENGTH__+0x700181>

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    1e18:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <__TEXT_REGION_LENGTH__+0x700182>


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    1e1c:	80 e4       	ldi	r24, 0x40	; 64
    1e1e:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    1e22:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    1e26:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7000b2>
    1e2a:	90 7f       	andi	r25, 0xF0	; 240
    1e2c:	90 93 b2 00 	sts	0x00B2, r25	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7000b2>
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    1e30:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7000b2>
    1e34:	92 60       	ori	r25, 0x02	; 2
    1e36:	90 93 b2 00 	sts	0x00B2, r25	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7000b2>

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    1e3a:	90 e3       	ldi	r25, 0x30	; 48
    1e3c:	90 93 41 06 	sts	0x0641, r25	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    1e40:	90 93 46 06 	sts	0x0646, r25	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    1e44:	80 93 50 06 	sts	0x0650, r24	; 0x800650 <__TEXT_REGION_LENGTH__+0x700650>
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    1e48:	c0 93 46 06 	sts	0x0646, r28	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    1e4c:	10 93 45 06 	sts	0x0645, r17	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    1e50:	03 e0       	ldi	r16, 0x03	; 3
    1e52:	00 93 41 06 	sts	0x0641, r16	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    1e56:	83 e1       	ldi	r24, 0x13	; 19
    1e58:	80 93 01 08 	sts	0x0801, r24	; 0x800801 <__TEXT_REGION_LENGTH__+0x700801>
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    1e5c:	21 e0       	ldi	r18, 0x01	; 1
    1e5e:	30 e0       	ldi	r19, 0x00	; 0
    1e60:	20 93 26 08 	sts	0x0826, r18	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    1e64:	30 93 27 08 	sts	0x0827, r19	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    1e68:	20 93 28 08 	sts	0x0828, r18	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1e6c:	30 93 29 08 	sts	0x0829, r19	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>

    AWEXC.OUTOVEN = 0x00;
    1e70:	10 92 8c 08 	sts	0x088C, r1	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    1e74:	80 93 80 08 	sts	0x0880, r24	; 0x800880 <__TEXT_REGION_LENGTH__+0x700880>

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    1e78:	10 92 23 03 	sts	0x0323, r1	; 0x800323 <__TEXT_REGION_LENGTH__+0x700323>
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    1e7c:	10 92 21 03 	sts	0x0321, r1	; 0x800321 <__TEXT_REGION_LENGTH__+0x700321>
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    1e80:	d8 e0       	ldi	r29, 0x08	; 8
    1e82:	d0 93 22 03 	sts	0x0322, r29	; 0x800322 <__TEXT_REGION_LENGTH__+0x700322>
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    1e86:	81 e1       	ldi	r24, 0x11	; 17
    1e88:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <__TEXT_REGION_LENGTH__+0x700320>
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    1e8c:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    1e90:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    1e94:	82 85       	ldd	r24, Z+10	; 0x0a
    1e96:	93 85       	ldd	r25, Z+11	; 0x0b
    1e98:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <__TEXT_REGION_LENGTH__+0x700338>
    1e9c:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <__TEXT_REGION_LENGTH__+0x700339>

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    1ea0:	8c e3       	ldi	r24, 0x3C	; 60
    1ea2:	80 93 82 03 	sts	0x0382, r24	; 0x800382 <__TEXT_REGION_LENGTH__+0x700382>
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    1ea6:	d0 93 80 03 	sts	0x0380, r29	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    1eaa:	80 93 83 03 	sts	0x0383, r24	; 0x800383 <__TEXT_REGION_LENGTH__+0x700383>
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    1eae:	d0 93 81 03 	sts	0x0381, r29	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>
    CodecInitCommon();
    ConfigurationInit();
    TerminalInit();
    1eb2:	66 d1       	rcall	.+716    	; 0x2180 <ConfigurationInit>
    RandomInit();
    1eb4:	0e 94 ee 1b 	call	0x37dc	; 0x37dc <TerminalInit>
    ButtonInit();
    1eb8:	b7 d1       	rcall	.+878    	; 0x2228 <RandomInit>
    1eba:	24 d7       	rcall	.+3656   	; 0x2d04 <ButtonInit>
#define ANTENNA_LEVEL_NUMERATOR	((uint32_t) (ANTENNA_LEVEL_MILLIVOLT * ANTENNA_LEVEL_FACTOR * ANTENNA_LEVEL_SCALE + .5))
#define ANTENNA_LEVEL_DENOMINATOR (ANTENNA_LEVEL_SCALE)

static inline
void AntennaLevelInit(void) {
    ADCA.CTRLA = ADC_ENABLE_bm;
    1ebc:	c0 93 00 02 	sts	0x0200, r28	; 0x800200 <__TEXT_REGION_LENGTH__+0x700200>
    ADCA.CTRLB = ADC_RESOLUTION_12BIT_gc;
    1ec0:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
    ADCA.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_BANDGAP_bm;
    1ec4:	10 93 02 02 	sts	0x0202, r17	; 0x800202 <__TEXT_REGION_LENGTH__+0x700202>
    ADCA.PRESCALER = ADC_PRESCALER_DIV32_gc;
    1ec8:	00 93 04 02 	sts	0x0204, r16	; 0x800204 <__TEXT_REGION_LENGTH__+0x700204>
    ADCA.CH0.CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    1ecc:	c0 93 20 02 	sts	0x0220, r28	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
    ADCA.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;
    1ed0:	d0 93 21 02 	sts	0x0221, r29	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
    AntennaLevelInit();
    LogInit();
    1ed4:	0e 94 43 18 	call	0x3086	; 0x3086 <LogInit>
    SystemInterruptInit();
    1ed8:	17 d1       	rcall	.+558    	; 0x2108 <SystemInterruptInit>
INLINE bool SystemTick100ms(void) {
    if (RTC.INTFLAGS & RTC_COMPIF_bm) {
        while (RTC.STATUS & RTC_SYNCBUSY_bm)
            ;

        RTC.INTFLAGS = RTC_COMPIF_bm;
    1eda:	d2 e0       	ldi	r29, 0x02	; 2
    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
        LEDGreenAction = Action;
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
        LEDRedAction = Action;
    1edc:	c1 e1       	ldi	r28, 0x11	; 17
void SystemStopUSBClock(void);
void SystemInterruptInit(void);
INLINE bool SystemTick100ms(void);

INLINE bool SystemTick100ms(void) {
    if (RTC.INTFLAGS & RTC_COMPIF_bm) {
    1ede:	80 91 03 04 	lds	r24, 0x0403	; 0x800403 <__TEXT_REGION_LENGTH__+0x700403>
    1ee2:	81 ff       	sbrs	r24, 1
    1ee4:	25 c0       	rjmp	.+74     	; 0x1f30 <main+0x168>
        while (RTC.STATUS & RTC_SYNCBUSY_bm)
    1ee6:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <__TEXT_REGION_LENGTH__+0x700401>
    1eea:	80 fd       	sbrc	r24, 0
            ;

        RTC.INTFLAGS = RTC_COMPIF_bm;
    1eec:	fc cf       	rjmp	.-8      	; 0x1ee6 <main+0x11e>

    while (1) {
        if (SystemTick100ms()) {
            LEDTick(); // this has to be the first function called here, since it is time-critical - the functions below may have non-negligible runtimes!
    1eee:	d0 93 03 04 	sts	0x0403, r29	; 0x800403 <__TEXT_REGION_LENGTH__+0x700403>

            RandomTick();
    1ef2:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <LEDTick>
            TerminalTick();
    1ef6:	ae d1       	rcall	.+860    	; 0x2254 <RandomTick>
    1ef8:	0e 94 21 1c 	call	0x3842	; 0x3842 <TerminalTick>
            ButtonTick();
    1efc:	0b d7       	rcall	.+3606   	; 0x2d14 <ButtonTick>
            LogTick();
    1efe:	0e 94 ab 19 	call	0x3356	; 0x3356 <LogTick>
INLINE void ApplicationTask(void) {
    ActiveConfiguration.ApplicationTaskFunc();
}

INLINE void ApplicationTick(void) {
    ActiveConfiguration.ApplicationTickFunc();
    1f02:	e0 91 c9 2f 	lds	r30, 0x2FC9	; 0x802fc9 <ActiveConfiguration+0xc>
    1f06:	f0 91 ca 2f 	lds	r31, 0x2FCA	; 0x802fca <ActiveConfiguration+0xd>
    1f0a:	19 95       	eicall
            ApplicationTick();
            CommandLineTick();
    1f0c:	0e 94 94 25 	call	0x4b28	; 0x4b28 <CommandLineTick>
            AntennaLevelTick();
    1f10:	0e 94 8d 1b 	call	0x371a	; 0x371a <AntennaLevelTick>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    1f14:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    1f18:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    1f1c:	87 81       	ldd	r24, Z+7	; 0x07
    1f1e:	81 30       	cpi	r24, 0x01	; 1
    1f20:	11 f4       	brne	.+4      	; 0x1f26 <main+0x15e>
        LEDGreenAction = Action;
    1f22:	c0 93 95 2c 	sts	0x2C95, r28	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    1f26:	86 81       	ldd	r24, Z+6	; 0x06
    1f28:	81 30       	cpi	r24, 0x01	; 1
        LEDRedAction = Action;
    1f2a:	11 f4       	brne	.+4      	; 0x1f30 <main+0x168>
    1f2c:	c0 93 94 2c 	sts	0x2C94, r28	; 0x802c94 <LEDRedAction>

            LEDHook(LED_POWERED, LED_ON);
        }

        TerminalTask();
    1f30:	0e 94 f2 1b 	call	0x37e4	; 0x37e4 <TerminalTask>
        LogTask();
    1f34:	a9 d7       	rcall	.+3922   	; 0x2e88 <LogTask>
INLINE void ApplicationInit(void) {
    ActiveConfiguration.ApplicationInitFunc();
}

INLINE void ApplicationTask(void) {
    ActiveConfiguration.ApplicationTaskFunc();
    1f36:	e0 91 c7 2f 	lds	r30, 0x2FC7	; 0x802fc7 <ActiveConfiguration+0xa>
    1f3a:	f0 91 c8 2f 	lds	r31, 0x2FC8	; 0x802fc8 <ActiveConfiguration+0xb>
    1f3e:	19 95       	eicall
INLINE void CodecDeInit(void) {
    ActiveConfiguration.CodecDeInitFunc();
}

INLINE void CodecTask(void) {
    ActiveConfiguration.CodecTaskFunc();
    1f40:	e0 91 c1 2f 	lds	r30, 0x2FC1	; 0x802fc1 <ActiveConfiguration+0x4>
    1f44:	f0 91 c2 2f 	lds	r31, 0x2FC2	; 0x802fc2 <ActiveConfiguration+0x5>
    1f48:	19 95       	eicall
    1f4a:	c9 cf       	rjmp	.-110    	; 0x1ede <main+0x116>

00001f4c <CALLBACK_USB_GetDescriptor>:
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void *Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType) {
    1f4c:	29 2f       	mov	r18, r25
    1f4e:	33 27       	eor	r19, r19
    1f50:	22 30       	cpi	r18, 0x02	; 2
    1f52:	31 05       	cpc	r19, r1
    1f54:	59 f0       	breq	.+22     	; 0x1f6c <CALLBACK_USB_GetDescriptor+0x20>
    1f56:	23 30       	cpi	r18, 0x03	; 3
    1f58:	31 05       	cpc	r19, r1
    1f5a:	69 f0       	breq	.+26     	; 0x1f76 <CALLBACK_USB_GetDescriptor+0x2a>
    1f5c:	21 30       	cpi	r18, 0x01	; 1
    1f5e:	31 05       	cpc	r19, r1
    1f60:	e9 f4       	brne	.+58     	; 0x1f9c <CALLBACK_USB_GetDescriptor+0x50>
        case DTYPE_Device:
            Address = &DeviceDescriptor;
            Size    = sizeof(USB_Descriptor_Device_t);
    1f62:	82 e1       	ldi	r24, 0x12	; 18
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    const void *Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType) {
        case DTYPE_Device:
            Address = &DeviceDescriptor;
    1f66:	26 e9       	ldi	r18, 0x96	; 150
    1f68:	32 e0       	ldi	r19, 0x02	; 2
    1f6a:	1c c0       	rjmp	.+56     	; 0x1fa4 <CALLBACK_USB_GetDescriptor+0x58>
            Size    = sizeof(USB_Descriptor_Device_t);
            break;
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
            Size    = sizeof(USB_Descriptor_Configuration_t);
    1f6c:	8e e3       	ldi	r24, 0x3E	; 62
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
        case DTYPE_Device:
            Address = &DeviceDescriptor;
            Size    = sizeof(USB_Descriptor_Device_t);
            break;
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
    1f70:	28 e5       	ldi	r18, 0x58	; 88
    1f72:	32 e0       	ldi	r19, 0x02	; 2
            Size    = sizeof(USB_Descriptor_Configuration_t);
            break;
    1f74:	17 c0       	rjmp	.+46     	; 0x1fa4 <CALLBACK_USB_GetDescriptor+0x58>
        case DTYPE_String:
            switch (DescriptorNumber) {
    1f76:	99 27       	eor	r25, r25
    1f78:	81 30       	cpi	r24, 0x01	; 1
    1f7a:	91 05       	cpc	r25, r1
    1f7c:	49 f0       	breq	.+18     	; 0x1f90 <CALLBACK_USB_GetDescriptor+0x44>
    1f7e:	28 f0       	brcs	.+10     	; 0x1f8a <CALLBACK_USB_GetDescriptor+0x3e>
    1f80:	02 97       	sbiw	r24, 0x02	; 2
    1f82:	61 f4       	brne	.+24     	; 0x1f9c <CALLBACK_USB_GetDescriptor+0x50>
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
                    break;
                case 0x02:
                    Address = &ProductString;
                    Size    = pgm_read_byte(&ProductString.Header.Size);
    1f84:	e8 e0       	ldi	r30, 0x08	; 8
    1f86:	f2 e0       	ldi	r31, 0x02	; 2
    1f88:	05 c0       	rjmp	.+10     	; 0x1f94 <CALLBACK_USB_GetDescriptor+0x48>
            break;
        case DTYPE_String:
            switch (DescriptorNumber) {
                case 0x00:
                    Address = &LanguageString;
                    Size    = pgm_read_byte(&LanguageString.Header.Size);
    1f8a:	e4 e5       	ldi	r30, 0x54	; 84
    1f8c:	f2 e0       	ldi	r31, 0x02	; 2
    1f8e:	02 c0       	rjmp	.+4      	; 0x1f94 <CALLBACK_USB_GetDescriptor+0x48>
                    break;
                case 0x01:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    1f90:	e8 e2       	ldi	r30, 0x28	; 40
    1f92:	f2 e0       	ldi	r31, 0x02	; 2
                    break;
                case 0x02:
                    Address = &ProductString;
                    Size    = pgm_read_byte(&ProductString.Header.Size);
    1f94:	84 91       	lpm	r24, Z
    1f96:	90 e0       	ldi	r25, 0x00	; 0
                case 0x01:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
                    break;
                case 0x02:
                    Address = &ProductString;
    1f98:	9f 01       	movw	r18, r30
                    Size    = pgm_read_byte(&ProductString.Header.Size);
                    break;
    1f9a:	04 c0       	rjmp	.+8      	; 0x1fa4 <CALLBACK_USB_GetDescriptor+0x58>
                                    const void **const DescriptorAddress) {
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void *Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;
    1f9c:	80 e0       	ldi	r24, 0x00	; 0
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
                                    const uint8_t wIndex,
                                    const void **const DescriptorAddress) {
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void *Address = NULL;
    1fa0:	20 e0       	ldi	r18, 0x00	; 0
    1fa2:	30 e0       	ldi	r19, 0x00	; 0
            }

            break;
    }

    *DescriptorAddress = Address;
    1fa4:	fa 01       	movw	r30, r20
    1fa6:	20 83       	st	Z, r18
    1fa8:	31 83       	std	Z+1, r19	; 0x01
    return Size;
}
    1faa:	08 95       	ret

00001fac <__vector_default>:

#ifndef WDT_PER_500CLK_gc
#define WDT_PER_500CLK_gc WDT_PER_512CLK_gc
#endif

ISR(BADISR_vect) {
    1fac:	1f 92       	push	r1
    1fae:	0f 92       	push	r0
    1fb0:	0f b6       	in	r0, 0x3f	; 63
    1fb2:	0f 92       	push	r0
    1fb4:	11 24       	eor	r1, r1
    1fb6:	08 b6       	in	r0, 0x38	; 56
    1fb8:	0f 92       	push	r0
    1fba:	18 be       	out	0x38, r1	; 56
    1fbc:	ff cf       	rjmp	.-2      	; 0x1fbc <__vector_default+0x10>

00001fbe <__vector_10>:
    //LED_PORT.OUTSET = LED_RED;
    while (1);
}

ISR(RTC_OVF_vect) {
    1fbe:	1f 92       	push	r1
    1fc0:	0f 92       	push	r0
    1fc2:	0f b6       	in	r0, 0x3f	; 63
    1fc4:	0f 92       	push	r0
    1fc6:	11 24       	eor	r1, r1
    1fc8:	08 b6       	in	r0, 0x38	; 56
    1fca:	0f 92       	push	r0
    1fcc:	18 be       	out	0x38, r1	; 56
    1fce:	8f 93       	push	r24
    1fd0:	9f 93       	push	r25
    SYSTEM_TICK_REGISTER += SYSTEM_TICK_PERIOD;
    1fd2:	8e b1       	in	r24, 0x0e	; 14
    1fd4:	9f b1       	in	r25, 0x0f	; 15
    1fd6:	80 58       	subi	r24, 0x80	; 128
    1fd8:	9f 4f       	sbci	r25, 0xFF	; 255
    1fda:	8e b9       	out	0x0e, r24	; 14
    1fdc:	9f b9       	out	0x0f, r25	; 15
}
    1fde:	9f 91       	pop	r25
    1fe0:	8f 91       	pop	r24
    1fe2:	0f 90       	pop	r0
    1fe4:	08 be       	out	0x38, r0	; 56
    1fe6:	0f 90       	pop	r0
    1fe8:	0f be       	out	0x3f, r0	; 63
    1fea:	0f 90       	pop	r0
    1fec:	1f 90       	pop	r1
    1fee:	18 95       	reti

00001ff0 <SystemInit>:

void SystemInit(void) {
    if (RST.STATUS & RST_WDRF_bm) {
    1ff0:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    1ff4:	83 ff       	sbrs	r24, 3
    1ff6:	0a c0       	rjmp	.+20     	; 0x200c <SystemInit+0x1c>
        /* On Watchdog reset clear WDRF bit, disable watchdog
         * and jump into bootloader */
        RST.STATUS = RST_WDRF_bm;
    1ff8:	88 e0       	ldi	r24, 0x08	; 8
    1ffa:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>

        CCP = CCP_IOREG_gc;
    1ffe:	88 ed       	ldi	r24, 0xD8	; 216
    2000:	84 bf       	out	0x34, r24	; 52
        WDT.CTRL = WDT_CEN_bm;
    2002:	81 e0       	ldi	r24, 0x01	; 1
    2004:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>

        asm volatile("jmp %0"::"i"(BOOT_SECTION_START + 0x1FC));
    2008:	0d 94 fe 00 	jmp	0x201fc	; 0x201fc <__data_load_end+0xfe0e>
    }

    /* XTAL x 2 as SysCLK */
    OSC.XOSCCTRL = OSC_FRQRANGE_12TO16_gc | OSC_XOSCSEL_XTAL_16KCLK_gc;
    200c:	8b ec       	ldi	r24, 0xCB	; 203
    200e:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
    OSC.CTRL |= OSC_XOSCEN_bm;
    2012:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    2016:	88 60       	ori	r24, 0x08	; 8
    2018:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    while (!(OSC.STATUS & OSC_XOSCRDY_bm))
    201c:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    2020:	83 ff       	sbrs	r24, 3
    2022:	fc cf       	rjmp	.-8      	; 0x201c <SystemInit+0x2c>
        ;

    OSC.PLLCTRL = OSC_PLLSRC_XOSC_gc | (2 << OSC_PLLFAC_gp);
    2024:	82 ec       	ldi	r24, 0xC2	; 194
    2026:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
    OSC.CTRL |= OSC_PLLEN_bm;
    202a:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    202e:	80 61       	ori	r24, 0x10	; 16
    2030:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>

    while (!(OSC.STATUS & OSC_PLLRDY_bm))
    2034:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    2038:	84 ff       	sbrs	r24, 4
    203a:	fc cf       	rjmp	.-8      	; 0x2034 <SystemInit+0x44>
        ;

    /* Set PLL as main clock */
    CCP = CCP_IOREG_gc;
    203c:	88 ed       	ldi	r24, 0xD8	; 216
    203e:	84 bf       	out	0x34, r24	; 52
    CLK.CTRL = CLK_SCLKSEL_PLL_gc;
    2040:	84 e0       	ldi	r24, 0x04	; 4
    2042:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>

    SYSTEM_TICK_REGISTER = 0;
    2046:	1e b8       	out	0x0e, r1	; 14
    2048:	1f b8       	out	0x0f, r1	; 15

    /* Enable RTC with roughly 1kHz clock for system tick
     * and to wake up while sleeping. */
    CLK.RTCCTRL = CLK_RTCSRC_ULP_gc | CLK_RTCEN_bm;
    204a:	81 e0       	ldi	r24, 0x01	; 1
    204c:	80 93 43 00 	sts	0x0043, r24	; 0x800043 <__TEXT_REGION_LENGTH__+0x700043>
    RTC.PER = SYSTEM_TICK_PERIOD - 1;
    2050:	2f e7       	ldi	r18, 0x7F	; 127
    2052:	30 e0       	ldi	r19, 0x00	; 0
    2054:	20 93 0a 04 	sts	0x040A, r18	; 0x80040a <__TEXT_REGION_LENGTH__+0x70040a>
    2058:	30 93 0b 04 	sts	0x040B, r19	; 0x80040b <__TEXT_REGION_LENGTH__+0x70040b>
    RTC.COMP = SYSTEM_TICK_PERIOD - 1;
    205c:	20 93 0c 04 	sts	0x040C, r18	; 0x80040c <__TEXT_REGION_LENGTH__+0x70040c>
    2060:	30 93 0d 04 	sts	0x040D, r19	; 0x80040d <__TEXT_REGION_LENGTH__+0x70040d>
    RTC.CTRL = RTC_PRESCALER_DIV1_gc;
    2064:	80 93 00 04 	sts	0x0400, r24	; 0x800400 <__TEXT_REGION_LENGTH__+0x700400>
    RTC.INTCTRL = RTC_OVFINTLVL_LO_gc;
    2068:	80 93 02 04 	sts	0x0402, r24	; 0x800402 <__TEXT_REGION_LENGTH__+0x700402>

    /* Enable EEPROM data memory mapping */
    //NVM.CTRLB |= NVM_EEMAPEN_bm;

    /* Enable DMA */
    DMA.CTRL = DMA_ENABLE_bm | DMA_DBUFMODE_DISABLED_gc | DMA_PRIMODE_RR0123_gc;
    206c:	80 e8       	ldi	r24, 0x80	; 128
    206e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__TEXT_REGION_LENGTH__+0x700100>
    2072:	08 95       	ret

00002074 <SystemReset>:

}

void SystemReset(void) {
    CCP = CCP_IOREG_gc;
    2074:	88 ed       	ldi	r24, 0xD8	; 216
    2076:	84 bf       	out	0x34, r24	; 52
    RST.CTRL = RST_SWRST_bm;
    2078:	81 e0       	ldi	r24, 0x01	; 1
    207a:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    207e:	08 95       	ret

00002080 <SystemEnterBootloader>:
}

void SystemEnterBootloader(void) {
    /* Use Watchdog timer to reset into bootloader. */
    CCP = CCP_IOREG_gc;
    2080:	88 ed       	ldi	r24, 0xD8	; 216
    2082:	84 bf       	out	0x34, r24	; 52
    WDT.CTRL = WDT_PER_500CLK_gc | WDT_ENABLE_bm | WDT_CEN_bm;
    2084:	8b e1       	ldi	r24, 0x1B	; 27
    2086:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    208a:	08 95       	ret

0000208c <SystemStartUSBClock>:
    OSC.CTRL |= OSC_PLLEN_bm;
    while (!(OSC.STATUS & OSC_PLLRDY_bm))
        ;
#else
    /* Use internal HS RC for USB */
    OSC.CTRL |= OSC_RC32MEN_bm;
    208c:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    2090:	82 60       	ori	r24, 0x02	; 2
    2092:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    while (!(OSC.STATUS & OSC_RC32MRDY_bm))
    2096:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    209a:	81 ff       	sbrs	r24, 1
    209c:	fc cf       	rjmp	.-8      	; 0x2096 <SystemStartUSBClock+0xa>
        ;

    /* Load RC32 CAL values for 48MHz use */
    NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    209e:	82 e0       	ldi	r24, 0x02	; 2
    20a0:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
    DFLLRC32M.CALA = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSCA));
    20a4:	ed e1       	ldi	r30, 0x1D	; 29
    20a6:	f0 e0       	ldi	r31, 0x00	; 0
    20a8:	e4 91       	lpm	r30, Z
    20aa:	e0 93 62 00 	sts	0x0062, r30	; 0x800062 <__TEXT_REGION_LENGTH__+0x700062>
    DFLLRC32M.CALB = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSC));
    20ae:	ec e1       	ldi	r30, 0x1C	; 28
    20b0:	f0 e0       	ldi	r31, 0x00	; 0
    20b2:	e4 91       	lpm	r30, Z
    20b4:	e0 93 63 00 	sts	0x0063, r30	; 0x800063 <__TEXT_REGION_LENGTH__+0x700063>
    NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    20b8:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

    /* For USBSOF operation, whe need to use COMP = 48MHz/1kHz = 0xBB80 */
    DFLLRC32M.COMP1 = 0x80;
    20bc:	80 e8       	ldi	r24, 0x80	; 128
    20be:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <__TEXT_REGION_LENGTH__+0x700065>
    DFLLRC32M.COMP2 = 0xBB;
    20c2:	8b eb       	ldi	r24, 0xBB	; 187
    20c4:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__TEXT_REGION_LENGTH__+0x700066>

    /* Select USBSOF as DFLL source */
    OSC.DFLLCTRL &= ~OSC_RC32MCREF_gm;
    20c8:	80 91 56 00 	lds	r24, 0x0056	; 0x800056 <__TEXT_REGION_LENGTH__+0x700056>
    20cc:	89 7f       	andi	r24, 0xF9	; 249
    20ce:	80 93 56 00 	sts	0x0056, r24	; 0x800056 <__TEXT_REGION_LENGTH__+0x700056>
    OSC.DFLLCTRL |= OSC_RC32MCREF_USBSOF_gc;
    20d2:	80 91 56 00 	lds	r24, 0x0056	; 0x800056 <__TEXT_REGION_LENGTH__+0x700056>
    20d6:	84 60       	ori	r24, 0x04	; 4
    20d8:	80 93 56 00 	sts	0x0056, r24	; 0x800056 <__TEXT_REGION_LENGTH__+0x700056>

    /* Enable DFLL */
    DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    20dc:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    20e0:	81 60       	ori	r24, 0x01	; 1
    20e2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    20e6:	08 95       	ret

000020e8 <SystemStopUSBClock>:
    CLK.USBCTRL &= ~CLK_USBSEN_bm;
    OSC.CTRL &= ~OSC_PLLEN_bm;
    OSC.CTRL &= ~OSC_XOSCEN_bm;
#else
    /* Disable USB Clock to minimize power consumption */
    CLK.USBCTRL &= ~CLK_USBSEN_bm;
    20e8:	e0 e4       	ldi	r30, 0x40	; 64
    20ea:	f0 e0       	ldi	r31, 0x00	; 0
    20ec:	84 81       	ldd	r24, Z+4	; 0x04
    20ee:	8e 7f       	andi	r24, 0xFE	; 254
    20f0:	84 83       	std	Z+4, r24	; 0x04
    DFLLRC32M.CTRL &= ~DFLL_ENABLE_bm;
    20f2:	e0 e6       	ldi	r30, 0x60	; 96
    20f4:	f0 e0       	ldi	r31, 0x00	; 0
    20f6:	80 81       	ld	r24, Z
    20f8:	8e 7f       	andi	r24, 0xFE	; 254
    20fa:	80 83       	st	Z, r24
    OSC.CTRL &= ~OSC_RC32MEN_bm;
    20fc:	e0 e5       	ldi	r30, 0x50	; 80
    20fe:	f0 e0       	ldi	r31, 0x00	; 0
    2100:	80 81       	ld	r24, Z
    2102:	8d 7f       	andi	r24, 0xFD	; 253
    2104:	80 83       	st	Z, r24
    2106:	08 95       	ret

00002108 <SystemInterruptInit>:
#endif
}

void SystemInterruptInit(void) {
    /* Enable all interrupt levels */
    PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
    2108:	87 e0       	ldi	r24, 0x07	; 7
    210a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    sei();
    210e:	78 94       	sei
    2110:	08 95       	ret

00002112 <ApplicationTickDummy>:
static void CodecDeInitDummy(void) { }
static void CodecTaskDummy(void) { }
static void ApplicationInitDummy(void) {}
static void ApplicationResetDummy(void) {}
static void ApplicationTaskDummy(void) {}
static void ApplicationTickDummy(void) {}
    2112:	08 95       	ret

00002114 <ApplicationProcessDummy>:
static uint16_t ApplicationProcessDummy(uint8_t *ByteBuffer, uint16_t ByteCount) { return 0; }
    2114:	80 e0       	ldi	r24, 0x00	; 0
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	08 95       	ret

0000211a <ApplicationSetUidDummy>:
static void ApplicationGetUidDummy(ConfigurationUidType Uid) { }
static void ApplicationSetUidDummy(ConfigurationUidType Uid) { }
    211a:	08 95       	ret

0000211c <ApplicationGetUidDummy>:
    211c:	08 95       	ret

0000211e <CodecInitDummy>:
    211e:	08 95       	ret

00002120 <CodecDeInitDummy>:
    2120:	08 95       	ret

00002122 <CodecTaskDummy>:
    2122:	08 95       	ret

00002124 <ApplicationInitDummy>:
    2124:	08 95       	ret

00002126 <ApplicationResetDummy>:
    2126:	08 95       	ret

00002128 <ApplicationTaskDummy>:
    2128:	08 95       	ret

0000212a <ConfigurationSetById>:
             &ConfigurationTable[CONFIG_NONE], sizeof(ConfigurationType));

    ConfigurationSetById(GlobalSettings.ActiveSettingPtr->Configuration);
}

void ConfigurationSetById(ConfigurationEnum Configuration) {
    212a:	0f 93       	push	r16
    212c:	1f 93       	push	r17
    212e:	cf 93       	push	r28
    2130:	c8 2f       	mov	r28, r24
INLINE void CodecInit(void) {
    ActiveConfiguration.CodecInitFunc();
}

INLINE void CodecDeInit(void) {
    ActiveConfiguration.CodecDeInitFunc();
    2132:	0d eb       	ldi	r16, 0xBD	; 189
    2134:	1f e2       	ldi	r17, 0x2F	; 47
    2136:	d8 01       	movw	r26, r16
    2138:	12 96       	adiw	r26, 0x02	; 2
    213a:	ed 91       	ld	r30, X+
    213c:	fc 91       	ld	r31, X
    213e:	13 97       	sbiw	r26, 0x03	; 3
    2140:	19 95       	eicall
    CodecDeInit();

    CommandLinePendingTaskBreak(); // break possibly pending task
    2142:	0e 94 cc 25 	call	0x4b98	; 0x4b98 <CommandLinePendingTaskBreak>

    GlobalSettings.ActiveSettingPtr->Configuration = Configuration;
    2146:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    214a:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    214e:	c5 83       	std	Z+5, r28	; 0x05

    /* Copy struct from PROGMEM to RAM */
    memcpy_P(&ActiveConfiguration,
             &ConfigurationTable[Configuration], sizeof(ConfigurationType));
    2150:	b9 e1       	ldi	r27, 0x19	; 25
    2152:	cb 9f       	mul	r28, r27
    2154:	b0 01       	movw	r22, r0
    2156:	11 24       	eor	r1, r1
    2158:	68 55       	subi	r22, 0x58	; 88
    215a:	7d 4f       	sbci	r23, 0xFD	; 253
    CommandLinePendingTaskBreak(); // break possibly pending task

    GlobalSettings.ActiveSettingPtr->Configuration = Configuration;

    /* Copy struct from PROGMEM to RAM */
    memcpy_P(&ActiveConfiguration,
    215c:	49 e1       	ldi	r20, 0x19	; 25
    215e:	50 e0       	ldi	r21, 0x00	; 0
    2160:	c8 01       	movw	r24, r16
    2162:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <memcpy_P>
void (* volatile isr_func_CODEC_TIMER_LOADMOD_CCB_VECT)(void);
void isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT(void);
void isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT(void);

INLINE void CodecInit(void) {
    ActiveConfiguration.CodecInitFunc();
    2166:	d8 01       	movw	r26, r16
    2168:	ed 91       	ld	r30, X+
    216a:	fc 91       	ld	r31, X
    216c:	19 95       	eicall
#include "EM4233.h"
#include "NFC_Command.h"

/* Function wrappers */
INLINE void ApplicationInit(void) {
    ActiveConfiguration.ApplicationInitFunc();
    216e:	d8 01       	movw	r26, r16
    2170:	16 96       	adiw	r26, 0x06	; 6
    2172:	ed 91       	ld	r30, X+
    2174:	fc 91       	ld	r31, X
    2176:	17 97       	sbiw	r26, 0x07	; 7
             &ConfigurationTable[Configuration], sizeof(ConfigurationType));

    CodecInit();
    ApplicationInit();
}
    2178:	cf 91       	pop	r28
    217a:	1f 91       	pop	r17
    217c:	0f 91       	pop	r16
    217e:	19 94       	eijmp

00002180 <ConfigurationInit>:
};

ConfigurationType ActiveConfiguration;

void ConfigurationInit(void) {
    memcpy_P(&ActiveConfiguration,
    2180:	49 e1       	ldi	r20, 0x19	; 25
    2182:	50 e0       	ldi	r21, 0x00	; 0
    2184:	68 ea       	ldi	r22, 0xA8	; 168
    2186:	72 e0       	ldi	r23, 0x02	; 2
    2188:	8d eb       	ldi	r24, 0xBD	; 189
    218a:	9f e2       	ldi	r25, 0x2F	; 47
    218c:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <memcpy_P>
             &ConfigurationTable[CONFIG_NONE], sizeof(ConfigurationType));

    ConfigurationSetById(GlobalSettings.ActiveSettingPtr->Configuration);
    2190:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    2194:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    2198:	85 81       	ldd	r24, Z+5	; 0x05
    219a:	c7 cf       	rjmp	.-114    	; 0x212a <ConfigurationSetById>

0000219c <ConfigurationGetByName>:

    CodecInit();
    ApplicationInit();
}

void ConfigurationGetByName(char *Configuration, uint16_t BufferSize) {
    219c:	0f 93       	push	r16
    219e:	1f 93       	push	r17
    MapIdToText(ConfigurationMap, ARRAY_COUNT(ConfigurationMap), GlobalSettings.ActiveSettingPtr->Configuration, Configuration, BufferSize);
    21a0:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    21a4:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    21a8:	8b 01       	movw	r16, r22
    21aa:	9c 01       	movw	r18, r24
    21ac:	45 81       	ldd	r20, Z+5	; 0x05
    21ae:	63 e1       	ldi	r22, 0x13	; 19
    21b0:	83 e8       	ldi	r24, 0x83	; 131
    21b2:	94 e0       	ldi	r25, 0x04	; 4
    21b4:	0e 94 29 1b 	call	0x3652	; 0x3652 <MapIdToText>
}
    21b8:	1f 91       	pop	r17
    21ba:	0f 91       	pop	r16
    21bc:	08 95       	ret

000021be <ConfigurationSetByName>:

bool ConfigurationSetByName(const char *Configuration) {
    21be:	ff 92       	push	r15
    21c0:	0f 93       	push	r16
    21c2:	1f 93       	push	r17
    21c4:	cf 93       	push	r28
    21c6:	df 93       	push	r29
    21c8:	1f 92       	push	r1
    21ca:	cd b7       	in	r28, 0x3d	; 61
    21cc:	de b7       	in	r29, 0x3e	; 62
    21ce:	8c 01       	movw	r16, r24
    MapIdType Id;

    if (MapTextToId(ConfigurationMap, ARRAY_COUNT(ConfigurationMap), Configuration, &Id)) {
    21d0:	9e 01       	movw	r18, r28
    21d2:	2f 5f       	subi	r18, 0xFF	; 255
    21d4:	3f 4f       	sbci	r19, 0xFF	; 255
    21d6:	ac 01       	movw	r20, r24
    21d8:	63 e1       	ldi	r22, 0x13	; 19
    21da:	83 e8       	ldi	r24, 0x83	; 131
    21dc:	94 e0       	ldi	r25, 0x04	; 4
    21de:	0e 94 41 1b 	call	0x3682	; 0x3682 <MapTextToId>
    21e2:	f8 2e       	mov	r15, r24
    21e4:	88 23       	and	r24, r24
    21e6:	89 f0       	breq	.+34     	; 0x220a <ConfigurationSetByName+0x4c>
        ConfigurationSetById(Id);
    21e8:	89 81       	ldd	r24, Y+1	; 0x01
    21ea:	9f df       	rcall	.-194    	; 0x212a <ConfigurationSetById>
    21ec:	f8 01       	movw	r30, r16

    return pgm_read_byte(&OddParityByteTable[Byte]);
}

INLINE uint8_t StringLength(const char *Str, uint8_t MaxLen) {
    uint8_t StrLen = 0;
    21ee:	40 e0       	ldi	r20, 0x00	; 0

    while (MaxLen > 0) {
        if (*Str++ == '\0')
    21f0:	81 91       	ld	r24, Z+
    21f2:	88 23       	and	r24, r24
    21f4:	19 f0       	breq	.+6      	; 0x21fc <ConfigurationSetByName+0x3e>
            break;

        MaxLen--;
        StrLen++;
    21f6:	4f 5f       	subi	r20, 0xFF	; 255
}

INLINE uint8_t StringLength(const char *Str, uint8_t MaxLen) {
    uint8_t StrLen = 0;

    while (MaxLen > 0) {
    21f8:	4f 31       	cpi	r20, 0x1F	; 31
    21fa:	d1 f7       	brne	.-12     	; 0x21f0 <ConfigurationSetByName+0x32>
void LogGetModeByName(char *Mode, uint16_t BufferSize);
void LogGetModeList(char *List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void *Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    21fc:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    2200:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    2204:	b8 01       	movw	r22, r16
    2206:	81 e1       	ldi	r24, 0x11	; 17
    2208:	19 95       	eicall
        LogEntry(LOG_INFO_CONFIG_SET, Configuration, StringLength(Configuration, CONFIGURATION_NAME_LENGTH_MAX - 1));
        return true;
    } else {
        return false;
    }
}
    220a:	8f 2d       	mov	r24, r15
    220c:	0f 90       	pop	r0
    220e:	df 91       	pop	r29
    2210:	cf 91       	pop	r28
    2212:	1f 91       	pop	r17
    2214:	0f 91       	pop	r16
    2216:	ff 90       	pop	r15
    2218:	08 95       	ret

0000221a <ConfigurationGetList>:

void ConfigurationGetList(char *List, uint16_t BufferSize) {
    221a:	9b 01       	movw	r18, r22
    MapToString(ConfigurationMap, ARRAY_COUNT(ConfigurationMap), List, BufferSize);
    221c:	ac 01       	movw	r20, r24
    221e:	63 e1       	ldi	r22, 0x13	; 19
    2220:	83 e8       	ldi	r24, 0x83	; 131
    2222:	94 e0       	ldi	r25, 0x04	; 4
    2224:	0c 94 68 1b 	jmp	0x36d0	; 0x36d0 <MapToString>

00002228 <RandomInit>:
#include "Random.h"

#include <stdlib.h>

void RandomInit(void) {
    2228:	08 95       	ret

0000222a <RandomGetByte>:

}

uint8_t RandomGetByte(void) {
    return rand() & 0xFF;
    222a:	0c 94 64 78 	jmp	0xf0c8	; 0xf0c8 <rand>
}
    222e:	08 95       	ret

00002230 <RandomGetBuffer>:

void RandomGetBuffer(void *Buffer, uint8_t ByteCount) {
    2230:	0f 93       	push	r16
    2232:	1f 93       	push	r17
    2234:	cf 93       	push	r28
    2236:	8c 01       	movw	r16, r24
    uint8_t *BufferPtr = (uint8_t *) Buffer;

    while (ByteCount--) {
    2238:	c6 2f       	mov	r28, r22
    223a:	cc 23       	and	r28, r28
    223c:	39 f0       	breq	.+14     	; 0x224c <RandomGetBuffer+0x1c>
void RandomInit(void) {

}

uint8_t RandomGetByte(void) {
    return rand() & 0xFF;
    223e:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <rand>

void RandomGetBuffer(void *Buffer, uint8_t ByteCount) {
    uint8_t *BufferPtr = (uint8_t *) Buffer;

    while (ByteCount--) {
        *BufferPtr++ = RandomGetByte();
    2242:	f8 01       	movw	r30, r16
    2244:	81 93       	st	Z+, r24
    2246:	8f 01       	movw	r16, r30
    2248:	c1 50       	subi	r28, 0x01	; 1
    224a:	f7 cf       	rjmp	.-18     	; 0x223a <RandomGetBuffer+0xa>
    }
}
    224c:	cf 91       	pop	r28
    224e:	1f 91       	pop	r17
    2250:	0f 91       	pop	r16
    2252:	08 95       	ret

00002254 <RandomTick>:

void RandomTick(void) {
    rand();
    2254:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <rand>
    rand();
    2258:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <rand>
    rand();
    225c:	0e 94 64 78 	call	0xf0c8	; 0xf0c8 <rand>
    rand();
    2260:	0c 94 64 78 	jmp	0xf0c8	; 0xf0c8 <rand>

00002264 <BufferToHexString>:
    0,	1,	1,	0,	1,	0,	0,	1,	1,	0,	0,	1,	0,	1,	1,	0,
    0,	1,	1,	0,	1,	0,	0,	1,	1,	0,	0,	1,	0,	1,	1,	0,
    1,	0,	0,	1,	0,	1,	1,	0,	0,	1,	1,	0,	1,	0,	0,	1,
};

uint16_t BufferToHexString(char *HexOut, uint16_t MaxChars, const void *Buffer, uint16_t ByteCount) {
    2264:	cf 93       	push	r28
    2266:	df 93       	push	r29
    2268:	ec 01       	movw	r28, r24
    uint8_t *ByteBuffer = (uint8_t *) Buffer;
    uint16_t CharCount = 0;

    /* Account for '\0' at the end */
    MaxChars--;
    226a:	61 50       	subi	r22, 0x01	; 1
    226c:	71 09       	sbc	r23, r1
    226e:	da 01       	movw	r26, r20
    2270:	42 0f       	add	r20, r18
    2272:	53 1f       	adc	r21, r19

    while ((ByteCount > 0) && (MaxChars >= 2)) {
    2274:	fc 01       	movw	r30, r24
    2276:	cf 01       	movw	r24, r30
    2278:	8c 1b       	sub	r24, r28
    227a:	9d 0b       	sbc	r25, r29
    227c:	a4 17       	cp	r26, r20
    227e:	b5 07       	cpc	r27, r21
    2280:	21 f4       	brne	.+8      	; 0x228a <BufferToHexString+0x26>
        CharCount += 2;
        ByteBuffer++;
        ByteCount -= 1;
    }

    *HexOut = '\0';
    2282:	10 82       	st	Z, r1

    return CharCount;
}
    2284:	df 91       	pop	r29
    2286:	cf 91       	pop	r28
    2288:	08 95       	ret
    uint16_t CharCount = 0;

    /* Account for '\0' at the end */
    MaxChars--;

    while ((ByteCount > 0) && (MaxChars >= 2)) {
    228a:	62 30       	cpi	r22, 0x02	; 2
    228c:	71 05       	cpc	r23, r1
    228e:	c8 f3       	brcs	.-14     	; 0x2282 <BufferToHexString+0x1e>
        uint8_t Byte = *ByteBuffer;
    2290:	9d 91       	ld	r25, X+

        HexOut[0] = NIBBLE_TO_HEXCHAR((Byte >> 4) & 0x0F);
    2292:	39 2f       	mov	r19, r25
    2294:	32 95       	swap	r19
    2296:	3f 70       	andi	r19, 0x0F	; 15
    2298:	3a 30       	cpi	r19, 0x0A	; 10
    229a:	10 f4       	brcc	.+4      	; 0x22a0 <BufferToHexString+0x3c>
    229c:	30 5d       	subi	r19, 0xD0	; 208
    229e:	01 c0       	rjmp	.+2      	; 0x22a2 <BufferToHexString+0x3e>
    22a0:	39 5c       	subi	r19, 0xC9	; 201
    22a2:	30 83       	st	Z, r19
    22a4:	9f 70       	andi	r25, 0x0F	; 15
        HexOut[1] = NIBBLE_TO_HEXCHAR((Byte >> 0) & 0x0F);
    22a6:	9a 30       	cpi	r25, 0x0A	; 10
    22a8:	10 f4       	brcc	.+4      	; 0x22ae <BufferToHexString+0x4a>
    22aa:	90 5d       	subi	r25, 0xD0	; 208
    22ac:	01 c0       	rjmp	.+2      	; 0x22b0 <BufferToHexString+0x4c>
    22ae:	99 5c       	subi	r25, 0xC9	; 201
    22b0:	91 83       	std	Z+1, r25	; 0x01

        HexOut += 2;
    22b2:	32 96       	adiw	r30, 0x02	; 2
        MaxChars -= 2;
    22b4:	62 50       	subi	r22, 0x02	; 2
    22b6:	71 09       	sbc	r23, r1
    22b8:	de cf       	rjmp	.-68     	; 0x2276 <BufferToHexString+0x12>

000022ba <HexStringToBuffer>:
    *HexOut = '\0';

    return CharCount;
}

uint16_t HexStringToBuffer(void *Buffer, uint16_t MaxBytes, const char *HexIn) {
    22ba:	cf 93       	push	r28
    22bc:	df 93       	push	r29
    22be:	ec 01       	movw	r28, r24
    22c0:	da 01       	movw	r26, r20
    uint8_t *ByteBuffer = (uint8_t *) Buffer;
    uint16_t ByteCount = 0;
    22c2:	20 e0       	ldi	r18, 0x00	; 0
    22c4:	30 e0       	ldi	r19, 0x00	; 0

    while ((HexIn[0] != '\0') && (HexIn[1] != '\0') && (MaxBytes > 0)) {
    22c6:	5c 91       	ld	r21, X
    22c8:	55 23       	and	r21, r21
    22ca:	51 f1       	breq	.+84     	; 0x2320 <HexStringToBuffer+0x66>
    22cc:	11 96       	adiw	r26, 0x01	; 1
    22ce:	9c 91       	ld	r25, X
    22d0:	11 97       	sbiw	r26, 0x01	; 1
    22d2:	99 23       	and	r25, r25
    22d4:	39 f1       	breq	.+78     	; 0x2324 <HexStringToBuffer+0x6a>
    22d6:	26 17       	cp	r18, r22
    22d8:	37 07       	cpc	r19, r23
    22da:	11 f1       	breq	.+68     	; 0x2320 <HexStringToBuffer+0x66>
        if (VALID_HEXCHAR(HexIn[0]) && VALID_HEXCHAR(HexIn[1])) {
    22dc:	80 ed       	ldi	r24, 0xD0	; 208
    22de:	85 0f       	add	r24, r21
    22e0:	8a 30       	cpi	r24, 0x0A	; 10
    22e2:	20 f0       	brcs	.+8      	; 0x22ec <HexStringToBuffer+0x32>
    22e4:	8f eb       	ldi	r24, 0xBF	; 191
    22e6:	85 0f       	add	r24, r21
    22e8:	86 30       	cpi	r24, 0x06	; 6
    22ea:	e0 f4       	brcc	.+56     	; 0x2324 <HexStringToBuffer+0x6a>
    22ec:	80 ed       	ldi	r24, 0xD0	; 208
    22ee:	89 0f       	add	r24, r25
    22f0:	8a 30       	cpi	r24, 0x0A	; 10
    22f2:	20 f0       	brcs	.+8      	; 0x22fc <HexStringToBuffer+0x42>
    22f4:	4f eb       	ldi	r20, 0xBF	; 191
    22f6:	49 0f       	add	r20, r25
    22f8:	46 30       	cpi	r20, 0x06	; 6
    22fa:	a0 f4       	brcc	.+40     	; 0x2324 <HexStringToBuffer+0x6a>
    22fc:	e5 2f       	mov	r30, r21
    22fe:	f0 e0       	ldi	r31, 0x00	; 0
            uint8_t Byte = 0;

            Byte |= HEXCHAR_TO_NIBBLE(HexIn[0]) << 4;
    2300:	51 34       	cpi	r21, 0x41	; 65
    2302:	08 f0       	brcs	.+2      	; 0x2306 <HexStringToBuffer+0x4c>
    2304:	f7 97       	sbiw	r30, 0x37	; 55
    2306:	e2 95       	swap	r30
    2308:	e0 7f       	andi	r30, 0xF0	; 240
            Byte |= HEXCHAR_TO_NIBBLE(HexIn[1]) << 0;
    230a:	91 34       	cpi	r25, 0x41	; 65
    230c:	10 f4       	brcc	.+4      	; 0x2312 <HexStringToBuffer+0x58>
    230e:	98 2f       	mov	r25, r24
    2310:	01 c0       	rjmp	.+2      	; 0x2314 <HexStringToBuffer+0x5a>
    2312:	97 53       	subi	r25, 0x37	; 55

            *ByteBuffer = Byte;
    2314:	9e 2b       	or	r25, r30
    2316:	99 93       	st	Y+, r25

            ByteBuffer++;
            MaxBytes--;
            ByteCount++;
    2318:	2f 5f       	subi	r18, 0xFF	; 255
    231a:	3f 4f       	sbci	r19, 0xFF	; 255
            HexIn += 2;
    231c:	12 96       	adiw	r26, 0x02	; 2
uint16_t HexStringToBuffer(void *Buffer, uint16_t MaxBytes, const char *HexIn) {
    uint8_t *ByteBuffer = (uint8_t *) Buffer;
    uint16_t ByteCount = 0;

    while ((HexIn[0] != '\0') && (HexIn[1] != '\0') && (MaxBytes > 0)) {
        if (VALID_HEXCHAR(HexIn[0]) && VALID_HEXCHAR(HexIn[1])) {
    231e:	d3 cf       	rjmp	.-90     	; 0x22c6 <HexStringToBuffer+0xc>
    2320:	c9 01       	movw	r24, r18
    2322:	02 c0       	rjmp	.+4      	; 0x2328 <HexStringToBuffer+0x6e>
            MaxBytes--;
            ByteCount++;
            HexIn += 2;
        } else {
            /* HEX chars only */
            return 0;
    2324:	80 e0       	ldi	r24, 0x00	; 0
    2326:	90 e0       	ldi	r25, 0x00	; 0
        /* Odd number of characters */
        return 0;
    }

    return ByteCount;
}
    2328:	df 91       	pop	r29
    232a:	cf 91       	pop	r28
    232c:	08 95       	ret

0000232e <MemoryInit>:
    }
}

void MemoryInit(void) {
    /* Configure FRAM_USART for SPI master mode 0 with maximum clock frequency */
    FRAM_PORT.OUTSET = FRAM_CS;
    232e:	e0 e6       	ldi	r30, 0x60	; 96
    2330:	f6 e0       	ldi	r31, 0x06	; 6
    2332:	80 e1       	ldi	r24, 0x10	; 16
    2334:	85 83       	std	Z+5, r24	; 0x05

    FRAM_PORT.OUTCLR = FRAM_SCK;
    2336:	82 e0       	ldi	r24, 0x02	; 2
    2338:	86 83       	std	Z+6, r24	; 0x06
    FRAM_PORT.OUTSET = FRAM_MOSI;
    233a:	88 e0       	ldi	r24, 0x08	; 8
    233c:	85 83       	std	Z+5, r24	; 0x05

    FRAM_PORT.DIRSET = FRAM_SCK | FRAM_MOSI | FRAM_CS;
    233e:	8a e1       	ldi	r24, 0x1A	; 26
    2340:	81 83       	std	Z+1, r24	; 0x01

    FRAM_USART.BAUDCTRLA = 0;
    2342:	e0 ea       	ldi	r30, 0xA0	; 160
    2344:	f9 e0       	ldi	r31, 0x09	; 9
    2346:	16 82       	std	Z+6, r1	; 0x06
    FRAM_USART.BAUDCTRLB = 0;
    2348:	17 82       	std	Z+7, r1	; 0x07
    FRAM_USART.CTRLC = USART_CMODE_MSPI_gc;
    234a:	80 ec       	ldi	r24, 0xC0	; 192
    234c:	85 83       	std	Z+5, r24	; 0x05
    FRAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
    234e:	88 e1       	ldi	r24, 0x18	; 24
    2350:	84 83       	std	Z+4, r24	; 0x04

    /* Init DMAs for reading and writing */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    2352:	e0 e0       	ldi	r30, 0x00	; 0
    2354:	f1 e0       	ldi	r31, 0x01	; 1
    2356:	12 8a       	std	Z+18, r1	; 0x12
    RECV_DMA.TRIGSRC = DMA_CH_TRIGSRC_USARTD0_RXC_gc;
    2358:	8b e6       	ldi	r24, 0x6B	; 107
    235a:	83 8b       	std	Z+19, r24	; 0x13
    RECV_DMA.TRFCNT = 0;
    235c:	14 8a       	std	Z+20, r1	; 0x14
    235e:	15 8a       	std	Z+21, r1	; 0x15
    RECV_DMA.SRCADDR0 = ((uintptr_t) &FRAM_USART.DATA >> 0) & 0xFF;
    2360:	20 ea       	ldi	r18, 0xA0	; 160
    2362:	20 8f       	std	Z+24, r18	; 0x18
    RECV_DMA.SRCADDR1 = ((uintptr_t) &FRAM_USART.DATA >> 8) & 0xFF;
    2364:	99 e0       	ldi	r25, 0x09	; 9
    2366:	91 8f       	std	Z+25, r25	; 0x19
    RECV_DMA.SRCADDR2 = 0;
    2368:	12 8e       	std	Z+26, r1	; 0x1a
    RECV_DMA.DESTADDR0 = 0;
    236a:	14 8e       	std	Z+28, r1	; 0x1c
    RECV_DMA.DESTADDR1 = 0;
    236c:	15 8e       	std	Z+29, r1	; 0x1d
    RECV_DMA.DESTADDR2 = 0;
    236e:	16 8e       	std	Z+30, r1	; 0x1e
    RECV_DMA.CTRLA = DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_1BYTE_gc;
    2370:	84 e0       	ldi	r24, 0x04	; 4
    2372:	80 8b       	std	Z+16, r24	; 0x10

    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    2374:	12 a2       	std	Z+34, r1	; 0x22
    SEND_DMA.TRIGSRC = DMA_CH_TRIGSRC_USARTD0_DRE_gc;
    2376:	3c e6       	ldi	r19, 0x6C	; 108
    2378:	33 a3       	std	Z+35, r19	; 0x23
    SEND_DMA.TRFCNT = 0;
    237a:	14 a2       	std	Z+36, r1	; 0x24
    237c:	15 a2       	std	Z+37, r1	; 0x25
    SEND_DMA.SRCADDR0 = 0;
    237e:	10 a6       	std	Z+40, r1	; 0x28
    SEND_DMA.SRCADDR1 = 0;
    2380:	11 a6       	std	Z+41, r1	; 0x29
    SEND_DMA.SRCADDR2 = 0;
    2382:	12 a6       	std	Z+42, r1	; 0x2a
    SEND_DMA.DESTADDR0 = ((uintptr_t) &FRAM_USART.DATA >> 0) & 0xFF;
    2384:	24 a7       	std	Z+44, r18	; 0x2c
    SEND_DMA.DESTADDR1 = ((uintptr_t) &FRAM_USART.DATA >> 8) & 0xFF;
    2386:	95 a7       	std	Z+45, r25	; 0x2d
    SEND_DMA.DESTADDR2 = 0;
    2388:	16 a6       	std	Z+46, r1	; 0x2e
    SEND_DMA.CTRLA = DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_1BYTE_gc;
    238a:	80 a3       	std	Z+32, r24	; 0x20
    238c:	08 95       	ret

0000238e <MemoryReadBlock>:
}

void MemoryReadBlock(void *Buffer, uint16_t Address, uint16_t ByteCount) {
    if (ByteCount == 0)
    238e:	41 15       	cp	r20, r1
    2390:	51 05       	cpc	r21, r1
    2392:	09 f4       	brne	.+2      	; 0x2396 <MemoryReadBlock+0x8>
    2394:	49 c0       	rjmp	.+146    	; 0x2428 <MemoryReadBlock+0x9a>
    }
}
#endif

INLINE void FRAMRead(void *Buffer, uint16_t Address, uint16_t ByteCount) {
    FRAM_PORT.OUTCLR = FRAM_CS;
    2396:	20 e1       	ldi	r18, 0x10	; 16
    2398:	20 93 66 06 	sts	0x0666, r18	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    239c:	23 e0       	ldi	r18, 0x03	; 3
    239e:	20 93 a0 09 	sts	0x09A0, r18	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    23a2:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    23a6:	27 ff       	sbrs	r18, 7
    23a8:	fc cf       	rjmp	.-8      	; 0x23a2 <MemoryReadBlock+0x14>

    return FRAM_USART.DATA;
    23aa:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    23ae:	70 93 a0 09 	sts	0x09A0, r23	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    23b2:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    23b6:	27 ff       	sbrs	r18, 7
    23b8:	fc cf       	rjmp	.-8      	; 0x23b2 <MemoryReadBlock+0x24>

    return FRAM_USART.DATA;
    23ba:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    23be:	60 93 a0 09 	sts	0x09A0, r22	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    23c2:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    23c6:	27 ff       	sbrs	r18, 7
    23c8:	fc cf       	rjmp	.-8      	; 0x23c2 <MemoryReadBlock+0x34>

    return FRAM_USART.DATA;
    23ca:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
}

#ifdef USE_DMA
INLINE void SPIReadBlock(void *Buffer, uint16_t ByteCount) {
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_INC_gc;
    23ce:	21 e0       	ldi	r18, 0x01	; 1
    23d0:	20 93 12 01 	sts	0x0112, r18	; 0x800112 <__TEXT_REGION_LENGTH__+0x700112>
    RECV_DMA.DESTADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    23d4:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <__TEXT_REGION_LENGTH__+0x70011c>
    RECV_DMA.DESTADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    23d8:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <__TEXT_REGION_LENGTH__+0x70011d>
    RECV_DMA.TRFCNT = ByteCount;
    23dc:	40 93 14 01 	sts	0x0114, r20	; 0x800114 <__TEXT_REGION_LENGTH__+0x700114>
    23e0:	50 93 15 01 	sts	0x0115, r21	; 0x800115 <__TEXT_REGION_LENGTH__+0x700115>
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    23e4:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
    SEND_DMA.SRCADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    23e8:	8c e8       	ldi	r24, 0x8C	; 140
    23ea:	94 e2       	ldi	r25, 0x24	; 36
    23ec:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    SEND_DMA.SRCADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    23f0:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    SEND_DMA.TRFCNT = ByteCount;
    23f4:	40 93 24 01 	sts	0x0124, r20	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
    23f8:	50 93 25 01 	sts	0x0125, r21	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>


    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    23fc:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    2400:	80 68       	ori	r24, 0x80	; 128
    2402:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    2406:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    240a:	80 68       	ori	r24, 0x80	; 128
    240c:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>

    /* Wait for DMA to finish */
    while (RECV_DMA.CTRLA & DMA_CH_ENABLE_bm)
    2410:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    2414:	87 fd       	sbrc	r24, 7
    2416:	fc cf       	rjmp	.-8      	; 0x2410 <MemoryReadBlock+0x82>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    2418:	80 e3       	ldi	r24, 0x30	; 48
    241a:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <__TEXT_REGION_LENGTH__+0x700111>
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    241e:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    SPITransferByte((Address >> 8) & 0xFF);   /* Address hi and lo byte */
    SPITransferByte((Address >> 0) & 0xFF);

    SPIReadBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    2422:	80 e1       	ldi	r24, 0x10	; 16
    2424:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
    2428:	08 95       	ret

0000242a <MemoryWriteBlock>:
        return;
    FRAMRead(Buffer, Address, ByteCount);
}

void MemoryWriteBlock(const void *Buffer, uint16_t Address, uint16_t ByteCount) {
    if (ByteCount == 0)
    242a:	41 15       	cp	r20, r1
    242c:	51 05       	cpc	r21, r1
    242e:	09 f4       	brne	.+2      	; 0x2432 <MemoryWriteBlock+0x8>
    2430:	69 c0       	rjmp	.+210    	; 0x2504 <MemoryWriteBlock+0xda>

    FRAM_PORT.OUTSET = FRAM_CS;
}

INLINE void FRAMWrite(const void *Buffer, uint16_t Address, uint16_t ByteCount) {
    FRAM_PORT.OUTCLR = FRAM_CS;
    2432:	20 e1       	ldi	r18, 0x10	; 16
    2434:	20 93 66 06 	sts	0x0666, r18	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    2438:	26 e0       	ldi	r18, 0x06	; 6
    243a:	20 93 a0 09 	sts	0x09A0, r18	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    243e:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2442:	27 ff       	sbrs	r18, 7
    2444:	fc cf       	rjmp	.-8      	; 0x243e <MemoryWriteBlock+0x14>

    return FRAM_USART.DATA;
    2446:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
}

INLINE void FRAMWrite(const void *Buffer, uint16_t Address, uint16_t ByteCount) {
    FRAM_PORT.OUTCLR = FRAM_CS;
    SPITransferByte(0x06); /* Write Enable */
    FRAM_PORT.OUTSET = FRAM_CS;
    244a:	20 e1       	ldi	r18, 0x10	; 16
    244c:	20 93 65 06 	sts	0x0665, r18	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>

    asm volatile("nop");
    2450:	00 00       	nop
    asm volatile("nop");
    2452:	00 00       	nop

    FRAM_PORT.OUTCLR = FRAM_CS;
    2454:	20 93 66 06 	sts	0x0666, r18	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    2458:	22 e0       	ldi	r18, 0x02	; 2
    245a:	20 93 a0 09 	sts	0x09A0, r18	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    245e:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2462:	27 ff       	sbrs	r18, 7
    2464:	fc cf       	rjmp	.-8      	; 0x245e <MemoryWriteBlock+0x34>

    return FRAM_USART.DATA;
    2466:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    246a:	70 93 a0 09 	sts	0x09A0, r23	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    246e:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2472:	27 ff       	sbrs	r18, 7
    2474:	fc cf       	rjmp	.-8      	; 0x246e <MemoryWriteBlock+0x44>

    return FRAM_USART.DATA;
    2476:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    247a:	60 93 a0 09 	sts	0x09A0, r22	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    247e:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2482:	27 ff       	sbrs	r18, 7
    2484:	fc cf       	rjmp	.-8      	; 0x247e <MemoryWriteBlock+0x54>

    return FRAM_USART.DATA;
    2486:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
#endif

#ifdef USE_DMA
INLINE void SPIWriteBlock(const void *Buffer, uint16_t ByteCount) {
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    248a:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <__TEXT_REGION_LENGTH__+0x700112>
    RECV_DMA.DESTADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    248e:	2c e8       	ldi	r18, 0x8C	; 140
    2490:	34 e2       	ldi	r19, 0x24	; 36
    2492:	20 93 1c 01 	sts	0x011C, r18	; 0x80011c <__TEXT_REGION_LENGTH__+0x70011c>
    RECV_DMA.DESTADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    2496:	30 93 1d 01 	sts	0x011D, r19	; 0x80011d <__TEXT_REGION_LENGTH__+0x70011d>
    RECV_DMA.TRFCNT = ByteCount;
    249a:	40 93 14 01 	sts	0x0114, r20	; 0x800114 <__TEXT_REGION_LENGTH__+0x700114>
    249e:	50 93 15 01 	sts	0x0115, r21	; 0x800115 <__TEXT_REGION_LENGTH__+0x700115>
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    24a2:	20 e1       	ldi	r18, 0x10	; 16
    24a4:	20 93 22 01 	sts	0x0122, r18	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
    SEND_DMA.SRCADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    24a8:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    SEND_DMA.SRCADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    24ac:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    SEND_DMA.TRFCNT = ByteCount;
    24b0:	40 93 24 01 	sts	0x0124, r20	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
    24b4:	50 93 25 01 	sts	0x0125, r21	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>

    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    24b8:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    24bc:	80 68       	ori	r24, 0x80	; 128
    24be:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    24c2:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    24c6:	80 68       	ori	r24, 0x80	; 128
    24c8:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>

    /* Wait for DMA to finish */
    while (RECV_DMA.CTRLA & DMA_CH_ENABLE_bm)
    24cc:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    24d0:	87 fd       	sbrc	r24, 7
    24d2:	fc cf       	rjmp	.-8      	; 0x24cc <MemoryWriteBlock+0xa2>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    24d4:	80 e3       	ldi	r24, 0x30	; 48
    24d6:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <__TEXT_REGION_LENGTH__+0x700111>
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    24da:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    SPITransferByte((Address >> 8) & 0xFF);   /* Address hi and lo byte */
    SPITransferByte((Address >> 0) & 0xFF);

    SPIWriteBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    24de:	80 e1       	ldi	r24, 0x10	; 16
    24e0:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    24e4:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    24e8:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    24ec:	87 81       	ldd	r24, Z+7	; 0x07
    24ee:	86 30       	cpi	r24, 0x06	; 6
    24f0:	19 f4       	brne	.+6      	; 0x24f8 <MemoryWriteBlock+0xce>
        LEDGreenAction = Action;
    24f2:	81 e1       	ldi	r24, 0x11	; 17
    24f4:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    24f8:	86 81       	ldd	r24, Z+6	; 0x06
    24fa:	86 30       	cpi	r24, 0x06	; 6
    24fc:	19 f4       	brne	.+6      	; 0x2504 <MemoryWriteBlock+0xda>
        LEDRedAction = Action;
    24fe:	81 e1       	ldi	r24, 0x11	; 17
    2500:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    2504:	08 95       	ret

00002506 <MemoryRecall>:
    FlashErase((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    MemoryRecall();
}

void MemoryRecall(void) {
    2506:	cf 92       	push	r12
    2508:	df 92       	push	r13
    250a:	ef 92       	push	r14
    250c:	ff 92       	push	r15
    250e:	cf 93       	push	r28
    2510:	df 93       	push	r29
    /* Recall memory from permanent flash */
    FlashToFRAM((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);
    2512:	c0 90 d8 2f 	lds	r12, 0x2FD8	; 0x802fd8 <GlobalSettings>
    2516:	d1 2c       	mov	r13, r1
    2518:	e1 2c       	mov	r14, r1
    251a:	f1 2c       	mov	r15, r1
    251c:	8d e0       	ldi	r24, 0x0D	; 13
    251e:	cc 0c       	add	r12, r12
    2520:	dd 1c       	adc	r13, r13
    2522:	ee 1c       	adc	r14, r14
    2524:	ff 1c       	adc	r15, r15
    2526:	8a 95       	dec	r24
    2528:	d1 f7       	brne	.-12     	; 0x251e <MemoryRecall+0x18>

INLINE void FlashToFRAM(uint32_t Address, uint16_t ByteCount) {
    /* We assume that ByteCount is a multiple of 2 */
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;

    if ((PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END)) {
    252a:	c1 14       	cp	r12, r1
    252c:	d1 04       	cpc	r13, r1
    252e:	81 e0       	ldi	r24, 0x01	; 1
    2530:	e8 06       	cpc	r14, r24
    2532:	f1 04       	cpc	r15, r1
    2534:	08 f0       	brcs	.+2      	; 0x2538 <MemoryRecall+0x32>
    2536:	4e c0       	rjmp	.+156    	; 0x25d4 <MemoryRecall+0xce>
        /* Sanity check to limit access to the allocated area.
         * Set up FRAM memory for writing. */
        FRAM_PORT.OUTCLR = FRAM_CS;
    2538:	80 e1       	ldi	r24, 0x10	; 16
    253a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    253e:	86 e0       	ldi	r24, 0x06	; 6
    2540:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2544:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2548:	87 ff       	sbrs	r24, 7
    254a:	fc cf       	rjmp	.-8      	; 0x2544 <MemoryRecall+0x3e>

    return FRAM_USART.DATA;
    254c:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    if ((PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END)) {
        /* Sanity check to limit access to the allocated area.
         * Set up FRAM memory for writing. */
        FRAM_PORT.OUTCLR = FRAM_CS;
        SPITransferByte(0x06); /* Write Enable */
        FRAM_PORT.OUTSET = FRAM_CS;
    2550:	80 e1       	ldi	r24, 0x10	; 16
    2552:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>

        asm volatile("nop");
    2556:	00 00       	nop
        asm volatile("nop");
    2558:	00 00       	nop

        FRAM_PORT.OUTCLR = FRAM_CS;
    255a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    255e:	82 e0       	ldi	r24, 0x02	; 2
    2560:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2564:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2568:	87 ff       	sbrs	r24, 7
    256a:	fc cf       	rjmp	.-8      	; 0x2564 <MemoryRecall+0x5e>

    return FRAM_USART.DATA;
    256c:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    2570:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2574:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2578:	87 ff       	sbrs	r24, 7
    257a:	fc cf       	rjmp	.-8      	; 0x2574 <MemoryRecall+0x6e>

    return FRAM_USART.DATA;
    257c:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    2580:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2584:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2588:	87 ff       	sbrs	r24, 7
    258a:	fc cf       	rjmp	.-8      	; 0x2584 <MemoryRecall+0x7e>
    }
}

INLINE void FlashToFRAM(uint32_t Address, uint16_t ByteCount) {
    /* We assume that ByteCount is a multiple of 2 */
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;
    258c:	8f ef       	ldi	r24, 0xFF	; 255
    258e:	e8 1a       	sub	r14, r24
    2590:	f8 0a       	sbc	r15, r24
INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));

    return FRAM_USART.DATA;
    2592:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    2596:	c0 e0       	ldi	r28, 0x00	; 0
    2598:	d0 e1       	ldi	r29, 0x10	; 16
        SPITransferByte(0);

        /* Loop through bytes, read words from flash and write
         * double byte into FRAM. */
        while (ByteCount > 1) {
            uint16_t Word = FlashReadWord(PhysicalAddress);
    259a:	c7 01       	movw	r24, r14
    259c:	b6 01       	movw	r22, r12
    259e:	58 da       	rcall	.-2896   	; 0x1a50 <FlashReadWord>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    25a0:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    25a4:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    25a8:	87 ff       	sbrs	r24, 7
    25aa:	fc cf       	rjmp	.-8      	; 0x25a4 <MemoryRecall+0x9e>

    return FRAM_USART.DATA;
    25ac:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    25b0:	90 93 a0 09 	sts	0x09A0, r25	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    25b4:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    25b8:	87 ff       	sbrs	r24, 7
    25ba:	fc cf       	rjmp	.-8      	; 0x25b4 <MemoryRecall+0xae>

    return FRAM_USART.DATA;
    25bc:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
            uint16_t Word = FlashReadWord(PhysicalAddress);

            SPITransferByte((Word >> 0) & 0xFF);
            SPITransferByte((Word >> 8) & 0xFF);

            PhysicalAddress += 2;
    25c0:	82 e0       	ldi	r24, 0x02	; 2
    25c2:	c8 0e       	add	r12, r24
    25c4:	d1 1c       	adc	r13, r1
    25c6:	e1 1c       	adc	r14, r1
    25c8:	f1 1c       	adc	r15, r1
    25ca:	21 97       	sbiw	r28, 0x01	; 1
        SPITransferByte(0); /* Address hi and lo byte */
        SPITransferByte(0);

        /* Loop through bytes, read words from flash and write
         * double byte into FRAM. */
        while (ByteCount > 1) {
    25cc:	31 f7       	brne	.-52     	; 0x259a <MemoryRecall+0x94>
            PhysicalAddress += 2;
            ByteCount -= 2;
        }

        /* End write procedure of FRAM */
        FRAM_PORT.OUTSET = FRAM_CS;
    25ce:	80 e1       	ldi	r24, 0x10	; 16
    25d0:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>

    return false;
}

INLINE void SystemTickClearFlag(void) {
    while (RTC.STATUS & RTC_SYNCBUSY_bm)
    25d4:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <__TEXT_REGION_LENGTH__+0x700401>
    25d8:	80 fd       	sbrc	r24, 0
    25da:	fc cf       	rjmp	.-8      	; 0x25d4 <MemoryRecall+0xce>
        ;

    RTC.INTFLAGS = RTC_COMPIF_bm;
    25dc:	82 e0       	ldi	r24, 0x02	; 2
    25de:	80 93 03 04 	sts	0x0403, r24	; 0x800403 <__TEXT_REGION_LENGTH__+0x700403>
void MemoryRecall(void) {
    /* Recall memory from permanent flash */
    FlashToFRAM((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    SystemTickClearFlag();
}
    25e2:	df 91       	pop	r29
    25e4:	cf 91       	pop	r28
    25e6:	ff 90       	pop	r15
    25e8:	ef 90       	pop	r14
    25ea:	df 90       	pop	r13
    25ec:	cf 90       	pop	r12
    25ee:	08 95       	ret

000025f0 <MemoryClear>:
    FRAMWrite(Buffer, Address, ByteCount);

    LEDHook(LED_MEMORY_CHANGED, LED_ON);
}

void MemoryClear(void) {
    25f0:	cf 92       	push	r12
    25f2:	df 92       	push	r13
    25f4:	ef 92       	push	r14
    25f6:	ff 92       	push	r15
    25f8:	cf 93       	push	r28
    25fa:	df 93       	push	r29
    FlashErase((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);
    25fc:	c0 90 d8 2f 	lds	r12, 0x2FD8	; 0x802fd8 <GlobalSettings>
    2600:	d1 2c       	mov	r13, r1
    2602:	e1 2c       	mov	r14, r1
    2604:	f1 2c       	mov	r15, r1
    2606:	8d e0       	ldi	r24, 0x0D	; 13
    2608:	cc 0c       	add	r12, r12
    260a:	dd 1c       	adc	r13, r13
    260c:	ee 1c       	adc	r14, r14
    260e:	ff 1c       	adc	r15, r15
    2610:	8a 95       	dec	r24
    2612:	d1 f7       	brne	.-12     	; 0x2608 <MemoryClear+0x18>

INLINE void FlashErase(uint32_t Address, uint16_t ByteCount) {
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;

    if ((PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END)) {
    2614:	c1 14       	cp	r12, r1
    2616:	d1 04       	cpc	r13, r1
    2618:	81 e0       	ldi	r24, 0x01	; 1
    261a:	e8 06       	cpc	r14, r24
    261c:	f1 04       	cpc	r15, r1
    261e:	38 f0       	brcs	.+14     	; 0x262e <MemoryClear+0x3e>

void MemoryClear(void) {
    FlashErase((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    MemoryRecall();
}
    2620:	df 91       	pop	r29
    2622:	cf 91       	pop	r28
    2624:	ff 90       	pop	r15
    2626:	ef 90       	pop	r14
    2628:	df 90       	pop	r13
    262a:	cf 90       	pop	r12
}

void MemoryClear(void) {
    FlashErase((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    MemoryRecall();
    262c:	6c cf       	rjmp	.-296    	; 0x2506 <MemoryRecall>
    }
}

INLINE void FlashErase(uint32_t Address, uint16_t ByteCount) {
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;
    262e:	8f ef       	ldi	r24, 0xFF	; 255
    2630:	e8 1a       	sub	r14, r24
    2632:	f8 0a       	sbc	r15, r24
    2634:	c1 e2       	ldi	r28, 0x21	; 33
    2636:	d0 e0       	ldi	r29, 0x00	; 0
    2638:	21 97       	sbiw	r28, 0x01	; 1

    if ((PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END)) {
        /* Sanity check to limit access to the allocated area */
        while (PageCount-- > 0) {
            FlashWaitForSPM();
    263a:	91 f3       	breq	.-28     	; 0x2620 <MemoryClear+0x30>
    263c:	24 da       	rcall	.-3000   	; 0x1a86 <FlashWaitForSPM>

            FlashEraseApplicationPage(PhysicalAddress);
    263e:	c7 01       	movw	r24, r14
    2640:	b6 01       	movw	r22, r12
            FlashWaitForSPM();
    2642:	0d da       	rcall	.-3046   	; 0x1a5e <FlashEraseApplicationPage>
    2644:	20 da       	rcall	.-3008   	; 0x1a86 <FlashWaitForSPM>

            PhysicalAddress += APP_SECTION_PAGE_SIZE;
    2646:	8f ef       	ldi	r24, 0xFF	; 255
    2648:	d8 1a       	sub	r13, r24
    264a:	e8 0a       	sbc	r14, r24
    264c:	f8 0a       	sbc	r15, r24
    264e:	f4 cf       	rjmp	.-24     	; 0x2638 <MemoryClear+0x48>

00002650 <MemoryStore>:
    FlashToFRAM((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    SystemTickClearFlag();
}

void MemoryStore(void) {
    2650:	cf 92       	push	r12
    2652:	df 92       	push	r13
    2654:	ef 92       	push	r14
    2656:	ff 92       	push	r15
    2658:	0f 93       	push	r16
    265a:	1f 93       	push	r17
    265c:	cf 93       	push	r28
    265e:	df 93       	push	r29
    /* Store current memory into permanent flash */
    FRAMToFlash((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);
    2660:	c0 90 d8 2f 	lds	r12, 0x2FD8	; 0x802fd8 <GlobalSettings>
    2664:	d1 2c       	mov	r13, r1
    2666:	e1 2c       	mov	r14, r1
    2668:	f1 2c       	mov	r15, r1
    266a:	8d e0       	ldi	r24, 0x0D	; 13
    266c:	cc 0c       	add	r12, r12
    266e:	dd 1c       	adc	r13, r13
    2670:	ee 1c       	adc	r14, r14
    2672:	ff 1c       	adc	r15, r15
    2674:	8a 95       	dec	r24
    2676:	d1 f7       	brne	.-12     	; 0x266c <MemoryStore+0x1c>
     * aligned to APP_SECTION_PAGE_SIZE and a multiple of APP_SECTION_PAGE_SIZE.
     * Thus only full pages are written into the flash. */
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;

    if ((PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END)) {
    2678:	c1 14       	cp	r12, r1
    267a:	d1 04       	cpc	r13, r1
    267c:	81 e0       	ldi	r24, 0x01	; 1
    267e:	e8 06       	cpc	r14, r24
    2680:	f1 04       	cpc	r15, r1
    2682:	08 f0       	brcs	.+2      	; 0x2686 <MemoryStore+0x36>
    2684:	4f c0       	rjmp	.+158    	; 0x2724 <MemoryStore+0xd4>
        /* Sanity check to limit access to the allocated area and setup FRAM
         * read. */
        FRAM_PORT.OUTCLR = FRAM_CS;
    2686:	80 e1       	ldi	r24, 0x10	; 16
    2688:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    268c:	83 e0       	ldi	r24, 0x03	; 3
    268e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2692:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    2696:	87 ff       	sbrs	r24, 7
    2698:	fc cf       	rjmp	.-8      	; 0x2692 <MemoryStore+0x42>

    return FRAM_USART.DATA;
    269a:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    269e:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    26a2:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    26a6:	87 ff       	sbrs	r24, 7
    26a8:	fc cf       	rjmp	.-8      	; 0x26a2 <MemoryStore+0x52>

    return FRAM_USART.DATA;
    26aa:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    26ae:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    26b2:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    26b6:	87 ff       	sbrs	r24, 7
    26b8:	fc cf       	rjmp	.-8      	; 0x26b2 <MemoryStore+0x62>
INLINE void FRAMToFlash(uint32_t Address, uint16_t ByteCount) {
    /* We assume that FlashWrite is always called for write actions that are
     * aligned to APP_SECTION_PAGE_SIZE and a multiple of APP_SECTION_PAGE_SIZE.
     * Thus only full pages are written into the flash. */
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;
    26ba:	8f ef       	ldi	r24, 0xFF	; 255
    26bc:	e8 1a       	sub	r14, r24
    26be:	f8 0a       	sbc	r15, r24
INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));

    return FRAM_USART.DATA;
    26c0:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    26c4:	01 e2       	ldi	r16, 0x21	; 33
    26c6:	10 e0       	ldi	r17, 0x00	; 0
    26c8:	01 50       	subi	r16, 0x01	; 1
    26ca:	11 09       	sbc	r17, r1

        SPITransferByte(0x03); /* Read command */
        SPITransferByte(0); /* Address hi and lo byte */
        SPITransferByte(0);

        while (PageCount-- > 0) {
    26cc:	41 f1       	breq	.+80     	; 0x271e <MemoryStore+0xce>
            /* For each page to program, wait for NVM to get ready,
             * erase the flash page buffer, program all data to the
             * flash page buffer and write buffer to flash using
             * the atomic erase and write operation. */

            FlashWaitForSPM();
    26ce:	db d9       	rcall	.-3146   	; 0x1a86 <FlashWaitForSPM>

            FlashEraseFlashBuffer();
    26d0:	d7 d9       	rcall	.-3154   	; 0x1a80 <FlashEraseFlashBuffer>
            FlashWaitForSPM();
    26d2:	d9 d9       	rcall	.-3150   	; 0x1a86 <FlashWaitForSPM>
    26d4:	c0 e0       	ldi	r28, 0x00	; 0

            /* Write one page worth of data into flash buffer */
            for (uint16_t i = 0; i < APP_SECTION_PAGE_SIZE; i += 2) {
    26d6:	d0 e0       	ldi	r29, 0x00	; 0
    26d8:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    26dc:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    26e0:	87 ff       	sbrs	r24, 7
    26e2:	fc cf       	rjmp	.-8      	; 0x26dc <MemoryStore+0x8c>
    26e4:	60 91 a0 09 	lds	r22, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    return FRAM_USART.DATA;
    26e8:	70 e0       	ldi	r23, 0x00	; 0

            /* Write one page worth of data into flash buffer */
            for (uint16_t i = 0; i < APP_SECTION_PAGE_SIZE; i += 2) {
                uint16_t Word = 0;

                Word |= ((uint16_t) SPITransferByte(0) << 0);
    26ea:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    26ee:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    26f2:	87 ff       	sbrs	r24, 7
    26f4:	fc cf       	rjmp	.-8      	; 0x26ee <MemoryStore+0x9e>
    26f6:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
                uint16_t Word = 0;

                Word |= ((uint16_t) SPITransferByte(0) << 0);
                Word |= ((uint16_t) SPITransferByte(0) << 8);

                FlashLoadFlashWord(i, Word);
    26fa:	78 2b       	or	r23, r24
    26fc:	ce 01       	movw	r24, r28
    26fe:	b5 d9       	rcall	.-3222   	; 0x1a6a <FlashLoadFlashWord>
                FlashWaitForSPM();
    2700:	c2 d9       	rcall	.-3196   	; 0x1a86 <FlashWaitForSPM>
    2702:	22 96       	adiw	r28, 0x02	; 2

            FlashEraseFlashBuffer();
            FlashWaitForSPM();

            /* Write one page worth of data into flash buffer */
            for (uint16_t i = 0; i < APP_SECTION_PAGE_SIZE; i += 2) {
    2704:	c1 15       	cp	r28, r1
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	d8 07       	cpc	r29, r24
                FlashLoadFlashWord(i, Word);
                FlashWaitForSPM();
            }

            /* Program flash buffer into flash */
            FlashEraseWriteApplicationPage(PhysicalAddress);
    270a:	31 f7       	brne	.-52     	; 0x26d8 <MemoryStore+0x88>
    270c:	c7 01       	movw	r24, r14
    270e:	b6 01       	movw	r22, r12
    2710:	b1 d9       	rcall	.-3230   	; 0x1a74 <FlashEraseWriteApplicationPage>
            FlashWaitForSPM();
    2712:	b9 d9       	rcall	.-3214   	; 0x1a86 <FlashWaitForSPM>
    2714:	8f ef       	ldi	r24, 0xFF	; 255

            PhysicalAddress += APP_SECTION_PAGE_SIZE;
    2716:	d8 1a       	sub	r13, r24
    2718:	e8 0a       	sbc	r14, r24
    271a:	f8 0a       	sbc	r15, r24
    271c:	d5 cf       	rjmp	.-86     	; 0x26c8 <MemoryStore+0x78>
    271e:	80 e1       	ldi	r24, 0x10	; 16
        }

        /* End read procedure of FRAM */
        FRAM_PORT.OUTSET = FRAM_CS;
    2720:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
    2724:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    2728:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    272c:	87 81       	ldd	r24, Z+7	; 0x07
    272e:	86 30       	cpi	r24, 0x06	; 6
    2730:	19 f4       	brne	.+6      	; 0x2738 <MemoryStore+0xe8>
    2732:	90 e1       	ldi	r25, 0x10	; 16
        LEDGreenAction = Action;
    2734:	90 93 95 2c 	sts	0x2C95, r25	; 0x802c95 <LEDGreenAction>
    2738:	96 81       	ldd	r25, Z+6	; 0x06
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    273a:	96 30       	cpi	r25, 0x06	; 6
    273c:	49 f4       	brne	.+18     	; 0x2750 <MemoryStore+0x100>
    273e:	20 e1       	ldi	r18, 0x10	; 16
        LEDRedAction = Action;
    2740:	20 93 94 2c 	sts	0x2C94, r18	; 0x802c94 <LEDRedAction>
    2744:	85 30       	cpi	r24, 0x05	; 5

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    2746:	59 f4       	brne	.+22     	; 0x275e <MemoryStore+0x10e>
    2748:	83 e1       	ldi	r24, 0x13	; 19
        LEDGreenAction = Action;
    274a:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    274e:	02 c0       	rjmp	.+4      	; 0x2754 <MemoryStore+0x104>
    2750:	85 30       	cpi	r24, 0x05	; 5

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    2752:	d1 f3       	breq	.-12     	; 0x2748 <MemoryStore+0xf8>
    2754:	95 30       	cpi	r25, 0x05	; 5
        LEDGreenAction = Action;
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    2756:	19 f4       	brne	.+6      	; 0x275e <MemoryStore+0x10e>
    2758:	83 e1       	ldi	r24, 0x13	; 19
        LEDRedAction = Action;
    275a:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    275e:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <__TEXT_REGION_LENGTH__+0x700401>

    return false;
}

INLINE void SystemTickClearFlag(void) {
    while (RTC.STATUS & RTC_SYNCBUSY_bm)
    2762:	80 fd       	sbrc	r24, 0
    2764:	fc cf       	rjmp	.-8      	; 0x275e <MemoryStore+0x10e>
    2766:	82 e0       	ldi	r24, 0x02	; 2
        ;

    RTC.INTFLAGS = RTC_COMPIF_bm;
    2768:	80 93 03 04 	sts	0x0403, r24	; 0x800403 <__TEXT_REGION_LENGTH__+0x700403>
    276c:	df 91       	pop	r29

    LEDHook(LED_MEMORY_CHANGED, LED_OFF);
    LEDHook(LED_MEMORY_STORED, LED_PULSE);

    SystemTickClearFlag();
}
    276e:	cf 91       	pop	r28
    2770:	1f 91       	pop	r17
    2772:	0f 91       	pop	r16
    2774:	ff 90       	pop	r15
    2776:	ef 90       	pop	r14
    2778:	df 90       	pop	r13
    277a:	cf 90       	pop	r12
    277c:	08 95       	ret

0000277e <MemoryUploadBlock>:
    277e:	cf 92       	push	r12

bool MemoryUploadBlock(void *Buffer, uint32_t BlockAddress, uint16_t ByteCount) {
    2780:	df 92       	push	r13
    2782:	ef 92       	push	r14
    2784:	ff 92       	push	r15
    2786:	0f 93       	push	r16
    2788:	1f 93       	push	r17
    if (BlockAddress >= MEMORY_SIZE_PER_SETTING) {
    278a:	41 15       	cp	r20, r1
    278c:	e0 e2       	ldi	r30, 0x20	; 32
    278e:	5e 07       	cpc	r21, r30
    2790:	61 05       	cpc	r22, r1
    2792:	71 05       	cpc	r23, r1
    2794:	08 f0       	brcs	.+2      	; 0x2798 <MemoryUploadBlock+0x1a>
    2796:	6b c0       	rjmp	.+214    	; 0x286e <MemoryUploadBlock+0xf0>
        /* Prevent writing out of bounds by silently ignoring it */
        return true;
    } else {
        /* Calculate bytes left in memory and start writing */
        uint32_t BytesLeft = MEMORY_SIZE_PER_SETTING - BlockAddress;
        ByteCount = MIN(ByteCount, BytesLeft);
    2798:	69 01       	movw	r12, r18
    279a:	e1 2c       	mov	r14, r1
    279c:	f1 2c       	mov	r15, r1
    279e:	00 e0       	ldi	r16, 0x00	; 0
    27a0:	10 e2       	ldi	r17, 0x20	; 32
    27a2:	20 e0       	ldi	r18, 0x00	; 0
    27a4:	30 e0       	ldi	r19, 0x00	; 0
    27a6:	04 1b       	sub	r16, r20
    27a8:	15 0b       	sbc	r17, r21
    27aa:	26 0b       	sbc	r18, r22
    27ac:	37 0b       	sbc	r19, r23
    27ae:	c0 16       	cp	r12, r16
    27b0:	d1 06       	cpc	r13, r17
    27b2:	e2 06       	cpc	r14, r18
    27b4:	f3 06       	cpc	r15, r19
    27b6:	10 f4       	brcc	.+4      	; 0x27bc <MemoryUploadBlock+0x3e>
    27b8:	97 01       	movw	r18, r14
    27ba:	86 01       	movw	r16, r12

    FRAM_PORT.OUTSET = FRAM_CS;
}

INLINE void FRAMWrite(const void *Buffer, uint16_t Address, uint16_t ByteCount) {
    FRAM_PORT.OUTCLR = FRAM_CS;
    27bc:	20 e1       	ldi	r18, 0x10	; 16
    27be:	20 93 66 06 	sts	0x0666, r18	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    27c2:	26 e0       	ldi	r18, 0x06	; 6
    27c4:	20 93 a0 09 	sts	0x09A0, r18	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    27c8:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    27cc:	27 ff       	sbrs	r18, 7
    27ce:	fc cf       	rjmp	.-8      	; 0x27c8 <MemoryUploadBlock+0x4a>

    return FRAM_USART.DATA;
    27d0:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
}

INLINE void FRAMWrite(const void *Buffer, uint16_t Address, uint16_t ByteCount) {
    FRAM_PORT.OUTCLR = FRAM_CS;
    SPITransferByte(0x06); /* Write Enable */
    FRAM_PORT.OUTSET = FRAM_CS;
    27d4:	20 e1       	ldi	r18, 0x10	; 16
    27d6:	20 93 65 06 	sts	0x0665, r18	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>

    asm volatile("nop");
    27da:	00 00       	nop
    asm volatile("nop");
    27dc:	00 00       	nop

    FRAM_PORT.OUTCLR = FRAM_CS;
    27de:	20 93 66 06 	sts	0x0666, r18	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    27e2:	22 e0       	ldi	r18, 0x02	; 2
    27e4:	20 93 a0 09 	sts	0x09A0, r18	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    27e8:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    27ec:	27 ff       	sbrs	r18, 7
    27ee:	fc cf       	rjmp	.-8      	; 0x27e8 <MemoryUploadBlock+0x6a>

    return FRAM_USART.DATA;
    27f0:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    27f4:	50 93 a0 09 	sts	0x09A0, r21	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    27f8:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    27fc:	27 ff       	sbrs	r18, 7
    27fe:	fc cf       	rjmp	.-8      	; 0x27f8 <MemoryUploadBlock+0x7a>

    return FRAM_USART.DATA;
    2800:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    2804:	40 93 a0 09 	sts	0x09A0, r20	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2808:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    280c:	27 ff       	sbrs	r18, 7
    280e:	fc cf       	rjmp	.-8      	; 0x2808 <MemoryUploadBlock+0x8a>

    return FRAM_USART.DATA;
    2810:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
#endif

#ifdef USE_DMA
INLINE void SPIWriteBlock(const void *Buffer, uint16_t ByteCount) {
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    2814:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <__TEXT_REGION_LENGTH__+0x700112>
    RECV_DMA.DESTADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    2818:	2c e8       	ldi	r18, 0x8C	; 140
    281a:	34 e2       	ldi	r19, 0x24	; 36
    281c:	20 93 1c 01 	sts	0x011C, r18	; 0x80011c <__TEXT_REGION_LENGTH__+0x70011c>
    RECV_DMA.DESTADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    2820:	30 93 1d 01 	sts	0x011D, r19	; 0x80011d <__TEXT_REGION_LENGTH__+0x70011d>
    RECV_DMA.TRFCNT = ByteCount;
    2824:	00 93 14 01 	sts	0x0114, r16	; 0x800114 <__TEXT_REGION_LENGTH__+0x700114>
    2828:	10 93 15 01 	sts	0x0115, r17	; 0x800115 <__TEXT_REGION_LENGTH__+0x700115>
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    282c:	20 e1       	ldi	r18, 0x10	; 16
    282e:	20 93 22 01 	sts	0x0122, r18	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
    SEND_DMA.SRCADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    2832:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    SEND_DMA.SRCADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    2836:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    SEND_DMA.TRFCNT = ByteCount;
    283a:	00 93 24 01 	sts	0x0124, r16	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
    283e:	10 93 25 01 	sts	0x0125, r17	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>

    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    2842:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    2846:	80 68       	ori	r24, 0x80	; 128
    2848:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    284c:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    2850:	80 68       	ori	r24, 0x80	; 128
    2852:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>

    /* Wait for DMA to finish */
    while (RECV_DMA.CTRLA & DMA_CH_ENABLE_bm)
    2856:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    285a:	87 fd       	sbrc	r24, 7
    285c:	fc cf       	rjmp	.-8      	; 0x2856 <MemoryUploadBlock+0xd8>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    285e:	80 e3       	ldi	r24, 0x30	; 48
    2860:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <__TEXT_REGION_LENGTH__+0x700111>
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    2864:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    SPITransferByte((Address >> 8) & 0xFF);   /* Address hi and lo byte */
    SPITransferByte((Address >> 0) & 0xFF);

    SPIWriteBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    2868:	80 e1       	ldi	r24, 0x10	; 16
    286a:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
        /* Store to local memory */
        FRAMWrite(Buffer, BlockAddress, ByteCount);

        return true;
    }
}
    286e:	81 e0       	ldi	r24, 0x01	; 1
    2870:	1f 91       	pop	r17
    2872:	0f 91       	pop	r16
    2874:	ff 90       	pop	r15
    2876:	ef 90       	pop	r14
    2878:	df 90       	pop	r13
    287a:	cf 90       	pop	r12
    287c:	08 95       	ret

0000287e <MemoryDownloadBlock>:

bool MemoryDownloadBlock(void *Buffer, uint32_t BlockAddress, uint16_t ByteCount) {
    287e:	cf 92       	push	r12
    2880:	df 92       	push	r13
    2882:	ef 92       	push	r14
    2884:	ff 92       	push	r15
    2886:	0f 93       	push	r16
    2888:	1f 93       	push	r17
    if (BlockAddress >= MEMORY_SIZE_PER_SETTING) {
    288a:	41 15       	cp	r20, r1
    288c:	e0 e2       	ldi	r30, 0x20	; 32
    288e:	5e 07       	cpc	r21, r30
    2890:	61 05       	cpc	r22, r1
    2892:	71 05       	cpc	r23, r1
    2894:	08 f0       	brcs	.+2      	; 0x2898 <MemoryDownloadBlock+0x1a>
    2896:	5d c0       	rjmp	.+186    	; 0x2952 <MemoryDownloadBlock+0xd4>
        /* There are bytes out of bounds to be read. Notify that we are done. */
        return false;
    } else {
        /* Calculate bytes left in memory and issue reading */
        uint32_t BytesLeft = MEMORY_SIZE_PER_SETTING - BlockAddress;
        ByteCount = MIN(ByteCount, BytesLeft);
    2898:	69 01       	movw	r12, r18
    289a:	e1 2c       	mov	r14, r1
    289c:	f1 2c       	mov	r15, r1
    289e:	00 e0       	ldi	r16, 0x00	; 0
    28a0:	10 e2       	ldi	r17, 0x20	; 32
    28a2:	20 e0       	ldi	r18, 0x00	; 0
    28a4:	30 e0       	ldi	r19, 0x00	; 0
    28a6:	04 1b       	sub	r16, r20
    28a8:	15 0b       	sbc	r17, r21
    28aa:	26 0b       	sbc	r18, r22
    28ac:	37 0b       	sbc	r19, r23
    28ae:	c0 16       	cp	r12, r16
    28b0:	d1 06       	cpc	r13, r17
    28b2:	e2 06       	cpc	r14, r18
    28b4:	f3 06       	cpc	r15, r19
    28b6:	10 f4       	brcc	.+4      	; 0x28bc <MemoryDownloadBlock+0x3e>
    28b8:	97 01       	movw	r18, r14
    28ba:	86 01       	movw	r16, r12
    }
}
#endif

INLINE void FRAMRead(void *Buffer, uint16_t Address, uint16_t ByteCount) {
    FRAM_PORT.OUTCLR = FRAM_CS;
    28bc:	20 e1       	ldi	r18, 0x10	; 16
    28be:	20 93 66 06 	sts	0x0666, r18	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    28c2:	23 e0       	ldi	r18, 0x03	; 3
    28c4:	20 93 a0 09 	sts	0x09A0, r18	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    28c8:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    28cc:	27 ff       	sbrs	r18, 7
    28ce:	fc cf       	rjmp	.-8      	; 0x28c8 <MemoryDownloadBlock+0x4a>

    return FRAM_USART.DATA;
    28d0:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    28d4:	50 93 a0 09 	sts	0x09A0, r21	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    28d8:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    28dc:	27 ff       	sbrs	r18, 7
    28de:	fc cf       	rjmp	.-8      	; 0x28d8 <MemoryDownloadBlock+0x5a>

    return FRAM_USART.DATA;
    28e0:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
void FlashWaitForSPM(void);

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data) {
    FRAM_USART.DATA = Data;
    28e4:	40 93 a0 09 	sts	0x09A0, r20	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    28e8:	20 91 a1 09 	lds	r18, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    28ec:	27 ff       	sbrs	r18, 7
    28ee:	fc cf       	rjmp	.-8      	; 0x28e8 <MemoryDownloadBlock+0x6a>

    return FRAM_USART.DATA;
    28f0:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
}

#ifdef USE_DMA
INLINE void SPIReadBlock(void *Buffer, uint16_t ByteCount) {
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_INC_gc;
    28f4:	21 e0       	ldi	r18, 0x01	; 1
    28f6:	20 93 12 01 	sts	0x0112, r18	; 0x800112 <__TEXT_REGION_LENGTH__+0x700112>
    RECV_DMA.DESTADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    28fa:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <__TEXT_REGION_LENGTH__+0x70011c>
    RECV_DMA.DESTADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    28fe:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <__TEXT_REGION_LENGTH__+0x70011d>
    RECV_DMA.TRFCNT = ByteCount;
    2902:	00 93 14 01 	sts	0x0114, r16	; 0x800114 <__TEXT_REGION_LENGTH__+0x700114>
    2906:	10 93 15 01 	sts	0x0115, r17	; 0x800115 <__TEXT_REGION_LENGTH__+0x700115>
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    290a:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
    SEND_DMA.SRCADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    290e:	8c e8       	ldi	r24, 0x8C	; 140
    2910:	94 e2       	ldi	r25, 0x24	; 36
    2912:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    SEND_DMA.SRCADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    2916:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    SEND_DMA.TRFCNT = ByteCount;
    291a:	00 93 24 01 	sts	0x0124, r16	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
    291e:	10 93 25 01 	sts	0x0125, r17	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>


    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    2922:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    2926:	80 68       	ori	r24, 0x80	; 128
    2928:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    292c:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    2930:	80 68       	ori	r24, 0x80	; 128
    2932:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>

    /* Wait for DMA to finish */
    while (RECV_DMA.CTRLA & DMA_CH_ENABLE_bm)
    2936:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__TEXT_REGION_LENGTH__+0x700110>
    293a:	87 fd       	sbrc	r24, 7
    293c:	fc cf       	rjmp	.-8      	; 0x2936 <MemoryDownloadBlock+0xb8>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    293e:	80 e3       	ldi	r24, 0x30	; 48
    2940:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <__TEXT_REGION_LENGTH__+0x700111>
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    2944:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    SPITransferByte((Address >> 8) & 0xFF);   /* Address hi and lo byte */
    SPITransferByte((Address >> 0) & 0xFF);

    SPIReadBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    2948:	80 e1       	ldi	r24, 0x10	; 16
    294a:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
        ByteCount = MIN(ByteCount, BytesLeft);

        /* Output local memory contents */
        FRAMRead(Buffer, BlockAddress, ByteCount);

        return true;
    294e:	81 e0       	ldi	r24, 0x01	; 1
    2950:	01 c0       	rjmp	.+2      	; 0x2954 <MemoryDownloadBlock+0xd6>
}

bool MemoryDownloadBlock(void *Buffer, uint32_t BlockAddress, uint16_t ByteCount) {
    if (BlockAddress >= MEMORY_SIZE_PER_SETTING) {
        /* There are bytes out of bounds to be read. Notify that we are done. */
        return false;
    2952:	80 e0       	ldi	r24, 0x00	; 0
        /* Output local memory contents */
        FRAMRead(Buffer, BlockAddress, ByteCount);

        return true;
    }
}
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	ff 90       	pop	r15
    295a:	ef 90       	pop	r14
    295c:	df 90       	pop	r13
    295e:	cf 90       	pop	r12
    2960:	08 95       	ret

00002962 <WaitForNVM>:
                     [z] "z"(z)
                    );
}

void WaitForNVM(void) {
    while (NVM.STATUS & NVM_NVMBUSY_bm) { };
    2962:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7001cf>
    2966:	87 fd       	sbrc	r24, 7
    2968:	fc cf       	rjmp	.-8      	; 0x2962 <WaitForNVM>
}
    296a:	08 95       	ret

0000296c <FlushNVMBuffer>:

void FlushNVMBuffer(void) {
    WaitForNVM();
    296c:	fa df       	rcall	.-12     	; 0x2962 <WaitForNVM>

    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    296e:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7001cf>
    2972:	81 ff       	sbrs	r24, 1
    2974:	0b c0       	rjmp	.+22     	; 0x298c <FlushNVMBuffer+0x20>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    2976:	86 e3       	ldi	r24, 0x36	; 54
    2978:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
// EEPROM functions

static inline void NVM_EXEC(void) {
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    297c:	eb ec       	ldi	r30, 0xCB	; 203
    297e:	f1 e0       	ldi	r31, 0x01	; 1
    2980:	21 e0       	ldi	r18, 0x01	; 1
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	88 ed       	ldi	r24, 0xD8	; 216
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	84 bf       	out	0x34, r24	; 52
    298a:	20 83       	st	Z, r18
    298c:	08 95       	ret

0000298e <ReadEEPBlock>:
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
        NVM_EXEC();
    }
}

uint16_t ReadEEPBlock(uint16_t Address, void *DestPtr, uint16_t ByteCount) {
    298e:	ef 92       	push	r14
    2990:	ff 92       	push	r15
    2992:	0f 93       	push	r16
    2994:	1f 93       	push	r17
    2996:	cf 93       	push	r28
    2998:	df 93       	push	r29
    299a:	ec 01       	movw	r28, r24
    299c:	7b 01       	movw	r14, r22
    299e:	8a 01       	movw	r16, r20
    uint16_t BytesRead = 0;
    uint8_t *BytePtr = (uint8_t *) DestPtr;
    NVM.ADDR2 = 0;
    29a0:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <__TEXT_REGION_LENGTH__+0x7001c2>

    WaitForNVM();
    29a4:	de df       	rcall	.-68     	; 0x2962 <WaitForNVM>
    29a6:	d7 01       	movw	r26, r14
    29a8:	ce 01       	movw	r24, r28
    29aa:	80 0f       	add	r24, r16
    29ac:	91 1f       	adc	r25, r17

    while (ByteCount > 0) {
        NVM.ADDR0 = Address & 0xFF;
        NVM.ADDR1 = (Address >> 8) & 0x1F;

        NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    29ae:	26 e0       	ldi	r18, 0x06	; 6
// EEPROM functions

static inline void NVM_EXEC(void) {
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    29b0:	48 ed       	ldi	r20, 0xD8	; 216
    29b2:	50 e0       	ldi	r21, 0x00	; 0
    29b4:	61 e0       	ldi	r22, 0x01	; 1
    29b6:	70 e0       	ldi	r23, 0x00	; 0
    29b8:	eb ec       	ldi	r30, 0xCB	; 203
    29ba:	f1 e0       	ldi	r31, 0x01	; 1
    uint8_t *BytePtr = (uint8_t *) DestPtr;
    NVM.ADDR2 = 0;

    WaitForNVM();

    while (ByteCount > 0) {
    29bc:	c8 17       	cp	r28, r24
    29be:	d9 07       	cpc	r29, r25
    29c0:	79 f0       	breq	.+30     	; 0x29e0 <ReadEEPBlock+0x52>
        NVM.ADDR0 = Address & 0xFF;
    29c2:	c0 93 c0 01 	sts	0x01C0, r28	; 0x8001c0 <__TEXT_REGION_LENGTH__+0x7001c0>
        NVM.ADDR1 = (Address >> 8) & 0x1F;
    29c6:	3d 2f       	mov	r19, r29
    29c8:	3f 71       	andi	r19, 0x1F	; 31
    29ca:	30 93 c1 01 	sts	0x01C1, r19	; 0x8001c1 <__TEXT_REGION_LENGTH__+0x7001c1>

        NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    29ce:	20 93 ca 01 	sts	0x01CA, r18	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
// EEPROM functions

static inline void NVM_EXEC(void) {
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    29d2:	44 bf       	out	0x34, r20	; 52
    29d4:	60 83       	st	Z, r22
        NVM.ADDR1 = (Address >> 8) & 0x1F;

        NVM.CMD = NVM_CMD_READ_EEPROM_gc;
        NVM_EXEC();

        *BytePtr++ = NVM.DATA0;
    29d6:	30 91 c4 01 	lds	r19, 0x01C4	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
    29da:	3d 93       	st	X+, r19
        Address++;
    29dc:	21 96       	adiw	r28, 0x01	; 1
    29de:	ee cf       	rjmp	.-36     	; 0x29bc <ReadEEPBlock+0x2e>
        ByteCount--;
        BytesRead++;
    }

    return BytesRead;
}
    29e0:	c8 01       	movw	r24, r16
    29e2:	df 91       	pop	r29
    29e4:	cf 91       	pop	r28
    29e6:	1f 91       	pop	r17
    29e8:	0f 91       	pop	r16
    29ea:	ff 90       	pop	r15
    29ec:	ef 90       	pop	r14
    29ee:	08 95       	ret

000029f0 <WriteEEPBlock>:


uint16_t WriteEEPBlock(uint16_t Address, const void *SrcPtr, uint16_t ByteCount) {
    29f0:	3f 92       	push	r3
    29f2:	4f 92       	push	r4
    29f4:	5f 92       	push	r5
    29f6:	6f 92       	push	r6
    29f8:	7f 92       	push	r7
    29fa:	8f 92       	push	r8
    29fc:	9f 92       	push	r9
    29fe:	af 92       	push	r10
    2a00:	bf 92       	push	r11
    2a02:	cf 92       	push	r12
    2a04:	df 92       	push	r13
    2a06:	ef 92       	push	r14
    2a08:	ff 92       	push	r15
    2a0a:	0f 93       	push	r16
    2a0c:	1f 93       	push	r17
    2a0e:	cf 93       	push	r28
    2a10:	df 93       	push	r29
    2a12:	8b 01       	movw	r16, r22
    2a14:	54 2e       	mov	r5, r20
    2a16:	65 2e       	mov	r6, r21
    const uint8_t *BytePtr = (const uint8_t *) SrcPtr;
    uint8_t ByteAddress = Address % EEPROM_PAGE_SIZE;
    2a18:	28 2f       	mov	r18, r24
    2a1a:	2f 71       	andi	r18, 0x1F	; 31
    2a1c:	72 2e       	mov	r7, r18
    uint16_t PageAddress = Address - ByteAddress;
    2a1e:	ec 01       	movw	r28, r24
    2a20:	c2 1b       	sub	r28, r18
    2a22:	d1 09       	sbc	r29, r1
    uint16_t BytesWritten = 0;

    FlushNVMBuffer();
    2a24:	a3 df       	rcall	.-186    	; 0x296c <FlushNVMBuffer>
    WaitForNVM();
    2a26:	9d df       	rcall	.-198    	; 0x2962 <WaitForNVM>
    2a28:	83 e3       	ldi	r24, 0x33	; 51
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    2a2a:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
    2a2e:	10 92 c1 01 	sts	0x01C1, r1	; 0x8001c1 <__TEXT_REGION_LENGTH__+0x7001c1>

    NVM.ADDR1 = 0;
    2a32:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <__TEXT_REGION_LENGTH__+0x7001c2>
    NVM.ADDR2 = 0;
    2a36:	78 01       	movw	r14, r16
    2a38:	05 2d       	mov	r16, r5

    while (ByteCount > 0) {
    2a3a:	16 2d       	mov	r17, r6
    2a3c:	85 e3       	ldi	r24, 0x35	; 53

        if (ByteCount == 0 || ByteAddress >= EEPROM_PAGE_SIZE) {
            NVM.ADDR0 = PageAddress & 0xFF;
            NVM.ADDR1 = (PageAddress >> 8) & 0x1F;

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    2a3e:	48 2e       	mov	r4, r24
    2a40:	98 ed       	ldi	r25, 0xD8	; 216
// EEPROM functions

static inline void NVM_EXEC(void) {
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    2a42:	c9 2e       	mov	r12, r25
    2a44:	d1 2c       	mov	r13, r1
    2a46:	88 24       	eor	r8, r8
    2a48:	83 94       	inc	r8
    2a4a:	91 2c       	mov	r9, r1
    2a4c:	3b ec       	ldi	r19, 0xCB	; 203
    2a4e:	a3 2e       	mov	r10, r19
    2a50:	bb 24       	eor	r11, r11
    2a52:	b3 94       	inc	r11
    2a54:	43 e3       	ldi	r20, 0x33	; 51
            PageAddress += EEPROM_PAGE_SIZE;
            ByteAddress = 0;

            WaitForNVM();

            NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    2a56:	34 2e       	mov	r3, r20
    2a58:	01 15       	cp	r16, r1
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;

    NVM.ADDR1 = 0;
    NVM.ADDR2 = 0;

    while (ByteCount > 0) {
    2a5a:	11 05       	cpc	r17, r1
    2a5c:	01 f1       	breq	.+64     	; 0x2a9e <WriteEEPBlock+0xae>
    2a5e:	70 92 c0 01 	sts	0x01C0, r7	; 0x8001c0 <__TEXT_REGION_LENGTH__+0x7001c0>
        NVM.ADDR0 = ByteAddress;
    2a62:	f7 01       	movw	r30, r14

        NVM.DATA0 = *BytePtr++;
    2a64:	81 91       	ld	r24, Z+
    2a66:	7f 01       	movw	r14, r30
    2a68:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
    2a6c:	01 50       	subi	r16, 0x01	; 1

        ByteAddress++;
        ByteCount--;
    2a6e:	11 09       	sbc	r17, r1
    2a70:	21 f0       	breq	.+8      	; 0x2a7a <WriteEEPBlock+0x8a>

        if (ByteCount == 0 || ByteAddress >= EEPROM_PAGE_SIZE) {
    2a72:	73 94       	inc	r7
    while (ByteCount > 0) {
        NVM.ADDR0 = ByteAddress;

        NVM.DATA0 = *BytePtr++;

        ByteAddress++;
    2a74:	f0 e2       	ldi	r31, 0x20	; 32
        ByteCount--;

        if (ByteCount == 0 || ByteAddress >= EEPROM_PAGE_SIZE) {
    2a76:	7f 12       	cpse	r7, r31
    2a78:	ef cf       	rjmp	.-34     	; 0x2a58 <WriteEEPBlock+0x68>
    2a7a:	c0 93 c0 01 	sts	0x01C0, r28	; 0x8001c0 <__TEXT_REGION_LENGTH__+0x7001c0>
            NVM.ADDR0 = PageAddress & 0xFF;
    2a7e:	8d 2f       	mov	r24, r29
            NVM.ADDR1 = (PageAddress >> 8) & 0x1F;
    2a80:	8f 71       	andi	r24, 0x1F	; 31
    2a82:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <__TEXT_REGION_LENGTH__+0x7001c1>
    2a86:	40 92 ca 01 	sts	0x01CA, r4	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    2a8a:	c6 01       	movw	r24, r12
// EEPROM functions

static inline void NVM_EXEC(void) {
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    2a8c:	f5 01       	movw	r30, r10
    2a8e:	84 bf       	out	0x34, r24	; 52
    2a90:	80 82       	st	Z, r8
            NVM.ADDR1 = (PageAddress >> 8) & 0x1F;

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
            NVM_EXEC();

            PageAddress += EEPROM_PAGE_SIZE;
    2a92:	a0 96       	adiw	r28, 0x20	; 32
            ByteAddress = 0;

            WaitForNVM();
    2a94:	66 df       	rcall	.-308    	; 0x2962 <WaitForNVM>
    2a96:	30 92 ca 01 	sts	0x01CA, r3	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

            NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    2a9a:	71 2c       	mov	r7, r1

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
            NVM_EXEC();

            PageAddress += EEPROM_PAGE_SIZE;
            ByteAddress = 0;
    2a9c:	dd cf       	rjmp	.-70     	; 0x2a58 <WriteEEPBlock+0x68>
    2a9e:	85 2d       	mov	r24, r5

        BytesWritten++;
    }

    return BytesWritten;
}
    2aa0:	96 2d       	mov	r25, r6
    2aa2:	df 91       	pop	r29
    2aa4:	cf 91       	pop	r28
    2aa6:	1f 91       	pop	r17
    2aa8:	0f 91       	pop	r16
    2aaa:	ff 90       	pop	r15
    2aac:	ef 90       	pop	r14
    2aae:	df 90       	pop	r13
    2ab0:	cf 90       	pop	r12
    2ab2:	bf 90       	pop	r11
    2ab4:	af 90       	pop	r10
    2ab6:	9f 90       	pop	r9
    2ab8:	8f 90       	pop	r8
    2aba:	7f 90       	pop	r7
    2abc:	6f 90       	pop	r6
    2abe:	5f 90       	pop	r5
    2ac0:	4f 90       	pop	r4
    2ac2:	3f 90       	pop	r3
    2ac4:	08 95       	ret

00002ac6 <ExecuteButtonAction>:
    2ac6:	1f 93       	push	r17
    { .Id = BUTTON_ACTION_STORE_LOG,			.Text = "STORE_LOG" },
    { .Id = BUTTON_ACTION_CLONE,			.Text = "CLONE" },
    { .Id = BUTTON_ACTION_CLONE_MFU,			.Text = "CLONE_MFU" },
};

static void ExecuteButtonAction(ButtonActionEnum ButtonAction) {
    2ac8:	cf 93       	push	r28
    2aca:	df 93       	push	r29
    2acc:	cd b7       	in	r28, 0x3d	; 61
    2ace:	de b7       	in	r29, 0x3e	; 62
    2ad0:	a0 97       	sbiw	r28, 0x20	; 32
    2ad2:	cd bf       	out	0x3d, r28	; 61
    2ad4:	de bf       	out	0x3e, r29	; 62
    uint8_t UidBuffer[32];

    switch (ButtonAction) {
    2ad6:	86 30       	cpi	r24, 0x06	; 6
    2ad8:	09 f4       	brne	.+2      	; 0x2adc <ExecuteButtonAction+0x16>
    2ada:	f2 c0       	rjmp	.+484    	; 0x2cc0 <ExecuteButtonAction+0x1fa>
    2adc:	d8 f4       	brcc	.+54     	; 0x2b14 <ExecuteButtonAction+0x4e>
    2ade:	83 30       	cpi	r24, 0x03	; 3
    2ae0:	09 f4       	brne	.+2      	; 0x2ae4 <ExecuteButtonAction+0x1e>
    2ae2:	72 c0       	rjmp	.+228    	; 0x2bc8 <ExecuteButtonAction+0x102>
    2ae4:	30 f4       	brcc	.+12     	; 0x2af2 <ExecuteButtonAction+0x2c>
    2ae6:	81 30       	cpi	r24, 0x01	; 1
    2ae8:	61 f1       	breq	.+88     	; 0x2b42 <ExecuteButtonAction+0x7c>
    2aea:	82 30       	cpi	r24, 0x02	; 2
    2aec:	09 f4       	brne	.+2      	; 0x2af0 <ExecuteButtonAction+0x2a>
    2aee:	40 c0       	rjmp	.+128    	; 0x2b70 <ExecuteButtonAction+0xaa>
    2af0:	02 c1       	rjmp	.+516    	; 0x2cf6 <ExecuteButtonAction+0x230>
    2af2:	84 30       	cpi	r24, 0x04	; 4
    2af4:	09 f4       	brne	.+2      	; 0x2af8 <ExecuteButtonAction+0x32>
    2af6:	8d c0       	rjmp	.+282    	; 0x2c12 <ExecuteButtonAction+0x14c>
    2af8:	85 30       	cpi	r24, 0x05	; 5
    2afa:	09 f0       	breq	.+2      	; 0x2afe <ExecuteButtonAction+0x38>
    2afc:	fc c0       	rjmp	.+504    	; 0x2cf6 <ExecuteButtonAction+0x230>
    ActiveConfiguration.ApplicationResetFunc();
    //LogEntry(LOG_INFO_RESET_APP, NULL, 0);
}

INLINE void ApplicationGetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationGetUidFunc(Uid);
    2afe:	e0 91 cd 2f 	lds	r30, 0x2FCD	; 0x802fcd <ActiveConfiguration+0x10>
    2b02:	f0 91 ce 2f 	lds	r31, 0x2FCE	; 0x802fce <ActiveConfiguration+0x11>
    2b06:	ce 01       	movw	r24, r28
    2b08:	01 96       	adiw	r24, 0x01	; 1
    2b0a:	19 95       	eicall
        }

        case BUTTON_ACTION_UID_RIGHT_DECREMENT: {
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i = ActiveConfiguration.UidSize;
    2b0c:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
            break;
        }

        case BUTTON_ACTION_UID_RIGHT_DECREMENT: {
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
    2b10:	41 e0       	ldi	r20, 0x01	; 1
            uint8_t i = ActiveConfiguration.UidSize;

            while (i-- > 0) {
    2b12:	ab c0       	rjmp	.+342    	; 0x2c6a <ExecuteButtonAction+0x1a4>
};

static void ExecuteButtonAction(ButtonActionEnum ButtonAction) {
    uint8_t UidBuffer[32];

    switch (ButtonAction) {
    2b14:	89 30       	cpi	r24, 0x09	; 9
    2b16:	09 f4       	brne	.+2      	; 0x2b1a <ExecuteButtonAction+0x54>
    2b18:	d7 c0       	rjmp	.+430    	; 0x2cc8 <ExecuteButtonAction+0x202>
    2b1a:	40 f4       	brcc	.+16     	; 0x2b2c <ExecuteButtonAction+0x66>
    2b1c:	87 30       	cpi	r24, 0x07	; 7
    2b1e:	09 f4       	brne	.+2      	; 0x2b22 <ExecuteButtonAction+0x5c>
    2b20:	d1 c0       	rjmp	.+418    	; 0x2cc4 <ExecuteButtonAction+0x1fe>
    2b22:	88 30       	cpi	r24, 0x08	; 8
    2b24:	09 f0       	breq	.+2      	; 0x2b28 <ExecuteButtonAction+0x62>
    2b26:	e7 c0       	rjmp	.+462    	; 0x2cf6 <ExecuteButtonAction+0x230>
            MemoryStore();
            break;
        }

        case BUTTON_ACTION_RECALL_MEM: {
            MemoryRecall();
    2b28:	ee dc       	rcall	.-1572   	; 0x2506 <MemoryRecall>
            break;
    2b2a:	e5 c0       	rjmp	.+458    	; 0x2cf6 <ExecuteButtonAction+0x230>
};

static void ExecuteButtonAction(ButtonActionEnum ButtonAction) {
    uint8_t UidBuffer[32];

    switch (ButtonAction) {
    2b2c:	8b 30       	cpi	r24, 0x0B	; 11
    2b2e:	09 f4       	brne	.+2      	; 0x2b32 <ExecuteButtonAction+0x6c>
    2b30:	de c0       	rjmp	.+444    	; 0x2cee <ExecuteButtonAction+0x228>
    2b32:	08 f4       	brcc	.+2      	; 0x2b36 <ExecuteButtonAction+0x70>
    2b34:	da c0       	rjmp	.+436    	; 0x2cea <ExecuteButtonAction+0x224>
    2b36:	8c 30       	cpi	r24, 0x0C	; 12
    2b38:	09 f0       	breq	.+2      	; 0x2b3c <ExecuteButtonAction+0x76>
    2b3a:	dd c0       	rjmp	.+442    	; 0x2cf6 <ExecuteButtonAction+0x230>
        case BUTTON_ACTION_CLONE: {
            CommandExecute("CLONE");
            break;
        }
        case BUTTON_ACTION_CLONE_MFU: {
            CommandExecute("CLONE_MFU");
    2b3c:	8e ec       	ldi	r24, 0xCE	; 206
    2b3e:	93 e2       	ldi	r25, 0x23	; 35
    2b40:	d8 c0       	rjmp	.+432    	; 0x2cf2 <ExecuteButtonAction+0x22c>
};

static void ExecuteButtonAction(ButtonActionEnum ButtonAction) {
    uint8_t UidBuffer[32];

    switch (ButtonAction) {
    2b42:	10 e0       	ldi	r17, 0x00	; 0
        case BUTTON_ACTION_UID_RANDOM: {
            for (uint8_t i = 0; i < ActiveConfiguration.UidSize; i++) {
    2b44:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    2b48:	18 17       	cp	r17, r24
                UidBuffer[i] = RandomGetByte();
    2b4a:	50 f4       	brcc	.+20     	; 0x2b60 <ExecuteButtonAction+0x9a>
    2b4c:	6e db       	rcall	.-2340   	; 0x222a <RandomGetByte>
    2b4e:	e1 e0       	ldi	r30, 0x01	; 1
    2b50:	f0 e0       	ldi	r31, 0x00	; 0
    2b52:	ec 0f       	add	r30, r28
    2b54:	fd 1f       	adc	r31, r29
    2b56:	e1 0f       	add	r30, r17
    2b58:	f1 1d       	adc	r31, r1
    2b5a:	80 83       	st	Z, r24
static void ExecuteButtonAction(ButtonActionEnum ButtonAction) {
    uint8_t UidBuffer[32];

    switch (ButtonAction) {
        case BUTTON_ACTION_UID_RANDOM: {
            for (uint8_t i = 0; i < ActiveConfiguration.UidSize; i++) {
    2b5c:	1f 5f       	subi	r17, 0xFF	; 255
    2b5e:	f2 cf       	rjmp	.-28     	; 0x2b44 <ExecuteButtonAction+0x7e>
                UidBuffer[i] = RandomGetByte();
            }
            /* If we are using an ISO15 tag, the first byte needs to be E0 by standard */
            if (ActiveConfiguration.TagFamily == TAG_FAMILY_ISO15693) {
    2b60:	80 91 d5 2f 	lds	r24, 0x2FD5	; 0x802fd5 <ActiveConfiguration+0x18>
    2b64:	85 30       	cpi	r24, 0x05	; 5
    2b66:	09 f0       	breq	.+2      	; 0x2b6a <ExecuteButtonAction+0xa4>
    2b68:	98 c0       	rjmp	.+304    	; 0x2c9a <ExecuteButtonAction+0x1d4>
                UidBuffer[0] = 0xE0;
    2b6a:	80 ee       	ldi	r24, 0xE0	; 224
    2b6c:	89 83       	std	Y+1, r24	; 0x01
    2b6e:	95 c0       	rjmp	.+298    	; 0x2c9a <ExecuteButtonAction+0x1d4>
            ApplicationSetUid(UidBuffer);
            break;
        }

        case BUTTON_ACTION_UID_LEFT_INCREMENT: {
            uint8_t offset = 0;
    2b70:	11 e0       	ldi	r17, 0x01	; 1
    2b72:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    2b76:	87 30       	cpi	r24, 0x07	; 7
    2b78:	09 f0       	breq	.+2      	; 0x2b7c <ExecuteButtonAction+0xb6>
    2b7a:	10 e0       	ldi	r17, 0x00	; 0
    2b7c:	e0 91 cd 2f 	lds	r30, 0x2FCD	; 0x802fcd <ActiveConfiguration+0x10>
    2b80:	f0 91 ce 2f 	lds	r31, 0x2FCE	; 0x802fce <ActiveConfiguration+0x11>
    2b84:	ce 01       	movw	r24, r28
    2b86:	01 96       	adiw	r24, 0x01	; 1
    2b88:	19 95       	eicall
#endif
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i;

            for (i = offset; i < ActiveConfiguration.UidSize; i++) {
    2b8a:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
            if (ActiveConfiguration.UidSize == 7) {
                offset = 1;
            }
#endif
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
    2b8e:	31 e0       	ldi	r19, 0x01	; 1
            uint8_t i;

            for (i = offset; i < ActiveConfiguration.UidSize; i++) {
    2b90:	14 17       	cp	r17, r20
    2b92:	08 f0       	brcs	.+2      	; 0x2b96 <ExecuteButtonAction+0xd0>
    2b94:	82 c0       	rjmp	.+260    	; 0x2c9a <ExecuteButtonAction+0x1d4>
                if (Carry) {
    2b96:	33 23       	and	r19, r19
    2b98:	a9 f0       	breq	.+42     	; 0x2bc4 <ExecuteButtonAction+0xfe>
                    if (UidBuffer[i] == 0xFF) {
    2b9a:	81 2f       	mov	r24, r17
    2b9c:	90 e0       	ldi	r25, 0x00	; 0
    2b9e:	e1 e0       	ldi	r30, 0x01	; 1
    2ba0:	f0 e0       	ldi	r31, 0x00	; 0
    2ba2:	ec 0f       	add	r30, r28
    2ba4:	fd 1f       	adc	r31, r29
    2ba6:	e8 0f       	add	r30, r24
    2ba8:	f9 1f       	adc	r31, r25
    2baa:	20 81       	ld	r18, Z
    2bac:	31 e0       	ldi	r19, 0x01	; 1
    2bae:	2f 3f       	cpi	r18, 0xFF	; 255
    2bb0:	09 f0       	breq	.+2      	; 0x2bb4 <ExecuteButtonAction+0xee>
    2bb2:	30 e0       	ldi	r19, 0x00	; 0
                        Carry = 1;
                    } else {
                        Carry = 0;
                    }

                    UidBuffer[i] = (UidBuffer[i] + 1) & 0xFF;
    2bb4:	e1 e0       	ldi	r30, 0x01	; 1
    2bb6:	f0 e0       	ldi	r31, 0x00	; 0
    2bb8:	ec 0f       	add	r30, r28
    2bba:	fd 1f       	adc	r31, r29
    2bbc:	e8 0f       	add	r30, r24
    2bbe:	f9 1f       	adc	r31, r25
    2bc0:	2f 5f       	subi	r18, 0xFF	; 255
    2bc2:	20 83       	st	Z, r18
#endif
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i;

            for (i = offset; i < ActiveConfiguration.UidSize; i++) {
    2bc4:	1f 5f       	subi	r17, 0xFF	; 255
    2bc6:	e4 cf       	rjmp	.-56     	; 0x2b90 <ExecuteButtonAction+0xca>
    2bc8:	e0 91 cd 2f 	lds	r30, 0x2FCD	; 0x802fcd <ActiveConfiguration+0x10>
    2bcc:	f0 91 ce 2f 	lds	r31, 0x2FCE	; 0x802fce <ActiveConfiguration+0x11>
    2bd0:	ce 01       	movw	r24, r28
    2bd2:	01 96       	adiw	r24, 0x01	; 1
    2bd4:	19 95       	eicall
        }

        case BUTTON_ACTION_UID_RIGHT_INCREMENT: {
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i = ActiveConfiguration.UidSize;
    2bd6:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
            break;
        }

        case BUTTON_ACTION_UID_RIGHT_INCREMENT: {
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
    2bda:	41 e0       	ldi	r20, 0x01	; 1
            uint8_t i = ActiveConfiguration.UidSize;

            while (i-- > 0) {
    2bdc:	81 50       	subi	r24, 0x01	; 1
    2bde:	08 f4       	brcc	.+2      	; 0x2be2 <ExecuteButtonAction+0x11c>
    2be0:	5c c0       	rjmp	.+184    	; 0x2c9a <ExecuteButtonAction+0x1d4>
                if (Carry) {
    2be2:	44 23       	and	r20, r20
    2be4:	d9 f3       	breq	.-10     	; 0x2bdc <ExecuteButtonAction+0x116>
                    if (UidBuffer[i] == 0xFF) {
    2be6:	28 2f       	mov	r18, r24
    2be8:	30 e0       	ldi	r19, 0x00	; 0
    2bea:	e1 e0       	ldi	r30, 0x01	; 1
    2bec:	f0 e0       	ldi	r31, 0x00	; 0
    2bee:	ec 0f       	add	r30, r28
    2bf0:	fd 1f       	adc	r31, r29
    2bf2:	e2 0f       	add	r30, r18
    2bf4:	f3 1f       	adc	r31, r19
    2bf6:	90 81       	ld	r25, Z
    2bf8:	41 e0       	ldi	r20, 0x01	; 1
    2bfa:	9f 3f       	cpi	r25, 0xFF	; 255
    2bfc:	09 f0       	breq	.+2      	; 0x2c00 <ExecuteButtonAction+0x13a>
    2bfe:	40 e0       	ldi	r20, 0x00	; 0
                        Carry = 1;
                    } else {
                        Carry = 0;
                    }

                    UidBuffer[i] = (UidBuffer[i] + 1) & 0xFF;
    2c00:	e1 e0       	ldi	r30, 0x01	; 1
    2c02:	f0 e0       	ldi	r31, 0x00	; 0
    2c04:	ec 0f       	add	r30, r28
    2c06:	fd 1f       	adc	r31, r29
    2c08:	e2 0f       	add	r30, r18
    2c0a:	f3 1f       	adc	r31, r19
    2c0c:	9f 5f       	subi	r25, 0xFF	; 255
    2c0e:	90 83       	st	Z, r25
    2c10:	e5 cf       	rjmp	.-54     	; 0x2bdc <ExecuteButtonAction+0x116>
            ApplicationSetUid(UidBuffer);
            break;
        }

        case BUTTON_ACTION_UID_LEFT_DECREMENT: {
            uint8_t offset = 0;
    2c12:	11 e0       	ldi	r17, 0x01	; 1
    2c14:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    2c18:	87 30       	cpi	r24, 0x07	; 7
    2c1a:	09 f0       	breq	.+2      	; 0x2c1e <ExecuteButtonAction+0x158>
    2c1c:	10 e0       	ldi	r17, 0x00	; 0
    2c1e:	e0 91 cd 2f 	lds	r30, 0x2FCD	; 0x802fcd <ActiveConfiguration+0x10>
    2c22:	f0 91 ce 2f 	lds	r31, 0x2FCE	; 0x802fce <ActiveConfiguration+0x11>
    2c26:	ce 01       	movw	r24, r28
    2c28:	01 96       	adiw	r24, 0x01	; 1
    2c2a:	19 95       	eicall
#endif
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i;

            for (i = offset; i < ActiveConfiguration.UidSize; i++) {
    2c2c:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
            if (ActiveConfiguration.UidSize == 7) {
                offset = 1;
            }
#endif
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
    2c30:	31 e0       	ldi	r19, 0x01	; 1
            uint8_t i;

            for (i = offset; i < ActiveConfiguration.UidSize; i++) {
    2c32:	14 17       	cp	r17, r20
    2c34:	90 f5       	brcc	.+100    	; 0x2c9a <ExecuteButtonAction+0x1d4>
                if (Carry) {
    2c36:	33 23       	and	r19, r19
    2c38:	a1 f0       	breq	.+40     	; 0x2c62 <ExecuteButtonAction+0x19c>
                    if (UidBuffer[i] == 0x00) {
    2c3a:	81 2f       	mov	r24, r17
    2c3c:	90 e0       	ldi	r25, 0x00	; 0
    2c3e:	e1 e0       	ldi	r30, 0x01	; 1
    2c40:	f0 e0       	ldi	r31, 0x00	; 0
    2c42:	ec 0f       	add	r30, r28
    2c44:	fd 1f       	adc	r31, r29
    2c46:	e8 0f       	add	r30, r24
    2c48:	f9 1f       	adc	r31, r25
    2c4a:	20 81       	ld	r18, Z
    2c4c:	31 e0       	ldi	r19, 0x01	; 1
    2c4e:	21 11       	cpse	r18, r1
    2c50:	30 e0       	ldi	r19, 0x00	; 0
                        Carry = 1;
                    } else {
                        Carry = 0;
                    }

                    UidBuffer[i] = (UidBuffer[i] - 1) & 0xFF;
    2c52:	e1 e0       	ldi	r30, 0x01	; 1
    2c54:	f0 e0       	ldi	r31, 0x00	; 0
    2c56:	ec 0f       	add	r30, r28
    2c58:	fd 1f       	adc	r31, r29
    2c5a:	e8 0f       	add	r30, r24
    2c5c:	f9 1f       	adc	r31, r25
    2c5e:	21 50       	subi	r18, 0x01	; 1
    2c60:	20 83       	st	Z, r18
#endif
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i;

            for (i = offset; i < ActiveConfiguration.UidSize; i++) {
    2c62:	1f 5f       	subi	r17, 0xFF	; 255
    2c64:	e6 cf       	rjmp	.-52     	; 0x2c32 <ExecuteButtonAction+0x16c>
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i = ActiveConfiguration.UidSize;

            while (i-- > 0) {
                if (Carry) {
    2c66:	41 11       	cpse	r20, r1
    2c68:	03 c0       	rjmp	.+6      	; 0x2c70 <ExecuteButtonAction+0x1aa>
        case BUTTON_ACTION_UID_RIGHT_DECREMENT: {
            ApplicationGetUid(UidBuffer);
            bool Carry = 1;
            uint8_t i = ActiveConfiguration.UidSize;

            while (i-- > 0) {
    2c6a:	81 50       	subi	r24, 0x01	; 1
    2c6c:	e0 f7       	brcc	.-8      	; 0x2c66 <ExecuteButtonAction+0x1a0>
    2c6e:	15 c0       	rjmp	.+42     	; 0x2c9a <ExecuteButtonAction+0x1d4>
                if (Carry) {
                    if (UidBuffer[i] == 0x00) {
    2c70:	28 2f       	mov	r18, r24
    2c72:	30 e0       	ldi	r19, 0x00	; 0
    2c74:	e1 e0       	ldi	r30, 0x01	; 1
    2c76:	f0 e0       	ldi	r31, 0x00	; 0
    2c78:	ec 0f       	add	r30, r28
    2c7a:	fd 1f       	adc	r31, r29
    2c7c:	e2 0f       	add	r30, r18
    2c7e:	f3 1f       	adc	r31, r19
    2c80:	90 81       	ld	r25, Z
    2c82:	41 e0       	ldi	r20, 0x01	; 1
    2c84:	91 11       	cpse	r25, r1
    2c86:	40 e0       	ldi	r20, 0x00	; 0
                        Carry = 1;
                    } else {
                        Carry = 0;
                    }

                    UidBuffer[i] = (UidBuffer[i] - 1) & 0xFF;
    2c88:	e1 e0       	ldi	r30, 0x01	; 1
    2c8a:	f0 e0       	ldi	r31, 0x00	; 0
    2c8c:	ec 0f       	add	r30, r28
    2c8e:	fd 1f       	adc	r31, r29
    2c90:	e2 0f       	add	r30, r18
    2c92:	f3 1f       	adc	r31, r19
    2c94:	91 50       	subi	r25, 0x01	; 1
    2c96:	90 83       	st	Z, r25
    2c98:	e8 cf       	rjmp	.-48     	; 0x2c6a <ExecuteButtonAction+0x1a4>
}

INLINE void ApplicationSetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationSetUidFunc(Uid);
    2c9a:	e0 91 cf 2f 	lds	r30, 0x2FCF	; 0x802fcf <ActiveConfiguration+0x12>
    2c9e:	f0 91 d0 2f 	lds	r31, 0x2FD0	; 0x802fd0 <ActiveConfiguration+0x13>
    2ca2:	ce 01       	movw	r24, r28
    2ca4:	01 96       	adiw	r24, 0x01	; 1
    2ca6:	19 95       	eicall
    2ca8:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    2cac:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    2cb0:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    2cb4:	be 01       	movw	r22, r28
    2cb6:	6f 5f       	subi	r22, 0xFF	; 255
    2cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2cba:	83 e1       	ldi	r24, 0x13	; 19
    2cbc:	19 95       	eicall
            ApplicationSetUid(UidBuffer);
            break;
        }

        case BUTTON_ACTION_CYCLE_SETTINGS: {
            SettingsCycle();
    2cbe:	1b c0       	rjmp	.+54     	; 0x2cf6 <ExecuteButtonAction+0x230>
            break;
    2cc0:	b5 d3       	rcall	.+1898   	; 0x342c <SettingsCycle>
        }

        case BUTTON_ACTION_STORE_MEM: {
            MemoryStore();
    2cc2:	19 c0       	rjmp	.+50     	; 0x2cf6 <ExecuteButtonAction+0x230>
    2cc4:	c5 dc       	rcall	.-1654   	; 0x2650 <MemoryStore>
            break;
    2cc6:	17 c0       	rjmp	.+46     	; 0x2cf6 <ExecuteButtonAction+0x230>
    }
}

// Get the status of the reader field
INLINE bool CodecGetReaderField(void) {
    return (CODEC_READER_TIMER.CTRLA == TC_CLKSEL_DIV1_gc) && (AWEXC.OUTOVEN == CODEC_READER_MASK);
    2cc8:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    2ccc:	81 30       	cpi	r24, 0x01	; 1
    2cce:	21 f4       	brne	.+8      	; 0x2cd8 <ExecuteButtonAction+0x212>
    2cd0:	90 91 8c 08 	lds	r25, 0x088C	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>
    2cd4:	93 30       	cpi	r25, 0x03	; 3
    2cd6:	09 f0       	breq	.+2      	; 0x2cda <ExecuteButtonAction+0x214>
    2cd8:	80 e0       	ldi	r24, 0x00	; 0
            MemoryRecall();
            break;
        }

        case BUTTON_ACTION_TOGGLE_FIELD: {
            if (!CodecGetReaderField()) {
    2cda:	80 fd       	sbrc	r24, 0
    2cdc:	03 c0       	rjmp	.+6      	; 0x2ce4 <ExecuteButtonAction+0x21e>
                CodecReaderFieldStart();
    2cde:	0e 94 56 26 	call	0x4cac	; 0x4cac <CodecReaderFieldStart>
            } else {
                CodecReaderFieldStop();
    2ce2:	09 c0       	rjmp	.+18     	; 0x2cf6 <ExecuteButtonAction+0x230>
    2ce4:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <CodecReaderFieldStop>
            }
            break;
        }

        case BUTTON_ACTION_STORE_LOG: {
            LogSRAMToFRAM();
    2ce8:	06 c0       	rjmp	.+12     	; 0x2cf6 <ExecuteButtonAction+0x230>
    2cea:	af d2       	rcall	.+1374   	; 0x324a <LogSRAMToFRAM>
            break;
    2cec:	04 c0       	rjmp	.+8      	; 0x2cf6 <ExecuteButtonAction+0x230>
        }

        case BUTTON_ACTION_CLONE: {
            CommandExecute("CLONE");
    2cee:	88 ec       	ldi	r24, 0xC8	; 200
    2cf0:	93 e2       	ldi	r25, 0x23	; 35
            break;
        }
        case BUTTON_ACTION_CLONE_MFU: {
            CommandExecute("CLONE_MFU");
    2cf2:	0e 94 ad 24 	call	0x495a	; 0x495a <CommandExecute>

        default:
            break;

    }
}
    2cf6:	a0 96       	adiw	r28, 0x20	; 32
    2cf8:	cd bf       	out	0x3d, r28	; 61
    2cfa:	de bf       	out	0x3e, r29	; 62
    2cfc:	df 91       	pop	r29
    2cfe:	cf 91       	pop	r28
    2d00:	1f 91       	pop	r17
    2d02:	08 95       	ret

00002d04 <ButtonInit>:

void ButtonInit(void) {
    BUTTON_PORT.DIRCLR = BUTTON_MASK;
    2d04:	e0 e0       	ldi	r30, 0x00	; 0
    2d06:	f6 e0       	ldi	r31, 0x06	; 6
    2d08:	80 e6       	ldi	r24, 0x60	; 96
    2d0a:	82 83       	std	Z+2, r24	; 0x02
    BUTTON_PORT.BUTTON_R_PINCTRL = PORT_OPC_PULLUP_gc;
    2d0c:	88 e1       	ldi	r24, 0x18	; 24
    2d0e:	86 8b       	std	Z+22, r24	; 0x16
    BUTTON_PORT.BUTTON_L_PINCTRL = PORT_OPC_PULLUP_gc;
    2d10:	85 8b       	std	Z+21, r24	; 0x15
    2d12:	08 95       	ret

00002d14 <ButtonTick>:
}

void ButtonTick(void) {
    2d14:	cf 93       	push	r28
    static uint8_t ButtonRPressTick = 0;
    static uint8_t ButtonLPressTick = 0;
    uint8_t ThisButtonState = ~BUTTON_PORT.IN;
    2d16:	c0 91 08 06 	lds	r28, 0x0608	; 0x800608 <__TEXT_REGION_LENGTH__+0x700608>
    2d1a:	c0 95       	com	r28

    if (ThisButtonState & BUTTON_R) {
    2d1c:	c6 ff       	sbrs	r28, 6
    2d1e:	12 c0       	rjmp	.+36     	; 0x2d44 <ButtonTick+0x30>
        /* Button is currently pressed */
        if (ButtonRPressTick < LONG_PRESS_TICK_COUNT) {
    2d20:	80 91 8e 24 	lds	r24, 0x248E	; 0x80248e <ButtonRPressTick.7252>
    2d24:	8a 30       	cpi	r24, 0x0A	; 10
    2d26:	50 f0       	brcs	.+20     	; 0x2d3c <ButtonTick+0x28>
            /* Count ticks while button is being pressed */
            ButtonRPressTick++;
        } else if (ButtonRPressTick == LONG_PRESS_TICK_COUNT) {
    2d28:	8a 30       	cpi	r24, 0x0A	; 10
    2d2a:	e1 f4       	brne	.+56     	; 0x2d64 <ButtonTick+0x50>
            /* Long button press detected execute button action and advance PressTickCounter
             * to an invalid state. */
            ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_R_PRESS_LONG]);
    2d2c:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    2d30:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    2d34:	81 81       	ldd	r24, Z+1	; 0x01
    2d36:	c7 de       	rcall	.-626    	; 0x2ac6 <ExecuteButtonAction>
            ButtonRPressTick++;
    2d38:	80 91 8e 24 	lds	r24, 0x248E	; 0x80248e <ButtonRPressTick.7252>
    2d3c:	8f 5f       	subi	r24, 0xFF	; 255
    2d3e:	80 93 8e 24 	sts	0x248E, r24	; 0x80248e <ButtonRPressTick.7252>
    2d42:	10 c0       	rjmp	.+32     	; 0x2d64 <ButtonTick+0x50>
        } else {
            /* Button is still pressed, ignore */
        }
    } else if (!(ThisButtonState & BUTTON_MASK)) {
    2d44:	8c 2f       	mov	r24, r28
    2d46:	80 76       	andi	r24, 0x60	; 96
    2d48:	69 f4       	brne	.+26     	; 0x2d64 <ButtonTick+0x50>
        /* Button is currently not being pressed. Check if PressTickCounter contains
         * a recent short button press. */
        if ((ButtonRPressTick > 0) && (ButtonRPressTick <= LONG_PRESS_TICK_COUNT)) {
    2d4a:	80 91 8e 24 	lds	r24, 0x248E	; 0x80248e <ButtonRPressTick.7252>
    2d4e:	81 50       	subi	r24, 0x01	; 1
    2d50:	8a 30       	cpi	r24, 0x0A	; 10
    2d52:	30 f4       	brcc	.+12     	; 0x2d60 <ButtonTick+0x4c>
            /* We have a short button press */
            ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_R_PRESS_SHORT]);
    2d54:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    2d58:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    2d5c:	80 81       	ld	r24, Z
    2d5e:	b3 de       	rcall	.-666    	; 0x2ac6 <ExecuteButtonAction>
        }

        ButtonRPressTick = 0;
    2d60:	10 92 8e 24 	sts	0x248E, r1	; 0x80248e <ButtonRPressTick.7252>
    }

    if (ThisButtonState & BUTTON_L) {
    2d64:	c5 ff       	sbrs	r28, 5
    2d66:	12 c0       	rjmp	.+36     	; 0x2d8c <ButtonTick+0x78>
        /* Button is currently pressed */
        if (ButtonLPressTick < LONG_PRESS_TICK_COUNT) {
    2d68:	80 91 8d 24 	lds	r24, 0x248D	; 0x80248d <ButtonLPressTick.7253>
    2d6c:	8a 30       	cpi	r24, 0x0A	; 10
    2d6e:	50 f0       	brcs	.+20     	; 0x2d84 <ButtonTick+0x70>
            /* Count ticks while button is being pressed */
            ButtonLPressTick++;
        } else if (ButtonLPressTick == LONG_PRESS_TICK_COUNT) {
    2d70:	8a 30       	cpi	r24, 0x0A	; 10
    2d72:	d9 f4       	brne	.+54     	; 0x2daa <ButtonTick+0x96>
            /* Long button press detected execute button action and advance PressTickCounter
             * to an invalid state. */
            ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_L_PRESS_LONG]);
    2d74:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    2d78:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    2d7c:	83 81       	ldd	r24, Z+3	; 0x03
    2d7e:	a3 de       	rcall	.-698    	; 0x2ac6 <ExecuteButtonAction>
            ButtonLPressTick++;
    2d80:	80 91 8d 24 	lds	r24, 0x248D	; 0x80248d <ButtonLPressTick.7253>
    2d84:	8f 5f       	subi	r24, 0xFF	; 255
    2d86:	80 93 8d 24 	sts	0x248D, r24	; 0x80248d <ButtonLPressTick.7253>
    2d8a:	0f c0       	rjmp	.+30     	; 0x2daa <ButtonTick+0x96>
        } else {
            /* Button is still pressed, ignore */
        }
    } else if (!(ThisButtonState & BUTTON_MASK)) {
    2d8c:	c0 76       	andi	r28, 0x60	; 96
    2d8e:	69 f4       	brne	.+26     	; 0x2daa <ButtonTick+0x96>
        /* Button is currently not being pressed. Check if PressTickCounter contains
         * a recent short button press. */
        if ((ButtonLPressTick > 0) && (ButtonLPressTick <= LONG_PRESS_TICK_COUNT)) {
    2d90:	80 91 8d 24 	lds	r24, 0x248D	; 0x80248d <ButtonLPressTick.7253>
    2d94:	81 50       	subi	r24, 0x01	; 1
    2d96:	8a 30       	cpi	r24, 0x0A	; 10
    2d98:	30 f4       	brcc	.+12     	; 0x2da6 <ButtonTick+0x92>
            /* We have a short button press */
            ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_L_PRESS_SHORT]);
    2d9a:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    2d9e:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    2da2:	82 81       	ldd	r24, Z+2	; 0x02
    2da4:	90 de       	rcall	.-736    	; 0x2ac6 <ExecuteButtonAction>
        }

        ButtonLPressTick = 0;
    2da6:	10 92 8d 24 	sts	0x248D, r1	; 0x80248d <ButtonLPressTick.7253>
    }
}
    2daa:	cf 91       	pop	r28
    2dac:	08 95       	ret

00002dae <ButtonGetActionList>:

void ButtonGetActionList(char *List, uint16_t BufferSize) {
    2dae:	9b 01       	movw	r18, r22
    MapToString(ButtonActionMap, ARRAY_COUNT(ButtonActionMap), List, BufferSize);
    2db0:	ac 01       	movw	r20, r24
    2db2:	6d e0       	ldi	r22, 0x0D	; 13
    2db4:	86 ef       	ldi	r24, 0xF6	; 246
    2db6:	98 e0       	ldi	r25, 0x08	; 8
    2db8:	8b c4       	rjmp	.+2326   	; 0x36d0 <MapToString>

00002dba <ButtonSetActionById>:
}

void ButtonSetActionById(ButtonTypeEnum Type, ButtonActionEnum Action) {
    2dba:	e8 2f       	mov	r30, r24
    2dbc:	f0 e0       	ldi	r31, 0x00	; 0
    2dbe:	e8 52       	subi	r30, 0x28	; 40
    2dc0:	f0 4d       	sbci	r31, 0xD0	; 208
    2dc2:	88 e0       	ldi	r24, 0x08	; 8
#ifndef BUTTON_SETTING_GLOBAL
    GlobalSettings.ActiveSettingPtr->ButtonActions[Type] = Action;
#else
    /* Write button action to all settings when using global settings */
    for (uint8_t i = 0; i < SETTINGS_COUNT; i++) {
        GlobalSettings.Settings[i].ButtonActions[Type] = Action;
    2dc4:	63 83       	std	Z+3, r22	; 0x03
    2dc6:	81 50       	subi	r24, 0x01	; 1
    2dc8:	3c 96       	adiw	r30, 0x0c	; 12
void ButtonSetActionById(ButtonTypeEnum Type, ButtonActionEnum Action) {
#ifndef BUTTON_SETTING_GLOBAL
    GlobalSettings.ActiveSettingPtr->ButtonActions[Type] = Action;
#else
    /* Write button action to all settings when using global settings */
    for (uint8_t i = 0; i < SETTINGS_COUNT; i++) {
    2dca:	81 11       	cpse	r24, r1
    2dcc:	fb cf       	rjmp	.-10     	; 0x2dc4 <ButtonSetActionById+0xa>
        GlobalSettings.Settings[i].ButtonActions[Type] = Action;
    }
#endif
}
    2dce:	08 95       	ret

00002dd0 <ButtonGetActionByName>:

void ButtonGetActionByName(ButtonTypeEnum Type, char *Action, uint16_t BufferSize) {
    2dd0:	0f 93       	push	r16
    2dd2:	1f 93       	push	r17
    2dd4:	9b 01       	movw	r18, r22
    MapIdToText(ButtonActionMap, ARRAY_COUNT(ButtonActionMap),
                GlobalSettings.ActiveSettingPtr->ButtonActions[Type], Action, BufferSize);
    2dd6:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    2dda:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    2dde:	e8 0f       	add	r30, r24
    2de0:	f1 1d       	adc	r31, r1
    }
#endif
}

void ButtonGetActionByName(ButtonTypeEnum Type, char *Action, uint16_t BufferSize) {
    MapIdToText(ButtonActionMap, ARRAY_COUNT(ButtonActionMap),
    2de2:	8a 01       	movw	r16, r20
    2de4:	40 81       	ld	r20, Z
    2de6:	6d e0       	ldi	r22, 0x0D	; 13
    2de8:	86 ef       	ldi	r24, 0xF6	; 246
    2dea:	98 e0       	ldi	r25, 0x08	; 8
    2dec:	32 d4       	rcall	.+2148   	; 0x3652 <MapIdToText>
                GlobalSettings.ActiveSettingPtr->ButtonActions[Type], Action, BufferSize);
}
    2dee:	1f 91       	pop	r17
    2df0:	0f 91       	pop	r16
    2df2:	08 95       	ret

00002df4 <ButtonSetActionByName>:

bool ButtonSetActionByName(ButtonTypeEnum Type, const char *Action) {
    2df4:	0f 93       	push	r16
    2df6:	1f 93       	push	r17
    2df8:	cf 93       	push	r28
    2dfa:	df 93       	push	r29
    2dfc:	1f 92       	push	r1
    2dfe:	cd b7       	in	r28, 0x3d	; 61
    2e00:	de b7       	in	r29, 0x3e	; 62
    2e02:	08 2f       	mov	r16, r24
    2e04:	ab 01       	movw	r20, r22
    MapIdType Id;

    if (MapTextToId(ButtonActionMap, ARRAY_COUNT(ButtonActionMap), Action, &Id)) {
    2e06:	9e 01       	movw	r18, r28
    2e08:	2f 5f       	subi	r18, 0xFF	; 255
    2e0a:	3f 4f       	sbci	r19, 0xFF	; 255
    2e0c:	6d e0       	ldi	r22, 0x0D	; 13
    2e0e:	86 ef       	ldi	r24, 0xF6	; 246
    2e10:	98 e0       	ldi	r25, 0x08	; 8
    2e12:	37 d4       	rcall	.+2158   	; 0x3682 <MapTextToId>
    2e14:	18 2f       	mov	r17, r24
    2e16:	88 23       	and	r24, r24
    2e18:	19 f0       	breq	.+6      	; 0x2e20 <ButtonSetActionByName+0x2c>
        ButtonSetActionById(Type, Id);
    2e1a:	69 81       	ldd	r22, Y+1	; 0x01
    2e1c:	80 2f       	mov	r24, r16
    2e1e:	cd df       	rcall	.-102    	; 0x2dba <ButtonSetActionById>
        return true;
    } else {
        return false;
    }
}
    2e20:	81 2f       	mov	r24, r17
    2e22:	0f 90       	pop	r0
    2e24:	df 91       	pop	r29
    2e26:	cf 91       	pop	r28
    2e28:	1f 91       	pop	r17
    2e2a:	0f 91       	pop	r16
    2e2c:	08 95       	ret

00002e2e <LogFuncOff>:
    { .Id = LOG_MODE_OFF, 		.Text = "OFF" 		},
    { .Id = LOG_MODE_MEMORY, 	.Text = "MEMORY" 	},
    { .Id = LOG_MODE_LIVE, 	.Text = "LIVE" 	}
};

static void LogFuncOff(LogEntryEnum Entry, const void *Data, uint8_t Length) {
    2e2e:	08 95       	ret

00002e30 <LogFuncLive>:
        LogSetModeById(LOG_MODE_OFF);
        LEDHook(LED_LOG_MEM_FULL, LED_ON);
    }
}

static void LogFuncLive(LogEntryEnum Entry, const void *Data, uint8_t Length) {
    2e30:	ef 92       	push	r14
    2e32:	ff 92       	push	r15
    2e34:	0f 93       	push	r16
    2e36:	1f 93       	push	r17
    2e38:	cf 93       	push	r28
    2e3a:	7b 01       	movw	r14, r22
    2e3c:	c4 2f       	mov	r28, r20
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    2e3e:	0e b1       	in	r16, 0x0e	; 14
    2e40:	1f b1       	in	r17, 0x0f	; 15
    2e42:	20 91 08 04 	lds	r18, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    2e46:	30 91 09 04 	lds	r19, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    2e4a:	02 2b       	or	r16, r18
    2e4c:	13 2b       	or	r17, r19
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
INLINE void TerminalSendByte(uint8_t Byte) { CDC_Device_SendByte(&TerminalHandle, Byte); }
    2e4e:	68 2f       	mov	r22, r24
    2e50:	83 e0       	ldi	r24, 0x03	; 3
    2e52:	90 e2       	ldi	r25, 0x20	; 32
    2e54:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    2e58:	6c 2f       	mov	r22, r28
    2e5a:	83 e0       	ldi	r24, 0x03	; 3
    2e5c:	90 e2       	ldi	r25, 0x20	; 32
    2e5e:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    2e62:	61 2f       	mov	r22, r17
    2e64:	83 e0       	ldi	r24, 0x03	; 3
    2e66:	90 e2       	ldi	r25, 0x20	; 32
    2e68:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    2e6c:	60 2f       	mov	r22, r16
    2e6e:	83 e0       	ldi	r24, 0x03	; 3
    2e70:	90 e2       	ldi	r25, 0x20	; 32
    2e72:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>

    TerminalSendByte((uint8_t) Entry);
    TerminalSendByte((uint8_t) Length);
    TerminalSendByte((uint8_t)(SysTick >> 8));
    TerminalSendByte((uint8_t)(SysTick >> 0));
    TerminalSendBlock(Data, Length);
    2e76:	6c 2f       	mov	r22, r28
    2e78:	70 e0       	ldi	r23, 0x00	; 0
    2e7a:	c7 01       	movw	r24, r14
}
    2e7c:	cf 91       	pop	r28
    2e7e:	1f 91       	pop	r17
    2e80:	0f 91       	pop	r16
    2e82:	ff 90       	pop	r15
    2e84:	ef 90       	pop	r14

    TerminalSendByte((uint8_t) Entry);
    TerminalSendByte((uint8_t) Length);
    TerminalSendByte((uint8_t)(SysTick >> 8));
    TerminalSendByte((uint8_t)(SysTick >> 0));
    TerminalSendBlock(Data, Length);
    2e86:	a4 c4       	rjmp	.+2376   	; 0x37d0 <TerminalSendBlock>

00002e88 <LogTask>:
void LogTick(void) {
    if (EnableLogSRAMtoFRAM)
        LogSRAMToFRAM();
}

void LogTask(void) {
    2e88:	08 95       	ret

00002e8a <LogMemLoadBlock>:

}

bool LogMemLoadBlock(void *Buffer, uint32_t BlockAddress, uint16_t ByteCount) {
    2e8a:	3f 92       	push	r3
    2e8c:	4f 92       	push	r4
    2e8e:	5f 92       	push	r5
    2e90:	6f 92       	push	r6
    2e92:	7f 92       	push	r7
    2e94:	8f 92       	push	r8
    2e96:	9f 92       	push	r9
    2e98:	af 92       	push	r10
    2e9a:	bf 92       	push	r11
    2e9c:	cf 92       	push	r12
    2e9e:	df 92       	push	r13
    2ea0:	ef 92       	push	r14
    2ea2:	ff 92       	push	r15
    2ea4:	0f 93       	push	r16
    2ea6:	1f 93       	push	r17
    2ea8:	cf 93       	push	r28
    2eaa:	df 93       	push	r29
    2eac:	7c 01       	movw	r14, r24
    2eae:	e9 01       	movw	r28, r18
    if (BlockAddress < sizeof(LogMem) + (LogFRAMAddr - FRAM_LOG_START_ADDR)) {
    2eb0:	c0 90 00 20 	lds	r12, 0x2000	; 0x802000 <__data_start>
    2eb4:	d0 90 01 20 	lds	r13, 0x2001	; 0x802001 <__data_start+0x1>
    2eb8:	96 01       	movw	r18, r12
    2eba:	22 50       	subi	r18, 0x02	; 2
    2ebc:	38 43       	sbci	r19, 0x38	; 56
    2ebe:	c9 01       	movw	r24, r18
    2ec0:	a0 e0       	ldi	r26, 0x00	; 0
    2ec2:	b0 e0       	ldi	r27, 0x00	; 0
    2ec4:	48 17       	cp	r20, r24
    2ec6:	59 07       	cpc	r21, r25
    2ec8:	6a 07       	cpc	r22, r26
    2eca:	7b 07       	cpc	r23, r27
    2ecc:	08 f0       	brcs	.+2      	; 0x2ed0 <LogMemLoadBlock+0x46>
    2ece:	5f c0       	rjmp	.+190    	; 0x2f8e <LogMemLoadBlock+0x104>
        bool overflow = false;
        uint16_t remainderByteCount = 0;
        uint16_t SizeInFRAMStored = LogFRAMAddr - FRAM_LOG_START_ADDR;
    2ed0:	e2 e0       	ldi	r30, 0x02	; 2
    2ed2:	ce 1a       	sub	r12, r30
    2ed4:	e0 e4       	ldi	r30, 0x40	; 64
    2ed6:	de 0a       	sbc	r13, r30
        // prevent buffer overflows:
        if ((BlockAddress + ByteCount) >= sizeof(LogMem) + SizeInFRAMStored) {
    2ed8:	2a 01       	movw	r4, r20
    2eda:	3b 01       	movw	r6, r22
    2edc:	4c 0e       	add	r4, r28
    2ede:	5d 1e       	adc	r5, r29
    2ee0:	61 1c       	adc	r6, r1
    2ee2:	71 1c       	adc	r7, r1
    2ee4:	48 16       	cp	r4, r24
    2ee6:	59 06       	cpc	r5, r25
    2ee8:	6a 06       	cpc	r6, r26
    2eea:	7b 06       	cpc	r7, r27
    2eec:	48 f0       	brcs	.+18     	; 0x2f00 <LogMemLoadBlock+0x76>
            overflow = true;
            uint16_t tmp = sizeof(LogMem) + SizeInFRAMStored - BlockAddress;
    2eee:	24 1b       	sub	r18, r20
    2ef0:	35 0b       	sbc	r19, r21
            remainderByteCount = ByteCount - tmp;
    2ef2:	8e 01       	movw	r16, r28
    2ef4:	02 1b       	sub	r16, r18
    2ef6:	13 0b       	sbc	r17, r19
            ByteCount = tmp;
    2ef8:	e9 01       	movw	r28, r18
        bool overflow = false;
        uint16_t remainderByteCount = 0;
        uint16_t SizeInFRAMStored = LogFRAMAddr - FRAM_LOG_START_ADDR;
        // prevent buffer overflows:
        if ((BlockAddress + ByteCount) >= sizeof(LogMem) + SizeInFRAMStored) {
            overflow = true;
    2efa:	33 24       	eor	r3, r3
    2efc:	33 94       	inc	r3
    2efe:	03 c0       	rjmp	.+6      	; 0x2f06 <LogMemLoadBlock+0x7c>
}

bool LogMemLoadBlock(void *Buffer, uint32_t BlockAddress, uint16_t ByteCount) {
    if (BlockAddress < sizeof(LogMem) + (LogFRAMAddr - FRAM_LOG_START_ADDR)) {
        bool overflow = false;
        uint16_t remainderByteCount = 0;
    2f00:	00 e0       	ldi	r16, 0x00	; 0
    2f02:	10 e0       	ldi	r17, 0x00	; 0

}

bool LogMemLoadBlock(void *Buffer, uint32_t BlockAddress, uint16_t ByteCount) {
    if (BlockAddress < sizeof(LogMem) + (LogFRAMAddr - FRAM_LOG_START_ADDR)) {
        bool overflow = false;
    2f04:	31 2c       	mov	r3, r1
        /*
         * 1. case: The whole block is in FRAM.
         * 2. case: The block wraps from FRAM to SRAM
         * 3. case: The whole block is in SRAM.
         */
        if (BlockAddress < SizeInFRAMStored && (BlockAddress + ByteCount) < SizeInFRAMStored) {
    2f06:	46 01       	movw	r8, r12
    2f08:	a1 2c       	mov	r10, r1
    2f0a:	b1 2c       	mov	r11, r1
    2f0c:	48 15       	cp	r20, r8
    2f0e:	59 05       	cpc	r21, r9
    2f10:	6a 05       	cpc	r22, r10
    2f12:	7b 05       	cpc	r23, r11
    2f14:	10 f5       	brcc	.+68     	; 0x2f5a <LogMemLoadBlock+0xd0>
    2f16:	ca 01       	movw	r24, r20
    2f18:	8e 5f       	subi	r24, 0xFE	; 254
    2f1a:	9f 4b       	sbci	r25, 0xBF	; 191
    2f1c:	2a 01       	movw	r4, r20
    2f1e:	3b 01       	movw	r6, r22
    2f20:	4c 0e       	add	r4, r28
    2f22:	5d 1e       	adc	r5, r29
    2f24:	61 1c       	adc	r6, r1
    2f26:	71 1c       	adc	r7, r1
    2f28:	48 14       	cp	r4, r8
    2f2a:	59 04       	cpc	r5, r9
    2f2c:	6a 04       	cpc	r6, r10
    2f2e:	7b 04       	cpc	r7, r11
    2f30:	28 f4       	brcc	.+10     	; 0x2f3c <LogMemLoadBlock+0xb2>
            MemoryReadBlock(Buffer, BlockAddress + FRAM_LOG_START_ADDR, ByteCount);
    2f32:	ae 01       	movw	r20, r28
    2f34:	bc 01       	movw	r22, r24
    2f36:	c7 01       	movw	r24, r14
    2f38:	2a da       	rcall	.-2988   	; 0x238e <MemoryReadBlock>
    2f3a:	18 c0       	rjmp	.+48     	; 0x2f6c <LogMemLoadBlock+0xe2>
        } else if (BlockAddress < SizeInFRAMStored) {
            uint16_t FramByteCount = SizeInFRAMStored - BlockAddress;
    2f3c:	c4 1a       	sub	r12, r20
    2f3e:	d5 0a       	sbc	r13, r21
            MemoryReadBlock(Buffer, BlockAddress + FRAM_LOG_START_ADDR, FramByteCount);
    2f40:	a6 01       	movw	r20, r12
    2f42:	bc 01       	movw	r22, r24
    2f44:	c7 01       	movw	r24, r14
    2f46:	23 da       	rcall	.-3002   	; 0x238e <MemoryReadBlock>
            memcpy(Buffer + FramByteCount, LogMem, ByteCount - FramByteCount);
    2f48:	ae 01       	movw	r20, r28
    2f4a:	4c 19       	sub	r20, r12
    2f4c:	5d 09       	sbc	r21, r13
    2f4e:	64 e9       	ldi	r22, 0x94	; 148
    2f50:	74 e2       	ldi	r23, 0x24	; 36
    2f52:	c7 01       	movw	r24, r14
    2f54:	8c 0d       	add	r24, r12
    2f56:	9d 1d       	adc	r25, r13
    2f58:	07 c0       	rjmp	.+14     	; 0x2f68 <LogMemLoadBlock+0xde>
        } else {
            memcpy(Buffer, LogMem + BlockAddress - SizeInFRAMStored, ByteCount);
    2f5a:	4c 19       	sub	r20, r12
    2f5c:	5d 09       	sbc	r21, r13
    2f5e:	ba 01       	movw	r22, r20
    2f60:	6c 56       	subi	r22, 0x6C	; 108
    2f62:	7b 4d       	sbci	r23, 0xDB	; 219
    2f64:	ae 01       	movw	r20, r28
    2f66:	c7 01       	movw	r24, r14
    2f68:	0e 94 a0 78 	call	0xf140	; 0xf140 <memcpy>
        }

        if (overflow) {
    2f6c:	33 20       	and	r3, r3
    2f6e:	41 f0       	breq	.+16     	; 0x2f80 <LogMemLoadBlock+0xf6>
    2f70:	0c 0f       	add	r16, r28
    2f72:	1d 1f       	adc	r17, r29
    2f74:	f7 01       	movw	r30, r14
    2f76:	e0 0f       	add	r30, r16
    2f78:	f1 1f       	adc	r31, r17
    2f7a:	ce 0d       	add	r28, r14
    2f7c:	df 1d       	adc	r29, r15
    2f7e:	02 c0       	rjmp	.+4      	; 0x2f84 <LogMemLoadBlock+0xfa>
            while (remainderByteCount--)
                ((uint8_t *) Buffer)[ByteCount + remainderByteCount] = 0x00;
        }

        return true;
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	06 c0       	rjmp	.+12     	; 0x2f90 <LogMemLoadBlock+0x106>
        } else {
            memcpy(Buffer, LogMem + BlockAddress - SizeInFRAMStored, ByteCount);
        }

        if (overflow) {
            while (remainderByteCount--)
    2f84:	ec 17       	cp	r30, r28
    2f86:	fd 07       	cpc	r31, r29
    2f88:	d9 f3       	breq	.-10     	; 0x2f80 <LogMemLoadBlock+0xf6>
                ((uint8_t *) Buffer)[ByteCount + remainderByteCount] = 0x00;
    2f8a:	12 92       	st	-Z, r1
    2f8c:	fb cf       	rjmp	.-10     	; 0x2f84 <LogMemLoadBlock+0xfa>
        }

        return true;
    } else {
        return false;
    2f8e:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    2f90:	df 91       	pop	r29
    2f92:	cf 91       	pop	r28
    2f94:	1f 91       	pop	r17
    2f96:	0f 91       	pop	r16
    2f98:	ff 90       	pop	r15
    2f9a:	ef 90       	pop	r14
    2f9c:	df 90       	pop	r13
    2f9e:	cf 90       	pop	r12
    2fa0:	bf 90       	pop	r11
    2fa2:	af 90       	pop	r10
    2fa4:	9f 90       	pop	r9
    2fa6:	8f 90       	pop	r8
    2fa8:	7f 90       	pop	r7
    2faa:	6f 90       	pop	r6
    2fac:	5f 90       	pop	r5
    2fae:	4f 90       	pop	r4
    2fb0:	3f 90       	pop	r3
    2fb2:	08 95       	ret

00002fb4 <LogMemClear>:

INLINE void LogSRAMClear(void) {
    uint16_t i, until = LOG_SIZE - LogMemLeft;
    2fb4:	20 91 90 24 	lds	r18, 0x2490	; 0x802490 <LogMemLeft>
    2fb8:	30 91 91 24 	lds	r19, 0x2491	; 0x802491 <LogMemLeft+0x1>
    2fbc:	80 e0       	ldi	r24, 0x00	; 0
    2fbe:	98 e0       	ldi	r25, 0x08	; 8
    2fc0:	82 1b       	sub	r24, r18
    2fc2:	93 0b       	sbc	r25, r19
    2fc4:	e4 e9       	ldi	r30, 0x94	; 148
    2fc6:	f4 e2       	ldi	r31, 0x24	; 36

    for (i = 0; i < until; i++) {
    2fc8:	9f 01       	movw	r18, r30
    2fca:	24 59       	subi	r18, 0x94	; 148
    2fcc:	34 42       	sbci	r19, 0x24	; 36
    2fce:	28 17       	cp	r18, r24
    2fd0:	39 07       	cpc	r19, r25
    2fd2:	10 f4       	brcc	.+4      	; 0x2fd8 <LogMemClear+0x24>
        LogMem[i] = (uint8_t) LOG_EMPTY;
    2fd4:	11 92       	st	Z+, r1
    2fd6:	f8 cf       	rjmp	.-16     	; 0x2fc8 <LogMemClear+0x14>
    }

    LogMemPtr = LogMem;
    2fd8:	84 e9       	ldi	r24, 0x94	; 148
    2fda:	94 e2       	ldi	r25, 0x24	; 36
    2fdc:	80 93 92 24 	sts	0x2492, r24	; 0x802492 <LogMemPtr>
    2fe0:	90 93 93 24 	sts	0x2493, r25	; 0x802493 <LogMemPtr+0x1>
    LogMemLeft = sizeof(LogMem);
    2fe4:	80 e0       	ldi	r24, 0x00	; 0
    2fe6:	98 e0       	ldi	r25, 0x08	; 8
    2fe8:	80 93 90 24 	sts	0x2490, r24	; 0x802490 <LogMemLeft>
    2fec:	90 93 91 24 	sts	0x2491, r25	; 0x802491 <LogMemLeft+0x1>
}

void LogMemClear(void) {
    LogSRAMClear();
    LogFRAMAddr = FRAM_LOG_START_ADDR;
    2ff0:	82 e0       	ldi	r24, 0x02	; 2
    2ff2:	90 e4       	ldi	r25, 0x40	; 64
    2ff4:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    2ff8:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    2ffc:	42 e0       	ldi	r20, 0x02	; 2
    2ffe:	50 e0       	ldi	r21, 0x00	; 0
    3000:	60 e0       	ldi	r22, 0x00	; 0
    3002:	70 e4       	ldi	r23, 0x40	; 64
    3004:	80 e0       	ldi	r24, 0x00	; 0
    3006:	90 e2       	ldi	r25, 0x20	; 32
    3008:	10 da       	rcall	.-3040   	; 0x242a <MemoryWriteBlock>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    300a:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    300e:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    3012:	87 81       	ldd	r24, Z+7	; 0x07
    3014:	8a 30       	cpi	r24, 0x0A	; 10
    3016:	19 f4       	brne	.+6      	; 0x301e <LogMemClear+0x6a>
        LEDGreenAction = Action;
    3018:	80 e1       	ldi	r24, 0x10	; 16
    301a:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    301e:	86 81       	ldd	r24, Z+6	; 0x06
    3020:	8a 30       	cpi	r24, 0x0A	; 10
    3022:	19 f4       	brne	.+6      	; 0x302a <LogMemClear+0x76>
        LEDRedAction = Action;
    3024:	80 e1       	ldi	r24, 0x10	; 16
    3026:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    302a:	08 95       	ret

0000302c <LogMemFree>:
    LEDHook(LED_LOG_MEM_FULL, LED_OFF);
}

uint16_t LogMemFree(void) {
    return LogMemLeft + FRAM_LOG_SIZE - LogFRAMAddr + FRAM_LOG_START_ADDR;
    302c:	80 91 90 24 	lds	r24, 0x2490	; 0x802490 <LogMemLeft>
    3030:	90 91 91 24 	lds	r25, 0x2491	; 0x802491 <LogMemLeft+0x1>
    3034:	90 58       	subi	r25, 0x80	; 128
    3036:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    303a:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
}
    303e:	82 1b       	sub	r24, r18
    3040:	93 0b       	sbc	r25, r19
    3042:	08 95       	ret

00003044 <LogSetModeById>:


void LogSetModeById(LogModeEnum Mode) {
    3044:	e8 ed       	ldi	r30, 0xD8	; 216
    3046:	ff e2       	ldi	r31, 0x2F	; 47
#ifndef LOG_SETTING_GLOBAL
    GlobalSettings.ActiveSettingPtr->LogMode = Mode;
#else
    /* Write Log settings globally */
    for (uint8_t i = 0; i < SETTINGS_COUNT; i++) {
        GlobalSettings.Settings[i].LogMode = Mode;
    3048:	87 83       	std	Z+7, r24	; 0x07
    304a:	3c 96       	adiw	r30, 0x0c	; 12
void LogSetModeById(LogModeEnum Mode) {
#ifndef LOG_SETTING_GLOBAL
    GlobalSettings.ActiveSettingPtr->LogMode = Mode;
#else
    /* Write Log settings globally */
    for (uint8_t i = 0; i < SETTINGS_COUNT; i++) {
    304c:	90 e3       	ldi	r25, 0x30	; 48
    304e:	e8 33       	cpi	r30, 0x38	; 56
    3050:	f9 07       	cpc	r31, r25
    3052:	d1 f7       	brne	.-12     	; 0x3048 <LogSetModeById+0x4>
        GlobalSettings.Settings[i].LogMode = Mode;
    }
#endif

    switch (Mode) {
    3054:	81 30       	cpi	r24, 0x01	; 1
    3056:	49 f0       	breq	.+18     	; 0x306a <LogSetModeById+0x26>
    3058:	18 f0       	brcs	.+6      	; 0x3060 <LogSetModeById+0x1c>
    305a:	82 30       	cpi	r24, 0x02	; 2
    305c:	59 f0       	breq	.+22     	; 0x3074 <LogSetModeById+0x30>
    305e:	08 95       	ret
        case LOG_MODE_OFF:
            EnableLogSRAMtoFRAM = false;
    3060:	10 92 8f 24 	sts	0x248F, r1	; 0x80248f <EnableLogSRAMtoFRAM>
            CurrentLogFunc = LogFuncOff;
    3064:	87 e1       	ldi	r24, 0x17	; 23
    3066:	97 e1       	ldi	r25, 0x17	; 23
    3068:	09 c0       	rjmp	.+18     	; 0x307c <LogSetModeById+0x38>
            break;

        case LOG_MODE_MEMORY:
            EnableLogSRAMtoFRAM = true;
    306a:	80 93 8f 24 	sts	0x248F, r24	; 0x80248f <EnableLogSRAMtoFRAM>
            CurrentLogFunc = LogFuncMemory;
    306e:	8e e9       	ldi	r24, 0x9E	; 158
    3070:	98 e1       	ldi	r25, 0x18	; 24
    3072:	04 c0       	rjmp	.+8      	; 0x307c <LogSetModeById+0x38>
            break;

        case LOG_MODE_LIVE:
            EnableLogSRAMtoFRAM = false;
    3074:	10 92 8f 24 	sts	0x248F, r1	; 0x80248f <EnableLogSRAMtoFRAM>
            CurrentLogFunc = LogFuncLive;
    3078:	88 e1       	ldi	r24, 0x18	; 24
    307a:	97 e1       	ldi	r25, 0x17	; 23
    307c:	80 93 d6 2f 	sts	0x2FD6, r24	; 0x802fd6 <CurrentLogFunc>
    3080:	90 93 d7 2f 	sts	0x2FD7, r25	; 0x802fd7 <CurrentLogFunc+0x1>
    3084:	08 95       	ret

00003086 <LogInit>:
    TerminalSendByte((uint8_t)(SysTick >> 8));
    TerminalSendByte((uint8_t)(SysTick >> 0));
    TerminalSendBlock(Data, Length);
}

void LogInit(void) {
    3086:	0f 93       	push	r16
    3088:	1f 93       	push	r17
    308a:	cf 93       	push	r28
    308c:	df 93       	push	r29
    308e:	1f 92       	push	r1
    3090:	cd b7       	in	r28, 0x3d	; 61
    3092:	de b7       	in	r29, 0x3e	; 62
    LogSetModeById(GlobalSettings.ActiveSettingPtr->LogMode);
    3094:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    3098:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    309c:	84 81       	ldd	r24, Z+4	; 0x04
    309e:	d2 df       	rcall	.-92     	; 0x3044 <LogSetModeById>
    LogMemPtr = LogMem;
    30a0:	84 e9       	ldi	r24, 0x94	; 148
    30a2:	94 e2       	ldi	r25, 0x24	; 36
    30a4:	80 93 92 24 	sts	0x2492, r24	; 0x802492 <LogMemPtr>
    30a8:	90 93 93 24 	sts	0x2493, r25	; 0x802493 <LogMemPtr+0x1>
    LogMemLeft = sizeof(LogMem);
    30ac:	00 e0       	ldi	r16, 0x00	; 0
    30ae:	18 e0       	ldi	r17, 0x08	; 8
    30b0:	00 93 90 24 	sts	0x2490, r16	; 0x802490 <LogMemLeft>
    30b4:	10 93 91 24 	sts	0x2491, r17	; 0x802491 <LogMemLeft+0x1>

    uint8_t result;
    ReadEEPBlock((uint16_t) &LogFRAMAddrValid, &result, 1);
    30b8:	41 e0       	ldi	r20, 0x01	; 1
    30ba:	50 e0       	ldi	r21, 0x00	; 0
    30bc:	be 01       	movw	r22, r28
    30be:	6f 5f       	subi	r22, 0xFF	; 255
    30c0:	7f 4f       	sbci	r23, 0xFF	; 255
    30c2:	80 e0       	ldi	r24, 0x00	; 0
    30c4:	90 e0       	ldi	r25, 0x00	; 0
    30c6:	63 dc       	rcall	.-1850   	; 0x298e <ReadEEPBlock>
    memset(LogMemPtr, LOG_EMPTY, LOG_SIZE);
    30c8:	e0 91 92 24 	lds	r30, 0x2492	; 0x802492 <LogMemPtr>
    30cc:	f0 91 93 24 	lds	r31, 0x2493	; 0x802493 <LogMemPtr+0x1>
    30d0:	df 01       	movw	r26, r30
    30d2:	c8 01       	movw	r24, r16
    30d4:	1d 92       	st	X+, r1
    30d6:	01 97       	sbiw	r24, 0x01	; 1
    30d8:	e9 f7       	brne	.-6      	; 0x30d4 <LogInit+0x4e>
    if (result) {
    30da:	89 81       	ldd	r24, Y+1	; 0x01
    30dc:	88 23       	and	r24, r24
    30de:	41 f0       	breq	.+16     	; 0x30f0 <LogInit+0x6a>
        MemoryReadBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    30e0:	42 e0       	ldi	r20, 0x02	; 2
    30e2:	50 e0       	ldi	r21, 0x00	; 0
    30e4:	60 e0       	ldi	r22, 0x00	; 0
    30e6:	70 e4       	ldi	r23, 0x40	; 64
    30e8:	80 e0       	ldi	r24, 0x00	; 0
    30ea:	90 e2       	ldi	r25, 0x20	; 32
    30ec:	50 d9       	rcall	.-3424   	; 0x238e <MemoryReadBlock>
    30ee:	17 c0       	rjmp	.+46     	; 0x311e <LogInit+0x98>
    } else {
        LogFRAMAddr = FRAM_LOG_START_ADDR;
    30f0:	82 e0       	ldi	r24, 0x02	; 2
    30f2:	90 e4       	ldi	r25, 0x40	; 64
    30f4:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    30f8:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
        MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    30fc:	42 e0       	ldi	r20, 0x02	; 2
    30fe:	50 e0       	ldi	r21, 0x00	; 0
    3100:	60 e0       	ldi	r22, 0x00	; 0
    3102:	70 e4       	ldi	r23, 0x40	; 64
    3104:	80 e0       	ldi	r24, 0x00	; 0
    3106:	90 e2       	ldi	r25, 0x20	; 32
    3108:	90 d9       	rcall	.-3296   	; 0x242a <MemoryWriteBlock>
        result = true;
    310a:	81 e0       	ldi	r24, 0x01	; 1
    310c:	89 83       	std	Y+1, r24	; 0x01
        WriteEEPBlock((uint16_t) &LogFRAMAddrValid, &result, 1);
    310e:	41 e0       	ldi	r20, 0x01	; 1
    3110:	50 e0       	ldi	r21, 0x00	; 0
    3112:	be 01       	movw	r22, r28
    3114:	6f 5f       	subi	r22, 0xFF	; 255
    3116:	7f 4f       	sbci	r23, 0xFF	; 255
    3118:	80 e0       	ldi	r24, 0x00	; 0
    311a:	90 e0       	ldi	r25, 0x00	; 0
    311c:	69 dc       	rcall	.-1838   	; 0x29f0 <WriteEEPBlock>
    311e:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    3122:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    3126:	40 e0       	ldi	r20, 0x00	; 0
    3128:	60 e0       	ldi	r22, 0x00	; 0
    312a:	70 e0       	ldi	r23, 0x00	; 0
    312c:	8f ef       	ldi	r24, 0xFF	; 255
    312e:	19 95       	eicall
    }

    LogEntry(LOG_INFO_SYSTEM_BOOT, NULL, 0);
}
    3130:	0f 90       	pop	r0
    3132:	df 91       	pop	r29
    3134:	cf 91       	pop	r28
    3136:	1f 91       	pop	r17
    3138:	0f 91       	pop	r16
    313a:	08 95       	ret

0000313c <LogFuncMemory>:

static void LogFuncOff(LogEntryEnum Entry, const void *Data, uint8_t Length) {
    /* Do nothing */
}

static void LogFuncMemory(LogEntryEnum Entry, const void *Data, uint8_t Length) {
    313c:	0f 93       	push	r16
    313e:	1f 93       	push	r17
    3140:	cf 93       	push	r28
    3142:	df 93       	push	r29
    3144:	ce b1       	in	r28, 0x0e	; 14
    3146:	df b1       	in	r29, 0x0f	; 15
    3148:	a0 91 08 04 	lds	r26, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    314c:	b0 91 09 04 	lds	r27, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    uint16_t SysTick = SystemGetSysTick();

    if (LogMemLeft >= (Length + 4)) {
    3150:	20 91 90 24 	lds	r18, 0x2490	; 0x802490 <LogMemLeft>
    3154:	30 91 91 24 	lds	r19, 0x2491	; 0x802491 <LogMemLeft+0x1>
    3158:	e4 2f       	mov	r30, r20
    315a:	f0 e0       	ldi	r31, 0x00	; 0
    315c:	8f 01       	movw	r16, r30
    315e:	0c 5f       	subi	r16, 0xFC	; 252
    3160:	1f 4f       	sbci	r17, 0xFF	; 255
    3162:	20 17       	cp	r18, r16
    3164:	31 07       	cpc	r19, r17
    3166:	58 f1       	brcs	.+86     	; 0x31be <LogFuncMemory+0x82>
    3168:	ca 2b       	or	r28, r26
    316a:	db 2b       	or	r29, r27
        LogMemLeft -= Length + 4;
    316c:	24 50       	subi	r18, 0x04	; 4
    316e:	31 09       	sbc	r19, r1
    3170:	2e 1b       	sub	r18, r30
    3172:	3f 0b       	sbc	r19, r31
    3174:	20 93 90 24 	sts	0x2490, r18	; 0x802490 <LogMemLeft>
    3178:	30 93 91 24 	sts	0x2491, r19	; 0x802491 <LogMemLeft+0x1>

        uint8_t *DataPtr = (uint8_t *) Data;

        /* Write down Entry Id, Data length and Timestamp */
        *LogMemPtr++ = (uint8_t) Entry;
    317c:	a0 91 92 24 	lds	r26, 0x2492	; 0x802492 <LogMemPtr>
    3180:	b0 91 93 24 	lds	r27, 0x2493	; 0x802493 <LogMemPtr+0x1>
    3184:	8c 93       	st	X, r24
        *LogMemPtr++ = (uint8_t) Length;
    3186:	11 96       	adiw	r26, 0x01	; 1
    3188:	4c 93       	st	X, r20
    318a:	11 97       	sbiw	r26, 0x01	; 1
        *LogMemPtr++ = (uint8_t)(SysTick >> 8);
    318c:	12 96       	adiw	r26, 0x02	; 2
    318e:	dc 93       	st	X, r29
    3190:	12 97       	sbiw	r26, 0x02	; 2
        *LogMemPtr++ = (uint8_t)(SysTick >> 0);
    3192:	cd 01       	movw	r24, r26
    3194:	04 96       	adiw	r24, 0x04	; 4
    3196:	80 93 92 24 	sts	0x2492, r24	; 0x802492 <LogMemPtr>
    319a:	90 93 93 24 	sts	0x2493, r25	; 0x802493 <LogMemPtr+0x1>
    319e:	13 96       	adiw	r26, 0x03	; 3
    31a0:	cc 93       	st	X, r28
    31a2:	db 01       	movw	r26, r22
    31a4:	ec 01       	movw	r28, r24

        /* Write down data bytes */
        while (Length--) {
    31a6:	41 50       	subi	r20, 0x01	; 1
    31a8:	18 f0       	brcs	.+6      	; 0x31b0 <LogFuncMemory+0x74>
            *LogMemPtr++ = *DataPtr++;
    31aa:	2d 91       	ld	r18, X+
    31ac:	29 93       	st	Y+, r18
    31ae:	fb cf       	rjmp	.-10     	; 0x31a6 <LogFuncMemory+0x6a>
    31b0:	e8 0f       	add	r30, r24
    31b2:	f9 1f       	adc	r31, r25
    31b4:	e0 93 92 24 	sts	0x2492, r30	; 0x802492 <LogMemPtr>
    31b8:	f0 93 93 24 	sts	0x2493, r31	; 0x802493 <LogMemPtr+0x1>
    31bc:	12 c0       	rjmp	.+36     	; 0x31e2 <LogFuncMemory+0xa6>
        }
    } else {
        /* If memory full. Deactivate logmode */
        LogSetModeById(LOG_MODE_OFF);
    31be:	80 e0       	ldi	r24, 0x00	; 0
    31c0:	41 df       	rcall	.-382    	; 0x3044 <LogSetModeById>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    31c2:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    31c6:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    31ca:	87 81       	ldd	r24, Z+7	; 0x07
    31cc:	8a 30       	cpi	r24, 0x0A	; 10
    31ce:	19 f4       	brne	.+6      	; 0x31d6 <LogFuncMemory+0x9a>
        LEDGreenAction = Action;
    31d0:	81 e1       	ldi	r24, 0x11	; 17
    31d2:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    31d6:	86 81       	ldd	r24, Z+6	; 0x06
    31d8:	8a 30       	cpi	r24, 0x0A	; 10
    31da:	19 f4       	brne	.+6      	; 0x31e2 <LogFuncMemory+0xa6>
        LEDRedAction = Action;
    31dc:	81 e1       	ldi	r24, 0x11	; 17
    31de:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
        LEDHook(LED_LOG_MEM_FULL, LED_ON);
    }
}
    31e2:	df 91       	pop	r29
    31e4:	cf 91       	pop	r28
    31e6:	1f 91       	pop	r17
    31e8:	0f 91       	pop	r16
    31ea:	08 95       	ret

000031ec <LogSetModeByName>:
            break;
    }

}

bool LogSetModeByName(const char *Mode) {
    31ec:	1f 93       	push	r17
    31ee:	cf 93       	push	r28
    31f0:	df 93       	push	r29
    31f2:	1f 92       	push	r1
    31f4:	cd b7       	in	r28, 0x3d	; 61
    31f6:	de b7       	in	r29, 0x3e	; 62
    MapIdType Id;

    if (MapTextToId(LogModeMap, ARRAY_COUNT(LogModeMap), Mode, &Id)) {
    31f8:	9e 01       	movw	r18, r28
    31fa:	2f 5f       	subi	r18, 0xFF	; 255
    31fc:	3f 4f       	sbci	r19, 0xFF	; 255
    31fe:	ac 01       	movw	r20, r24
    3200:	63 e0       	ldi	r22, 0x03	; 3
    3202:	83 ea       	ldi	r24, 0xA3	; 163
    3204:	9a e0       	ldi	r25, 0x0A	; 10
    3206:	3d d2       	rcall	.+1146   	; 0x3682 <MapTextToId>
    3208:	18 2f       	mov	r17, r24
    320a:	88 23       	and	r24, r24
    320c:	11 f0       	breq	.+4      	; 0x3212 <LogSetModeByName+0x26>
        LogSetModeById(Id);
    320e:	89 81       	ldd	r24, Y+1	; 0x01
    3210:	19 df       	rcall	.-462    	; 0x3044 <LogSetModeById>
        return true;
    }

    return false;
}
    3212:	81 2f       	mov	r24, r17
    3214:	0f 90       	pop	r0
    3216:	df 91       	pop	r29
    3218:	cf 91       	pop	r28
    321a:	1f 91       	pop	r17
    321c:	08 95       	ret

0000321e <LogGetModeByName>:

void LogGetModeByName(char *Mode, uint16_t BufferSize) {
    321e:	0f 93       	push	r16
    3220:	1f 93       	push	r17
    MapIdToText(LogModeMap, ARRAY_COUNT(LogModeMap),
                GlobalSettings.ActiveSettingPtr->LogMode, Mode, BufferSize);
    3222:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    3226:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>

    return false;
}

void LogGetModeByName(char *Mode, uint16_t BufferSize) {
    MapIdToText(LogModeMap, ARRAY_COUNT(LogModeMap),
    322a:	8b 01       	movw	r16, r22
    322c:	9c 01       	movw	r18, r24
    322e:	44 81       	ldd	r20, Z+4	; 0x04
    3230:	63 e0       	ldi	r22, 0x03	; 3
    3232:	83 ea       	ldi	r24, 0xA3	; 163
    3234:	9a e0       	ldi	r25, 0x0A	; 10
    3236:	0d d2       	rcall	.+1050   	; 0x3652 <MapIdToText>
                GlobalSettings.ActiveSettingPtr->LogMode, Mode, BufferSize);
}
    3238:	1f 91       	pop	r17
    323a:	0f 91       	pop	r16
    323c:	08 95       	ret

0000323e <LogGetModeList>:

void LogGetModeList(char *List, uint16_t BufferSize) {
    323e:	9b 01       	movw	r18, r22
    MapToString(LogModeMap, ARRAY_COUNT(LogModeMap), List, BufferSize);
    3240:	ac 01       	movw	r20, r24
    3242:	63 e0       	ldi	r22, 0x03	; 3
    3244:	83 ea       	ldi	r24, 0xA3	; 163
    3246:	9a e0       	ldi	r25, 0x0A	; 10
    3248:	43 c2       	rjmp	.+1158   	; 0x36d0 <MapToString>

0000324a <LogSRAMToFRAM>:
}

void LogSRAMToFRAM(void) {
    324a:	0f 93       	push	r16
    324c:	1f 93       	push	r17
    324e:	cf 93       	push	r28
    3250:	df 93       	push	r29
    if (LogMemLeft < LOG_SIZE) {
    3252:	80 91 90 24 	lds	r24, 0x2490	; 0x802490 <LogMemLeft>
    3256:	90 91 91 24 	lds	r25, 0x2491	; 0x802491 <LogMemLeft+0x1>
    325a:	81 15       	cp	r24, r1
    325c:	28 e0       	ldi	r18, 0x08	; 8
    325e:	92 07       	cpc	r25, r18
    3260:	08 f0       	brcs	.+2      	; 0x3264 <LogSRAMToFRAM+0x1a>
    3262:	74 c0       	rjmp	.+232    	; 0x334c <LogSRAMToFRAM+0x102>
        uint16_t FRAM_Free = FRAM_LOG_SIZE - (LogFRAMAddr - FRAM_LOG_START_ADDR);
    3264:	60 91 00 20 	lds	r22, 0x2000	; 0x802000 <__data_start>
    3268:	70 91 01 20 	lds	r23, 0x2001	; 0x802001 <__data_start+0x1>
    326c:	c0 e0       	ldi	r28, 0x00	; 0
    326e:	d0 e8       	ldi	r29, 0x80	; 128
    3270:	c6 1b       	sub	r28, r22
    3272:	d7 0b       	sbc	r29, r23

        if (FRAM_Free >= LOG_SIZE - LogMemLeft) {
    3274:	00 e0       	ldi	r16, 0x00	; 0
    3276:	18 e0       	ldi	r17, 0x08	; 8
    3278:	a8 01       	movw	r20, r16
    327a:	48 1b       	sub	r20, r24
    327c:	59 0b       	sbc	r21, r25
    327e:	c4 17       	cp	r28, r20
    3280:	d5 07       	cpc	r29, r21
    3282:	58 f1       	brcs	.+86     	; 0x32da <LogSRAMToFRAM+0x90>
            MemoryWriteBlock(LogMem, LogFRAMAddr, LOG_SIZE - LogMemLeft);
    3284:	84 e9       	ldi	r24, 0x94	; 148
    3286:	94 e2       	ldi	r25, 0x24	; 36
    3288:	d0 d8       	rcall	.-3680   	; 0x242a <MemoryWriteBlock>
            LogFRAMAddr += LOG_SIZE - LogMemLeft;
    328a:	20 91 90 24 	lds	r18, 0x2490	; 0x802490 <LogMemLeft>
    328e:	30 91 91 24 	lds	r19, 0x2491	; 0x802491 <LogMemLeft+0x1>
    3292:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3296:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    329a:	98 5f       	subi	r25, 0xF8	; 248
    329c:	82 1b       	sub	r24, r18
    329e:	93 0b       	sbc	r25, r19
    32a0:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    32a4:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
        return false;
    }
}

INLINE void LogSRAMClear(void) {
    uint16_t i, until = LOG_SIZE - LogMemLeft;
    32a8:	02 1b       	sub	r16, r18
    32aa:	13 0b       	sbc	r17, r19
    32ac:	e4 e9       	ldi	r30, 0x94	; 148
    32ae:	f4 e2       	ldi	r31, 0x24	; 36

    for (i = 0; i < until; i++) {
    32b0:	cf 01       	movw	r24, r30
    32b2:	84 59       	subi	r24, 0x94	; 148
    32b4:	94 42       	sbci	r25, 0x24	; 36
    32b6:	80 17       	cp	r24, r16
    32b8:	91 07       	cpc	r25, r17
    32ba:	10 f4       	brcc	.+4      	; 0x32c0 <LogSRAMToFRAM+0x76>
        LogMem[i] = (uint8_t) LOG_EMPTY;
    32bc:	11 92       	st	Z+, r1
    32be:	f8 cf       	rjmp	.-16     	; 0x32b0 <LogSRAMToFRAM+0x66>
    }

    LogMemPtr = LogMem;
    32c0:	84 e9       	ldi	r24, 0x94	; 148
    32c2:	94 e2       	ldi	r25, 0x24	; 36
    32c4:	80 93 92 24 	sts	0x2492, r24	; 0x802492 <LogMemPtr>
    32c8:	90 93 93 24 	sts	0x2493, r25	; 0x802493 <LogMemPtr+0x1>
    LogMemLeft = sizeof(LogMem);
    32cc:	80 e0       	ldi	r24, 0x00	; 0
    32ce:	98 e0       	ldi	r25, 0x08	; 8
    32d0:	80 93 90 24 	sts	0x2490, r24	; 0x802490 <LogMemLeft>
    32d4:	90 93 91 24 	sts	0x2491, r25	; 0x802491 <LogMemLeft+0x1>
    32d8:	2e c0       	rjmp	.+92     	; 0x3336 <LogSRAMToFRAM+0xec>
        if (FRAM_Free >= LOG_SIZE - LogMemLeft) {
            MemoryWriteBlock(LogMem, LogFRAMAddr, LOG_SIZE - LogMemLeft);
            LogFRAMAddr += LOG_SIZE - LogMemLeft;
            LogSRAMClear();
            MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
        } else if (FRAM_Free > 0) {
    32da:	20 97       	sbiw	r28, 0x00	; 0
    32dc:	b9 f1       	breq	.+110    	; 0x334c <LogSRAMToFRAM+0x102>
            // not everything fits in FRAM, simply write as much as possible to FRAM
            MemoryWriteBlock(LogMem, LogFRAMAddr, FRAM_Free);
    32de:	ae 01       	movw	r20, r28
    32e0:	84 e9       	ldi	r24, 0x94	; 148
    32e2:	94 e2       	ldi	r25, 0x24	; 36
    32e4:	a2 d8       	rcall	.-3772   	; 0x242a <MemoryWriteBlock>
            memmove(LogMem, LogMem + FRAM_Free, LOG_SIZE - FRAM_Free); // FRAM_Free is < LOG_SIZE - LogMemLeft and thus also < LOG_SIZE
    32e6:	a8 01       	movw	r20, r16
    32e8:	4c 1b       	sub	r20, r28
    32ea:	5d 0b       	sbc	r21, r29
    32ec:	be 01       	movw	r22, r28
    32ee:	6c 56       	subi	r22, 0x6C	; 108
    32f0:	7b 4d       	sbci	r23, 0xDB	; 219
    32f2:	84 e9       	ldi	r24, 0x94	; 148
    32f4:	94 e2       	ldi	r25, 0x24	; 36
    32f6:	0e 94 a9 78 	call	0xf152	; 0xf152 <memmove>

            LogMemPtr -= FRAM_Free;
    32fa:	80 91 92 24 	lds	r24, 0x2492	; 0x802492 <LogMemPtr>
    32fe:	90 91 93 24 	lds	r25, 0x2493	; 0x802493 <LogMemPtr+0x1>
    3302:	8c 1b       	sub	r24, r28
    3304:	9d 0b       	sbc	r25, r29
    3306:	80 93 92 24 	sts	0x2492, r24	; 0x802492 <LogMemPtr>
    330a:	90 93 93 24 	sts	0x2493, r25	; 0x802493 <LogMemPtr+0x1>
            LogMemLeft += FRAM_Free;
    330e:	80 91 90 24 	lds	r24, 0x2490	; 0x802490 <LogMemLeft>
    3312:	90 91 91 24 	lds	r25, 0x2491	; 0x802491 <LogMemLeft+0x1>
    3316:	8c 0f       	add	r24, r28
    3318:	9d 1f       	adc	r25, r29
    331a:	80 93 90 24 	sts	0x2490, r24	; 0x802490 <LogMemLeft>
    331e:	90 93 91 24 	sts	0x2491, r25	; 0x802491 <LogMemLeft+0x1>
            LogFRAMAddr += FRAM_Free;
    3322:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3326:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    332a:	c8 0f       	add	r28, r24
    332c:	d9 1f       	adc	r29, r25
    332e:	c0 93 00 20 	sts	0x2000, r28	; 0x802000 <__data_start>
    3332:	d0 93 01 20 	sts	0x2001, r29	; 0x802001 <__data_start+0x1>
            MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    3336:	42 e0       	ldi	r20, 0x02	; 2
    3338:	50 e0       	ldi	r21, 0x00	; 0
    333a:	60 e0       	ldi	r22, 0x00	; 0
    333c:	70 e4       	ldi	r23, 0x40	; 64
    333e:	80 e0       	ldi	r24, 0x00	; 0
    3340:	90 e2       	ldi	r25, 0x20	; 32
        } else {
            // TODO handle the case in which the FRAM is full
        }
    }
}
    3342:	df 91       	pop	r29
    3344:	cf 91       	pop	r28
    3346:	1f 91       	pop	r17
            memmove(LogMem, LogMem + FRAM_Free, LOG_SIZE - FRAM_Free); // FRAM_Free is < LOG_SIZE - LogMemLeft and thus also < LOG_SIZE

            LogMemPtr -= FRAM_Free;
            LogMemLeft += FRAM_Free;
            LogFRAMAddr += FRAM_Free;
            MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    3348:	0f 91       	pop	r16
    334a:	6f c8       	rjmp	.-3874   	; 0x242a <MemoryWriteBlock>
        } else {
            // TODO handle the case in which the FRAM is full
        }
    }
}
    334c:	df 91       	pop	r29
    334e:	cf 91       	pop	r28
    3350:	1f 91       	pop	r17
    3352:	0f 91       	pop	r16
    3354:	08 95       	ret

00003356 <LogTick>:

    LogEntry(LOG_INFO_SYSTEM_BOOT, NULL, 0);
}

void LogTick(void) {
    if (EnableLogSRAMtoFRAM)
    3356:	80 91 8f 24 	lds	r24, 0x248F	; 0x80248f <EnableLogSRAMtoFRAM>
    335a:	81 11       	cpse	r24, r1
        LogSRAMToFRAM();
    335c:	76 cf       	rjmp	.-276    	; 0x324a <LogSRAMToFRAM>
    335e:	08 95       	ret

00003360 <SettingsLoad>:
    }
}

uint8_t SettingsGetActiveById(void) {
    return INDEX_TO_SETTING(GlobalSettings.ActiveSettingIdx);
}
    3360:	43 e6       	ldi	r20, 0x63	; 99
    3362:	50 e0       	ldi	r21, 0x00	; 0
    3364:	68 ed       	ldi	r22, 0xD8	; 216
    3366:	7f e2       	ldi	r23, 0x2F	; 47
    3368:	81 e0       	ldi	r24, 0x01	; 1
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	10 cb       	rjmp	.-2528   	; 0x298e <ReadEEPBlock>

0000336e <SettingsSave>:
    336e:	43 e6       	ldi	r20, 0x63	; 99
    3370:	50 e0       	ldi	r21, 0x00	; 0
    3372:	68 ed       	ldi	r22, 0xD8	; 216
    3374:	7f e2       	ldi	r23, 0x2F	; 47
    3376:	81 e0       	ldi	r24, 0x01	; 1
    3378:	90 e0       	ldi	r25, 0x00	; 0
    337a:	3a cb       	rjmp	.-2444   	; 0x29f0 <WriteEEPBlock>

0000337c <SettingsSetActiveById>:
    337c:	0f 93       	push	r16
    337e:	1f 93       	push	r17
    3380:	cf 93       	push	r28
    3382:	df 93       	push	r29
    3384:	cf ef       	ldi	r28, 0xFF	; 255
    3386:	c8 0f       	add	r28, r24
    3388:	c8 30       	cpi	r28, 0x08	; 8
    338a:	08 f0       	brcs	.+2      	; 0x338e <SettingsSetActiveById+0x12>
    338c:	47 c0       	rjmp	.+142    	; 0x341c <SettingsSetActiveById+0xa0>
    338e:	d8 2f       	mov	r29, r24
    3390:	0e 94 cc 25 	call	0x4b98	; 0x4b98 <CommandLinePendingTaskBreak>
    3394:	80 91 d8 2f 	lds	r24, 0x2FD8	; 0x802fd8 <GlobalSettings>
    3398:	c8 17       	cp	r28, r24
    339a:	79 f1       	breq	.+94     	; 0x33fa <SettingsSetActiveById+0x7e>
    339c:	59 d9       	rcall	.-3406   	; 0x2650 <MemoryStore>
    339e:	c0 93 d8 2f 	sts	0x2FD8, r28	; 0x802fd8 <GlobalSettings>
    33a2:	8c e0       	ldi	r24, 0x0C	; 12
    33a4:	c8 9f       	mul	r28, r24
    33a6:	90 01       	movw	r18, r0
    33a8:	11 24       	eor	r1, r1
    33aa:	25 52       	subi	r18, 0x25	; 37
    33ac:	30 4d       	sbci	r19, 0xD0	; 208
    33ae:	20 93 d9 2f 	sts	0x2FD9, r18	; 0x802fd9 <GlobalSettings+0x1>
    33b2:	30 93 da 2f 	sts	0x2FDA, r19	; 0x802fda <GlobalSettings+0x2>
    33b6:	a7 d8       	rcall	.-3762   	; 0x2506 <MemoryRecall>
    33b8:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    33bc:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    33c0:	85 81       	ldd	r24, Z+5	; 0x05
    33c2:	0e 94 95 10 	call	0x212a	; 0x212a <ConfigurationSetById>
    33c6:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    33ca:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    33ce:	84 81       	ldd	r24, Z+4	; 0x04
    33d0:	39 de       	rcall	.-910    	; 0x3044 <LogSetModeById>
    33d2:	01 e0       	ldi	r16, 0x01	; 1
    33d4:	10 e0       	ldi	r17, 0x00	; 0
    33d6:	08 5d       	subi	r16, 0xD8	; 216
    33d8:	1f 42       	sbci	r17, 0x2F	; 47
    33da:	60 91 d8 2f 	lds	r22, 0x2FD8	; 0x802fd8 <GlobalSettings>
    33de:	c8 01       	movw	r24, r16
    33e0:	88 52       	subi	r24, 0x28	; 40
    33e2:	90 4d       	sbci	r25, 0xD0	; 208
    33e4:	0e 94 41 7f 	call	0xfe82	; 0xfe82 <eeprom_update_byte>
    33e8:	60 91 d9 2f 	lds	r22, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    33ec:	70 91 da 2f 	lds	r23, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    33f0:	c8 01       	movw	r24, r16
    33f2:	87 52       	subi	r24, 0x27	; 39
    33f4:	90 4d       	sbci	r25, 0xD0	; 208
    33f6:	0e 94 4a 7f 	call	0xfe94	; 0xfe94 <eeprom_update_word>
    33fa:	8f e1       	ldi	r24, 0x1F	; 31
    33fc:	8d 0f       	add	r24, r29
    33fe:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    3402:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    3406:	97 81       	ldd	r25, Z+7	; 0x07
    3408:	94 30       	cpi	r25, 0x04	; 4
    340a:	11 f4       	brne	.+4      	; 0x3410 <SettingsSetActiveById+0x94>
    340c:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    3410:	96 81       	ldd	r25, Z+6	; 0x06
    3412:	94 30       	cpi	r25, 0x04	; 4
    3414:	29 f4       	brne	.+10     	; 0x3420 <SettingsSetActiveById+0xa4>
    3416:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    341a:	02 c0       	rjmp	.+4      	; 0x3420 <SettingsSetActiveById+0xa4>
    341c:	80 e0       	ldi	r24, 0x00	; 0
    341e:	01 c0       	rjmp	.+2      	; 0x3422 <SettingsSetActiveById+0xa6>
    3420:	81 e0       	ldi	r24, 0x01	; 1
    3422:	df 91       	pop	r29
    3424:	cf 91       	pop	r28
    3426:	1f 91       	pop	r17
    3428:	0f 91       	pop	r16
    342a:	08 95       	ret

0000342c <SettingsCycle>:
    342c:	80 91 d8 2f 	lds	r24, 0x2FD8	; 0x802fd8 <GlobalSettings>
    3430:	99 e0       	ldi	r25, 0x09	; 9
    3432:	4c e0       	ldi	r20, 0x0C	; 12
    3434:	91 50       	subi	r25, 0x01	; 1
    3436:	99 f0       	breq	.+38     	; 0x345e <SettingsCycle+0x32>
    3438:	28 2f       	mov	r18, r24
    343a:	30 e0       	ldi	r19, 0x00	; 0
    343c:	2f 5f       	subi	r18, 0xFF	; 255
    343e:	3f 4f       	sbci	r19, 0xFF	; 255
    3440:	27 70       	andi	r18, 0x07	; 7
    3442:	33 27       	eor	r19, r19
    3444:	82 2f       	mov	r24, r18
    3446:	42 9f       	mul	r20, r18
    3448:	f0 01       	movw	r30, r0
    344a:	43 9f       	mul	r20, r19
    344c:	f0 0d       	add	r31, r0
    344e:	11 24       	eor	r1, r1
    3450:	e8 52       	subi	r30, 0x28	; 40
    3452:	f0 4d       	sbci	r31, 0xD0	; 208
    3454:	20 85       	ldd	r18, Z+8	; 0x08
    3456:	22 23       	and	r18, r18
    3458:	69 f3       	breq	.-38     	; 0x3434 <SettingsCycle+0x8>
    345a:	8f 5f       	subi	r24, 0xFF	; 255
    345c:	8f cf       	rjmp	.-226    	; 0x337c <SettingsSetActiveById>
    345e:	08 95       	ret

00003460 <SettingsGetActiveByName>:

void SettingsGetActiveByName(char *SettingOut, uint16_t BufferSize) {
    3460:	fc 01       	movw	r30, r24
    SettingOut[0] = SettingsGetActiveById() + '0';
    3462:	90 91 d8 2f 	lds	r25, 0x2FD8	; 0x802fd8 <GlobalSettings>
    3466:	9f 5c       	subi	r25, 0xCF	; 207
    3468:	90 83       	st	Z, r25
    SettingOut[1] = '\0';
    346a:	11 82       	std	Z+1, r1	; 0x01
    346c:	08 95       	ret

0000346e <SettingsSetActiveByName>:
}

bool SettingsSetActiveByName(const char *Setting) {
    346e:	cf 93       	push	r28
    uint8_t SettingNr = Setting[0] - '0';

    if (Setting[1] == '\0') {
    3470:	fc 01       	movw	r30, r24
    3472:	21 81       	ldd	r18, Z+1	; 0x01
    3474:	21 11       	cpse	r18, r1
    3476:	0d c0       	rjmp	.+26     	; 0x3492 <SettingsSetActiveByName+0x24>
    3478:	bc 01       	movw	r22, r24
    SettingOut[0] = SettingsGetActiveById() + '0';
    SettingOut[1] = '\0';
}

bool SettingsSetActiveByName(const char *Setting) {
    uint8_t SettingNr = Setting[0] - '0';
    347a:	c0 81       	ld	r28, Z
    347c:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    3480:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    3484:	41 e0       	ldi	r20, 0x01	; 1
    3486:	82 e1       	ldi	r24, 0x12	; 18
    3488:	19 95       	eicall

    if (Setting[1] == '\0') {
        LogEntry(LOG_INFO_SETTING_SET, Setting, 1);
        return SettingsSetActiveById(SettingNr);
    348a:	80 ed       	ldi	r24, 0xD0	; 208
    348c:	8c 0f       	add	r24, r28
    } else {
        return false;
    }
}
    348e:	cf 91       	pop	r28
bool SettingsSetActiveByName(const char *Setting) {
    uint8_t SettingNr = Setting[0] - '0';

    if (Setting[1] == '\0') {
        LogEntry(LOG_INFO_SETTING_SET, Setting, 1);
        return SettingsSetActiveById(SettingNr);
    3490:	75 cf       	rjmp	.-278    	; 0x337c <SettingsSetActiveById>
    } else {
        return false;
    }
}
    3492:	80 e0       	ldi	r24, 0x00	; 0
    3494:	cf 91       	pop	r28
    3496:	08 95       	ret

00003498 <LEDInit>:

    }
}

void LEDInit(void) {
    LED_PORT.DIRSET = LED_MASK;
    3498:	88 e1       	ldi	r24, 0x18	; 24
    349a:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
    349e:	08 95       	ret

000034a0 <LEDTick>:
INLINE void Tick(uint8_t Mask, LEDActionEnum *Action) {
    static uint8_t LEDRedBlinkPrescaler = 0;
    static uint8_t LEDGreenBlinkPrescaler = 0;
    uint8_t *BlinkPrescaler = (Action == &LEDGreenAction) ? &LEDGreenBlinkPrescaler : &LEDRedBlinkPrescaler;

    switch (*Action) {
    34a0:	80 91 94 2c 	lds	r24, 0x2C94	; 0x802c94 <LEDRedAction>
    34a4:	82 31       	cpi	r24, 0x12	; 18
    34a6:	91 f0       	breq	.+36     	; 0x34cc <LEDTick+0x2c>
    34a8:	30 f4       	brcc	.+12     	; 0x34b6 <LEDTick+0x16>
    34aa:	80 31       	cpi	r24, 0x10	; 16
    34ac:	b9 f0       	breq	.+46     	; 0x34dc <LEDTick+0x3c>
    34ae:	50 f4       	brcc	.+20     	; 0x34c4 <LEDTick+0x24>
    34b0:	88 23       	and	r24, r24
    34b2:	a9 f1       	breq	.+106    	; 0x351e <LEDTick+0x7e>
    34b4:	32 c0       	rjmp	.+100    	; 0x351a <LEDTick+0x7a>
    34b6:	83 31       	cpi	r24, 0x13	; 19
    34b8:	69 f0       	breq	.+26     	; 0x34d4 <LEDTick+0x34>
    34ba:	90 ee       	ldi	r25, 0xE0	; 224
    34bc:	98 0f       	add	r25, r24
    34be:	98 30       	cpi	r25, 0x08	; 8
    34c0:	88 f0       	brcs	.+34     	; 0x34e4 <LEDTick+0x44>
    34c2:	2b c0       	rjmp	.+86     	; 0x351a <LEDTick+0x7a>
            LED_PORT.OUTCLR = Mask;
            *Action = LED_NO_ACTION;
            break;

        case LED_ON:
            LED_PORT.OUTSET = Mask;
    34c4:	88 e0       	ldi	r24, 0x08	; 8
    34c6:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    34ca:	27 c0       	rjmp	.+78     	; 0x351a <LEDTick+0x7a>
            *Action = LED_NO_ACTION;
            break;

        case LED_TOGGLE:
            LED_PORT.OUTTGL = Mask;
    34cc:	88 e0       	ldi	r24, 0x08	; 8
    34ce:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <__TEXT_REGION_LENGTH__+0x700607>
    34d2:	23 c0       	rjmp	.+70     	; 0x351a <LEDTick+0x7a>
            *Action = LED_NO_ACTION;
            break;

        case LED_PULSE:
            if (!(LED_PORT.OUT & Mask)) {
    34d4:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <__TEXT_REGION_LENGTH__+0x700604>
    34d8:	83 ff       	sbrs	r24, 3
    34da:	12 c0       	rjmp	.+36     	; 0x3500 <LEDTick+0x60>
                LED_PORT.OUTSET = Mask;
            } else {
                LED_PORT.OUTCLR = Mask;
    34dc:	88 e0       	ldi	r24, 0x08	; 8
    34de:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    34e2:	1b c0       	rjmp	.+54     	; 0x351a <LEDTick+0x7a>
                *Action = LED_NO_ACTION;
            }
            break;

        case LED_BLINK_1X ... LED_BLINK_8X:
            if (++(*BlinkPrescaler) == BLINK_PRESCALER) {
    34e4:	90 91 96 2c 	lds	r25, 0x2C96	; 0x802c96 <LEDRedBlinkPrescaler.6823>
    34e8:	9f 5f       	subi	r25, 0xFF	; 255
    34ea:	91 30       	cpi	r25, 0x01	; 1
    34ec:	19 f0       	breq	.+6      	; 0x34f4 <LEDTick+0x54>
    34ee:	90 93 96 2c 	sts	0x2C96, r25	; 0x802c96 <LEDRedBlinkPrescaler.6823>
    34f2:	15 c0       	rjmp	.+42     	; 0x351e <LEDTick+0x7e>
                *BlinkPrescaler = 0;
    34f4:	10 92 96 2c 	sts	0x2C96, r1	; 0x802c96 <LEDRedBlinkPrescaler.6823>

                /* Blink functionality occurs at slower speed than Tick-frequency */
                if (!(LED_PORT.OUT & Mask)) {
    34f8:	90 91 04 06 	lds	r25, 0x0604	; 0x800604 <__TEXT_REGION_LENGTH__+0x700604>
    34fc:	93 fd       	sbrc	r25, 3
    34fe:	04 c0       	rjmp	.+8      	; 0x3508 <LEDTick+0x68>
                    /* LED is off, turn it on */
                    LED_PORT.OUTSET = Mask;
    3500:	88 e0       	ldi	r24, 0x08	; 8
    3502:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    3506:	0b c0       	rjmp	.+22     	; 0x351e <LEDTick+0x7e>
                } else {
                    /* LED is on, turn it off and change state */
                    LED_PORT.OUTCLR = Mask;
    3508:	98 e0       	ldi	r25, 0x08	; 8
    350a:	90 93 06 06 	sts	0x0606, r25	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>

                    if (*Action == LED_BLINK_1X) {
    350e:	80 32       	cpi	r24, 0x20	; 32
    3510:	21 f0       	breq	.+8      	; 0x351a <LEDTick+0x7a>
                        *Action = LED_NO_ACTION;
                    } else {
                        /* Still some blinks to do. Use the fact that LED_BLINK_XY are ordered sequentially */
                        *Action = *Action - 1;
    3512:	81 50       	subi	r24, 0x01	; 1
    3514:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    3518:	02 c0       	rjmp	.+4      	; 0x351e <LEDTick+0x7e>
            }
            break;

        default:
            /* Should not happen (TM) */
            *Action = LED_NO_ACTION;
    351a:	10 92 94 2c 	sts	0x2C94, r1	; 0x802c94 <LEDRedAction>
INLINE void Tick(uint8_t Mask, LEDActionEnum *Action) {
    static uint8_t LEDRedBlinkPrescaler = 0;
    static uint8_t LEDGreenBlinkPrescaler = 0;
    uint8_t *BlinkPrescaler = (Action == &LEDGreenAction) ? &LEDGreenBlinkPrescaler : &LEDRedBlinkPrescaler;

    switch (*Action) {
    351e:	80 91 95 2c 	lds	r24, 0x2C95	; 0x802c95 <LEDGreenAction>
    3522:	82 31       	cpi	r24, 0x12	; 18
    3524:	91 f0       	breq	.+36     	; 0x354a <LEDTick+0xaa>
    3526:	30 f4       	brcc	.+12     	; 0x3534 <LEDTick+0x94>
    3528:	80 31       	cpi	r24, 0x10	; 16
    352a:	c1 f0       	breq	.+48     	; 0x355c <LEDTick+0xbc>
    352c:	50 f4       	brcc	.+20     	; 0x3542 <LEDTick+0xa2>
    352e:	88 23       	and	r24, r24
    3530:	a9 f1       	breq	.+106    	; 0x359c <LEDTick+0xfc>
    3532:	32 c0       	rjmp	.+100    	; 0x3598 <LEDTick+0xf8>
    3534:	83 31       	cpi	r24, 0x13	; 19
    3536:	69 f0       	breq	.+26     	; 0x3552 <LEDTick+0xb2>
    3538:	90 ee       	ldi	r25, 0xE0	; 224
    353a:	98 0f       	add	r25, r24
    353c:	98 30       	cpi	r25, 0x08	; 8
    353e:	88 f0       	brcs	.+34     	; 0x3562 <LEDTick+0xc2>
    3540:	2b c0       	rjmp	.+86     	; 0x3598 <LEDTick+0xf8>
            LED_PORT.OUTCLR = Mask;
            *Action = LED_NO_ACTION;
            break;

        case LED_ON:
            LED_PORT.OUTSET = Mask;
    3542:	80 e1       	ldi	r24, 0x10	; 16
    3544:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    3548:	27 c0       	rjmp	.+78     	; 0x3598 <LEDTick+0xf8>
            *Action = LED_NO_ACTION;
            break;

        case LED_TOGGLE:
            LED_PORT.OUTTGL = Mask;
    354a:	80 e1       	ldi	r24, 0x10	; 16
    354c:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <__TEXT_REGION_LENGTH__+0x700607>
    3550:	23 c0       	rjmp	.+70     	; 0x3598 <LEDTick+0xf8>
            *Action = LED_NO_ACTION;
            break;

        case LED_PULSE:
            if (!(LED_PORT.OUT & Mask)) {
    3552:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <__TEXT_REGION_LENGTH__+0x700604>
    3556:	84 ff       	sbrs	r24, 4
    3558:	12 c0       	rjmp	.+36     	; 0x357e <LEDTick+0xde>
                LED_PORT.OUTSET = Mask;
            } else {
                LED_PORT.OUTCLR = Mask;
    355a:	80 e1       	ldi	r24, 0x10	; 16
    355c:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    3560:	1b c0       	rjmp	.+54     	; 0x3598 <LEDTick+0xf8>
                *Action = LED_NO_ACTION;
            }
            break;

        case LED_BLINK_1X ... LED_BLINK_8X:
            if (++(*BlinkPrescaler) == BLINK_PRESCALER) {
    3562:	90 91 97 2c 	lds	r25, 0x2C97	; 0x802c97 <LEDGreenBlinkPrescaler.6824>
    3566:	9f 5f       	subi	r25, 0xFF	; 255
    3568:	91 30       	cpi	r25, 0x01	; 1
    356a:	19 f0       	breq	.+6      	; 0x3572 <LEDTick+0xd2>
    356c:	90 93 97 2c 	sts	0x2C97, r25	; 0x802c97 <LEDGreenBlinkPrescaler.6824>
    3570:	08 95       	ret
                *BlinkPrescaler = 0;
    3572:	10 92 97 2c 	sts	0x2C97, r1	; 0x802c97 <LEDGreenBlinkPrescaler.6824>

                /* Blink functionality occurs at slower speed than Tick-frequency */
                if (!(LED_PORT.OUT & Mask)) {
    3576:	90 91 04 06 	lds	r25, 0x0604	; 0x800604 <__TEXT_REGION_LENGTH__+0x700604>
    357a:	94 fd       	sbrc	r25, 4
    357c:	04 c0       	rjmp	.+8      	; 0x3586 <LEDTick+0xe6>
                    /* LED is off, turn it on */
                    LED_PORT.OUTSET = Mask;
    357e:	80 e1       	ldi	r24, 0x10	; 16
    3580:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    3584:	08 95       	ret
                } else {
                    /* LED is on, turn it off and change state */
                    LED_PORT.OUTCLR = Mask;
    3586:	90 e1       	ldi	r25, 0x10	; 16
    3588:	90 93 06 06 	sts	0x0606, r25	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>

                    if (*Action == LED_BLINK_1X) {
    358c:	80 32       	cpi	r24, 0x20	; 32
    358e:	21 f0       	breq	.+8      	; 0x3598 <LEDTick+0xf8>
                        *Action = LED_NO_ACTION;
                    } else {
                        /* Still some blinks to do. Use the fact that LED_BLINK_XY are ordered sequentially */
                        *Action = *Action - 1;
    3590:	81 50       	subi	r24, 0x01	; 1
    3592:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    3596:	08 95       	ret
            }
            break;

        default:
            /* Should not happen (TM) */
            *Action = LED_NO_ACTION;
    3598:	10 92 95 2c 	sts	0x2C95, r1	; 0x802c95 <LEDGreenAction>
    359c:	08 95       	ret

0000359e <LEDGetFuncList>:
void LEDTick(void) {
    Tick(LED_RED, &LEDRedAction);
    Tick(LED_GREEN, &LEDGreenAction);
}

void LEDGetFuncList(char *List, uint16_t BufferSize) {
    359e:	9b 01       	movw	r18, r22
    MapToString(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap), List, BufferSize);
    35a0:	ac 01       	movw	r20, r24
    35a2:	6b e0       	ldi	r22, 0x0B	; 11
    35a4:	86 e0       	ldi	r24, 0x06	; 6
    35a6:	9b e0       	ldi	r25, 0x0B	; 11
    35a8:	93 c0       	rjmp	.+294    	; 0x36d0 <MapToString>

000035aa <LEDSetFuncById>:
}

void LEDSetFuncById(uint8_t Mask, LEDHookEnum Function) {
    35aa:	e8 ed       	ldi	r30, 0xD8	; 216
    35ac:	ff e2       	ldi	r31, 0x2F	; 47
    35ae:	98 e0       	ldi	r25, 0x08	; 8
    35b0:	28 2f       	mov	r18, r24
    35b2:	20 71       	andi	r18, 0x10	; 16
    35b4:	88 70       	andi	r24, 0x08	; 8
        GlobalSettings.ActiveSettingPtr->LEDRedFunction = Function;
    }
#else
    /* Write LED func to all settings when using global settings */
    for (uint8_t i = 0; i < SETTINGS_COUNT; i++) {
        if (Mask & LED_GREEN) {
    35b6:	21 11       	cpse	r18, r1
            GlobalSettings.Settings[i].LEDGreenFunction = Function;
    35b8:	62 87       	std	Z+10, r22	; 0x0a
        }

        if (Mask & LED_RED) {
    35ba:	81 11       	cpse	r24, r1
            GlobalSettings.Settings[i].LEDRedFunction = Function;
    35bc:	61 87       	std	Z+9, r22	; 0x09
    35be:	91 50       	subi	r25, 0x01	; 1
    35c0:	3c 96       	adiw	r30, 0x0c	; 12
    if (Mask & LED_RED) {
        GlobalSettings.ActiveSettingPtr->LEDRedFunction = Function;
    }
#else
    /* Write LED func to all settings when using global settings */
    for (uint8_t i = 0; i < SETTINGS_COUNT; i++) {
    35c2:	91 11       	cpse	r25, r1
    35c4:	f8 cf       	rjmp	.-16     	; 0x35b6 <LEDSetFuncById+0xc>
        }
    }
#endif

    /* Clear modified LED and remove any pending actions */
    if (Mask & LED_GREEN) {
    35c6:	22 23       	and	r18, r18
    35c8:	29 f0       	breq	.+10     	; 0x35d4 <LEDSetFuncById+0x2a>
        LED_PORT.OUTCLR = LED_GREEN;
    35ca:	90 e1       	ldi	r25, 0x10	; 16
    35cc:	90 93 06 06 	sts	0x0606, r25	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
        LEDGreenAction = LED_NO_ACTION;
    35d0:	10 92 95 2c 	sts	0x2C95, r1	; 0x802c95 <LEDGreenAction>
    }

    if (Mask & LED_RED) {
    35d4:	88 23       	and	r24, r24
    35d6:	29 f0       	breq	.+10     	; 0x35e2 <LEDSetFuncById+0x38>
        LED_PORT.OUTCLR = LED_RED;
    35d8:	88 e0       	ldi	r24, 0x08	; 8
    35da:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
        LEDRedAction = LED_NO_ACTION;
    35de:	10 92 94 2c 	sts	0x2C94, r1	; 0x802c94 <LEDRedAction>
    35e2:	08 95       	ret

000035e4 <LEDGetFuncByName>:
    }

}

void LEDGetFuncByName(uint8_t Mask, char *Function, uint16_t BufferSize) {
    35e4:	0f 93       	push	r16
    35e6:	1f 93       	push	r17
    35e8:	9b 01       	movw	r18, r22
    35ea:	8a 01       	movw	r16, r20
    if (Mask == LED_GREEN) {
    35ec:	80 31       	cpi	r24, 0x10	; 16
    35ee:	31 f4       	brne	.+12     	; 0x35fc <LEDGetFuncByName+0x18>
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
                    GlobalSettings.ActiveSettingPtr->LEDGreenFunction, Function, BufferSize);
    35f0:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    35f4:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>

}

void LEDGetFuncByName(uint8_t Mask, char *Function, uint16_t BufferSize) {
    if (Mask == LED_GREEN) {
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
    35f8:	47 81       	ldd	r20, Z+7	; 0x07
    35fa:	07 c0       	rjmp	.+14     	; 0x360a <LEDGetFuncByName+0x26>
                    GlobalSettings.ActiveSettingPtr->LEDGreenFunction, Function, BufferSize);
    } else if (Mask == LED_RED) {
    35fc:	88 30       	cpi	r24, 0x08	; 8
    35fe:	49 f4       	brne	.+18     	; 0x3612 <LEDGetFuncByName+0x2e>
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
                    GlobalSettings.ActiveSettingPtr->LEDRedFunction, Function, BufferSize);
    3600:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    3604:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
void LEDGetFuncByName(uint8_t Mask, char *Function, uint16_t BufferSize) {
    if (Mask == LED_GREEN) {
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
                    GlobalSettings.ActiveSettingPtr->LEDGreenFunction, Function, BufferSize);
    } else if (Mask == LED_RED) {
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
    3608:	46 81       	ldd	r20, Z+6	; 0x06
    360a:	6b e0       	ldi	r22, 0x0B	; 11
    360c:	86 e0       	ldi	r24, 0x06	; 6
    360e:	9b e0       	ldi	r25, 0x0B	; 11
    3610:	20 d0       	rcall	.+64     	; 0x3652 <MapIdToText>
                    GlobalSettings.ActiveSettingPtr->LEDRedFunction, Function, BufferSize);
    }
}
    3612:	1f 91       	pop	r17
    3614:	0f 91       	pop	r16
    3616:	08 95       	ret

00003618 <LEDSetFuncByName>:

bool LEDSetFuncByName(uint8_t Mask, const char *Function) {
    3618:	0f 93       	push	r16
    361a:	1f 93       	push	r17
    361c:	cf 93       	push	r28
    361e:	df 93       	push	r29
    3620:	1f 92       	push	r1
    3622:	cd b7       	in	r28, 0x3d	; 61
    3624:	de b7       	in	r29, 0x3e	; 62
    3626:	08 2f       	mov	r16, r24
    3628:	ab 01       	movw	r20, r22
    MapIdType Id;

    if (MapTextToId(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap), Function, &Id)) {
    362a:	9e 01       	movw	r18, r28
    362c:	2f 5f       	subi	r18, 0xFF	; 255
    362e:	3f 4f       	sbci	r19, 0xFF	; 255
    3630:	6b e0       	ldi	r22, 0x0B	; 11
    3632:	86 e0       	ldi	r24, 0x06	; 6
    3634:	9b e0       	ldi	r25, 0x0B	; 11
    3636:	25 d0       	rcall	.+74     	; 0x3682 <MapTextToId>
    3638:	18 2f       	mov	r17, r24
    363a:	88 23       	and	r24, r24
    363c:	19 f0       	breq	.+6      	; 0x3644 <LEDSetFuncByName+0x2c>
        LEDSetFuncById(Mask, Id);
    363e:	69 81       	ldd	r22, Y+1	; 0x01
    3640:	80 2f       	mov	r24, r16
    3642:	b3 df       	rcall	.-154    	; 0x35aa <LEDSetFuncById>
        return true;
    } else {
        return false;
    }
}
    3644:	81 2f       	mov	r24, r17
    3646:	0f 90       	pop	r0
    3648:	df 91       	pop	r29
    364a:	cf 91       	pop	r28
    364c:	1f 91       	pop	r17
    364e:	0f 91       	pop	r16
    3650:	08 95       	ret

00003652 <MapIdToText>:
#include "Map.h"

bool MapIdToText(const MapEntryType *MapPtr, uint8_t MapSize, MapIdType Id, char *Text, uint16_t MaxBufferSize) {
    3652:	0f 93       	push	r16
    3654:	1f 93       	push	r17
    3656:	fc 01       	movw	r30, r24
    while (MapSize--) {
    3658:	66 23       	and	r22, r22
    365a:	79 f0       	breq	.+30     	; 0x367a <MapIdToText+0x28>
        if (pgm_read_byte(&MapPtr->Id) == Id) {
    365c:	94 91       	lpm	r25, Z
    365e:	61 50       	subi	r22, 0x01	; 1
    3660:	94 13       	cpse	r25, r20
    3662:	09 c0       	rjmp	.+18     	; 0x3676 <MapIdToText+0x24>
            strncpy_P(Text, MapPtr->Text, MaxBufferSize);
    3664:	bf 01       	movw	r22, r30
    3666:	6f 5f       	subi	r22, 0xFF	; 255
    3668:	7f 4f       	sbci	r23, 0xFF	; 255
    366a:	a8 01       	movw	r20, r16
    366c:	c9 01       	movw	r24, r18
    366e:	0e 94 84 78 	call	0xf108	; 0xf108 <strncpy_P>
            return true;
    3672:	81 e0       	ldi	r24, 0x01	; 1
    3674:	03 c0       	rjmp	.+6      	; 0x367c <MapIdToText+0x2a>
        }

        MapPtr++;
    3676:	b1 96       	adiw	r30, 0x21	; 33
    3678:	ef cf       	rjmp	.-34     	; 0x3658 <MapIdToText+0x6>
    }

    return false;
    367a:	80 e0       	ldi	r24, 0x00	; 0
}
    367c:	1f 91       	pop	r17
    367e:	0f 91       	pop	r16
    3680:	08 95       	ret

00003682 <MapTextToId>:

bool MapTextToId(const MapEntryType *MapPtr, uint8_t MapSize, MapTextPtrType Text, MapIdType *IdPtr) {
    3682:	cf 92       	push	r12
    3684:	df 92       	push	r13
    3686:	ef 92       	push	r14
    3688:	ff 92       	push	r15
    368a:	1f 93       	push	r17
    368c:	cf 93       	push	r28
    368e:	df 93       	push	r29
    3690:	ec 01       	movw	r28, r24
    3692:	7a 01       	movw	r14, r20
    3694:	69 01       	movw	r12, r18
    while (MapSize--) {
    3696:	16 2f       	mov	r17, r22
    3698:	11 23       	and	r17, r17
    369a:	89 f0       	breq	.+34     	; 0x36be <MapTextToId+0x3c>
        if (strcmp_P(Text, MapPtr->Text) == 0) {
    369c:	be 01       	movw	r22, r28
    369e:	6f 5f       	subi	r22, 0xFF	; 255
    36a0:	7f 4f       	sbci	r23, 0xFF	; 255
    36a2:	c7 01       	movw	r24, r14
    36a4:	0e 94 7b 78 	call	0xf0f6	; 0xf0f6 <strcmp_P>
    36a8:	11 50       	subi	r17, 0x01	; 1
    36aa:	89 2b       	or	r24, r25
    36ac:	31 f4       	brne	.+12     	; 0x36ba <MapTextToId+0x38>
            if (sizeof(MapIdType) == 1) {
                *IdPtr = pgm_read_byte(&MapPtr->Id);
    36ae:	fe 01       	movw	r30, r28
    36b0:	c4 91       	lpm	r28, Z
    36b2:	f6 01       	movw	r30, r12
    36b4:	c0 83       	st	Z, r28
            } else if (sizeof(MapIdType) == 2) {
                *IdPtr = pgm_read_word(&MapPtr->Id);
            }
            return true;
    36b6:	81 e0       	ldi	r24, 0x01	; 1
    36b8:	03 c0       	rjmp	.+6      	; 0x36c0 <MapTextToId+0x3e>
        }

        MapPtr++;
    36ba:	a1 96       	adiw	r28, 0x21	; 33
    36bc:	ed cf       	rjmp	.-38     	; 0x3698 <MapTextToId+0x16>
    }

    return false;
    36be:	80 e0       	ldi	r24, 0x00	; 0
}
    36c0:	df 91       	pop	r29
    36c2:	cf 91       	pop	r28
    36c4:	1f 91       	pop	r17
    36c6:	ff 90       	pop	r15
    36c8:	ef 90       	pop	r14
    36ca:	df 90       	pop	r13
    36cc:	cf 90       	pop	r12
    36ce:	08 95       	ret

000036d0 <MapToString>:

void MapToString(MapEntryType *MapPtr, uint8_t MapSize, char *String, uint16_t MaxBufferSize) {
    36d0:	cf 93       	push	r28
    36d2:	01 96       	adiw	r24, 0x01	; 1
            /* More than one map entries left */
            if (BytesLeft == 0) {
                return;
            }

            *String++ = ',';
    36d4:	cc e2       	ldi	r28, 0x2C	; 44

void MapToString(MapEntryType *MapPtr, uint8_t MapSize, char *String, uint16_t MaxBufferSize) {
    uint8_t EntriesLeft = MapSize;
    uint16_t BytesLeft = MaxBufferSize;

    while (EntriesLeft > 0) {
    36d6:	66 23       	and	r22, r22
    36d8:	d1 f0       	breq	.+52     	; 0x370e <MapToString+0x3e>
        const char *Text = MapPtr->Text;
    36da:	fc 01       	movw	r30, r24
    36dc:	da 01       	movw	r26, r20
    36de:	ad 01       	movw	r20, r26
        char c;

        while ((c = pgm_read_byte(Text)) != '\0') {
    36e0:	74 91       	lpm	r23, Z
    36e2:	77 23       	and	r23, r23
    36e4:	41 f0       	breq	.+16     	; 0x36f6 <MapToString+0x26>
            if (BytesLeft == 0) {
    36e6:	21 15       	cp	r18, r1
    36e8:	31 05       	cpc	r19, r1
    36ea:	a9 f0       	breq	.+42     	; 0x3716 <MapToString+0x46>
                return;
            }

            *String++ = c;
    36ec:	7d 93       	st	X+, r23
            Text++;
    36ee:	31 96       	adiw	r30, 0x01	; 1
            BytesLeft--;
    36f0:	21 50       	subi	r18, 0x01	; 1
    36f2:	31 09       	sbc	r19, r1
    36f4:	f4 cf       	rjmp	.-24     	; 0x36de <MapToString+0xe>
        }

        if (EntriesLeft > 1) {
    36f6:	62 30       	cpi	r22, 0x02	; 2
    36f8:	38 f0       	brcs	.+14     	; 0x3708 <MapToString+0x38>
            /* More than one map entries left */
            if (BytesLeft == 0) {
    36fa:	21 15       	cp	r18, r1
    36fc:	31 05       	cpc	r19, r1
    36fe:	59 f0       	breq	.+22     	; 0x3716 <MapToString+0x46>
                return;
            }

            *String++ = ',';
    3700:	fd 01       	movw	r30, r26
    3702:	c0 83       	st	Z, r28
    3704:	4f 5f       	subi	r20, 0xFF	; 255
    3706:	5f 4f       	sbci	r21, 0xFF	; 255
        }

        MapPtr++;
        EntriesLeft--;
    3708:	61 50       	subi	r22, 0x01	; 1
    370a:	81 96       	adiw	r24, 0x21	; 33
    370c:	e4 cf       	rjmp	.-56     	; 0x36d6 <MapToString+0x6>
    }

    /* Terminate string */
    if (BytesLeft > 0) {
    370e:	23 2b       	or	r18, r19
    3710:	11 f0       	breq	.+4      	; 0x3716 <MapToString+0x46>
        *String++ = '\0';
    3712:	fa 01       	movw	r30, r20
    3714:	10 82       	st	Z, r1
        BytesLeft--;
    }
}
    3716:	cf 91       	pop	r28
    3718:	08 95       	ret

0000371a <AntennaLevelTick>:

}

static inline
uint16_t AntennaLevelGet(void) {
    ADCA.CH0.CTRL |= ADC_CH_START_bm;
    371a:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
    371e:	80 68       	ori	r24, 0x80	; 128
    3720:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
    while (!(ADCA.CH0.INTFLAGS & ADC_CH_CHIF_bm));
    3724:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <__TEXT_REGION_LENGTH__+0x700223>
    3728:	80 ff       	sbrs	r24, 0
    372a:	fc cf       	rjmp	.-8      	; 0x3724 <AntennaLevelTick+0xa>

    ADCA.CH0.INTFLAGS = ADC_CH_CHIF_bm;
    372c:	81 e0       	ldi	r24, 0x01	; 1
    372e:	80 93 23 02 	sts	0x0223, r24	; 0x800223 <__TEXT_REGION_LENGTH__+0x700223>

    int16_t Result = ADCA.CH0RES - ANTENNA_LEVEL_OFFSET;
    3732:	a0 91 10 02 	lds	r26, 0x0210	; 0x800210 <__TEXT_REGION_LENGTH__+0x700210>
    3736:	b0 91 11 02 	lds	r27, 0x0211	; 0x800211 <__TEXT_REGION_LENGTH__+0x700211>
#define FIELD_MIN_RSSI 500

void AntennaLevelTick(void) {
    uint16_t rssi = AntennaLevelGet();

    if (rssi < FIELD_MIN_RSSI) {
    373a:	ae 5b       	subi	r26, 0xBE	; 190
    373c:	b1 09       	sbc	r27, r1
    373e:	b7 ff       	sbrs	r27, 7
    3740:	02 c0       	rjmp	.+4      	; 0x3746 <AntennaLevelTick+0x2c>
    3742:	a0 e0       	ldi	r26, 0x00	; 0
    3744:	b0 e0       	ldi	r27, 0x00	; 0
    3746:	20 e0       	ldi	r18, 0x00	; 0
    3748:	38 eb       	ldi	r19, 0xB8	; 184
    374a:	4b e0       	ldi	r20, 0x0B	; 11
    374c:	50 e0       	ldi	r21, 0x00	; 0
    374e:	0e 94 fe 77 	call	0xeffc	; 0xeffc <__mulshisi3>
    3752:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    3756:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    375a:	84 3f       	cpi	r24, 0xF4	; 244
    375c:	91 40       	sbci	r25, 0x01	; 1
    375e:	a8 f4       	brcc	.+42     	; 0x378a <AntennaLevelTick+0x70>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    3760:	87 81       	ldd	r24, Z+7	; 0x07
    3762:	87 30       	cpi	r24, 0x07	; 7
    3764:	19 f4       	brne	.+6      	; 0x376c <AntennaLevelTick+0x52>
        LEDGreenAction = Action;
    3766:	80 e1       	ldi	r24, 0x10	; 16
    3768:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    376c:	86 81       	ldd	r24, Z+6	; 0x06
    376e:	87 30       	cpi	r24, 0x07	; 7
    3770:	19 f4       	brne	.+6      	; 0x3778 <AntennaLevelTick+0x5e>
        LEDRedAction = Action;
    3772:	80 e1       	ldi	r24, 0x10	; 16
    3774:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
        LEDHook(LED_FIELD_DETECTED, LED_OFF);
        if (ActiveConfiguration.UidSize != 0) // this implies that we are emulating right now
    3778:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    377c:	88 23       	and	r24, r24
    377e:	89 f0       	breq	.+34     	; 0x37a2 <AntennaLevelTick+0x88>
INLINE uint16_t ApplicationProcess(uint8_t *ByteBuffer, uint16_t ByteCount) {
    return ActiveConfiguration.ApplicationProcessFunc(ByteBuffer, ByteCount);
}

INLINE void ApplicationReset(void) {
    ActiveConfiguration.ApplicationResetFunc();
    3780:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    3784:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    3788:	19 94       	eijmp

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    378a:	87 81       	ldd	r24, Z+7	; 0x07
    378c:	87 30       	cpi	r24, 0x07	; 7
    378e:	19 f4       	brne	.+6      	; 0x3796 <AntennaLevelTick+0x7c>
        LEDGreenAction = Action;
    3790:	81 e1       	ldi	r24, 0x11	; 17
    3792:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    3796:	86 81       	ldd	r24, Z+6	; 0x06
    3798:	87 30       	cpi	r24, 0x07	; 7
    379a:	19 f4       	brne	.+6      	; 0x37a2 <AntennaLevelTick+0x88>
        LEDRedAction = Action;
    379c:	81 e1       	ldi	r24, 0x11	; 17
    379e:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    37a2:	08 95       	ret

000037a4 <TerminalSendString>:
uint8_t TerminalBuffer[TERMINAL_BUFFER_SIZE];
TerminalStateEnum TerminalState = TERMINAL_UNINITIALIZED;
static uint8_t TerminalInitDelay = INIT_DELAY;

void TerminalSendString(const char *s) {
    CDC_Device_SendString(&TerminalHandle, s);
    37a4:	bc 01       	movw	r22, r24
    37a6:	83 e0       	ldi	r24, 0x03	; 3
    37a8:	90 e2       	ldi	r25, 0x20	; 32
    37aa:	0c 94 89 74 	jmp	0xe912	; 0xe912 <CDC_Device_SendString>

000037ae <TerminalSendStringP>:
}

void TerminalSendStringP(const char *s) {
    37ae:	cf 93       	push	r28
    37b0:	df 93       	push	r29
    char c;

    while ((c = pgm_read_byte(s++)) != '\0') {
    37b2:	fc 01       	movw	r30, r24
    37b4:	64 91       	lpm	r22, Z
    37b6:	ec 01       	movw	r28, r24
    37b8:	21 96       	adiw	r28, 0x01	; 1
    37ba:	66 23       	and	r22, r22
    37bc:	31 f0       	breq	.+12     	; 0x37ca <TerminalSendStringP+0x1c>
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    37be:	83 e0       	ldi	r24, 0x03	; 3
    37c0:	90 e2       	ldi	r25, 0x20	; 32
    37c2:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    37c6:	ce 01       	movw	r24, r28
    37c8:	f4 cf       	rjmp	.-24     	; 0x37b2 <TerminalSendStringP+0x4>
        TerminalSendChar(c);
    }
}
    37ca:	df 91       	pop	r29
    37cc:	cf 91       	pop	r28
    37ce:	08 95       	ret

000037d0 <TerminalSendBlock>:
}

*/


void TerminalSendBlock(const void *Buffer, uint16_t ByteCount) {
    37d0:	ab 01       	movw	r20, r22
    CDC_Device_SendData(&TerminalHandle, Buffer, ByteCount);
    37d2:	bc 01       	movw	r22, r24
    37d4:	83 e0       	ldi	r24, 0x03	; 3
    37d6:	90 e2       	ldi	r25, 0x20	; 32
    37d8:	0c 94 b3 74 	jmp	0xe966	; 0xe966 <CDC_Device_SendData>

000037dc <TerminalInit>:
            break;
    }
}

void TerminalInit(void) {
    TERMINAL_VBUS_PORT.DIRCLR = TERMINAL_VBUS_MASK;
    37dc:	80 e2       	ldi	r24, 0x20	; 32
    37de:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <__TEXT_REGION_LENGTH__+0x700662>
    37e2:	08 95       	ret

000037e4 <TerminalTask>:
}

void TerminalTask(void) {
    37e4:	cf 93       	push	r28
    37e6:	df 93       	push	r29
    if (TerminalState == TERMINAL_INITIALIZED) {
    37e8:	80 91 98 2c 	lds	r24, 0x2C98	; 0x802c98 <TerminalState>
    37ec:	82 30       	cpi	r24, 0x02	; 2
    37ee:	31 f5       	brne	.+76     	; 0x383c <TerminalTask+0x58>
        CDC_Device_USBTask(&TerminalHandle);
    37f0:	83 e0       	ldi	r24, 0x03	; 3
    37f2:	90 e2       	ldi	r25, 0x20	; 32
    37f4:	0e 94 40 75 	call	0xea80	; 0xea80 <CDC_Device_USBTask>
        USB_USBTask();
    37f8:	0e 94 1e 70 	call	0xe03c	; 0xe03c <USB_USBTask>
    CDC_Device_SendData(&TerminalHandle, Buffer, ByteCount);
}


static void ProcessByte(void) {
    int16_t Byte = CDC_Device_ReceiveByte(&TerminalHandle);
    37fc:	83 e0       	ldi	r24, 0x03	; 3
    37fe:	90 e2       	ldi	r25, 0x20	; 32
    3800:	0e 94 5c 75 	call	0xeab8	; 0xeab8 <CDC_Device_ReceiveByte>
    3804:	ec 01       	movw	r28, r24

    if (Byte >= 0) {
    3806:	97 fd       	sbrc	r25, 7
    3808:	19 c0       	rjmp	.+50     	; 0x383c <TerminalTask+0x58>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    380a:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    380e:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    3812:	87 81       	ldd	r24, Z+7	; 0x07
    3814:	83 30       	cpi	r24, 0x03	; 3
    3816:	19 f4       	brne	.+6      	; 0x381e <TerminalTask+0x3a>
        LEDGreenAction = Action;
    3818:	83 e1       	ldi	r24, 0x13	; 19
    381a:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    381e:	86 81       	ldd	r24, Z+6	; 0x06
    3820:	83 30       	cpi	r24, 0x03	; 3
    3822:	19 f4       	brne	.+6      	; 0x382a <TerminalTask+0x46>
        LEDRedAction = Action;
    3824:	83 e1       	ldi	r24, 0x13	; 19
    3826:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
        /* Byte received */
        LEDHook(LED_TERMINAL_RXTX, LED_PULSE);

        if (XModemProcessByte(Byte)) {
    382a:	8c 2f       	mov	r24, r28
    382c:	b9 d6       	rcall	.+3442   	; 0x45a0 <XModemProcessByte>
    382e:	81 11       	cpse	r24, r1
    3830:	05 c0       	rjmp	.+10     	; 0x383c <TerminalTask+0x58>
            /* XModem handled the byte */
        } else if (CommandLineProcessByte(Byte)) {
    3832:	8c 2f       	mov	r24, r28
        CDC_Device_USBTask(&TerminalHandle);
        USB_USBTask();

        ProcessByte();
    }
}
    3834:	df 91       	pop	r29
    3836:	cf 91       	pop	r28
        /* Byte received */
        LEDHook(LED_TERMINAL_RXTX, LED_PULSE);

        if (XModemProcessByte(Byte)) {
            /* XModem handled the byte */
        } else if (CommandLineProcessByte(Byte)) {
    3838:	0c 94 cd 24 	jmp	0x499a	; 0x499a <CommandLineProcessByte>
        CDC_Device_USBTask(&TerminalHandle);
        USB_USBTask();

        ProcessByte();
    }
}
    383c:	df 91       	pop	r29
    383e:	cf 91       	pop	r28
    3840:	08 95       	ret

00003842 <TerminalTick>:
        }
    }
}

static void SenseVBus(void) {
    switch (TerminalState) {
    3842:	80 91 98 2c 	lds	r24, 0x2C98	; 0x802c98 <TerminalState>
    3846:	81 30       	cpi	r24, 0x01	; 1
    3848:	79 f0       	breq	.+30     	; 0x3868 <TerminalTick+0x26>
    384a:	28 f0       	brcs	.+10     	; 0x3856 <TerminalTick+0x14>
    384c:	82 30       	cpi	r24, 0x02	; 2
    384e:	c9 f0       	breq	.+50     	; 0x3882 <TerminalTick+0x40>
    3850:	83 30       	cpi	r24, 0x03	; 3
    3852:	11 f1       	breq	.+68     	; 0x3898 <TerminalTick+0x56>
    3854:	2e c0       	rjmp	.+92     	; 0x38b2 <TerminalTick+0x70>
        case TERMINAL_UNINITIALIZED:
            if (TERMINAL_VBUS_PORT.IN & TERMINAL_VBUS_MASK) {
    3856:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <__TEXT_REGION_LENGTH__+0x700668>
    385a:	85 ff       	sbrs	r24, 5
    385c:	31 c0       	rjmp	.+98     	; 0x38c0 <TerminalTick+0x7e>
                /* Not initialized and VBUS sense high */
                TerminalInitDelay = INIT_DELAY;
    385e:	8f e0       	ldi	r24, 0x0F	; 15
    3860:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <TerminalInitDelay>
                TerminalState = TERMINAL_INITIALIZING;
    3864:	81 e0       	ldi	r24, 0x01	; 1
    3866:	15 c0       	rjmp	.+42     	; 0x3892 <TerminalTick+0x50>
            }
            break;

        case TERMINAL_INITIALIZING:
            if (--TerminalInitDelay == 0) {
    3868:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <TerminalInitDelay>
    386c:	81 50       	subi	r24, 0x01	; 1
    386e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <TerminalInitDelay>
    3872:	81 11       	cpse	r24, r1
    3874:	25 c0       	rjmp	.+74     	; 0x38c0 <TerminalTick+0x7e>
                SystemStartUSBClock();
    3876:	0e 94 46 10 	call	0x208c	; 0x208c <SystemStartUSBClock>
                USB_Init();
    387a:	0e 94 b6 73 	call	0xe76c	; 0xe76c <USB_Init>
                TerminalState = TERMINAL_INITIALIZED;
    387e:	82 e0       	ldi	r24, 0x02	; 2
    3880:	08 c0       	rjmp	.+16     	; 0x3892 <TerminalTick+0x50>
            }
            break;

        case TERMINAL_INITIALIZED:
            if (!(TERMINAL_VBUS_PORT.IN & TERMINAL_VBUS_MASK)) {
    3882:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <__TEXT_REGION_LENGTH__+0x700668>
    3886:	85 fd       	sbrc	r24, 5
    3888:	18 c0       	rjmp	.+48     	; 0x38ba <TerminalTick+0x78>
                /* Initialized and VBUS sense low */
                TerminalInitDelay = INIT_DELAY;
    388a:	8f e0       	ldi	r24, 0x0F	; 15
    388c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <TerminalInitDelay>
                TerminalState = TERMINAL_UNITIALIZING;
    3890:	83 e0       	ldi	r24, 0x03	; 3
    3892:	80 93 98 2c 	sts	0x2C98, r24	; 0x802c98 <TerminalState>
    3896:	0d c0       	rjmp	.+26     	; 0x38b2 <TerminalTick+0x70>
            }
            break;

        case TERMINAL_UNITIALIZING:
            if (--TerminalInitDelay == 0) {
    3898:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <TerminalInitDelay>
    389c:	81 50       	subi	r24, 0x01	; 1
    389e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <TerminalInitDelay>
    38a2:	81 11       	cpse	r24, r1
    38a4:	0d c0       	rjmp	.+26     	; 0x38c0 <TerminalTick+0x7e>
                USB_Disable();
    38a6:	0e 94 7b 73 	call	0xe6f6	; 0xe6f6 <USB_Disable>
                SystemStopUSBClock();
    38aa:	0e 94 74 10 	call	0x20e8	; 0x20e8 <SystemStopUSBClock>
                TerminalState = TERMINAL_UNINITIALIZED;
    38ae:	10 92 98 2c 	sts	0x2C98, r1	; 0x802c98 <TerminalState>
}

void TerminalTick(void) {
    SenseVBus();

    if (TerminalState == TERMINAL_INITIALIZED) {
    38b2:	80 91 98 2c 	lds	r24, 0x2C98	; 0x802c98 <TerminalState>
    38b6:	82 30       	cpi	r24, 0x02	; 2
    38b8:	19 f4       	brne	.+6      	; 0x38c0 <TerminalTick+0x7e>
        XModemTick();
    38ba:	c2 d7       	rcall	.+3972   	; 0x4840 <XModemTick>
        CommandLineTick();
    38bc:	0c 94 94 25 	jmp	0x4b28	; 0x4b28 <CommandLineTick>
    38c0:	08 95       	ret

000038c2 <EVENT_USB_Device_Connect>:

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    38c2:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    38c6:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    38ca:	87 81       	ldd	r24, Z+7	; 0x07
    38cc:	82 30       	cpi	r24, 0x02	; 2
    38ce:	19 f4       	brne	.+6      	; 0x38d6 <EVENT_USB_Device_Connect+0x14>
        LEDGreenAction = Action;
    38d0:	81 e1       	ldi	r24, 0x11	; 17
    38d2:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    38d6:	86 81       	ldd	r24, Z+6	; 0x06
    38d8:	82 30       	cpi	r24, 0x02	; 2
    38da:	19 f4       	brne	.+6      	; 0x38e2 <EVENT_USB_Device_Connect+0x20>
        LEDRedAction = Action;
    38dc:	81 e1       	ldi	r24, 0x11	; 17
    38de:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    38e2:	08 95       	ret

000038e4 <EVENT_USB_Device_Disconnect>:

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    38e4:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    38e8:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    38ec:	87 81       	ldd	r24, Z+7	; 0x07
    38ee:	82 30       	cpi	r24, 0x02	; 2
    38f0:	19 f4       	brne	.+6      	; 0x38f8 <EVENT_USB_Device_Disconnect+0x14>
        LEDGreenAction = Action;
    38f2:	80 e1       	ldi	r24, 0x10	; 16
    38f4:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    38f8:	86 81       	ldd	r24, Z+6	; 0x06
    38fa:	82 30       	cpi	r24, 0x02	; 2
    38fc:	19 f4       	brne	.+6      	; 0x3904 <EVENT_USB_Device_Disconnect+0x20>
        LEDRedAction = Action;
    38fe:	80 e1       	ldi	r24, 0x10	; 16
    3900:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    3904:	08 95       	ret

00003906 <EVENT_USB_Device_ConfigurationChanged>:
}


/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void) {
    CDC_Device_ConfigureEndpoints(&TerminalHandle);
    3906:	83 e0       	ldi	r24, 0x03	; 3
    3908:	90 e2       	ldi	r25, 0x20	; 32
    390a:	0c 94 64 74 	jmp	0xe8c8	; 0xe8c8 <CDC_Device_ConfigureEndpoints>

0000390e <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void) {
    CDC_Device_ProcessControlRequest(&TerminalHandle);
    390e:	83 e0       	ldi	r24, 0x03	; 3
    3910:	90 e2       	ldi	r25, 0x20	; 32
    3912:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <CDC_Device_ProcessControlRequest>

00003916 <CommandGetVersion>:
extern Sniff14443Command Sniff14443CurrentCommand;

extern const PROGMEM CommandEntryType CommandTable[];

CommandStatusIdType CommandGetVersion(char *OutParam) {
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR(
    3916:	29 e1       	ldi	r18, 0x19	; 25
    3918:	3e e0       	ldi	r19, 0x0E	; 14
    391a:	3f 93       	push	r19
    391c:	2f 93       	push	r18
    391e:	23 e1       	ldi	r18, 0x13	; 19
    3920:	3e e0       	ldi	r19, 0x0E	; 14
    3922:	3f 93       	push	r19
    3924:	2f 93       	push	r18
    3926:	2c e0       	ldi	r18, 0x0C	; 12
    3928:	3e e0       	ldi	r19, 0x0E	; 14
    392a:	3f 93       	push	r19
    392c:	2f 93       	push	r18
    392e:	2b e0       	ldi	r18, 0x0B	; 11
    3930:	3e e0       	ldi	r19, 0x0E	; 14
    3932:	3f 93       	push	r19
    3934:	2f 93       	push	r18
    3936:	2b e6       	ldi	r18, 0x6B	; 107
    3938:	3d e0       	ldi	r19, 0x0D	; 13
    393a:	3f 93       	push	r19
    393c:	2f 93       	push	r18
    393e:	22 e0       	ldi	r18, 0x02	; 2
    3940:	2f 93       	push	r18
    3942:	1f 92       	push	r1
    3944:	9f 93       	push	r25
    3946:	8f 93       	push	r24
    3948:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
                   "ChameleonMini RevG %S using LUFA %S compiled with AVR-GCC %S. Based on the open-source NFC tool ChameleonMini. https://github.com/emsec/ChameleonMini commit %S"
               ), PSTR(CHAMELEON_MINI_VERSION_STRING), PSTR(LUFA_VERSION_STRING), PSTR(__VERSION__), PSTR(COMMIT_ID)
              );

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    394c:	8d b7       	in	r24, 0x3d	; 61
    394e:	9e b7       	in	r25, 0x3e	; 62
    3950:	0e 96       	adiw	r24, 0x0e	; 14
    3952:	8d bf       	out	0x3d, r24	; 61
    3954:	9e bf       	out	0x3e, r25	; 62
}
    3956:	85 e6       	ldi	r24, 0x65	; 101
    3958:	08 95       	ret

0000395a <CommandGetConfig>:

CommandStatusIdType CommandGetConfig(char *OutParam) {
    ConfigurationGetByName(OutParam, TERMINAL_BUFFER_SIZE);
    395a:	60 e0       	ldi	r22, 0x00	; 0
    395c:	72 e0       	ldi	r23, 0x02	; 2
    395e:	0e 94 ce 10 	call	0x219c	; 0x219c <ConfigurationGetByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3962:	85 e6       	ldi	r24, 0x65	; 101
    3964:	08 95       	ret

00003966 <CommandSetConfig>:

CommandStatusIdType CommandSetConfig(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3966:	fb 01       	movw	r30, r22
    3968:	20 81       	ld	r18, Z
    396a:	2f 33       	cpi	r18, 0x3F	; 63
    396c:	49 f4       	brne	.+18     	; 0x3980 <CommandSetConfig+0x1a>
    396e:	21 81       	ldd	r18, Z+1	; 0x01
    3970:	21 11       	cpse	r18, r1
    3972:	06 c0       	rjmp	.+12     	; 0x3980 <CommandSetConfig+0x1a>
        ConfigurationGetList(OutMessage, TERMINAL_BUFFER_SIZE);
    3974:	60 e0       	ldi	r22, 0x00	; 0
    3976:	72 e0       	ldi	r23, 0x02	; 2
    3978:	0e 94 0d 11 	call	0x221a	; 0x221a <ConfigurationGetList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    397c:	85 e6       	ldi	r24, 0x65	; 101
    397e:	08 95       	ret
    } else if (ConfigurationSetByName(InParam)) {
    3980:	cb 01       	movw	r24, r22
    3982:	0e 94 df 10 	call	0x21be	; 0x21be <ConfigurationSetByName>
    3986:	88 23       	and	r24, r24
    3988:	71 f0       	breq	.+28     	; 0x39a6 <CommandSetConfig+0x40>
        SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->Configuration);
    398a:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    398e:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
INLINE void SettingUpdate(const void *addr, uint16_t size) {
#if ENABLE_EEPROM_SETTINGS
    uintptr_t EEAddr = (uintptr_t)addr - (uintptr_t)&GlobalSettings + (uintptr_t)&StoredSettings;
    switch (size) {
        case 1:
            eeprom_update_byte((uint8_t *)EEAddr, *(uint8_t *)addr);
    3992:	cf 01       	movw	r24, r30
    3994:	83 5d       	subi	r24, 0xD3	; 211
    3996:	9f 42       	sbci	r25, 0x2F	; 47
    3998:	65 81       	ldd	r22, Z+5	; 0x05
    399a:	8f 5f       	subi	r24, 0xFF	; 255
    399c:	9f 4f       	sbci	r25, 0xFF	; 255
    399e:	0e 94 41 7f 	call	0xfe82	; 0xfe82 <eeprom_update_byte>
        return COMMAND_INFO_OK_ID;
    39a2:	84 e6       	ldi	r24, 0x64	; 100
    39a4:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    39a6:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    39a8:	08 95       	ret

000039aa <CommandGetUid>:

CommandStatusIdType CommandGetUid(char *OutParam) {
    39aa:	ef 92       	push	r14
    39ac:	ff 92       	push	r15
    39ae:	0f 93       	push	r16
    39b0:	1f 93       	push	r17
    39b2:	cf 93       	push	r28
    39b4:	df 93       	push	r29
    39b6:	cd b7       	in	r28, 0x3d	; 61
    39b8:	de b7       	in	r29, 0x3e	; 62
    39ba:	a0 97       	sbiw	r28, 0x20	; 32
    39bc:	cd bf       	out	0x3d, r28	; 61
    39be:	de bf       	out	0x3e, r29	; 62
    39c0:	7c 01       	movw	r14, r24
    uint8_t UidBuffer[COMMAND_UID_BUFSIZE];
    uint16_t UidSize = ActiveConfiguration.UidSize;
    39c2:	00 91 d3 2f 	lds	r16, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    39c6:	10 e0       	ldi	r17, 0x00	; 0

    if (UidSize == 0) {
    39c8:	01 15       	cp	r16, r1
    39ca:	11 05       	cpc	r17, r1
    39cc:	91 f4       	brne	.+36     	; 0x39f2 <CommandGetUid+0x48>
        snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("NO UID."));
    39ce:	83 e6       	ldi	r24, 0x63	; 99
    39d0:	9d e0       	ldi	r25, 0x0D	; 13
    39d2:	9f 93       	push	r25
    39d4:	8f 93       	push	r24
    39d6:	82 e0       	ldi	r24, 0x02	; 2
    39d8:	8f 93       	push	r24
    39da:	1f 92       	push	r1
    39dc:	ff 92       	push	r15
    39de:	ef 92       	push	r14
    39e0:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    39e4:	0f 90       	pop	r0
    39e6:	0f 90       	pop	r0
    39e8:	0f 90       	pop	r0
    39ea:	0f 90       	pop	r0
    39ec:	0f 90       	pop	r0
    39ee:	0f 90       	pop	r0
    39f0:	10 c0       	rjmp	.+32     	; 0x3a12 <CommandGetUid+0x68>
    ActiveConfiguration.ApplicationResetFunc();
    //LogEntry(LOG_INFO_RESET_APP, NULL, 0);
}

INLINE void ApplicationGetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationGetUidFunc(Uid);
    39f2:	e0 91 cd 2f 	lds	r30, 0x2FCD	; 0x802fcd <ActiveConfiguration+0x10>
    39f6:	f0 91 ce 2f 	lds	r31, 0x2FCE	; 0x802fce <ActiveConfiguration+0x11>
    39fa:	ce 01       	movw	r24, r28
    39fc:	01 96       	adiw	r24, 0x01	; 1
    39fe:	19 95       	eicall
    }

    ApplicationGetUid(UidBuffer);

    BufferToHexString(OutParam, TERMINAL_BUFFER_SIZE,
    3a00:	98 01       	movw	r18, r16
    3a02:	ae 01       	movw	r20, r28
    3a04:	4f 5f       	subi	r20, 0xFF	; 255
    3a06:	5f 4f       	sbci	r21, 0xFF	; 255
    3a08:	60 e0       	ldi	r22, 0x00	; 0
    3a0a:	72 e0       	ldi	r23, 0x02	; 2
    3a0c:	c7 01       	movw	r24, r14
    3a0e:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
                      UidBuffer, UidSize);

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3a12:	85 e6       	ldi	r24, 0x65	; 101
    3a14:	a0 96       	adiw	r28, 0x20	; 32
    3a16:	cd bf       	out	0x3d, r28	; 61
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	df 91       	pop	r29
    3a1c:	cf 91       	pop	r28
    3a1e:	1f 91       	pop	r17
    3a20:	0f 91       	pop	r16
    3a22:	ff 90       	pop	r15
    3a24:	ef 90       	pop	r14
    3a26:	08 95       	ret

00003a28 <CommandSetUid>:

CommandStatusIdType CommandSetUid(char *OutMessage, const char *InParam) {
    3a28:	df 92       	push	r13
    3a2a:	ef 92       	push	r14
    3a2c:	ff 92       	push	r15
    3a2e:	0f 93       	push	r16
    3a30:	1f 93       	push	r17
    3a32:	cf 93       	push	r28
    3a34:	df 93       	push	r29
    3a36:	cd b7       	in	r28, 0x3d	; 61
    3a38:	de b7       	in	r29, 0x3e	; 62
    3a3a:	a0 97       	sbiw	r28, 0x20	; 32
    3a3c:	cd bf       	out	0x3d, r28	; 61
    3a3e:	de bf       	out	0x3e, r29	; 62
    3a40:	7b 01       	movw	r14, r22
    uint8_t UidBuffer[COMMAND_UID_BUFSIZE];
    uint16_t UidSize = ActiveConfiguration.UidSize;
    3a42:	00 91 d3 2f 	lds	r16, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    3a46:	10 e0       	ldi	r17, 0x00	; 0

    if (strcmp_P(InParam, PSTR(COMMAND_UID_RANDOM)) == 0) {
    3a48:	6c e5       	ldi	r22, 0x5C	; 92
    3a4a:	7d e0       	ldi	r23, 0x0D	; 13
    3a4c:	c7 01       	movw	r24, r14
    3a4e:	0e 94 7b 78 	call	0xf0f6	; 0xf0f6 <strcmp_P>
    3a52:	89 2b       	or	r24, r25
    3a54:	c1 f4       	brne	.+48     	; 0x3a86 <CommandSetUid+0x5e>
    3a56:	d1 2c       	mov	r13, r1
        /* Load with random bytes */
        for (uint8_t i = 0; i < UidSize; i++) {
    3a58:	ed 2c       	mov	r14, r13
    3a5a:	f1 2c       	mov	r15, r1
    3a5c:	e0 16       	cp	r14, r16
    3a5e:	f1 06       	cpc	r15, r17
    3a60:	58 f4       	brcc	.+22     	; 0x3a78 <CommandSetUid+0x50>
            UidBuffer[i] = RandomGetByte();
    3a62:	0e 94 15 11 	call	0x222a	; 0x222a <RandomGetByte>
    3a66:	e1 e0       	ldi	r30, 0x01	; 1
    3a68:	f0 e0       	ldi	r31, 0x00	; 0
    3a6a:	ec 0f       	add	r30, r28
    3a6c:	fd 1f       	adc	r31, r29
    3a6e:	ee 0d       	add	r30, r14
    3a70:	ff 1d       	adc	r31, r15
    3a72:	80 83       	st	Z, r24
    uint8_t UidBuffer[COMMAND_UID_BUFSIZE];
    uint16_t UidSize = ActiveConfiguration.UidSize;

    if (strcmp_P(InParam, PSTR(COMMAND_UID_RANDOM)) == 0) {
        /* Load with random bytes */
        for (uint8_t i = 0; i < UidSize; i++) {
    3a74:	d3 94       	inc	r13
    3a76:	f0 cf       	rjmp	.-32     	; 0x3a58 <CommandSetUid+0x30>
            UidBuffer[i] = RandomGetByte();
        }
        /* If we are using an ISO15 tag, the first byte needs to be E0 by standard */
        if (ActiveConfiguration.TagFamily == TAG_FAMILY_ISO15693) {
    3a78:	80 91 d5 2f 	lds	r24, 0x2FD5	; 0x802fd5 <ActiveConfiguration+0x18>
    3a7c:	85 30       	cpi	r24, 0x05	; 5
    3a7e:	69 f4       	brne	.+26     	; 0x3a9a <CommandSetUid+0x72>
            UidBuffer[0] = 0xE0;
    3a80:	80 ee       	ldi	r24, 0xE0	; 224
    3a82:	89 83       	std	Y+1, r24	; 0x01
    3a84:	0a c0       	rjmp	.+20     	; 0x3a9a <CommandSetUid+0x72>
        }

    } else {
        /* Convert to Bytes */
        if (HexStringToBuffer(UidBuffer, sizeof(UidBuffer), InParam) != UidSize) {
    3a86:	a7 01       	movw	r20, r14
    3a88:	60 e2       	ldi	r22, 0x20	; 32
    3a8a:	70 e0       	ldi	r23, 0x00	; 0
    3a8c:	ce 01       	movw	r24, r28
    3a8e:	01 96       	adiw	r24, 0x01	; 1
    3a90:	0e 94 5d 11 	call	0x22ba	; 0x22ba <HexStringToBuffer>
    3a94:	08 17       	cp	r16, r24
    3a96:	19 07       	cpc	r17, r25
    3a98:	a1 f4       	brne	.+40     	; 0x3ac2 <CommandSetUid+0x9a>
}

INLINE void ApplicationSetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationSetUidFunc(Uid);
    3a9a:	e0 91 cf 2f 	lds	r30, 0x2FCF	; 0x802fcf <ActiveConfiguration+0x12>
    3a9e:	f0 91 d0 2f 	lds	r31, 0x2FD0	; 0x802fd0 <ActiveConfiguration+0x13>
    3aa2:	ce 01       	movw	r24, r28
    3aa4:	01 96       	adiw	r24, 0x01	; 1
    3aa6:	19 95       	eicall
void LogGetModeByName(char *Mode, uint16_t BufferSize);
void LogGetModeList(char *List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void *Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    3aa8:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    3aac:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    3ab0:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    3ab4:	be 01       	movw	r22, r28
    3ab6:	6f 5f       	subi	r22, 0xFF	; 255
    3ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aba:	83 e1       	ldi	r24, 0x13	; 19
    3abc:	19 95       	eicall
        }
    }

    ApplicationSetUid(UidBuffer);

    return COMMAND_INFO_OK_ID;
    3abe:	84 e6       	ldi	r24, 0x64	; 100
    3ac0:	01 c0       	rjmp	.+2      	; 0x3ac4 <CommandSetUid+0x9c>

    } else {
        /* Convert to Bytes */
        if (HexStringToBuffer(UidBuffer, sizeof(UidBuffer), InParam) != UidSize) {
            /* Malformed input. Abort */
            return COMMAND_ERR_INVALID_PARAM_ID;
    3ac2:	8a ec       	ldi	r24, 0xCA	; 202
    }

    ApplicationSetUid(UidBuffer);

    return COMMAND_INFO_OK_ID;
}
    3ac4:	a0 96       	adiw	r28, 0x20	; 32
    3ac6:	cd bf       	out	0x3d, r28	; 61
    3ac8:	de bf       	out	0x3e, r29	; 62
    3aca:	df 91       	pop	r29
    3acc:	cf 91       	pop	r28
    3ace:	1f 91       	pop	r17
    3ad0:	0f 91       	pop	r16
    3ad2:	ff 90       	pop	r15
    3ad4:	ef 90       	pop	r14
    3ad6:	df 90       	pop	r13
    3ad8:	08 95       	ret

00003ada <CommandGetReadOnly>:

CommandStatusIdType CommandGetReadOnly(char *OutParam) {
    3ada:	fc 01       	movw	r30, r24
    if (ActiveConfiguration.ReadOnly) {
    3adc:	80 91 d4 2f 	lds	r24, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    3ae0:	88 23       	and	r24, r24
    3ae2:	11 f0       	breq	.+4      	; 0x3ae8 <CommandGetReadOnly+0xe>
        OutParam[0] = COMMAND_CHAR_TRUE;
    3ae4:	81 e3       	ldi	r24, 0x31	; 49
    3ae6:	01 c0       	rjmp	.+2      	; 0x3aea <CommandGetReadOnly+0x10>
    } else {
        OutParam[0] = COMMAND_CHAR_FALSE;
    3ae8:	80 e3       	ldi	r24, 0x30	; 48
    3aea:	80 83       	st	Z, r24
    }

    OutParam[1] = '\0';
    3aec:	11 82       	std	Z+1, r1	; 0x01

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3aee:	85 e6       	ldi	r24, 0x65	; 101
    3af0:	08 95       	ret

00003af2 <CommandSetReadOnly>:

CommandStatusIdType CommandSetReadOnly(char *OutMessage, const char *InParam) {
    if (InParam[1] == '\0') {
    3af2:	fb 01       	movw	r30, r22
    3af4:	21 81       	ldd	r18, Z+1	; 0x01
    3af6:	21 11       	cpse	r18, r1
    3af8:	27 c0       	rjmp	.+78     	; 0x3b48 <CommandSetReadOnly+0x56>
        if (InParam[0] == COMMAND_CHAR_TRUE) {
    3afa:	20 81       	ld	r18, Z
    3afc:	21 33       	cpi	r18, 0x31	; 49
    3afe:	21 f4       	brne	.+8      	; 0x3b08 <CommandSetReadOnly+0x16>
            ActiveConfiguration.ReadOnly = true;
    3b00:	81 e0       	ldi	r24, 0x01	; 1
    3b02:	80 93 d4 2f 	sts	0x2FD4, r24	; 0x802fd4 <ActiveConfiguration+0x17>
    3b06:	04 c0       	rjmp	.+8      	; 0x3b10 <CommandSetReadOnly+0x1e>
            return COMMAND_INFO_OK_ID;
        } else if (InParam[0] == COMMAND_CHAR_FALSE) {
    3b08:	20 33       	cpi	r18, 0x30	; 48
    3b0a:	21 f4       	brne	.+8      	; 0x3b14 <CommandSetReadOnly+0x22>
            ActiveConfiguration.ReadOnly = false;
    3b0c:	10 92 d4 2f 	sts	0x2FD4, r1	; 0x802fd4 <ActiveConfiguration+0x17>
            return COMMAND_INFO_OK_ID;
    3b10:	84 e6       	ldi	r24, 0x64	; 100
    3b12:	08 95       	ret
        } else if (InParam[0] == COMMAND_CHAR_SUGGEST) {
    3b14:	2f 33       	cpi	r18, 0x3F	; 63
    3b16:	c1 f4       	brne	.+48     	; 0x3b48 <CommandSetReadOnly+0x56>
            snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("%c,%c"), COMMAND_CHAR_TRUE, COMMAND_CHAR_FALSE);
    3b18:	1f 92       	push	r1
    3b1a:	20 e3       	ldi	r18, 0x30	; 48
    3b1c:	2f 93       	push	r18
    3b1e:	1f 92       	push	r1
    3b20:	21 e3       	ldi	r18, 0x31	; 49
    3b22:	2f 93       	push	r18
    3b24:	26 e5       	ldi	r18, 0x56	; 86
    3b26:	3d e0       	ldi	r19, 0x0D	; 13
    3b28:	3f 93       	push	r19
    3b2a:	2f 93       	push	r18
    3b2c:	22 e0       	ldi	r18, 0x02	; 2
    3b2e:	2f 93       	push	r18
    3b30:	1f 92       	push	r1
    3b32:	9f 93       	push	r25
    3b34:	8f 93       	push	r24
    3b36:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
            return COMMAND_INFO_OK_WITH_TEXT_ID;
    3b3a:	8d b7       	in	r24, 0x3d	; 61
    3b3c:	9e b7       	in	r25, 0x3e	; 62
    3b3e:	0a 96       	adiw	r24, 0x0a	; 10
    3b40:	8d bf       	out	0x3d, r24	; 61
    3b42:	9e bf       	out	0x3e, r25	; 62
    3b44:	85 e6       	ldi	r24, 0x65	; 101
    3b46:	08 95       	ret
        }
    }

    return COMMAND_ERR_INVALID_PARAM_ID;
    3b48:	8a ec       	ldi	r24, 0xCA	; 202
}
    3b4a:	08 95       	ret

00003b4c <CommandExecUpload>:

CommandStatusIdType CommandExecUpload(char *OutMessage) {
    XModemReceive(MemoryUploadBlock);
    3b4c:	8f eb       	ldi	r24, 0xBF	; 191
    3b4e:	93 e1       	ldi	r25, 0x13	; 19
    3b50:	f6 d4       	rcall	.+2540   	; 0x453e <XModemReceive>
    return COMMAND_INFO_XMODEM_WAIT_ID;
}
    3b52:	8e e6       	ldi	r24, 0x6E	; 110
    3b54:	08 95       	ret

00003b56 <CommandExecDownload>:

CommandStatusIdType CommandExecDownload(char *OutMessage) {
    XModemSend(MemoryDownloadBlock);
    3b56:	8f e3       	ldi	r24, 0x3F	; 63
    3b58:	94 e1       	ldi	r25, 0x14	; 20
    3b5a:	0c d5       	rcall	.+2584   	; 0x4574 <XModemSend>
    return COMMAND_INFO_XMODEM_WAIT_ID;
}
    3b5c:	8e e6       	ldi	r24, 0x6E	; 110
    3b5e:	08 95       	ret

00003b60 <CommandExecReset>:
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				USB.CTRLB &= ~USB_ATTACH_bm;
    3b60:	e0 ec       	ldi	r30, 0xC0	; 192
    3b62:	f4 e0       	ldi	r31, 0x04	; 4
    3b64:	81 81       	ldd	r24, Z+1	; 0x01
    3b66:	8e 7f       	andi	r24, 0xFE	; 254
    3b68:	81 83       	std	Z+1, r24	; 0x01

CommandStatusIdType CommandExecReset(char *OutMessage) {
    USB_Detach();
    USB_Disable();
    3b6a:	0e 94 7b 73 	call	0xe6f6	; 0xe6f6 <USB_Disable>

    SystemReset();
    3b6e:	0e 94 3a 10 	call	0x2074	; 0x2074 <SystemReset>

    return COMMAND_INFO_OK_ID;
}
    3b72:	84 e6       	ldi	r24, 0x64	; 100
    3b74:	08 95       	ret

00003b76 <CommandExecUpgrade>:
    3b76:	e0 ec       	ldi	r30, 0xC0	; 192
    3b78:	f4 e0       	ldi	r31, 0x04	; 4
    3b7a:	81 81       	ldd	r24, Z+1	; 0x01
    3b7c:	8e 7f       	andi	r24, 0xFE	; 254
    3b7e:	81 83       	std	Z+1, r24	; 0x01

#ifdef SUPPORT_FIRMWARE_UPGRADE
CommandStatusIdType CommandExecUpgrade(char *OutMessage) {
    USB_Detach();
    USB_Disable();
    3b80:	0e 94 7b 73 	call	0xe6f6	; 0xe6f6 <USB_Disable>

    SystemEnterBootloader();
    3b84:	0e 94 40 10 	call	0x2080	; 0x2080 <SystemEnterBootloader>

    return COMMAND_INFO_OK_ID;
}
    3b88:	84 e6       	ldi	r24, 0x64	; 100
    3b8a:	08 95       	ret

00003b8c <CommandGetMemSize>:
#endif

CommandStatusIdType CommandGetMemSize(char *OutParam) {
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u"), ActiveConfiguration.MemorySize);
    3b8c:	ed eb       	ldi	r30, 0xBD	; 189
    3b8e:	ff e2       	ldi	r31, 0x2F	; 47
    3b90:	25 89       	ldd	r18, Z+21	; 0x15
    3b92:	2f 93       	push	r18
    3b94:	24 89       	ldd	r18, Z+20	; 0x14
    3b96:	2f 93       	push	r18
    3b98:	23 e5       	ldi	r18, 0x53	; 83
    3b9a:	3d e0       	ldi	r19, 0x0D	; 13
    3b9c:	3f 93       	push	r19
    3b9e:	2f 93       	push	r18
    3ba0:	22 e0       	ldi	r18, 0x02	; 2
    3ba2:	2f 93       	push	r18
    3ba4:	1f 92       	push	r1
    3ba6:	9f 93       	push	r25
    3ba8:	8f 93       	push	r24
    3baa:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3bae:	8d b7       	in	r24, 0x3d	; 61
    3bb0:	9e b7       	in	r25, 0x3e	; 62
    3bb2:	08 96       	adiw	r24, 0x08	; 8
    3bb4:	8d bf       	out	0x3d, r24	; 61
    3bb6:	9e bf       	out	0x3e, r25	; 62
}
    3bb8:	85 e6       	ldi	r24, 0x65	; 101
    3bba:	08 95       	ret

00003bbc <CommandGetUidSize>:

CommandStatusIdType CommandGetUidSize(char *OutParam) {
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u"), ActiveConfiguration.UidSize);
    3bbc:	20 91 d3 2f 	lds	r18, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    3bc0:	1f 92       	push	r1
    3bc2:	2f 93       	push	r18
    3bc4:	20 e5       	ldi	r18, 0x50	; 80
    3bc6:	3d e0       	ldi	r19, 0x0D	; 13
    3bc8:	3f 93       	push	r19
    3bca:	2f 93       	push	r18
    3bcc:	22 e0       	ldi	r18, 0x02	; 2
    3bce:	2f 93       	push	r18
    3bd0:	1f 92       	push	r1
    3bd2:	9f 93       	push	r25
    3bd4:	8f 93       	push	r24
    3bd6:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3bda:	8d b7       	in	r24, 0x3d	; 61
    3bdc:	9e b7       	in	r25, 0x3e	; 62
    3bde:	08 96       	adiw	r24, 0x08	; 8
    3be0:	8d bf       	out	0x3d, r24	; 61
    3be2:	9e bf       	out	0x3e, r25	; 62
}
    3be4:	85 e6       	ldi	r24, 0x65	; 101
    3be6:	08 95       	ret

00003be8 <CommandGetRButton>:

CommandStatusIdType CommandGetRButton(char *OutParam) {
    ButtonGetActionByName(BUTTON_R_PRESS_SHORT, OutParam, TERMINAL_BUFFER_SIZE);
    3be8:	40 e0       	ldi	r20, 0x00	; 0
    3bea:	52 e0       	ldi	r21, 0x02	; 2
    3bec:	bc 01       	movw	r22, r24
    3bee:	80 e0       	ldi	r24, 0x00	; 0
    3bf0:	ef d8       	rcall	.-3618   	; 0x2dd0 <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3bf2:	85 e6       	ldi	r24, 0x65	; 101
    3bf4:	08 95       	ret

00003bf6 <CommandSetRButton>:

CommandStatusIdType CommandSetRButton(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3bf6:	fb 01       	movw	r30, r22
    3bf8:	20 81       	ld	r18, Z
    3bfa:	2f 33       	cpi	r18, 0x3F	; 63
    3bfc:	41 f4       	brne	.+16     	; 0x3c0e <CommandSetRButton+0x18>
    3bfe:	21 81       	ldd	r18, Z+1	; 0x01
    3c00:	21 11       	cpse	r18, r1
    3c02:	05 c0       	rjmp	.+10     	; 0x3c0e <CommandSetRButton+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    3c04:	60 e0       	ldi	r22, 0x00	; 0
    3c06:	72 e0       	ldi	r23, 0x02	; 2
    3c08:	d2 d8       	rcall	.-3676   	; 0x2dae <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3c0a:	85 e6       	ldi	r24, 0x65	; 101
    3c0c:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_R_PRESS_SHORT, InParam)) {
    3c0e:	80 e0       	ldi	r24, 0x00	; 0
    3c10:	f1 d8       	rcall	.-3614   	; 0x2df4 <ButtonSetActionByName>
    3c12:	88 23       	and	r24, r24
    3c14:	19 f0       	breq	.+6      	; 0x3c1c <CommandSetRButton+0x26>
        /* Try to set action name */
        SettingsSave();
    3c16:	ab db       	rcall	.-2218   	; 0x336e <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3c18:	84 e6       	ldi	r24, 0x64	; 100
    3c1a:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3c1c:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3c1e:	08 95       	ret

00003c20 <CommandGetRButtonLong>:

CommandStatusIdType CommandGetRButtonLong(char *OutParam) {
    ButtonGetActionByName(BUTTON_R_PRESS_LONG, OutParam, TERMINAL_BUFFER_SIZE);
    3c20:	40 e0       	ldi	r20, 0x00	; 0
    3c22:	52 e0       	ldi	r21, 0x02	; 2
    3c24:	bc 01       	movw	r22, r24
    3c26:	81 e0       	ldi	r24, 0x01	; 1
    3c28:	d3 d8       	rcall	.-3674   	; 0x2dd0 <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3c2a:	85 e6       	ldi	r24, 0x65	; 101
    3c2c:	08 95       	ret

00003c2e <CommandSetRButtonLong>:

CommandStatusIdType CommandSetRButtonLong(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3c2e:	fb 01       	movw	r30, r22
    3c30:	20 81       	ld	r18, Z
    3c32:	2f 33       	cpi	r18, 0x3F	; 63
    3c34:	41 f4       	brne	.+16     	; 0x3c46 <CommandSetRButtonLong+0x18>
    3c36:	21 81       	ldd	r18, Z+1	; 0x01
    3c38:	21 11       	cpse	r18, r1
    3c3a:	05 c0       	rjmp	.+10     	; 0x3c46 <CommandSetRButtonLong+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    3c3c:	60 e0       	ldi	r22, 0x00	; 0
    3c3e:	72 e0       	ldi	r23, 0x02	; 2
    3c40:	b6 d8       	rcall	.-3732   	; 0x2dae <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3c42:	85 e6       	ldi	r24, 0x65	; 101
    3c44:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_R_PRESS_LONG, InParam)) {
    3c46:	81 e0       	ldi	r24, 0x01	; 1
    3c48:	d5 d8       	rcall	.-3670   	; 0x2df4 <ButtonSetActionByName>
    3c4a:	88 23       	and	r24, r24
    3c4c:	19 f0       	breq	.+6      	; 0x3c54 <CommandSetRButtonLong+0x26>
        /* Try to set action name */
        SettingsSave();
    3c4e:	8f db       	rcall	.-2274   	; 0x336e <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3c50:	84 e6       	ldi	r24, 0x64	; 100
    3c52:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3c54:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3c56:	08 95       	ret

00003c58 <CommandGetLButton>:

CommandStatusIdType CommandGetLButton(char *OutParam) {
    ButtonGetActionByName(BUTTON_L_PRESS_SHORT, OutParam, TERMINAL_BUFFER_SIZE);
    3c58:	40 e0       	ldi	r20, 0x00	; 0
    3c5a:	52 e0       	ldi	r21, 0x02	; 2
    3c5c:	bc 01       	movw	r22, r24
    3c5e:	82 e0       	ldi	r24, 0x02	; 2
    3c60:	b7 d8       	rcall	.-3730   	; 0x2dd0 <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3c62:	85 e6       	ldi	r24, 0x65	; 101
    3c64:	08 95       	ret

00003c66 <CommandSetLButton>:

CommandStatusIdType CommandSetLButton(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3c66:	fb 01       	movw	r30, r22
    3c68:	20 81       	ld	r18, Z
    3c6a:	2f 33       	cpi	r18, 0x3F	; 63
    3c6c:	41 f4       	brne	.+16     	; 0x3c7e <CommandSetLButton+0x18>
    3c6e:	21 81       	ldd	r18, Z+1	; 0x01
    3c70:	21 11       	cpse	r18, r1
    3c72:	05 c0       	rjmp	.+10     	; 0x3c7e <CommandSetLButton+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    3c74:	60 e0       	ldi	r22, 0x00	; 0
    3c76:	72 e0       	ldi	r23, 0x02	; 2
    3c78:	9a d8       	rcall	.-3788   	; 0x2dae <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3c7a:	85 e6       	ldi	r24, 0x65	; 101
    3c7c:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_L_PRESS_SHORT, InParam)) {
    3c7e:	82 e0       	ldi	r24, 0x02	; 2
    3c80:	b9 d8       	rcall	.-3726   	; 0x2df4 <ButtonSetActionByName>
    3c82:	88 23       	and	r24, r24
    3c84:	19 f0       	breq	.+6      	; 0x3c8c <CommandSetLButton+0x26>
        /* Try to set action name */
        SettingsSave();
    3c86:	73 db       	rcall	.-2330   	; 0x336e <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3c88:	84 e6       	ldi	r24, 0x64	; 100
    3c8a:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3c8c:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3c8e:	08 95       	ret

00003c90 <CommandGetLButtonLong>:

CommandStatusIdType CommandGetLButtonLong(char *OutParam) {
    ButtonGetActionByName(BUTTON_L_PRESS_LONG, OutParam, TERMINAL_BUFFER_SIZE);
    3c90:	40 e0       	ldi	r20, 0x00	; 0
    3c92:	52 e0       	ldi	r21, 0x02	; 2
    3c94:	bc 01       	movw	r22, r24
    3c96:	83 e0       	ldi	r24, 0x03	; 3
    3c98:	9b d8       	rcall	.-3786   	; 0x2dd0 <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3c9a:	85 e6       	ldi	r24, 0x65	; 101
    3c9c:	08 95       	ret

00003c9e <CommandSetLButtonLong>:

CommandStatusIdType CommandSetLButtonLong(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3c9e:	fb 01       	movw	r30, r22
    3ca0:	20 81       	ld	r18, Z
    3ca2:	2f 33       	cpi	r18, 0x3F	; 63
    3ca4:	41 f4       	brne	.+16     	; 0x3cb6 <CommandSetLButtonLong+0x18>
    3ca6:	21 81       	ldd	r18, Z+1	; 0x01
    3ca8:	21 11       	cpse	r18, r1
    3caa:	05 c0       	rjmp	.+10     	; 0x3cb6 <CommandSetLButtonLong+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    3cac:	60 e0       	ldi	r22, 0x00	; 0
    3cae:	72 e0       	ldi	r23, 0x02	; 2
    3cb0:	7e d8       	rcall	.-3844   	; 0x2dae <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3cb2:	85 e6       	ldi	r24, 0x65	; 101
    3cb4:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_L_PRESS_LONG, InParam)) {
    3cb6:	83 e0       	ldi	r24, 0x03	; 3
    3cb8:	9d d8       	rcall	.-3782   	; 0x2df4 <ButtonSetActionByName>
    3cba:	88 23       	and	r24, r24
    3cbc:	19 f0       	breq	.+6      	; 0x3cc4 <CommandSetLButtonLong+0x26>
        /* Try to set action name */
        SettingsSave();
    3cbe:	57 db       	rcall	.-2386   	; 0x336e <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3cc0:	84 e6       	ldi	r24, 0x64	; 100
    3cc2:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3cc4:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3cc6:	08 95       	ret

00003cc8 <CommandGetLedGreen>:

CommandStatusIdType CommandGetLedGreen(char *OutParam) {
    LEDGetFuncByName(LED_GREEN, OutParam, TERMINAL_BUFFER_SIZE);
    3cc8:	40 e0       	ldi	r20, 0x00	; 0
    3cca:	52 e0       	ldi	r21, 0x02	; 2
    3ccc:	bc 01       	movw	r22, r24
    3cce:	80 e1       	ldi	r24, 0x10	; 16
    3cd0:	89 dc       	rcall	.-1774   	; 0x35e4 <LEDGetFuncByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3cd2:	85 e6       	ldi	r24, 0x65	; 101
    3cd4:	08 95       	ret

00003cd6 <CommandSetLedGreen>:

CommandStatusIdType CommandSetLedGreen(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3cd6:	fb 01       	movw	r30, r22
    3cd8:	20 81       	ld	r18, Z
    3cda:	2f 33       	cpi	r18, 0x3F	; 63
    3cdc:	41 f4       	brne	.+16     	; 0x3cee <CommandSetLedGreen+0x18>
    3cde:	21 81       	ldd	r18, Z+1	; 0x01
    3ce0:	21 11       	cpse	r18, r1
    3ce2:	05 c0       	rjmp	.+10     	; 0x3cee <CommandSetLedGreen+0x18>
        LEDGetFuncList(OutMessage, TERMINAL_BUFFER_SIZE);
    3ce4:	60 e0       	ldi	r22, 0x00	; 0
    3ce6:	72 e0       	ldi	r23, 0x02	; 2
    3ce8:	5a dc       	rcall	.-1868   	; 0x359e <LEDGetFuncList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3cea:	85 e6       	ldi	r24, 0x65	; 101
    3cec:	08 95       	ret
    } else if (LEDSetFuncByName(LED_GREEN, InParam)) {
    3cee:	80 e1       	ldi	r24, 0x10	; 16
    3cf0:	93 dc       	rcall	.-1754   	; 0x3618 <LEDSetFuncByName>
    3cf2:	88 23       	and	r24, r24
        SettingsSave();
    3cf4:	19 f0       	breq	.+6      	; 0x3cfc <CommandSetLedGreen+0x26>
    3cf6:	3b db       	rcall	.-2442   	; 0x336e <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3cf8:	84 e6       	ldi	r24, 0x64	; 100
    3cfa:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3cfc:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3cfe:	08 95       	ret

00003d00 <CommandGetLedRed>:

CommandStatusIdType CommandGetLedRed(char *OutParam) {
    LEDGetFuncByName(LED_RED, OutParam, TERMINAL_BUFFER_SIZE);
    3d00:	40 e0       	ldi	r20, 0x00	; 0
    3d02:	52 e0       	ldi	r21, 0x02	; 2
    3d04:	bc 01       	movw	r22, r24
    3d06:	88 e0       	ldi	r24, 0x08	; 8
    3d08:	6d dc       	rcall	.-1830   	; 0x35e4 <LEDGetFuncByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3d0a:	85 e6       	ldi	r24, 0x65	; 101
    3d0c:	08 95       	ret

00003d0e <CommandSetLedRed>:

CommandStatusIdType CommandSetLedRed(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3d0e:	fb 01       	movw	r30, r22
    3d10:	20 81       	ld	r18, Z
    3d12:	2f 33       	cpi	r18, 0x3F	; 63
    3d14:	41 f4       	brne	.+16     	; 0x3d26 <CommandSetLedRed+0x18>
    3d16:	21 81       	ldd	r18, Z+1	; 0x01
    3d18:	21 11       	cpse	r18, r1
    3d1a:	05 c0       	rjmp	.+10     	; 0x3d26 <CommandSetLedRed+0x18>
        LEDGetFuncList(OutMessage, TERMINAL_BUFFER_SIZE);
    3d1c:	60 e0       	ldi	r22, 0x00	; 0
    3d1e:	72 e0       	ldi	r23, 0x02	; 2
    3d20:	3e dc       	rcall	.-1924   	; 0x359e <LEDGetFuncList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3d22:	85 e6       	ldi	r24, 0x65	; 101
    3d24:	08 95       	ret
    } else if (LEDSetFuncByName(LED_RED, InParam)) {
    3d26:	88 e0       	ldi	r24, 0x08	; 8
    3d28:	77 dc       	rcall	.-1810   	; 0x3618 <LEDSetFuncByName>
    3d2a:	88 23       	and	r24, r24
        SettingsSave();
    3d2c:	19 f0       	breq	.+6      	; 0x3d34 <CommandSetLedRed+0x26>
    3d2e:	1f db       	rcall	.-2498   	; 0x336e <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3d30:	84 e6       	ldi	r24, 0x64	; 100
    3d32:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3d34:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3d36:	08 95       	ret

00003d38 <CommandGetLogMode>:

CommandStatusIdType CommandGetLogMode(char *OutParam) {
    /* Get Logmode */
    LogGetModeByName(OutParam, TERMINAL_BUFFER_SIZE);
    3d38:	60 e0       	ldi	r22, 0x00	; 0
    3d3a:	72 e0       	ldi	r23, 0x02	; 2
    3d3c:	70 da       	rcall	.-2848   	; 0x321e <LogGetModeByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3d3e:	85 e6       	ldi	r24, 0x65	; 101
    3d40:	08 95       	ret

00003d42 <CommandSetLogMode>:

CommandStatusIdType CommandSetLogMode(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3d42:	fb 01       	movw	r30, r22
    3d44:	20 81       	ld	r18, Z
    3d46:	2f 33       	cpi	r18, 0x3F	; 63
    3d48:	41 f4       	brne	.+16     	; 0x3d5a <CommandSetLogMode+0x18>
    3d4a:	21 81       	ldd	r18, Z+1	; 0x01
    3d4c:	21 11       	cpse	r18, r1
    3d4e:	05 c0       	rjmp	.+10     	; 0x3d5a <CommandSetLogMode+0x18>
        LogGetModeList(OutMessage, TERMINAL_BUFFER_SIZE);
    3d50:	60 e0       	ldi	r22, 0x00	; 0
    3d52:	72 e0       	ldi	r23, 0x02	; 2
    3d54:	74 da       	rcall	.-2840   	; 0x323e <LogGetModeList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3d56:	85 e6       	ldi	r24, 0x65	; 101
    3d58:	08 95       	ret
    } else if (LogSetModeByName(InParam)) {
    3d5a:	cb 01       	movw	r24, r22
    3d5c:	47 da       	rcall	.-2930   	; 0x31ec <LogSetModeByName>
    3d5e:	88 23       	and	r24, r24
        SettingsSave();
    3d60:	19 f0       	breq	.+6      	; 0x3d68 <CommandSetLogMode+0x26>
    3d62:	05 db       	rcall	.-2550   	; 0x336e <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3d64:	84 e6       	ldi	r24, 0x64	; 100
    3d66:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3d68:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3d6a:	08 95       	ret

00003d6c <CommandGetLogMem>:

CommandStatusIdType CommandGetLogMem(char *OutParam) {
    3d6c:	cf 93       	push	r28
    3d6e:	df 93       	push	r29
    3d70:	ec 01       	movw	r28, r24
    uint16_t free = LogMemFree();
    3d72:	5c d9       	rcall	.-3400   	; 0x302c <LogMemFree>
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE,
    3d74:	81 30       	cpi	r24, 0x01	; 1
    3d76:	28 e0       	ldi	r18, 0x08	; 8
    3d78:	92 07       	cpc	r25, r18
    3d7a:	18 f0       	brcs	.+6      	; 0x3d82 <CommandGetLogMem+0x16>
    3d7c:	9c 01       	movw	r18, r24
    3d7e:	38 50       	subi	r19, 0x08	; 8
    3d80:	02 c0       	rjmp	.+4      	; 0x3d86 <CommandGetLogMem+0x1a>
    3d82:	20 e0       	ldi	r18, 0x00	; 0
    3d84:	30 e0       	ldi	r19, 0x00	; 0
    3d86:	3f 93       	push	r19
    3d88:	2f 93       	push	r18
    3d8a:	9f 93       	push	r25
    3d8c:	8f 93       	push	r24
    3d8e:	80 e3       	ldi	r24, 0x30	; 48
    3d90:	9d e0       	ldi	r25, 0x0D	; 13
    3d92:	9f 93       	push	r25
    3d94:	8f 93       	push	r24
    3d96:	82 e0       	ldi	r24, 0x02	; 2
    3d98:	8f 93       	push	r24
    3d9a:	1f 92       	push	r1
    3d9c:	df 93       	push	r29
    3d9e:	cf 93       	push	r28
    3da0:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
               PSTR("%u (from which %u non-volatile)"), free, (free <= LOG_SIZE) ? 0 : (free - LOG_SIZE));


    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3da4:	8d b7       	in	r24, 0x3d	; 61
    3da6:	9e b7       	in	r25, 0x3e	; 62
    3da8:	0a 96       	adiw	r24, 0x0a	; 10
    3daa:	8d bf       	out	0x3d, r24	; 61
    3dac:	9e bf       	out	0x3e, r25	; 62
}
    3dae:	85 e6       	ldi	r24, 0x65	; 101
    3db0:	df 91       	pop	r29
    3db2:	cf 91       	pop	r28
    3db4:	08 95       	ret

00003db6 <CommandExecLogDownload>:


CommandStatusIdType CommandExecLogDownload(char *OutMessage) {
    XModemSend(LogMemLoadBlock);
    3db6:	85 e4       	ldi	r24, 0x45	; 69
    3db8:	97 e1       	ldi	r25, 0x17	; 23
    3dba:	dc d3       	rcall	.+1976   	; 0x4574 <XModemSend>
    return COMMAND_INFO_XMODEM_WAIT_ID;
}
    3dbc:	8e e6       	ldi	r24, 0x6E	; 110
    3dbe:	08 95       	ret

00003dc0 <CommandExecStoreLog>:

CommandStatusIdType CommandExecStoreLog(char *OutMessage) {
    LogSRAMToFRAM();
    3dc0:	44 da       	rcall	.-2936   	; 0x324a <LogSRAMToFRAM>
    return COMMAND_INFO_OK_ID;
}
    3dc2:	84 e6       	ldi	r24, 0x64	; 100
    3dc4:	08 95       	ret

00003dc6 <CommandExecLogClear>:

CommandStatusIdType CommandExecLogClear(char *OutMessage) {
    LogMemClear();
    3dc6:	f6 d8       	rcall	.-3604   	; 0x2fb4 <LogMemClear>
    return COMMAND_INFO_OK_ID;
}
    3dc8:	84 e6       	ldi	r24, 0x64	; 100
    3dca:	08 95       	ret

00003dcc <CommandGetSetting>:

CommandStatusIdType CommandGetSetting(char *OutParam) {
    SettingsGetActiveByName(OutParam, TERMINAL_BUFFER_SIZE);
    3dcc:	60 e0       	ldi	r22, 0x00	; 0
    3dce:	72 e0       	ldi	r23, 0x02	; 2
    3dd0:	47 db       	rcall	.-2418   	; 0x3460 <SettingsGetActiveByName>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3dd2:	85 e6       	ldi	r24, 0x65	; 101
    3dd4:	08 95       	ret

00003dd6 <CommandSetSetting>:

CommandStatusIdType CommandSetSetting(char *OutMessage, const char *InParam) {
    3dd6:	cb 01       	movw	r24, r22
    if (SettingsSetActiveByName(InParam)) {
    3dd8:	4a db       	rcall	.-2412   	; 0x346e <SettingsSetActiveByName>
    3dda:	81 11       	cpse	r24, r1
    3ddc:	02 c0       	rjmp	.+4      	; 0x3de2 <CommandSetSetting+0xc>
        return COMMAND_INFO_OK_ID;
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3dde:	8a ec       	ldi	r24, 0xCA	; 202
    3de0:	08 95       	ret
    return COMMAND_INFO_OK_WITH_TEXT_ID;
}

CommandStatusIdType CommandSetSetting(char *OutMessage, const char *InParam) {
    if (SettingsSetActiveByName(InParam)) {
        return COMMAND_INFO_OK_ID;
    3de2:	84 e6       	ldi	r24, 0x64	; 100
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    }
}
    3de4:	08 95       	ret

00003de6 <CommandExecClear>:

CommandStatusIdType CommandExecClear(char *OutMessage) {
    MemoryClear();
    3de6:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <MemoryClear>
    return COMMAND_INFO_OK_ID;
}
    3dea:	84 e6       	ldi	r24, 0x64	; 100
    3dec:	08 95       	ret

00003dee <CommandExecStore>:

CommandStatusIdType CommandExecStore(char *OutMessage) {
    MemoryStore();
    3dee:	0e 94 28 13 	call	0x2650	; 0x2650 <MemoryStore>
    return COMMAND_INFO_OK_ID;
}
    3df2:	84 e6       	ldi	r24, 0x64	; 100
    3df4:	08 95       	ret

00003df6 <CommandExecRecall>:

CommandStatusIdType CommandExecRecall(char *OutMessage) {
    MemoryRecall();
    3df6:	0e 94 83 12 	call	0x2506	; 0x2506 <MemoryRecall>
    return COMMAND_INFO_OK_ID;
}
    3dfa:	84 e6       	ldi	r24, 0x64	; 100
    3dfc:	08 95       	ret

00003dfe <CommandGetCharging>:
    BATTERY_PORT.DIRCLR = BATTERY_PORT_MASK;
    BATTERY_PORT.BATTERY_STAT_PINCTRL = PORT_OPC_PULLUP_gc;
}

INLINE bool BatteryIsCharging(void) {
    if (!(BATTERY_PORT.IN & BATTERY_STAT_PIN)) {
    3dfe:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <__TEXT_REGION_LENGTH__+0x700668>
    3e02:	80 fd       	sbrc	r24, 0
    3e04:	02 c0       	rjmp	.+4      	; 0x3e0a <CommandGetCharging+0xc>

CommandStatusIdType CommandGetCharging(char *OutMessage) {
    if (BatteryIsCharging()) {
        return COMMAND_INFO_TRUE_ID;
    3e06:	89 e7       	ldi	r24, 0x79	; 121
    3e08:	08 95       	ret
    } else {
        return COMMAND_INFO_FALSE_ID;
    3e0a:	88 e7       	ldi	r24, 0x78	; 120
    }
}
    3e0c:	08 95       	ret

00003e0e <CommandExecHelp>:

CommandStatusIdType CommandExecHelp(char *OutMessage) {
    3e0e:	df 92       	push	r13
    3e10:	ef 92       	push	r14
    3e12:	ff 92       	push	r15
    3e14:	0f 93       	push	r16
    3e16:	1f 93       	push	r17
    3e18:	cf 93       	push	r28
    3e1a:	df 93       	push	r29
    3e1c:	ec 01       	movw	r28, r24
    const CommandEntryType *EntryPtr = CommandTable;
    uint16_t ByteCount = TERMINAL_BUFFER_SIZE - 1; /* Account for '\0' */
    3e1e:	0f ef       	ldi	r16, 0xFF	; 255
    3e20:	11 e0       	ldi	r17, 0x01	; 1
        return COMMAND_INFO_FALSE_ID;
    }
}

CommandStatusIdType CommandExecHelp(char *OutMessage) {
    const CommandEntryType *EntryPtr = CommandTable;
    3e22:	8c e5       	ldi	r24, 0x5C	; 92
    3e24:	e8 2e       	mov	r14, r24
    3e26:	8f e0       	ldi	r24, 0x0F	; 15
    3e28:	f8 2e       	mov	r15, r24
            *OutMessage++ = c;
            CommandName++;
            ByteCount--;
        }

        *OutMessage++ = ',';
    3e2a:	9c e2       	ldi	r25, 0x2C	; 44
    3e2c:	d9 2e       	mov	r13, r25

CommandStatusIdType CommandExecHelp(char *OutMessage) {
    const CommandEntryType *EntryPtr = CommandTable;
    uint16_t ByteCount = TERMINAL_BUFFER_SIZE - 1; /* Account for '\0' */

    while (strcmp_P(COMMAND_LIST_END, EntryPtr->Command) != 0 && ByteCount > 0) {
    3e2e:	b7 01       	movw	r22, r14
    3e30:	89 ee       	ldi	r24, 0xE9	; 233
    3e32:	93 e2       	ldi	r25, 0x23	; 35
    3e34:	0e 94 7b 78 	call	0xf0f6	; 0xf0f6 <strcmp_P>
    3e38:	89 2b       	or	r24, r25
    3e3a:	d1 f0       	breq	.+52     	; 0x3e70 <CommandExecHelp+0x62>
    3e3c:	01 15       	cp	r16, r1
    3e3e:	11 05       	cpc	r17, r1
    3e40:	b9 f0       	breq	.+46     	; 0x3e70 <CommandExecHelp+0x62>
    3e42:	de 01       	movw	r26, r28
    3e44:	f7 01       	movw	r30, r14
        const char *CommandName = EntryPtr->Command;
        char c;

        while ((c = pgm_read_byte(CommandName)) != '\0' && ByteCount > 1) {
    3e46:	24 91       	lpm	r18, Z
    3e48:	ed 01       	movw	r28, r26
    3e4a:	21 96       	adiw	r28, 0x01	; 1
    3e4c:	c8 01       	movw	r24, r16
    3e4e:	01 97       	sbiw	r24, 0x01	; 1
    3e50:	22 23       	and	r18, r18
    3e52:	41 f0       	breq	.+16     	; 0x3e64 <CommandExecHelp+0x56>
    3e54:	01 30       	cpi	r16, 0x01	; 1
    3e56:	11 05       	cpc	r17, r1
    3e58:	29 f0       	breq	.+10     	; 0x3e64 <CommandExecHelp+0x56>
            *OutMessage++ = c;
    3e5a:	2c 93       	st	X, r18
    3e5c:	de 01       	movw	r26, r28
            CommandName++;
    3e5e:	31 96       	adiw	r30, 0x01	; 1
            ByteCount--;
    3e60:	8c 01       	movw	r16, r24
    3e62:	f1 cf       	rjmp	.-30     	; 0x3e46 <CommandExecHelp+0x38>
        }

        *OutMessage++ = ',';
    3e64:	dc 92       	st	X, r13
        ByteCount--;
    3e66:	8c 01       	movw	r16, r24

        EntryPtr++;
    3e68:	88 e1       	ldi	r24, 0x18	; 24
    3e6a:	e8 0e       	add	r14, r24
    3e6c:	f1 1c       	adc	r15, r1
    3e6e:	df cf       	rjmp	.-66     	; 0x3e2e <CommandExecHelp+0x20>
    }

    *--OutMessage = '\0';
    3e70:	21 97       	sbiw	r28, 0x01	; 1
    3e72:	18 82       	st	Y, r1

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3e74:	85 e6       	ldi	r24, 0x65	; 101
    3e76:	df 91       	pop	r29
    3e78:	cf 91       	pop	r28
    3e7a:	1f 91       	pop	r17
    3e7c:	0f 91       	pop	r16
    3e7e:	ff 90       	pop	r15
    3e80:	ef 90       	pop	r14
    3e82:	df 90       	pop	r13
    3e84:	08 95       	ret

00003e86 <CommandGetRssi>:

CommandStatusIdType CommandGetRssi(char *OutParam) {
    3e86:	fc 01       	movw	r30, r24

}

static inline
uint16_t AntennaLevelGet(void) {
    ADCA.CH0.CTRL |= ADC_CH_START_bm;
    3e88:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
    3e8c:	80 68       	ori	r24, 0x80	; 128
    3e8e:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
    while (!(ADCA.CH0.INTFLAGS & ADC_CH_CHIF_bm));
    3e92:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <__TEXT_REGION_LENGTH__+0x700223>
    3e96:	80 ff       	sbrs	r24, 0
    3e98:	fc cf       	rjmp	.-8      	; 0x3e92 <CommandGetRssi+0xc>

    ADCA.CH0.INTFLAGS = ADC_CH_CHIF_bm;
    3e9a:	81 e0       	ldi	r24, 0x01	; 1
    3e9c:	80 93 23 02 	sts	0x0223, r24	; 0x800223 <__TEXT_REGION_LENGTH__+0x700223>

    int16_t Result = ADCA.CH0RES - ANTENNA_LEVEL_OFFSET;
    3ea0:	a0 91 10 02 	lds	r26, 0x0210	; 0x800210 <__TEXT_REGION_LENGTH__+0x700210>
    3ea4:	b0 91 11 02 	lds	r27, 0x0211	; 0x800211 <__TEXT_REGION_LENGTH__+0x700211>
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE,
    3ea8:	ae 5b       	subi	r26, 0xBE	; 190
    3eaa:	b1 09       	sbc	r27, r1
    3eac:	b7 ff       	sbrs	r27, 7
    3eae:	02 c0       	rjmp	.+4      	; 0x3eb4 <CommandGetRssi+0x2e>
    3eb0:	a0 e0       	ldi	r26, 0x00	; 0
    3eb2:	b0 e0       	ldi	r27, 0x00	; 0
    3eb4:	20 e0       	ldi	r18, 0x00	; 0
    3eb6:	38 eb       	ldi	r19, 0xB8	; 184
    3eb8:	4b e0       	ldi	r20, 0x0B	; 11
    3eba:	50 e0       	ldi	r21, 0x00	; 0
    3ebc:	0e 94 fe 77 	call	0xeffc	; 0xeffc <__mulshisi3>
    3ec0:	aa 27       	eor	r26, r26
    3ec2:	bb 27       	eor	r27, r27
    3ec4:	9f 93       	push	r25
    3ec6:	8f 93       	push	r24
    3ec8:	89 e2       	ldi	r24, 0x29	; 41
    3eca:	9d e0       	ldi	r25, 0x0D	; 13
    3ecc:	9f 93       	push	r25
    3ece:	8f 93       	push	r24
    3ed0:	82 e0       	ldi	r24, 0x02	; 2
    3ed2:	8f 93       	push	r24
    3ed4:	1f 92       	push	r1
    3ed6:	ff 93       	push	r31
    3ed8:	ef 93       	push	r30
    3eda:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
               PSTR("%5u mV"), AntennaLevelGet());

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3ede:	8d b7       	in	r24, 0x3d	; 61
    3ee0:	9e b7       	in	r25, 0x3e	; 62
    3ee2:	08 96       	adiw	r24, 0x08	; 8
    3ee4:	8d bf       	out	0x3d, r24	; 61
    3ee6:	9e bf       	out	0x3e, r25	; 62
}
    3ee8:	85 e6       	ldi	r24, 0x65	; 101
    3eea:	08 95       	ret

00003eec <CommandGetSysTick>:

    RTC.INTFLAGS = RTC_COMPIF_bm;
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    3eec:	4e b1       	in	r20, 0x0e	; 14
    3eee:	5f b1       	in	r21, 0x0f	; 15
    3ef0:	20 91 08 04 	lds	r18, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    3ef4:	30 91 09 04 	lds	r19, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>

CommandStatusIdType CommandGetSysTick(char *OutParam) {
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%4.4X"), SystemGetSysTick());
    3ef8:	24 2b       	or	r18, r20
    3efa:	35 2b       	or	r19, r21
    3efc:	3f 93       	push	r19
    3efe:	2f 93       	push	r18
    3f00:	23 e2       	ldi	r18, 0x23	; 35
    3f02:	3d e0       	ldi	r19, 0x0D	; 13
    3f04:	3f 93       	push	r19
    3f06:	2f 93       	push	r18
    3f08:	22 e0       	ldi	r18, 0x02	; 2
    3f0a:	2f 93       	push	r18
    3f0c:	1f 92       	push	r1
    3f0e:	9f 93       	push	r25
    3f10:	8f 93       	push	r24
    3f12:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3f16:	8d b7       	in	r24, 0x3d	; 61
    3f18:	9e b7       	in	r25, 0x3e	; 62
    3f1a:	08 96       	adiw	r24, 0x08	; 8
    3f1c:	8d bf       	out	0x3d, r24	; 61
    3f1e:	9e bf       	out	0x3e, r25	; 62
}
    3f20:	85 e6       	ldi	r24, 0x65	; 101
    3f22:	08 95       	ret

00003f24 <CommandExecParamSend>:

CommandStatusIdType CommandExecParamSend(char *OutMessage, const char *InParams) {
    3f24:	0f 93       	push	r16
    3f26:	1f 93       	push	r17
    3f28:	cf 93       	push	r28
    3f2a:	df 93       	push	r29
    3f2c:	1f 92       	push	r1
    3f2e:	1f 92       	push	r1
    3f30:	cd b7       	in	r28, 0x3d	; 61
    3f32:	de b7       	in	r29, 0x3e	; 62
    3f34:	8b 01       	movw	r16, r22
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    3f36:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    3f3a:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    3f3e:	85 81       	ldd	r24, Z+5	; 0x05
    3f40:	8b 30       	cpi	r24, 0x0B	; 11
    3f42:	09 f0       	breq	.+2      	; 0x3f46 <CommandExecParamSend+0x22>
    3f44:	6f c0       	rjmp	.+222    	; 0x4024 <__stack+0x25>
INLINE uint16_t ApplicationProcess(uint8_t *ByteBuffer, uint16_t ByteCount) {
    return ActiveConfiguration.ApplicationProcessFunc(ByteBuffer, ByteCount);
}

INLINE void ApplicationReset(void) {
    ActiveConfiguration.ApplicationResetFunc();
    3f46:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    3f4a:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    3f4e:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;

    ApplicationReset();
    Reader14443CurrentCommand = Reader14443_Send;
    3f50:	81 e0       	ldi	r24, 0x01	; 1
    3f52:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>

    char const *paramTwo = strchr(InParams, ' ');
    3f56:	60 e2       	ldi	r22, 0x20	; 32
    3f58:	70 e0       	ldi	r23, 0x00	; 0
    3f5a:	c8 01       	movw	r24, r16
    3f5c:	0e 94 c1 78 	call	0xf182	; 0xf182 <strchr>
    uint16_t length;
    if (paramTwo == NULL) { // this means, we have to calculate the length
    3f60:	00 97       	sbiw	r24, 0x00	; 0
    3f62:	f9 f4       	brne	.+62     	; 0x3fa2 <CommandExecParamSend+0x7e>
        length = strlen(InParams);
    3f64:	f8 01       	movw	r30, r16
    3f66:	01 90       	ld	r0, Z+
    3f68:	00 20       	and	r0, r0
    3f6a:	e9 f7       	brne	.-6      	; 0x3f66 <CommandExecParamSend+0x42>
    3f6c:	31 97       	sbiw	r30, 0x01	; 1
    3f6e:	e0 1b       	sub	r30, r16
    3f70:	f1 0b       	sbc	r31, r17
        if (length & 1) // return error when length is odd
    3f72:	e0 fd       	sbrc	r30, 0
    3f74:	59 c0       	rjmp	.+178    	; 0x4028 <__stack+0x29>
            return COMMAND_ERR_INVALID_PARAM_ID;
        length /= 2;
    3f76:	f6 95       	lsr	r31
    3f78:	e7 95       	ror	r30
        if (length == 1) {
    3f7a:	e1 30       	cpi	r30, 0x01	; 1
    3f7c:	f1 05       	cpc	r31, r1
    3f7e:	39 f4       	brne	.+14     	; 0x3f8e <CommandExecParamSend+0x6a>
            ReaderSendBitCount = 7; // this is a short frame
    3f80:	87 e0       	ldi	r24, 0x07	; 7
    3f82:	90 e0       	ldi	r25, 0x00	; 0
    3f84:	80 93 bb 2f 	sts	0x2FBB, r24	; 0x802fbb <ReaderSendBitCount>
    3f88:	90 93 bc 2f 	sts	0x2FBC, r25	; 0x802fbc <ReaderSendBitCount+0x1>
    3f8c:	37 c0       	rjmp	.+110    	; 0x3ffc <CommandExecParamSend+0xd8>
        } else {
            ReaderSendBitCount = length * 8;
    3f8e:	53 e0       	ldi	r21, 0x03	; 3
    3f90:	ee 0f       	add	r30, r30
    3f92:	ff 1f       	adc	r31, r31
    3f94:	5a 95       	dec	r21
    3f96:	e1 f7       	brne	.-8      	; 0x3f90 <CommandExecParamSend+0x6c>
    3f98:	e0 93 bb 2f 	sts	0x2FBB, r30	; 0x802fbb <ReaderSendBitCount>
    3f9c:	f0 93 bc 2f 	sts	0x2FBC, r31	; 0x802fbc <ReaderSendBitCount+0x1>
    3fa0:	2d c0       	rjmp	.+90     	; 0x3ffc <CommandExecParamSend+0xd8>
        }
    } else if (paramTwo == (InParams + 4)) { // we have a bitcount prepended
    3fa2:	98 01       	movw	r18, r16
    3fa4:	2c 5f       	subi	r18, 0xFC	; 252
    3fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fa8:	82 17       	cp	r24, r18
    3faa:	93 07       	cpc	r25, r19
    3fac:	e9 f5       	brne	.+122    	; 0x4028 <__stack+0x29>
        uint8_t tmp[2];
        HexStringToBuffer(tmp, 2, InParams);
    3fae:	a8 01       	movw	r20, r16
    3fb0:	62 e0       	ldi	r22, 0x02	; 2
    3fb2:	70 e0       	ldi	r23, 0x00	; 0
    3fb4:	ce 01       	movw	r24, r28
    3fb6:	01 96       	adiw	r24, 0x01	; 1
    3fb8:	0e 94 5d 11 	call	0x22ba	; 0x22ba <HexStringToBuffer>
        ReaderSendBitCount = (tmp[0] << 8) + tmp[1]; // set our BitCount to the given value
    3fbc:	89 81       	ldd	r24, Y+1	; 0x01
    3fbe:	90 e0       	ldi	r25, 0x00	; 0
    3fc0:	98 2f       	mov	r25, r24
    3fc2:	88 27       	eor	r24, r24
    3fc4:	2a 81       	ldd	r18, Y+2	; 0x02
    3fc6:	82 0f       	add	r24, r18
    3fc8:	91 1d       	adc	r25, r1
    3fca:	80 93 bb 2f 	sts	0x2FBB, r24	; 0x802fbb <ReaderSendBitCount>
    3fce:	90 93 bc 2f 	sts	0x2FBC, r25	; 0x802fbc <ReaderSendBitCount+0x1>
        InParams = ++paramTwo; // set InParams to the beginning of the second parameter
    3fd2:	0b 5f       	subi	r16, 0xFB	; 251
    3fd4:	1f 4f       	sbci	r17, 0xFF	; 255
        length = strlen(InParams);
    3fd6:	f8 01       	movw	r30, r16
    3fd8:	01 90       	ld	r0, Z+
    3fda:	00 20       	and	r0, r0
    3fdc:	e9 f7       	brne	.-6      	; 0x3fd8 <CommandExecParamSend+0xb4>
    3fde:	31 97       	sbiw	r30, 0x01	; 1
    3fe0:	e0 1b       	sub	r30, r16
    3fe2:	f1 0b       	sbc	r31, r17
        if ((length & 1) || (length / 2 * 8) < ReaderSendBitCount) // this parameter is malformed, if it is odd or if there are less bits than the BitCount indicates
    3fe4:	e0 fd       	sbrc	r30, 0
    3fe6:	20 c0       	rjmp	.+64     	; 0x4028 <__stack+0x29>
    3fe8:	f6 95       	lsr	r31
    3fea:	e7 95       	ror	r30
    3fec:	33 e0       	ldi	r19, 0x03	; 3
    3fee:	ee 0f       	add	r30, r30
    3ff0:	ff 1f       	adc	r31, r31
    3ff2:	3a 95       	dec	r19
    3ff4:	e1 f7       	brne	.-8      	; 0x3fee <CommandExecParamSend+0xca>
    3ff6:	e8 17       	cp	r30, r24
    3ff8:	f9 07       	cpc	r31, r25
    3ffa:	b0 f0       	brcs	.+44     	; 0x4028 <__stack+0x29>
            return COMMAND_ERR_INVALID_PARAM_ID;
    } else { // any other case means we have malformed parameters
        return COMMAND_ERR_INVALID_PARAM_ID;
    }

    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount + 7) / 8, InParams);
    3ffc:	60 91 bb 2f 	lds	r22, 0x2FBB	; 0x802fbb <ReaderSendBitCount>
    4000:	70 91 bc 2f 	lds	r23, 0x2FBC	; 0x802fbc <ReaderSendBitCount+0x1>
    4004:	69 5f       	subi	r22, 0xF9	; 249
    4006:	7f 4f       	sbci	r23, 0xFF	; 255
    4008:	83 e0       	ldi	r24, 0x03	; 3
    400a:	76 95       	lsr	r23
    400c:	67 95       	ror	r22
    400e:	8a 95       	dec	r24
    4010:	e1 f7       	brne	.-8      	; 0x400a <__stack+0xb>
    4012:	a8 01       	movw	r20, r16
    4014:	89 eb       	ldi	r24, 0xB9	; 185
    4016:	9e e2       	ldi	r25, 0x2E	; 46
    4018:	0e 94 5d 11 	call	0x22ba	; 0x22ba <HexStringToBuffer>

    Reader14443ACodecStart();
    401c:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>

    return TIMEOUT_COMMAND;
    4020:	8f ef       	ldi	r24, 0xFF	; 255
    4022:	03 c0       	rjmp	.+6      	; 0x402a <__stack+0x2b>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
}

CommandStatusIdType CommandExecParamSend(char *OutMessage, const char *InParams) {
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    4024:	89 ec       	ldi	r24, 0xC9	; 201
    4026:	01 c0       	rjmp	.+2      	; 0x402a <__stack+0x2b>
    char const *paramTwo = strchr(InParams, ' ');
    uint16_t length;
    if (paramTwo == NULL) { // this means, we have to calculate the length
        length = strlen(InParams);
        if (length & 1) // return error when length is odd
            return COMMAND_ERR_INVALID_PARAM_ID;
    4028:	8a ec       	ldi	r24, 0xCA	; 202
    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount + 7) / 8, InParams);

    Reader14443ACodecStart();

    return TIMEOUT_COMMAND;
}
    402a:	0f 90       	pop	r0
    402c:	0f 90       	pop	r0
    402e:	df 91       	pop	r29
    4030:	cf 91       	pop	r28
    4032:	1f 91       	pop	r17
    4034:	0f 91       	pop	r16
    4036:	08 95       	ret

00004038 <CommandExecParamSendRaw>:

CommandStatusIdType CommandExecParamSendRaw(char *OutMessage, const char *InParams) {
    4038:	ef 92       	push	r14
    403a:	ff 92       	push	r15
    403c:	0f 93       	push	r16
    403e:	1f 93       	push	r17
    4040:	cf 93       	push	r28
    4042:	df 93       	push	r29
    4044:	1f 92       	push	r1
    4046:	1f 92       	push	r1
    4048:	cd b7       	in	r28, 0x3d	; 61
    404a:	de b7       	in	r29, 0x3e	; 62
    404c:	8b 01       	movw	r16, r22
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    404e:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4052:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4056:	85 81       	ldd	r24, Z+5	; 0x05
    4058:	8b 30       	cpi	r24, 0x0B	; 11
    405a:	09 f0       	breq	.+2      	; 0x405e <CommandExecParamSendRaw+0x26>
    405c:	80 c0       	rjmp	.+256    	; 0x415e <CommandExecParamSendRaw+0x126>
    405e:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    4062:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    4066:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;

    ApplicationReset();
    Reader14443CurrentCommand = Reader14443_Send_Raw;
    4068:	82 e0       	ldi	r24, 0x02	; 2
    406a:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>

    char const *paramTwo = strchr(InParams, ' ');
    406e:	60 e2       	ldi	r22, 0x20	; 32
    4070:	70 e0       	ldi	r23, 0x00	; 0
    4072:	c8 01       	movw	r24, r16
    4074:	0e 94 c1 78 	call	0xf182	; 0xf182 <strchr>
    4078:	7c 01       	movw	r14, r24
    uint16_t length;
    if (paramTwo == NULL) { // this means, we have to calculate the length
    407a:	89 2b       	or	r24, r25
    407c:	31 f5       	brne	.+76     	; 0x40ca <CommandExecParamSendRaw+0x92>
        length = strlen(InParams);
    407e:	f8 01       	movw	r30, r16
    4080:	01 90       	ld	r0, Z+
    4082:	00 20       	and	r0, r0
    4084:	e9 f7       	brne	.-6      	; 0x4080 <CommandExecParamSendRaw+0x48>
    4086:	31 97       	sbiw	r30, 0x01	; 1
    4088:	e0 1b       	sub	r30, r16
    408a:	f1 0b       	sbc	r31, r17
        if (length & 1) // return error when length is odd
    408c:	e0 fd       	sbrc	r30, 0
    408e:	69 c0       	rjmp	.+210    	; 0x4162 <CommandExecParamSendRaw+0x12a>
            return COMMAND_ERR_INVALID_PARAM_ID;
        length /= 2;
    4090:	f6 95       	lsr	r31
    4092:	e7 95       	ror	r30
        if (length == 1) {
    4094:	e1 30       	cpi	r30, 0x01	; 1
    4096:	f1 05       	cpc	r31, r1
    4098:	39 f4       	brne	.+14     	; 0x40a8 <CommandExecParamSendRaw+0x70>
            ReaderSendBitCount = 7; // this is a short frame
    409a:	87 e0       	ldi	r24, 0x07	; 7
    409c:	90 e0       	ldi	r25, 0x00	; 0
    409e:	80 93 bb 2f 	sts	0x2FBB, r24	; 0x802fbb <ReaderSendBitCount>
    40a2:	90 93 bc 2f 	sts	0x2FBC, r25	; 0x802fbc <ReaderSendBitCount+0x1>
    40a6:	47 c0       	rjmp	.+142    	; 0x4136 <CommandExecParamSendRaw+0xfe>
        } else {
            length *= 8;
    40a8:	53 e0       	ldi	r21, 0x03	; 3
    40aa:	ee 0f       	add	r30, r30
    40ac:	ff 1f       	adc	r31, r31
    40ae:	5a 95       	dec	r21
    40b0:	e1 f7       	brne	.-8      	; 0x40aa <CommandExecParamSendRaw+0x72>
            ReaderSendBitCount = length - (length % 9); // how many bytes+paritybit match into our input?
    40b2:	cf 01       	movw	r24, r30
    40b4:	69 e0       	ldi	r22, 0x09	; 9
    40b6:	70 e0       	ldi	r23, 0x00	; 0
    40b8:	0e 94 ea 77 	call	0xefd4	; 0xefd4 <__udivmodhi4>
    40bc:	e8 1b       	sub	r30, r24
    40be:	f9 0b       	sbc	r31, r25
    40c0:	e0 93 bb 2f 	sts	0x2FBB, r30	; 0x802fbb <ReaderSendBitCount>
    40c4:	f0 93 bc 2f 	sts	0x2FBC, r31	; 0x802fbc <ReaderSendBitCount+0x1>
    40c8:	36 c0       	rjmp	.+108    	; 0x4136 <CommandExecParamSendRaw+0xfe>
        }
    } else if (paramTwo == (InParams + 4)) { // we have a bitcount prepended
    40ca:	c8 01       	movw	r24, r16
    40cc:	04 96       	adiw	r24, 0x04	; 4
    40ce:	e8 16       	cp	r14, r24
    40d0:	f9 06       	cpc	r15, r25
    40d2:	09 f0       	breq	.+2      	; 0x40d6 <CommandExecParamSendRaw+0x9e>
    40d4:	46 c0       	rjmp	.+140    	; 0x4162 <CommandExecParamSendRaw+0x12a>
        uint8_t tmp[2];
        HexStringToBuffer(tmp, 2, InParams);
    40d6:	a8 01       	movw	r20, r16
    40d8:	62 e0       	ldi	r22, 0x02	; 2
    40da:	70 e0       	ldi	r23, 0x00	; 0
    40dc:	ce 01       	movw	r24, r28
    40de:	01 96       	adiw	r24, 0x01	; 1
    40e0:	0e 94 5d 11 	call	0x22ba	; 0x22ba <HexStringToBuffer>
        ReaderSendBitCount = (tmp[0] << 8) + tmp[1]; // set our BitCount to the given value
    40e4:	89 81       	ldd	r24, Y+1	; 0x01
    40e6:	90 e0       	ldi	r25, 0x00	; 0
    40e8:	98 2f       	mov	r25, r24
    40ea:	88 27       	eor	r24, r24
    40ec:	2a 81       	ldd	r18, Y+2	; 0x02
    40ee:	82 0f       	add	r24, r18
    40f0:	91 1d       	adc	r25, r1
    40f2:	80 93 bb 2f 	sts	0x2FBB, r24	; 0x802fbb <ReaderSendBitCount>
    40f6:	90 93 bc 2f 	sts	0x2FBC, r25	; 0x802fbc <ReaderSendBitCount+0x1>
        if (ReaderSendBitCount != 7 && (ReaderSendBitCount % 8)) // since we have to add parity bits here (in case this is not a short frame), the number of bits to be sent has to be a multiple of 8
    40fa:	87 30       	cpi	r24, 0x07	; 7
    40fc:	91 05       	cpc	r25, r1
    40fe:	29 f0       	breq	.+10     	; 0x410a <CommandExecParamSendRaw+0xd2>
    4100:	9c 01       	movw	r18, r24
    4102:	27 70       	andi	r18, 0x07	; 7
    4104:	33 27       	eor	r19, r19
    4106:	23 2b       	or	r18, r19
    4108:	61 f5       	brne	.+88     	; 0x4162 <CommandExecParamSendRaw+0x12a>
            return COMMAND_ERR_INVALID_PARAM_ID;
        InParams = ++paramTwo; // set InParams to the beginning of the second parameter
    410a:	87 01       	movw	r16, r14
    410c:	0f 5f       	subi	r16, 0xFF	; 255
    410e:	1f 4f       	sbci	r17, 0xFF	; 255
        length = strlen(InParams);
    4110:	f8 01       	movw	r30, r16
    4112:	01 90       	ld	r0, Z+
    4114:	00 20       	and	r0, r0
    4116:	e9 f7       	brne	.-6      	; 0x4112 <CommandExecParamSendRaw+0xda>
    4118:	31 97       	sbiw	r30, 0x01	; 1
    411a:	e0 1b       	sub	r30, r16
    411c:	f1 0b       	sbc	r31, r17
        if ((length & 1) || (length / 2 * 8) < ReaderSendBitCount) // this parameter is malformed, if it is odd or if there are less bits than the BitCount indicates
    411e:	e0 fd       	sbrc	r30, 0
    4120:	20 c0       	rjmp	.+64     	; 0x4162 <CommandExecParamSendRaw+0x12a>
    4122:	f6 95       	lsr	r31
    4124:	e7 95       	ror	r30
    4126:	33 e0       	ldi	r19, 0x03	; 3
    4128:	ee 0f       	add	r30, r30
    412a:	ff 1f       	adc	r31, r31
    412c:	3a 95       	dec	r19
    412e:	e1 f7       	brne	.-8      	; 0x4128 <CommandExecParamSendRaw+0xf0>
    4130:	e8 17       	cp	r30, r24
    4132:	f9 07       	cpc	r31, r25
    4134:	b0 f0       	brcs	.+44     	; 0x4162 <CommandExecParamSendRaw+0x12a>
            return COMMAND_ERR_INVALID_PARAM_ID;
    } else { // any other case means we have malformed parameters
        return COMMAND_ERR_INVALID_PARAM_ID;
    }

    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount + 7) / 8, InParams);
    4136:	60 91 bb 2f 	lds	r22, 0x2FBB	; 0x802fbb <ReaderSendBitCount>
    413a:	70 91 bc 2f 	lds	r23, 0x2FBC	; 0x802fbc <ReaderSendBitCount+0x1>
    413e:	69 5f       	subi	r22, 0xF9	; 249
    4140:	7f 4f       	sbci	r23, 0xFF	; 255
    4142:	83 e0       	ldi	r24, 0x03	; 3
    4144:	76 95       	lsr	r23
    4146:	67 95       	ror	r22
    4148:	8a 95       	dec	r24
    414a:	e1 f7       	brne	.-8      	; 0x4144 <CommandExecParamSendRaw+0x10c>
    414c:	a8 01       	movw	r20, r16
    414e:	89 eb       	ldi	r24, 0xB9	; 185
    4150:	9e e2       	ldi	r25, 0x2E	; 46
    4152:	0e 94 5d 11 	call	0x22ba	; 0x22ba <HexStringToBuffer>

    Reader14443ACodecStart();
    4156:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>

    return TIMEOUT_COMMAND;
    415a:	8f ef       	ldi	r24, 0xFF	; 255
    415c:	03 c0       	rjmp	.+6      	; 0x4164 <CommandExecParamSendRaw+0x12c>
    return TIMEOUT_COMMAND;
}

CommandStatusIdType CommandExecParamSendRaw(char *OutMessage, const char *InParams) {
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    415e:	89 ec       	ldi	r24, 0xC9	; 201
    4160:	01 c0       	rjmp	.+2      	; 0x4164 <CommandExecParamSendRaw+0x12c>
    char const *paramTwo = strchr(InParams, ' ');
    uint16_t length;
    if (paramTwo == NULL) { // this means, we have to calculate the length
        length = strlen(InParams);
        if (length & 1) // return error when length is odd
            return COMMAND_ERR_INVALID_PARAM_ID;
    4162:	8a ec       	ldi	r24, 0xCA	; 202
    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount + 7) / 8, InParams);

    Reader14443ACodecStart();

    return TIMEOUT_COMMAND;
}
    4164:	0f 90       	pop	r0
    4166:	0f 90       	pop	r0
    4168:	df 91       	pop	r29
    416a:	cf 91       	pop	r28
    416c:	1f 91       	pop	r17
    416e:	0f 91       	pop	r16
    4170:	ff 90       	pop	r15
    4172:	ef 90       	pop	r14
    4174:	08 95       	ret

00004176 <CommandExecDumpMFU>:

CommandStatusIdType CommandExecDumpMFU(char *OutMessage) {
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    4176:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    417a:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    417e:	85 81       	ldd	r24, Z+5	; 0x05
    4180:	8b 30       	cpi	r24, 0x0B	; 11
    4182:	a1 f4       	brne	.+40     	; 0x41ac <CommandExecDumpMFU+0x36>
    4184:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    4188:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    418c:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;
    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Read_MF_Ultralight;
    418e:	85 e0       	ldi	r24, 0x05	; 5
    4190:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>
    Reader14443AAppInit();
    4194:	0e 94 12 50 	call	0xa024	; 0xa024 <Reader14443AAppInit>
    Reader14443ACodecStart();
    4198:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    419c:	8c e1       	ldi	r24, 0x1C	; 28
    419e:	90 e5       	ldi	r25, 0x50	; 80
    41a0:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <CommandLinePendingTaskTimeout>
    41a4:	90 93 a8 2c 	sts	0x2CA8, r25	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    return TIMEOUT_COMMAND;
    41a8:	8f ef       	ldi	r24, 0xFF	; 255
    41aa:	08 95       	ret
    return TIMEOUT_COMMAND;
}

CommandStatusIdType CommandExecDumpMFU(char *OutMessage) {
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    41ac:	89 ec       	ldi	r24, 0xC9	; 201
    Reader14443CurrentCommand = Reader14443_Read_MF_Ultralight;
    Reader14443AAppInit();
    Reader14443ACodecStart();
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    return TIMEOUT_COMMAND;
}
    41ae:	08 95       	ret

000041b0 <CommandExecCloneMFU>:

CommandStatusIdType CommandExecCloneMFU(char *OutMessage) {
    ConfigurationSetById(CONFIG_ISO14443A_READER);
    41b0:	8b e0       	ldi	r24, 0x0B	; 11
    41b2:	0e 94 95 10 	call	0x212a	; 0x212a <ConfigurationSetById>
    41b6:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    41ba:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    41be:	19 95       	eicall
    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Clone_MF_Ultralight;
    41c0:	88 e0       	ldi	r24, 0x08	; 8
    41c2:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>
    Reader14443AAppInit();
    41c6:	0e 94 12 50 	call	0xa024	; 0xa024 <Reader14443AAppInit>
    Reader14443ACodecStart();
    41ca:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    41ce:	8c e1       	ldi	r24, 0x1C	; 28
    41d0:	90 e5       	ldi	r25, 0x50	; 80
    41d2:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <CommandLinePendingTaskTimeout>
    41d6:	90 93 a8 2c 	sts	0x2CA8, r25	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    return TIMEOUT_COMMAND;
}
    41da:	8f ef       	ldi	r24, 0xFF	; 255
    41dc:	08 95       	ret

000041de <CommandExecGetUid>:

CommandStatusIdType CommandExecGetUid(char *OutMessage) { // this function is for reading the uid in reader mode
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    41de:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    41e2:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    41e6:	85 81       	ldd	r24, Z+5	; 0x05
    41e8:	8b 30       	cpi	r24, 0x0B	; 11
    41ea:	a1 f4       	brne	.+40     	; 0x4214 <CommandExecGetUid+0x36>
    41ec:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    41f0:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    41f4:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;
    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Get_UID;
    41f6:	83 e0       	ldi	r24, 0x03	; 3
    41f8:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>
    Reader14443AAppInit();
    41fc:	0e 94 12 50 	call	0xa024	; 0xa024 <Reader14443AAppInit>
    Reader14443ACodecStart();
    4200:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    4204:	8c e1       	ldi	r24, 0x1C	; 28
    4206:	90 e5       	ldi	r25, 0x50	; 80
    4208:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <CommandLinePendingTaskTimeout>
    420c:	90 93 a8 2c 	sts	0x2CA8, r25	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    return TIMEOUT_COMMAND;
    4210:	8f ef       	ldi	r24, 0xFF	; 255
    4212:	08 95       	ret
    return TIMEOUT_COMMAND;
}

CommandStatusIdType CommandExecGetUid(char *OutMessage) { // this function is for reading the uid in reader mode
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    4214:	89 ec       	ldi	r24, 0xC9	; 201
    Reader14443CurrentCommand = Reader14443_Get_UID;
    Reader14443AAppInit();
    Reader14443ACodecStart();
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    return TIMEOUT_COMMAND;
}
    4216:	08 95       	ret

00004218 <CommandExecIdentifyCard>:

CommandStatusIdType CommandExecIdentifyCard(char *OutMessage) {
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    4218:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    421c:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4220:	85 81       	ldd	r24, Z+5	; 0x05
    4222:	8b 30       	cpi	r24, 0x0B	; 11
    4224:	a1 f4       	brne	.+40     	; 0x424e <CommandExecIdentifyCard+0x36>
    4226:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    422a:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    422e:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;
    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Identify;
    4230:	86 e0       	ldi	r24, 0x06	; 6
    4232:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>
    Reader14443AAppInit();
    4236:	0e 94 12 50 	call	0xa024	; 0xa024 <Reader14443AAppInit>
    Reader14443ACodecStart();
    423a:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    423e:	8c e1       	ldi	r24, 0x1C	; 28
    4240:	90 e5       	ldi	r25, 0x50	; 80
    4242:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <CommandLinePendingTaskTimeout>
    4246:	90 93 a8 2c 	sts	0x2CA8, r25	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    return TIMEOUT_COMMAND;
    424a:	8f ef       	ldi	r24, 0xFF	; 255
    424c:	08 95       	ret
    return TIMEOUT_COMMAND;
}

CommandStatusIdType CommandExecIdentifyCard(char *OutMessage) {
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    424e:	89 ec       	ldi	r24, 0xC9	; 201
    Reader14443CurrentCommand = Reader14443_Identify;
    Reader14443AAppInit();
    Reader14443ACodecStart();
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    return TIMEOUT_COMMAND;
}
    4250:	08 95       	ret

00004252 <CommandGetTimeout>:

CommandStatusIdType CommandGetTimeout(char *OutParam) {
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u ms"), GlobalSettings.ActiveSettingPtr->PendingTaskTimeout * 100);
    4252:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4256:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    425a:	40 85       	ldd	r20, Z+8	; 0x08
    425c:	51 85       	ldd	r21, Z+9	; 0x09
    425e:	64 e6       	ldi	r22, 0x64	; 100
    4260:	64 9f       	mul	r22, r20
    4262:	90 01       	movw	r18, r0
    4264:	65 9f       	mul	r22, r21
    4266:	30 0d       	add	r19, r0
    4268:	11 24       	eor	r1, r1
    426a:	3f 93       	push	r19
    426c:	2f 93       	push	r18
    426e:	2d e1       	ldi	r18, 0x1D	; 29
    4270:	3d e0       	ldi	r19, 0x0D	; 13
    4272:	3f 93       	push	r19
    4274:	2f 93       	push	r18
    4276:	22 e0       	ldi	r18, 0x02	; 2
    4278:	2f 93       	push	r18
    427a:	1f 92       	push	r1
    427c:	9f 93       	push	r25
    427e:	8f 93       	push	r24
    4280:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
    4284:	8d b7       	in	r24, 0x3d	; 61
    4286:	9e b7       	in	r25, 0x3e	; 62
    4288:	08 96       	adiw	r24, 0x08	; 8
    428a:	8d bf       	out	0x3d, r24	; 61
    428c:	9e bf       	out	0x3e, r25	; 62
}
    428e:	85 e6       	ldi	r24, 0x65	; 101
    4290:	08 95       	ret

00004292 <CommandSetTimeout>:

CommandStatusIdType CommandSetTimeout(char *OutMessage, const char *InParam) {
    4292:	cf 93       	push	r28
    4294:	df 93       	push	r29
    4296:	1f 92       	push	r1
    4298:	1f 92       	push	r1
    429a:	cd b7       	in	r28, 0x3d	; 61
    429c:	de b7       	in	r29, 0x3e	; 62
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    429e:	fb 01       	movw	r30, r22
    42a0:	20 81       	ld	r18, Z
    42a2:	2f 33       	cpi	r18, 0x3F	; 63
    42a4:	b1 f4       	brne	.+44     	; 0x42d2 <CommandSetTimeout+0x40>
    42a6:	21 81       	ldd	r18, Z+1	; 0x01
    42a8:	21 11       	cpse	r18, r1
    42aa:	13 c0       	rjmp	.+38     	; 0x42d2 <CommandSetTimeout+0x40>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("0 = no timeout\r\n1-600 = 100 ms - 60000 ms timeout"));
    42ac:	2b ee       	ldi	r18, 0xEB	; 235
    42ae:	3c e0       	ldi	r19, 0x0C	; 12
    42b0:	3f 93       	push	r19
    42b2:	2f 93       	push	r18
    42b4:	22 e0       	ldi	r18, 0x02	; 2
    42b6:	2f 93       	push	r18
    42b8:	1f 92       	push	r1
    42ba:	9f 93       	push	r25
    42bc:	8f 93       	push	r24
    42be:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    42c2:	0f 90       	pop	r0
    42c4:	0f 90       	pop	r0
    42c6:	0f 90       	pop	r0
    42c8:	0f 90       	pop	r0
    42ca:	0f 90       	pop	r0
    42cc:	0f 90       	pop	r0
    42ce:	85 e6       	ldi	r24, 0x65	; 101
    42d0:	2e c0       	rjmp	.+92     	; 0x432e <CommandSetTimeout+0x9c>
    }
    uint16_t tmp = 601;
    42d2:	89 e5       	ldi	r24, 0x59	; 89
    42d4:	92 e0       	ldi	r25, 0x02	; 2
    42d6:	89 83       	std	Y+1, r24	; 0x01
    42d8:	9a 83       	std	Y+2, r25	; 0x02
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > 600)
    42da:	ce 01       	movw	r24, r28
    42dc:	01 96       	adiw	r24, 0x01	; 1
    42de:	9f 93       	push	r25
    42e0:	8f 93       	push	r24
    42e2:	87 ee       	ldi	r24, 0xE7	; 231
    42e4:	9c e0       	ldi	r25, 0x0C	; 12
    42e6:	9f 93       	push	r25
    42e8:	8f 93       	push	r24
    42ea:	7f 93       	push	r23
    42ec:	6f 93       	push	r22
    42ee:	0e 94 3f 79 	call	0xf27e	; 0xf27e <sscanf_P>
    42f2:	0f 90       	pop	r0
    42f4:	0f 90       	pop	r0
    42f6:	0f 90       	pop	r0
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	0f 90       	pop	r0
    42fe:	89 2b       	or	r24, r25
    4300:	a9 f0       	breq	.+42     	; 0x432c <CommandSetTimeout+0x9a>
    4302:	69 81       	ldd	r22, Y+1	; 0x01
    4304:	7a 81       	ldd	r23, Y+2	; 0x02
    4306:	69 35       	cpi	r22, 0x59	; 89
    4308:	f2 e0       	ldi	r31, 0x02	; 2
    430a:	7f 07       	cpc	r23, r31
    430c:	78 f4       	brcc	.+30     	; 0x432c <CommandSetTimeout+0x9a>
        return COMMAND_ERR_INVALID_PARAM_ID;
    GlobalSettings.ActiveSettingPtr->PendingTaskTimeout = tmp;
    430e:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4312:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4316:	60 87       	std	Z+8, r22	; 0x08
    4318:	71 87       	std	Z+9, r23	; 0x09
            break;

        case 2:
            eeprom_update_word((uint16_t *)EEAddr, *(uint16_t *)addr);
    431a:	cf 01       	movw	r24, r30
    431c:	80 5d       	subi	r24, 0xD0	; 208
    431e:	9f 42       	sbci	r25, 0x2F	; 47
    4320:	8f 5f       	subi	r24, 0xFF	; 255
    4322:	9f 4f       	sbci	r25, 0xFF	; 255
    4324:	0e 94 4a 7f 	call	0xfe94	; 0xfe94 <eeprom_update_word>
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->PendingTaskTimeout);
    return COMMAND_INFO_OK_ID;
    4328:	84 e6       	ldi	r24, 0x64	; 100
    432a:	01 c0       	rjmp	.+2      	; 0x432e <CommandSetTimeout+0x9c>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("0 = no timeout\r\n1-600 = 100 ms - 60000 ms timeout"));
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    }
    uint16_t tmp = 601;
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > 600)
        return COMMAND_ERR_INVALID_PARAM_ID;
    432c:	8a ec       	ldi	r24, 0xCA	; 202
    GlobalSettings.ActiveSettingPtr->PendingTaskTimeout = tmp;
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->PendingTaskTimeout);
    return COMMAND_INFO_OK_ID;
}
    432e:	0f 90       	pop	r0
    4330:	0f 90       	pop	r0
    4332:	df 91       	pop	r29
    4334:	cf 91       	pop	r28
    4336:	08 95       	ret

00004338 <CommandGetThreshold>:

CommandStatusIdType CommandGetThreshold(char *OutParam) {
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u"), GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    4338:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    433c:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4340:	23 85       	ldd	r18, Z+11	; 0x0b
    4342:	2f 93       	push	r18
    4344:	22 85       	ldd	r18, Z+10	; 0x0a
    4346:	2f 93       	push	r18
    4348:	24 ee       	ldi	r18, 0xE4	; 228
    434a:	3c e0       	ldi	r19, 0x0C	; 12
    434c:	3f 93       	push	r19
    434e:	2f 93       	push	r18
    4350:	22 e0       	ldi	r18, 0x02	; 2
    4352:	2f 93       	push	r18
    4354:	1f 92       	push	r1
    4356:	9f 93       	push	r25
    4358:	8f 93       	push	r24
    435a:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
    435e:	8d b7       	in	r24, 0x3d	; 61
    4360:	9e b7       	in	r25, 0x3e	; 62
    4362:	08 96       	adiw	r24, 0x08	; 8
    4364:	8d bf       	out	0x3d, r24	; 61
    4366:	9e bf       	out	0x3e, r25	; 62
}
    4368:	85 e6       	ldi	r24, 0x65	; 101
    436a:	08 95       	ret

0000436c <CommandSetThreshold>:

CommandStatusIdType CommandSetThreshold(char *OutMessage, const char *InParam) {
    436c:	cf 93       	push	r28
    436e:	df 93       	push	r29
    4370:	1f 92       	push	r1
    4372:	1f 92       	push	r1
    4374:	cd b7       	in	r28, 0x3d	; 61
    4376:	de b7       	in	r29, 0x3e	; 62
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    4378:	fb 01       	movw	r30, r22
    437a:	20 81       	ld	r18, Z
    437c:	2f 33       	cpi	r18, 0x3F	; 63
    437e:	b1 f4       	brne	.+44     	; 0x43ac <CommandSetThreshold+0x40>
    4380:	21 81       	ldd	r18, Z+1	; 0x01
    4382:	21 11       	cpse	r18, r1
    4384:	13 c0       	rjmp	.+38     	; 0x43ac <CommandSetThreshold+0x40>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("Any integer from 0 to %u. Reference voltage will be (VCC * THRESHOLD / 4095) mV."), CODEC_MAXIMUM_THRESHOLD);
    4386:	2f e0       	ldi	r18, 0x0F	; 15
    4388:	2f 93       	push	r18
    438a:	2f ef       	ldi	r18, 0xFF	; 255
    438c:	2f 93       	push	r18
    438e:	23 e9       	ldi	r18, 0x93	; 147
    4390:	3c e0       	ldi	r19, 0x0C	; 12
    4392:	3f 93       	push	r19
    4394:	2f 93       	push	r18
    4396:	22 e0       	ldi	r18, 0x02	; 2
    4398:	2f 93       	push	r18
    439a:	1f 92       	push	r1
    439c:	9f 93       	push	r25
    439e:	8f 93       	push	r24
    43a0:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    43a4:	cd bf       	out	0x3d, r28	; 61
    43a6:	de bf       	out	0x3e, r29	; 62
    43a8:	85 e6       	ldi	r24, 0x65	; 101
    43aa:	30 c0       	rjmp	.+96     	; 0x440c <CommandSetThreshold+0xa0>
    }
    uint16_t tmp = 0;
    43ac:	19 82       	std	Y+1, r1	; 0x01
    43ae:	1a 82       	std	Y+2, r1	; 0x02
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > CODEC_MAXIMUM_THRESHOLD)
    43b0:	ce 01       	movw	r24, r28
    43b2:	01 96       	adiw	r24, 0x01	; 1
    43b4:	9f 93       	push	r25
    43b6:	8f 93       	push	r24
    43b8:	8f e8       	ldi	r24, 0x8F	; 143
    43ba:	9c e0       	ldi	r25, 0x0C	; 12
    43bc:	9f 93       	push	r25
    43be:	8f 93       	push	r24
    43c0:	7f 93       	push	r23
    43c2:	6f 93       	push	r22
    43c4:	0e 94 3f 79 	call	0xf27e	; 0xf27e <sscanf_P>
    43c8:	0f 90       	pop	r0
    43ca:	0f 90       	pop	r0
    43cc:	0f 90       	pop	r0
    43ce:	0f 90       	pop	r0
    43d0:	0f 90       	pop	r0
    43d2:	0f 90       	pop	r0
    43d4:	89 2b       	or	r24, r25
    43d6:	c9 f0       	breq	.+50     	; 0x440a <CommandSetThreshold+0x9e>
    43d8:	69 81       	ldd	r22, Y+1	; 0x01
    43da:	7a 81       	ldd	r23, Y+2	; 0x02
    43dc:	61 15       	cp	r22, r1
    43de:	90 e1       	ldi	r25, 0x10	; 16
    43e0:	79 07       	cpc	r23, r25
    43e2:	98 f4       	brcc	.+38     	; 0x440a <CommandSetThreshold+0x9e>
        return COMMAND_ERR_INVALID_PARAM_ID;
    DACB.CH0DATA = tmp;
    43e4:	60 93 38 03 	sts	0x0338, r22	; 0x800338 <__TEXT_REGION_LENGTH__+0x700338>
    43e8:	70 93 39 03 	sts	0x0339, r23	; 0x800339 <__TEXT_REGION_LENGTH__+0x700339>
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = tmp;
    43ec:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    43f0:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    43f4:	62 87       	std	Z+10, r22	; 0x0a
    43f6:	73 87       	std	Z+11, r23	; 0x0b
    43f8:	cf 01       	movw	r24, r30
    43fa:	8e 5c       	subi	r24, 0xCE	; 206
    43fc:	9f 42       	sbci	r25, 0x2F	; 47
    43fe:	8f 5f       	subi	r24, 0xFF	; 255
    4400:	9f 4f       	sbci	r25, 0xFF	; 255
    4402:	0e 94 4a 7f 	call	0xfe94	; 0xfe94 <eeprom_update_word>
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    return COMMAND_INFO_OK_ID;
    4406:	84 e6       	ldi	r24, 0x64	; 100
    4408:	01 c0       	rjmp	.+2      	; 0x440c <CommandSetThreshold+0xa0>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("Any integer from 0 to %u. Reference voltage will be (VCC * THRESHOLD / 4095) mV."), CODEC_MAXIMUM_THRESHOLD);
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    }
    uint16_t tmp = 0;
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > CODEC_MAXIMUM_THRESHOLD)
        return COMMAND_ERR_INVALID_PARAM_ID;
    440a:	8a ec       	ldi	r24, 0xCA	; 202
    DACB.CH0DATA = tmp;
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = tmp;
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    return COMMAND_INFO_OK_ID;
}
    440c:	0f 90       	pop	r0
    440e:	0f 90       	pop	r0
    4410:	df 91       	pop	r29
    4412:	cf 91       	pop	r28
    4414:	08 95       	ret

00004416 <CommandSetField>:

CommandStatusIdType CommandSetField(char *OutMessage, const char *InParam) {
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    4416:	fb 01       	movw	r30, r22
    4418:	20 81       	ld	r18, Z
    441a:	2f 33       	cpi	r18, 0x3F	; 63
    441c:	d9 f4       	brne	.+54     	; 0x4454 <CommandSetField+0x3e>
    441e:	21 81       	ldd	r18, Z+1	; 0x01
    4420:	21 11       	cpse	r18, r1
    4422:	21 c0       	rjmp	.+66     	; 0x4466 <CommandSetField+0x50>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("%c,%c"), COMMAND_CHAR_TRUE, COMMAND_CHAR_FALSE);
    4424:	1f 92       	push	r1
    4426:	20 e3       	ldi	r18, 0x30	; 48
    4428:	2f 93       	push	r18
    442a:	1f 92       	push	r1
    442c:	21 e3       	ldi	r18, 0x31	; 49
    442e:	2f 93       	push	r18
    4430:	29 e8       	ldi	r18, 0x89	; 137
    4432:	3c e0       	ldi	r19, 0x0C	; 12
    4434:	3f 93       	push	r19
    4436:	2f 93       	push	r18
    4438:	22 e0       	ldi	r18, 0x02	; 2
    443a:	2f 93       	push	r18
    443c:	1f 92       	push	r1
    443e:	9f 93       	push	r25
    4440:	8f 93       	push	r24
    4442:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    4446:	8d b7       	in	r24, 0x3d	; 61
    4448:	9e b7       	in	r25, 0x3e	; 62
    444a:	0a 96       	adiw	r24, 0x0a	; 10
    444c:	8d bf       	out	0x3d, r24	; 61
    444e:	9e bf       	out	0x3e, r25	; 62
    4450:	85 e6       	ldi	r24, 0x65	; 101
    4452:	08 95       	ret
    }
    if (InParam[0] == COMMAND_CHAR_TRUE) {
    4454:	21 33       	cpi	r18, 0x31	; 49
    4456:	11 f4       	brne	.+4      	; 0x445c <CommandSetField+0x46>
        CodecReaderFieldStart();
    4458:	29 d4       	rcall	.+2130   	; 0x4cac <CodecReaderFieldStart>
    445a:	03 c0       	rjmp	.+6      	; 0x4462 <CommandSetField+0x4c>
    } else if (InParam[0] == COMMAND_CHAR_FALSE) {
    445c:	20 33       	cpi	r18, 0x30	; 48
        CodecReaderFieldStop();
    445e:	19 f4       	brne	.+6      	; 0x4466 <CommandSetField+0x50>
    4460:	4b d4       	rcall	.+2198   	; 0x4cf8 <CodecReaderFieldStop>
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    }
    return COMMAND_INFO_OK_ID;
    4462:	84 e6       	ldi	r24, 0x64	; 100
    4464:	08 95       	ret
    if (InParam[0] == COMMAND_CHAR_TRUE) {
        CodecReaderFieldStart();
    } else if (InParam[0] == COMMAND_CHAR_FALSE) {
        CodecReaderFieldStop();
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    4466:	8a ec       	ldi	r24, 0xCA	; 202
    }
    return COMMAND_INFO_OK_ID;
}
    4468:	08 95       	ret

0000446a <CommandGetField>:

CommandStatusIdType CommandGetField(char *OutMessage) {
    446a:	fc 01       	movw	r30, r24
    }
}

// Get the status of the reader field
INLINE bool CodecGetReaderField(void) {
    return (CODEC_READER_TIMER.CTRLA == TC_CLKSEL_DIV1_gc) && (AWEXC.OUTOVEN == CODEC_READER_MASK);
    446c:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    4470:	81 30       	cpi	r24, 0x01	; 1
    4472:	29 f4       	brne	.+10     	; 0x447e <CommandGetField+0x14>
    4474:	80 91 8c 08 	lds	r24, 0x088C	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>
    4478:	91 e0       	ldi	r25, 0x01	; 1
    447a:	83 30       	cpi	r24, 0x03	; 3
    447c:	09 f0       	breq	.+2      	; 0x4480 <CommandGetField+0x16>
    447e:	90 e0       	ldi	r25, 0x00	; 0
    if (CodecGetReaderField())
    4480:	90 ff       	sbrs	r25, 0
    4482:	02 c0       	rjmp	.+4      	; 0x4488 <CommandGetField+0x1e>
        OutMessage[0] = COMMAND_CHAR_TRUE;
    4484:	81 e3       	ldi	r24, 0x31	; 49
    4486:	01 c0       	rjmp	.+2      	; 0x448a <CommandGetField+0x20>
    else
        OutMessage[0] = COMMAND_CHAR_FALSE;
    4488:	80 e3       	ldi	r24, 0x30	; 48
    448a:	80 83       	st	Z, r24
    OutMessage[1] = '\0';
    448c:	11 82       	std	Z+1, r1	; 0x01
    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    448e:	85 e6       	ldi	r24, 0x65	; 101
    4490:	08 95       	ret

00004492 <CommandExecAutocalibrate>:


CommandStatusIdType CommandExecAutocalibrate(char *OutMessage) {
    if (GlobalSettings.ActiveSettingPtr->Configuration == CONFIG_ISO14443A_READER) {
    4492:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4496:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    449a:	85 81       	ldd	r24, Z+5	; 0x05
    449c:	8b 30       	cpi	r24, 0x0B	; 11
    449e:	79 f4       	brne	.+30     	; 0x44be <CommandExecAutocalibrate+0x2c>
    44a0:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    44a4:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    44a8:	19 95       	eicall
        ApplicationReset();

        Reader14443CurrentCommand = Reader14443_Autocalibrate;
    44aa:	84 e0       	ldi	r24, 0x04	; 4
    44ac:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>
        Reader14443AAppInit();
    44b0:	0e 94 12 50 	call	0xa024	; 0xa024 <Reader14443AAppInit>
        Reader14443ACodecStart();
    44b4:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
        CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    44b8:	8c e1       	ldi	r24, 0x1C	; 28
    44ba:	90 e5       	ldi	r25, 0x50	; 80
    44bc:	0e c0       	rjmp	.+28     	; 0x44da <CommandExecAutocalibrate+0x48>
        return TIMEOUT_COMMAND;
    } else if (GlobalSettings.ActiveSettingPtr->Configuration == CONFIG_ISO14443A_SNIFF) {
    44be:	8a 30       	cpi	r24, 0x0A	; 10
    44c0:	91 f4       	brne	.+36     	; 0x44e6 <CommandExecAutocalibrate+0x54>
    44c2:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    44c6:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    44ca:	19 95       	eicall
        ApplicationReset();

        Sniff14443CurrentCommand = Sniff14443_Autocalibrate;
    44cc:	81 e0       	ldi	r24, 0x01	; 1
    44ce:	80 93 f8 2d 	sts	0x2DF8, r24	; 0x802df8 <Sniff14443CurrentCommand>
        Sniff14443AAppInit();
    44d2:	0e 94 1e 58 	call	0xb03c	; 0xb03c <Sniff14443AAppInit>
        CommandLinePendingTaskTimeout = &Sniff14443AAppTimeout;
    44d6:	83 e3       	ldi	r24, 0x33	; 51
    44d8:	98 e5       	ldi	r25, 0x58	; 88
    44da:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <CommandLinePendingTaskTimeout>
    44de:	90 93 a8 2c 	sts	0x2CA8, r25	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
        return TIMEOUT_COMMAND;
    44e2:	8f ef       	ldi	r24, 0xFF	; 255
    44e4:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_USAGE_ID;
    44e6:	89 ec       	ldi	r24, 0xC9	; 201
    }

}
    44e8:	08 95       	ret

000044ea <CommandExecClone>:

CommandStatusIdType CommandExecClone(char *OutMessage) {
    ConfigurationSetById(CONFIG_ISO14443A_READER);
    44ea:	8b e0       	ldi	r24, 0x0B	; 11
    44ec:	0e 94 95 10 	call	0x212a	; 0x212a <ConfigurationSetById>
    44f0:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    44f4:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    44f8:	19 95       	eicall

    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Identify_Clone;
    44fa:	87 e0       	ldi	r24, 0x07	; 7
    44fc:	80 93 1c 2d 	sts	0x2D1C, r24	; 0x802d1c <Reader14443CurrentCommand>
    Reader14443AAppInit();
    4500:	0e 94 12 50 	call	0xa024	; 0xa024 <Reader14443AAppInit>
    Reader14443ACodecStart();
    4504:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    4508:	8c e1       	ldi	r24, 0x1C	; 28
    450a:	90 e5       	ldi	r25, 0x50	; 80
    450c:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <CommandLinePendingTaskTimeout>
    4510:	90 93 a8 2c 	sts	0x2CA8, r25	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>

    return TIMEOUT_COMMAND;
}
    4514:	8f ef       	ldi	r24, 0xFF	; 255
    4516:	08 95       	ret

00004518 <CommandTest>:
//test command that outputs string
CommandStatusIdType CommandTest(char *OutParam) { 
    snprintf_P(OutParam , TERMINAL_BUFFER_SIZE, PSTR("TEST! --- Hello World\n\r"));
    4518:	21 e7       	ldi	r18, 0x71	; 113
    451a:	3c e0       	ldi	r19, 0x0C	; 12
    451c:	3f 93       	push	r19
    451e:	2f 93       	push	r18
    4520:	22 e0       	ldi	r18, 0x02	; 2
    4522:	2f 93       	push	r18
    4524:	1f 92       	push	r1
    4526:	9f 93       	push	r25
    4528:	8f 93       	push	r24
    452a:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
    452e:	0f 90       	pop	r0
    4530:	0f 90       	pop	r0
    4532:	0f 90       	pop	r0
    4534:	0f 90       	pop	r0
    4536:	0f 90       	pop	r0
    4538:	0f 90       	pop	r0
}
    453a:	85 e6       	ldi	r24, 0x65	; 101
    453c:	08 95       	ret

0000453e <XModemReceive>:

    return Checksum;
}

void XModemReceive(XModemCallbackType TheCallbackFunc) {
    State = STATE_RECEIVE_INIT;
    453e:	21 e0       	ldi	r18, 0x01	; 1
    4540:	20 93 a6 2c 	sts	0x2CA6, r18	; 0x802ca6 <State>
    CurrentFrameNumber = FIRST_FRAME_NUMBER;
    4544:	20 93 a5 2c 	sts	0x2CA5, r18	; 0x802ca5 <CurrentFrameNumber>
    RetryCount = RECV_INIT_COUNT;
    4548:	2c e3       	ldi	r18, 0x3C	; 60
    454a:	20 93 a3 2c 	sts	0x2CA3, r18	; 0x802ca3 <RetryCount>
    RetryTimeout = RECV_INIT_TIMEOUT;
    454e:	25 e0       	ldi	r18, 0x05	; 5
    4550:	30 e0       	ldi	r19, 0x00	; 0
    4552:	20 93 a1 2c 	sts	0x2CA1, r18	; 0x802ca1 <RetryTimeout>
    4556:	30 93 a2 2c 	sts	0x2CA2, r19	; 0x802ca2 <RetryTimeout+0x1>
    BlockAddress = 0;
    455a:	10 92 9b 2c 	sts	0x2C9B, r1	; 0x802c9b <BlockAddress>
    455e:	10 92 9c 2c 	sts	0x2C9C, r1	; 0x802c9c <BlockAddress+0x1>
    4562:	10 92 9d 2c 	sts	0x2C9D, r1	; 0x802c9d <BlockAddress+0x2>
    4566:	10 92 9e 2c 	sts	0x2C9E, r1	; 0x802c9e <BlockAddress+0x3>

    CallbackFunc = TheCallbackFunc;
    456a:	80 93 99 2c 	sts	0x2C99, r24	; 0x802c99 <CallbackFunc>
    456e:	90 93 9a 2c 	sts	0x2C9A, r25	; 0x802c9a <CallbackFunc+0x1>
    4572:	08 95       	ret

00004574 <XModemSend>:
}

void XModemSend(XModemCallbackType TheCallbackFunc) {
    State = STATE_SEND_INIT;
    4574:	27 e0       	ldi	r18, 0x07	; 7
    4576:	20 93 a6 2c 	sts	0x2CA6, r18	; 0x802ca6 <State>
    RetryTimeout = SEND_INIT_TIMEOUT;
    457a:	2c e2       	ldi	r18, 0x2C	; 44
    457c:	31 e0       	ldi	r19, 0x01	; 1
    457e:	20 93 a1 2c 	sts	0x2CA1, r18	; 0x802ca1 <RetryTimeout>
    4582:	30 93 a2 2c 	sts	0x2CA2, r19	; 0x802ca2 <RetryTimeout+0x1>
    BlockAddress = 0;
    4586:	10 92 9b 2c 	sts	0x2C9B, r1	; 0x802c9b <BlockAddress>
    458a:	10 92 9c 2c 	sts	0x2C9C, r1	; 0x802c9c <BlockAddress+0x1>
    458e:	10 92 9d 2c 	sts	0x2C9D, r1	; 0x802c9d <BlockAddress+0x2>
    4592:	10 92 9e 2c 	sts	0x2C9E, r1	; 0x802c9e <BlockAddress+0x3>

    CallbackFunc = TheCallbackFunc;
    4596:	80 93 99 2c 	sts	0x2C99, r24	; 0x802c99 <CallbackFunc>
    459a:	90 93 9a 2c 	sts	0x2C9A, r25	; 0x802c9a <CallbackFunc+0x1>
    459e:	08 95       	ret

000045a0 <XModemProcessByte>:
}

bool XModemProcessByte(uint8_t Byte) {
    45a0:	cf 93       	push	r28
    switch (State) {
    45a2:	90 91 a6 2c 	lds	r25, 0x2CA6	; 0x802ca6 <State>
    45a6:	95 30       	cpi	r25, 0x05	; 5
    45a8:	09 f4       	brne	.+2      	; 0x45ac <XModemProcessByte+0xc>
    45aa:	41 c0       	rjmp	.+130    	; 0x462e <XModemProcessByte+0x8e>
    45ac:	30 f4       	brcc	.+12     	; 0x45ba <XModemProcessByte+0x1a>
    45ae:	93 30       	cpi	r25, 0x03	; 3
    45b0:	19 f1       	breq	.+70     	; 0x45f8 <XModemProcessByte+0x58>
    45b2:	30 f5       	brcc	.+76     	; 0x4600 <XModemProcessByte+0x60>
    45b4:	91 30       	cpi	r25, 0x01	; 1
    45b6:	68 f4       	brcc	.+26     	; 0x45d2 <XModemProcessByte+0x32>
    45b8:	3f c1       	rjmp	.+638    	; 0x4838 <XModemProcessByte+0x298>
    45ba:	97 30       	cpi	r25, 0x07	; 7
    45bc:	09 f4       	brne	.+2      	; 0x45c0 <XModemProcessByte+0x20>
    45be:	aa c0       	rjmp	.+340    	; 0x4714 <XModemProcessByte+0x174>
    45c0:	08 f4       	brcc	.+2      	; 0x45c4 <XModemProcessByte+0x24>
    45c2:	4a c0       	rjmp	.+148    	; 0x4658 <XModemProcessByte+0xb8>
    45c4:	98 30       	cpi	r25, 0x08	; 8
    45c6:	09 f4       	brne	.+2      	; 0x45ca <XModemProcessByte+0x2a>
    45c8:	ac c0       	rjmp	.+344    	; 0x4722 <XModemProcessByte+0x182>
    45ca:	99 30       	cpi	r25, 0x09	; 9
    45cc:	09 f4       	brne	.+2      	; 0x45d0 <XModemProcessByte+0x30>
    45ce:	95 c0       	rjmp	.+298    	; 0x46fa <XModemProcessByte+0x15a>
    45d0:	33 c1       	rjmp	.+614    	; 0x4838 <XModemProcessByte+0x298>
        case STATE_RECEIVE_INIT:
        case STATE_RECEIVE_WAIT:
            if (Byte == BYTE_SOH) {
    45d2:	81 30       	cpi	r24, 0x01	; 1
    45d4:	31 f4       	brne	.+12     	; 0x45e2 <XModemProcessByte+0x42>
                /* Next frame incoming */
                BufferIdx = 0;
    45d6:	10 92 9f 2c 	sts	0x2C9F, r1	; 0x802c9f <BufferIdx>
    45da:	10 92 a0 2c 	sts	0x2CA0, r1	; 0x802ca0 <BufferIdx+0x1>
                Checksum = CHECKSUM_INIT_VALUE;
                State = STATE_RECEIVE_FRAMENUM1;
    45de:	83 e0       	ldi	r24, 0x03	; 3
    45e0:	23 c0       	rjmp	.+70     	; 0x4628 <XModemProcessByte+0x88>
            } else if (Byte == BYTE_EOT) {
    45e2:	84 30       	cpi	r24, 0x04	; 4
    45e4:	11 f4       	brne	.+4      	; 0x45ea <XModemProcessByte+0x4a>
INLINE void TerminalSendByte(uint8_t Byte) { CDC_Device_SendByte(&TerminalHandle, Byte); }
    45e6:	66 e0       	ldi	r22, 0x06	; 6
    45e8:	84 c0       	rjmp	.+264    	; 0x46f2 <XModemProcessByte+0x152>
                /* Transmission finished */
                TerminalSendByte(BYTE_ACK);
                State = STATE_OFF;
            } else if ((Byte == BYTE_CAN) || (Byte == BYTE_ESC)) {
    45ea:	88 31       	cpi	r24, 0x18	; 24
    45ec:	09 f4       	brne	.+2      	; 0x45f0 <XModemProcessByte+0x50>
    45ee:	85 c0       	rjmp	.+266    	; 0x46fa <XModemProcessByte+0x15a>
    45f0:	8b 31       	cpi	r24, 0x1B	; 27
    45f2:	09 f0       	breq	.+2      	; 0x45f6 <XModemProcessByte+0x56>
    45f4:	84 c0       	rjmp	.+264    	; 0x46fe <XModemProcessByte+0x15e>
    45f6:	81 c0       	rjmp	.+258    	; 0x46fa <XModemProcessByte+0x15a>

            break;

        case STATE_RECEIVE_FRAMENUM1:
            /* Store frame number */
            ReceivedFrameNumber = Byte;
    45f8:	80 93 a4 2c 	sts	0x2CA4, r24	; 0x802ca4 <ReceivedFrameNumber>
            State = STATE_RECEIVE_FRAMENUM2;
    45fc:	84 e0       	ldi	r24, 0x04	; 4
    45fe:	14 c0       	rjmp	.+40     	; 0x4628 <XModemProcessByte+0x88>
            break;

        case STATE_RECEIVE_FRAMENUM2:
            if (Byte == (255 - ReceivedFrameNumber)) {
    4600:	90 e0       	ldi	r25, 0x00	; 0
    4602:	40 91 a4 2c 	lds	r20, 0x2CA4	; 0x802ca4 <ReceivedFrameNumber>
    4606:	2f ef       	ldi	r18, 0xFF	; 255
    4608:	30 e0       	ldi	r19, 0x00	; 0
    460a:	24 1b       	sub	r18, r20
    460c:	31 09       	sbc	r19, r1
    460e:	82 17       	cp	r24, r18
    4610:	93 07       	cpc	r25, r19
    4612:	21 f4       	brne	.+8      	; 0x461c <XModemProcessByte+0x7c>
                /* frame-number check passed. */
                State = STATE_RECEIVE_DATA;
    4614:	85 e0       	ldi	r24, 0x05	; 5
    4616:	08 c0       	rjmp	.+16     	; 0x4628 <XModemProcessByte+0x88>

        case STATE_RECEIVE_PROCESS:
            if (ReceivedFrameNumber == CurrentFrameNumber) {
                /* This is the expected frame. Calculate and verify checksum */

                if (CalcChecksum(TerminalBuffer, XMODEM_BLOCK_SIZE) == Byte) {
    4618:	89 17       	cp	r24, r25
    461a:	79 f1       	breq	.+94     	; 0x467a <XModemProcessByte+0xda>
    461c:	65 e1       	ldi	r22, 0x15	; 21
    461e:	83 e0       	ldi	r24, 0x03	; 3
    4620:	90 e2       	ldi	r25, 0x20	; 32
    4622:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
                /* frame-number check passed. */
                State = STATE_RECEIVE_DATA;
            } else {
                /* Something went wrong. Try to recover by sending NAK */
                TerminalSendByte(BYTE_NAK);
                State = STATE_RECEIVE_WAIT;
    4626:	82 e0       	ldi	r24, 0x02	; 2
    4628:	80 93 a6 2c 	sts	0x2CA6, r24	; 0x802ca6 <State>
    462c:	68 c0       	rjmp	.+208    	; 0x46fe <XModemProcessByte+0x15e>

            break;

        case STATE_RECEIVE_DATA:
            /* Process byte and update checksum */
            TerminalBuffer[BufferIdx++] = Byte;
    462e:	20 91 9f 2c 	lds	r18, 0x2C9F	; 0x802c9f <BufferIdx>
    4632:	30 91 a0 2c 	lds	r19, 0x2CA0	; 0x802ca0 <BufferIdx+0x1>
    4636:	a9 01       	movw	r20, r18
    4638:	4f 5f       	subi	r20, 0xFF	; 255
    463a:	5f 4f       	sbci	r21, 0xFF	; 255
    463c:	40 93 9f 2c 	sts	0x2C9F, r20	; 0x802c9f <BufferIdx>
    4640:	50 93 a0 2c 	sts	0x2CA0, r21	; 0x802ca0 <BufferIdx+0x1>
    4644:	f9 01       	movw	r30, r18
    4646:	e5 5c       	subi	r30, 0xC5	; 197
    4648:	ff 4c       	sbci	r31, 0xCF	; 207
    464a:	80 83       	st	Z, r24

            if (BufferIdx == XMODEM_BLOCK_SIZE) {
    464c:	40 38       	cpi	r20, 0x80	; 128
    464e:	51 05       	cpc	r21, r1
    4650:	09 f0       	breq	.+2      	; 0x4654 <XModemProcessByte+0xb4>
    4652:	55 c0       	rjmp	.+170    	; 0x46fe <XModemProcessByte+0x15e>
                /* Block full */
                State = STATE_RECEIVE_PROCESS;
    4654:	86 e0       	ldi	r24, 0x06	; 6
    4656:	e8 cf       	rjmp	.-48     	; 0x4628 <XModemProcessByte+0x88>
            }

            break;

        case STATE_RECEIVE_PROCESS:
            if (ReceivedFrameNumber == CurrentFrameNumber) {
    4658:	20 91 a4 2c 	lds	r18, 0x2CA4	; 0x802ca4 <ReceivedFrameNumber>
    465c:	90 91 a5 2c 	lds	r25, 0x2CA5	; 0x802ca5 <CurrentFrameNumber>
    4660:	29 13       	cpse	r18, r25
    4662:	4f c0       	rjmp	.+158    	; 0x4702 <XModemProcessByte+0x162>
    4664:	eb e3       	ldi	r30, 0x3B	; 59
    4666:	f0 e3       	ldi	r31, 0x30	; 48
    4668:	2b eb       	ldi	r18, 0xBB	; 187
    466a:	30 e3       	ldi	r19, 0x30	; 48
    466c:	90 e0       	ldi	r25, 0x00	; 0

static uint8_t CalcChecksum(const void *Buffer, uint16_t ByteCount) {
    uint8_t Checksum = CHECKSUM_INIT_VALUE;
    uint8_t *DataPtr = (uint8_t *) Buffer;

    while (ByteCount--) {
    466e:	2e 17       	cp	r18, r30
    4670:	3f 07       	cpc	r19, r31
    4672:	91 f2       	breq	.-92     	; 0x4618 <XModemProcessByte+0x78>
        Checksum += *DataPtr++;
    4674:	41 91       	ld	r20, Z+
    4676:	94 0f       	add	r25, r20
    4678:	fa cf       	rjmp	.-12     	; 0x466e <XModemProcessByte+0xce>
            if (ReceivedFrameNumber == CurrentFrameNumber) {
                /* This is the expected frame. Calculate and verify checksum */

                if (CalcChecksum(TerminalBuffer, XMODEM_BLOCK_SIZE) == Byte) {
                    /* Checksum is valid. Pass received data to callback function */
                    if (CallbackFunc(TerminalBuffer, BlockAddress, XMODEM_BLOCK_SIZE)) {
    467a:	40 91 9b 2c 	lds	r20, 0x2C9B	; 0x802c9b <BlockAddress>
    467e:	50 91 9c 2c 	lds	r21, 0x2C9C	; 0x802c9c <BlockAddress+0x1>
    4682:	60 91 9d 2c 	lds	r22, 0x2C9D	; 0x802c9d <BlockAddress+0x2>
    4686:	70 91 9e 2c 	lds	r23, 0x2C9E	; 0x802c9e <BlockAddress+0x3>
    468a:	e0 91 99 2c 	lds	r30, 0x2C99	; 0x802c99 <CallbackFunc>
    468e:	f0 91 9a 2c 	lds	r31, 0x2C9A	; 0x802c9a <CallbackFunc+0x1>
    4692:	20 e8       	ldi	r18, 0x80	; 128
    4694:	30 e0       	ldi	r19, 0x00	; 0
    4696:	8b e3       	ldi	r24, 0x3B	; 59
    4698:	90 e3       	ldi	r25, 0x30	; 48
    469a:	19 95       	eicall
    469c:	c8 2f       	mov	r28, r24
    469e:	88 23       	and	r24, r24
    46a0:	11 f1       	breq	.+68     	; 0x46e6 <XModemProcessByte+0x146>
                        /* Proceed to next frame and send ACK */
                        CurrentFrameNumber++;
    46a2:	80 91 a5 2c 	lds	r24, 0x2CA5	; 0x802ca5 <CurrentFrameNumber>
    46a6:	8f 5f       	subi	r24, 0xFF	; 255
    46a8:	80 93 a5 2c 	sts	0x2CA5, r24	; 0x802ca5 <CurrentFrameNumber>
                        BlockAddress += XMODEM_BLOCK_SIZE;
    46ac:	80 91 9b 2c 	lds	r24, 0x2C9B	; 0x802c9b <BlockAddress>
    46b0:	90 91 9c 2c 	lds	r25, 0x2C9C	; 0x802c9c <BlockAddress+0x1>
    46b4:	a0 91 9d 2c 	lds	r26, 0x2C9D	; 0x802c9d <BlockAddress+0x2>
    46b8:	b0 91 9e 2c 	lds	r27, 0x2C9E	; 0x802c9e <BlockAddress+0x3>
    46bc:	80 58       	subi	r24, 0x80	; 128
    46be:	9f 4f       	sbci	r25, 0xFF	; 255
    46c0:	af 4f       	sbci	r26, 0xFF	; 255
    46c2:	bf 4f       	sbci	r27, 0xFF	; 255
    46c4:	80 93 9b 2c 	sts	0x2C9B, r24	; 0x802c9b <BlockAddress>
    46c8:	90 93 9c 2c 	sts	0x2C9C, r25	; 0x802c9c <BlockAddress+0x1>
    46cc:	a0 93 9d 2c 	sts	0x2C9D, r26	; 0x802c9d <BlockAddress+0x2>
    46d0:	b0 93 9e 2c 	sts	0x2C9E, r27	; 0x802c9e <BlockAddress+0x3>
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    46d4:	66 e0       	ldi	r22, 0x06	; 6
    46d6:	83 e0       	ldi	r24, 0x03	; 3
    46d8:	90 e2       	ldi	r25, 0x20	; 32
    46da:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
                        TerminalSendChar(BYTE_ACK);
                        State = STATE_RECEIVE_WAIT;
    46de:	82 e0       	ldi	r24, 0x02	; 2
    46e0:	80 93 a6 2c 	sts	0x2CA6, r24	; 0x802ca6 <State>
    46e4:	aa c0       	rjmp	.+340    	; 0x483a <XModemProcessByte+0x29a>
INLINE void TerminalSendByte(uint8_t Byte) { CDC_Device_SendByte(&TerminalHandle, Byte); }
    46e6:	68 e1       	ldi	r22, 0x18	; 24
    46e8:	83 e0       	ldi	r24, 0x03	; 3
    46ea:	90 e2       	ldi	r25, 0x20	; 32
    46ec:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    46f0:	68 e1       	ldi	r22, 0x18	; 24
    46f2:	83 e0       	ldi	r24, 0x03	; 3
    46f4:	90 e2       	ldi	r25, 0x20	; 32
    46f6:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
                    } else {
                        /* Application signals to cancel the transmission */
                        TerminalSendByte(BYTE_CAN);
                        TerminalSendByte(BYTE_CAN);
                        State = STATE_OFF;
    46fa:	10 92 a6 2c 	sts	0x2CA6, r1	; 0x802ca6 <State>
        default:
            return false;
            break;
    }

    return true;
    46fe:	c1 e0       	ldi	r28, 0x01	; 1
    4700:	9c c0       	rjmp	.+312    	; 0x483a <XModemProcessByte+0x29a>
                } else {
                    /* Data seems to be damaged */
                    TerminalSendByte(BYTE_NAK);
                    State = STATE_RECEIVE_WAIT;
                }
            } else if (ReceivedFrameNumber == (CurrentFrameNumber - 1)) {
    4702:	30 e0       	ldi	r19, 0x00	; 0
    4704:	89 2f       	mov	r24, r25
    4706:	90 e0       	ldi	r25, 0x00	; 0
    4708:	01 97       	sbiw	r24, 0x01	; 1
    470a:	28 17       	cp	r18, r24
    470c:	39 07       	cpc	r19, r25
    470e:	81 f7       	brne	.-32     	; 0x46f0 <XModemProcessByte+0x150>
    4710:	66 e0       	ldi	r22, 0x06	; 6
    4712:	85 cf       	rjmp	.-246    	; 0x461e <XModemProcessByte+0x7e>

            break;

        case STATE_SEND_INIT:
            /* Start sending on NAK */
            if (Byte == BYTE_NAK) {
    4714:	85 31       	cpi	r24, 0x15	; 21
    4716:	19 f4       	brne	.+6      	; 0x471e <XModemProcessByte+0x17e>
                CurrentFrameNumber = FIRST_FRAME_NUMBER - 1;
    4718:	10 92 a5 2c 	sts	0x2CA5, r1	; 0x802ca5 <CurrentFrameNumber>
    471c:	08 c0       	rjmp	.+16     	; 0x472e <XModemProcessByte+0x18e>
                Byte = BYTE_ACK;
            } else if (Byte == BYTE_ESC) {
    471e:	8b 31       	cpi	r24, 0x1B	; 27
    4720:	61 f3       	breq	.-40     	; 0x46fa <XModemProcessByte+0x15a>
            }

        /* Fallthrough */

        case STATE_SEND_WAIT:
            if (Byte == BYTE_CAN) {
    4722:	88 31       	cpi	r24, 0x18	; 24
    4724:	09 f4       	brne	.+2      	; 0x4728 <XModemProcessByte+0x188>
    4726:	5f cf       	rjmp	.-322    	; 0x45e6 <XModemProcessByte+0x46>
                /* Cancel */
                TerminalSendByte(BYTE_ACK);
                State = STATE_OFF;
            } else if (Byte == BYTE_ACK) {
    4728:	86 30       	cpi	r24, 0x06	; 6
    472a:	09 f0       	breq	.+2      	; 0x472e <XModemProcessByte+0x18e>
    472c:	5a c0       	rjmp	.+180    	; 0x47e2 <XModemProcessByte+0x242>
                /* Acknowledge. Proceed to next frame, get data and calc checksum */
                CurrentFrameNumber++;
    472e:	80 91 a5 2c 	lds	r24, 0x2CA5	; 0x802ca5 <CurrentFrameNumber>
    4732:	8f 5f       	subi	r24, 0xFF	; 255
    4734:	80 93 a5 2c 	sts	0x2CA5, r24	; 0x802ca5 <CurrentFrameNumber>

                if (CallbackFunc(TerminalBuffer, BlockAddress, XMODEM_BLOCK_SIZE)) {
    4738:	40 91 9b 2c 	lds	r20, 0x2C9B	; 0x802c9b <BlockAddress>
    473c:	50 91 9c 2c 	lds	r21, 0x2C9C	; 0x802c9c <BlockAddress+0x1>
    4740:	60 91 9d 2c 	lds	r22, 0x2C9D	; 0x802c9d <BlockAddress+0x2>
    4744:	70 91 9e 2c 	lds	r23, 0x2C9E	; 0x802c9e <BlockAddress+0x3>
    4748:	e0 91 99 2c 	lds	r30, 0x2C99	; 0x802c99 <CallbackFunc>
    474c:	f0 91 9a 2c 	lds	r31, 0x2C9A	; 0x802c9a <CallbackFunc+0x1>
    4750:	20 e8       	ldi	r18, 0x80	; 128
    4752:	30 e0       	ldi	r19, 0x00	; 0
    4754:	8b e3       	ldi	r24, 0x3B	; 59
    4756:	90 e3       	ldi	r25, 0x30	; 48
    4758:	19 95       	eicall
    475a:	c8 2f       	mov	r28, r24
    475c:	88 23       	and	r24, r24
    475e:	d1 f1       	breq	.+116    	; 0x47d4 <XModemProcessByte+0x234>
    4760:	61 e0       	ldi	r22, 0x01	; 1
    4762:	83 e0       	ldi	r24, 0x03	; 3
    4764:	90 e2       	ldi	r25, 0x20	; 32
    4766:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    476a:	60 91 a5 2c 	lds	r22, 0x2CA5	; 0x802ca5 <CurrentFrameNumber>
    476e:	83 e0       	ldi	r24, 0x03	; 3
    4770:	90 e2       	ldi	r25, 0x20	; 32
    4772:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    4776:	60 91 a5 2c 	lds	r22, 0x2CA5	; 0x802ca5 <CurrentFrameNumber>
    477a:	60 95       	com	r22
    477c:	83 e0       	ldi	r24, 0x03	; 3
    477e:	90 e2       	ldi	r25, 0x20	; 32
    4780:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
                    TerminalSendByte(BYTE_SOH);
                    TerminalSendByte(CurrentFrameNumber);
                    TerminalSendByte(255 - CurrentFrameNumber);
                    TerminalSendBlock(TerminalBuffer, XMODEM_BLOCK_SIZE);
    4784:	60 e8       	ldi	r22, 0x80	; 128
    4786:	70 e0       	ldi	r23, 0x00	; 0
    4788:	8b e3       	ldi	r24, 0x3B	; 59
    478a:	90 e3       	ldi	r25, 0x30	; 48
    478c:	21 d8       	rcall	.-4030   	; 0x37d0 <TerminalSendBlock>
    478e:	eb e3       	ldi	r30, 0x3B	; 59
    4790:	f0 e3       	ldi	r31, 0x30	; 48
static uint32_t BlockAddress;

static XModemCallbackType CallbackFunc;

static uint8_t CalcChecksum(const void *Buffer, uint16_t ByteCount) {
    uint8_t Checksum = CHECKSUM_INIT_VALUE;
    4792:	60 e0       	ldi	r22, 0x00	; 0
    uint8_t *DataPtr = (uint8_t *) Buffer;

    while (ByteCount--) {
    4794:	80 e3       	ldi	r24, 0x30	; 48
    4796:	eb 3b       	cpi	r30, 0xBB	; 187
    4798:	f8 07       	cpc	r31, r24
    479a:	19 f0       	breq	.+6      	; 0x47a2 <XModemProcessByte+0x202>
        Checksum += *DataPtr++;
    479c:	81 91       	ld	r24, Z+
    479e:	68 0f       	add	r22, r24
    47a0:	f9 cf       	rjmp	.-14     	; 0x4794 <XModemProcessByte+0x1f4>
    47a2:	83 e0       	ldi	r24, 0x03	; 3
    47a4:	90 e2       	ldi	r25, 0x20	; 32
    47a6:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
                    TerminalSendByte(CurrentFrameNumber);
                    TerminalSendByte(255 - CurrentFrameNumber);
                    TerminalSendBlock(TerminalBuffer, XMODEM_BLOCK_SIZE);
                    TerminalSendByte(CalcChecksum(TerminalBuffer, XMODEM_BLOCK_SIZE));

                    BlockAddress += XMODEM_BLOCK_SIZE;
    47aa:	80 91 9b 2c 	lds	r24, 0x2C9B	; 0x802c9b <BlockAddress>
    47ae:	90 91 9c 2c 	lds	r25, 0x2C9C	; 0x802c9c <BlockAddress+0x1>
    47b2:	a0 91 9d 2c 	lds	r26, 0x2C9D	; 0x802c9d <BlockAddress+0x2>
    47b6:	b0 91 9e 2c 	lds	r27, 0x2C9E	; 0x802c9e <BlockAddress+0x3>
    47ba:	80 58       	subi	r24, 0x80	; 128
    47bc:	9f 4f       	sbci	r25, 0xFF	; 255
    47be:	af 4f       	sbci	r26, 0xFF	; 255
    47c0:	bf 4f       	sbci	r27, 0xFF	; 255
    47c2:	80 93 9b 2c 	sts	0x2C9B, r24	; 0x802c9b <BlockAddress>
    47c6:	90 93 9c 2c 	sts	0x2C9C, r25	; 0x802c9c <BlockAddress+0x1>
    47ca:	a0 93 9d 2c 	sts	0x2C9D, r26	; 0x802c9d <BlockAddress+0x2>
    47ce:	b0 93 9e 2c 	sts	0x2C9E, r27	; 0x802c9e <BlockAddress+0x3>
    47d2:	33 c0       	rjmp	.+102    	; 0x483a <XModemProcessByte+0x29a>
    47d4:	64 e0       	ldi	r22, 0x04	; 4
    47d6:	83 e0       	ldi	r24, 0x03	; 3
    47d8:	90 e2       	ldi	r25, 0x20	; 32
    47da:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
                } else {
                    TerminalSendByte(BYTE_EOT);
                    State = STATE_SEND_EOT;
    47de:	89 e0       	ldi	r24, 0x09	; 9
    47e0:	23 cf       	rjmp	.-442    	; 0x4628 <XModemProcessByte+0x88>
                }
            } else if (Byte == BYTE_NAK) {
    47e2:	85 31       	cpi	r24, 0x15	; 21
    47e4:	09 f0       	breq	.+2      	; 0x47e8 <XModemProcessByte+0x248>
    47e6:	8b cf       	rjmp	.-234    	; 0x46fe <XModemProcessByte+0x15e>
    47e8:	61 e0       	ldi	r22, 0x01	; 1
    47ea:	83 e0       	ldi	r24, 0x03	; 3
    47ec:	90 e2       	ldi	r25, 0x20	; 32
    47ee:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    47f2:	60 91 a5 2c 	lds	r22, 0x2CA5	; 0x802ca5 <CurrentFrameNumber>
    47f6:	83 e0       	ldi	r24, 0x03	; 3
    47f8:	90 e2       	ldi	r25, 0x20	; 32
    47fa:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    47fe:	60 91 a5 2c 	lds	r22, 0x2CA5	; 0x802ca5 <CurrentFrameNumber>
    4802:	60 95       	com	r22
    4804:	83 e0       	ldi	r24, 0x03	; 3
    4806:	90 e2       	ldi	r25, 0x20	; 32
    4808:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
                /* Resend frame */
                TerminalSendByte(BYTE_SOH);
                TerminalSendByte(CurrentFrameNumber);
                TerminalSendByte(255 - CurrentFrameNumber);
                TerminalSendBlock(TerminalBuffer, XMODEM_BLOCK_SIZE);
    480c:	60 e8       	ldi	r22, 0x80	; 128
    480e:	70 e0       	ldi	r23, 0x00	; 0
    4810:	8b e3       	ldi	r24, 0x3B	; 59
    4812:	90 e3       	ldi	r25, 0x30	; 48
    4814:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <TerminalSendBlock>
    4818:	eb e3       	ldi	r30, 0x3B	; 59
    481a:	f0 e3       	ldi	r31, 0x30	; 48
    481c:	8b eb       	ldi	r24, 0xBB	; 187
    481e:	90 e3       	ldi	r25, 0x30	; 48
static uint32_t BlockAddress;

static XModemCallbackType CallbackFunc;

static uint8_t CalcChecksum(const void *Buffer, uint16_t ByteCount) {
    uint8_t Checksum = CHECKSUM_INIT_VALUE;
    4820:	60 e0       	ldi	r22, 0x00	; 0
    uint8_t *DataPtr = (uint8_t *) Buffer;

    while (ByteCount--) {
    4822:	8e 17       	cp	r24, r30
    4824:	9f 07       	cpc	r25, r31
    4826:	19 f0       	breq	.+6      	; 0x482e <XModemProcessByte+0x28e>
        Checksum += *DataPtr++;
    4828:	21 91       	ld	r18, Z+
    482a:	62 0f       	add	r22, r18
    482c:	fa cf       	rjmp	.-12     	; 0x4822 <XModemProcessByte+0x282>
    482e:	83 e0       	ldi	r24, 0x03	; 3
    4830:	90 e2       	ldi	r25, 0x20	; 32
    4832:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    4836:	63 cf       	rjmp	.-314    	; 0x46fe <XModemProcessByte+0x15e>
            /* Receive Ack */
            State = STATE_OFF;
            break;

        default:
            return false;
    4838:	c0 e0       	ldi	r28, 0x00	; 0
            break;
    }

    return true;
}
    483a:	8c 2f       	mov	r24, r28
    483c:	cf 91       	pop	r28
    483e:	08 95       	ret

00004840 <XModemTick>:

void XModemTick(void) {
    /* Timeouts go here */
    switch (State) {
    4840:	80 91 a6 2c 	lds	r24, 0x2CA6	; 0x802ca6 <State>
    4844:	81 30       	cpi	r24, 0x01	; 1
    4846:	19 f0       	breq	.+6      	; 0x484e <XModemTick+0xe>
    4848:	87 30       	cpi	r24, 0x07	; 7
    484a:	29 f1       	breq	.+74     	; 0x4896 <XModemTick+0x56>
    484c:	08 95       	ret
        case STATE_RECEIVE_INIT:
            if (RetryTimeout-- == 0) {
    484e:	80 91 a1 2c 	lds	r24, 0x2CA1	; 0x802ca1 <RetryTimeout>
    4852:	90 91 a2 2c 	lds	r25, 0x2CA2	; 0x802ca2 <RetryTimeout+0x1>
    4856:	9c 01       	movw	r18, r24
    4858:	21 50       	subi	r18, 0x01	; 1
    485a:	31 09       	sbc	r19, r1
    485c:	20 93 a1 2c 	sts	0x2CA1, r18	; 0x802ca1 <RetryTimeout>
    4860:	30 93 a2 2c 	sts	0x2CA2, r19	; 0x802ca2 <RetryTimeout+0x1>
    4864:	89 2b       	or	r24, r25
    4866:	31 f5       	brne	.+76     	; 0x48b4 <XModemTick+0x74>
                if (RetryCount-- > 0) {
    4868:	80 91 a3 2c 	lds	r24, 0x2CA3	; 0x802ca3 <RetryCount>
    486c:	9f ef       	ldi	r25, 0xFF	; 255
    486e:	98 0f       	add	r25, r24
    4870:	90 93 a3 2c 	sts	0x2CA3, r25	; 0x802ca3 <RetryCount>
    4874:	88 23       	and	r24, r24
    4876:	31 f0       	breq	.+12     	; 0x4884 <XModemTick+0x44>
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    4878:	65 e1       	ldi	r22, 0x15	; 21
    487a:	83 e0       	ldi	r24, 0x03	; 3
    487c:	90 e2       	ldi	r25, 0x20	; 32
    487e:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    4882:	02 c0       	rjmp	.+4      	; 0x4888 <XModemTick+0x48>
                    /* Put out communication request */
                    TerminalSendChar(BYTE_NAK);
                } else {
                    /* Just shut off after some time. */
                    State = STATE_OFF;
    4884:	10 92 a6 2c 	sts	0x2CA6, r1	; 0x802ca6 <State>
                }

                RetryTimeout = RECV_INIT_TIMEOUT;
    4888:	85 e0       	ldi	r24, 0x05	; 5
    488a:	90 e0       	ldi	r25, 0x00	; 0
    488c:	80 93 a1 2c 	sts	0x2CA1, r24	; 0x802ca1 <RetryTimeout>
    4890:	90 93 a2 2c 	sts	0x2CA2, r25	; 0x802ca2 <RetryTimeout+0x1>
    4894:	08 95       	ret
            }
            break;

        case STATE_SEND_INIT:
            if (RetryTimeout-- == 0) {
    4896:	80 91 a1 2c 	lds	r24, 0x2CA1	; 0x802ca1 <RetryTimeout>
    489a:	90 91 a2 2c 	lds	r25, 0x2CA2	; 0x802ca2 <RetryTimeout+0x1>
    489e:	9c 01       	movw	r18, r24
    48a0:	21 50       	subi	r18, 0x01	; 1
    48a2:	31 09       	sbc	r19, r1
    48a4:	20 93 a1 2c 	sts	0x2CA1, r18	; 0x802ca1 <RetryTimeout>
    48a8:	30 93 a2 2c 	sts	0x2CA2, r19	; 0x802ca2 <RetryTimeout+0x1>
    48ac:	89 2b       	or	r24, r25
    48ae:	11 f4       	brne	.+4      	; 0x48b4 <XModemTick+0x74>
                /* Abort */
                State = STATE_OFF;
    48b0:	10 92 a6 2c 	sts	0x2CA6, r1	; 0x802ca6 <State>
    48b4:	08 95       	ret

000048b6 <GetStatusMessageP>:
        TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    }
}

void CommandLineInit(void) {
    BufferIdx = 0;
    48b6:	e3 e3       	ldi	r30, 0x33	; 51
    48b8:	fe e0       	ldi	r31, 0x0E	; 14
    48ba:	20 e0       	ldi	r18, 0x00	; 0
    48bc:	30 e0       	ldi	r19, 0x00	; 0
    48be:	94 91       	lpm	r25, Z
    48c0:	98 13       	cpse	r25, r24
    48c2:	09 c0       	rjmp	.+18     	; 0x48d6 <GetStatusMessageP+0x20>
    48c4:	41 e2       	ldi	r20, 0x21	; 33
    48c6:	42 9f       	mul	r20, r18
    48c8:	c0 01       	movw	r24, r0
    48ca:	43 9f       	mul	r20, r19
    48cc:	90 0d       	add	r25, r0
    48ce:	11 24       	eor	r1, r1
    48d0:	8c 5c       	subi	r24, 0xCC	; 204
    48d2:	91 4f       	sbci	r25, 0xF1	; 241
    48d4:	08 95       	ret
    48d6:	2f 5f       	subi	r18, 0xFF	; 255
    48d8:	3f 4f       	sbci	r19, 0xFF	; 255
    48da:	b1 96       	adiw	r30, 0x21	; 33
    48dc:	29 30       	cpi	r18, 0x09	; 9
    48de:	31 05       	cpc	r19, r1
    48e0:	71 f7       	brne	.-36     	; 0x48be <GetStatusMessageP+0x8>
    48e2:	80 e0       	ldi	r24, 0x00	; 0
    48e4:	90 e0       	ldi	r25, 0x00	; 0
    48e6:	08 95       	ret

000048e8 <CallCommandFunc>:
    48e8:	26 2f       	mov	r18, r22
    48ea:	ba 01       	movw	r22, r20
    48ec:	2f 33       	cpi	r18, 0x3F	; 63
    48ee:	11 f4       	brne	.+4      	; 0x48f4 <CallCommandFunc+0xc>
    48f0:	46 96       	adiw	r24, 0x16	; 22
    48f2:	07 c0       	rjmp	.+14     	; 0x4902 <CallCommandFunc+0x1a>
    48f4:	2d 33       	cpi	r18, 0x3D	; 61
    48f6:	11 f4       	brne	.+4      	; 0x48fc <CallCommandFunc+0x14>
    48f8:	44 96       	adiw	r24, 0x14	; 20
    48fa:	11 c0       	rjmp	.+34     	; 0x491e <CallCommandFunc+0x36>
    48fc:	21 11       	cpse	r18, r1
    48fe:	0c c0       	rjmp	.+24     	; 0x4918 <CallCommandFunc+0x30>
    4900:	40 96       	adiw	r24, 0x10	; 16
    4902:	fc 01       	movw	r30, r24
    4904:	25 91       	lpm	r18, Z+
    4906:	34 91       	lpm	r19, Z
    4908:	21 15       	cp	r18, r1
    490a:	31 05       	cpc	r19, r1
    490c:	21 f1       	breq	.+72     	; 0x4956 <CallCommandFunc+0x6e>
    490e:	8b e3       	ldi	r24, 0x3B	; 59
    4910:	90 e3       	ldi	r25, 0x30	; 48
    4912:	f9 01       	movw	r30, r18
    4914:	19 95       	eicall
    4916:	0d c0       	rjmp	.+26     	; 0x4932 <CallCommandFunc+0x4a>
    4918:	20 32       	cpi	r18, 0x20	; 32
    491a:	e9 f4       	brne	.+58     	; 0x4956 <CallCommandFunc+0x6e>
    491c:	42 96       	adiw	r24, 0x12	; 18
    491e:	fc 01       	movw	r30, r24
    4920:	25 91       	lpm	r18, Z+
    4922:	34 91       	lpm	r19, Z
    4924:	21 15       	cp	r18, r1
    4926:	31 05       	cpc	r19, r1
    4928:	b1 f0       	breq	.+44     	; 0x4956 <CallCommandFunc+0x6e>
    492a:	8b e3       	ldi	r24, 0x3B	; 59
    492c:	90 e3       	ldi	r25, 0x30	; 48
    492e:	f9 01       	movw	r30, r18
    4930:	19 95       	eicall
    4932:	8f 3f       	cpi	r24, 0xFF	; 255
    4934:	89 f4       	brne	.+34     	; 0x4958 <CallCommandFunc+0x70>
    4936:	91 e0       	ldi	r25, 0x01	; 1
    4938:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <TaskPending>
    493c:	4e b1       	in	r20, 0x0e	; 14
    493e:	5f b1       	in	r21, 0x0f	; 15
    4940:	20 91 08 04 	lds	r18, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    4944:	30 91 09 04 	lds	r19, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    4948:	24 2b       	or	r18, r20
    494a:	35 2b       	or	r19, r21
    494c:	20 93 a9 2c 	sts	0x2CA9, r18	; 0x802ca9 <TaskPendingSince>
    4950:	30 93 aa 2c 	sts	0x2CAA, r19	; 0x802caa <TaskPendingSince+0x1>
    4954:	08 95       	ret
    4956:	89 ec       	ldi	r24, 0xC9	; 201
    4958:	08 95       	ret

0000495a <CommandExecute>:
    495a:	0f 93       	push	r16
    495c:	1f 93       	push	r17
    495e:	cf 93       	push	r28
    4960:	df 93       	push	r29
    4962:	8c 01       	movw	r16, r24
    4964:	cc e5       	ldi	r28, 0x5C	; 92
    4966:	df e0       	ldi	r29, 0x0F	; 15
    4968:	be 01       	movw	r22, r28
    496a:	c8 01       	movw	r24, r16
    496c:	0e 94 7b 78 	call	0xf0f6	; 0xf0f6 <strcmp_P>
    4970:	89 2b       	or	r24, r25
    4972:	49 f4       	brne	.+18     	; 0x4986 <CommandExecute+0x2c>
    4974:	40 e0       	ldi	r20, 0x00	; 0
    4976:	50 e0       	ldi	r21, 0x00	; 0
    4978:	60 e0       	ldi	r22, 0x00	; 0
    497a:	ce 01       	movw	r24, r28
    497c:	df 91       	pop	r29
    497e:	cf 91       	pop	r28
    4980:	1f 91       	pop	r17
    4982:	0f 91       	pop	r16
    4984:	b1 cf       	rjmp	.-158    	; 0x48e8 <CallCommandFunc>
    4986:	68 96       	adiw	r28, 0x18	; 24
    4988:	83 e1       	ldi	r24, 0x13	; 19
    498a:	cc 34       	cpi	r28, 0x4C	; 76
    498c:	d8 07       	cpc	r29, r24
    498e:	61 f7       	brne	.-40     	; 0x4968 <CommandExecute+0xe>
    4990:	df 91       	pop	r29
    4992:	cf 91       	pop	r28
    4994:	1f 91       	pop	r17
    4996:	0f 91       	pop	r16
    4998:	08 95       	ret

0000499a <CommandLineProcessByte>:
}

bool CommandLineProcessByte(uint8_t Byte) {
    499a:	cf 92       	push	r12
    499c:	df 92       	push	r13
    499e:	ef 92       	push	r14
    49a0:	ff 92       	push	r15
    49a2:	1f 93       	push	r17
    49a4:	cf 93       	push	r28
    49a6:	df 93       	push	r29
    if (IS_CHARACTER(Byte)) {
    49a8:	98 2f       	mov	r25, r24
    49aa:	9f 7d       	andi	r25, 0xDF	; 223
    49ac:	91 54       	subi	r25, 0x41	; 65
    49ae:	9a 31       	cpi	r25, 0x1A	; 26
    49b0:	60 f0       	brcs	.+24     	; 0x49ca <CommandLineProcessByte+0x30>
    49b2:	90 ed       	ldi	r25, 0xD0	; 208
    49b4:	98 0f       	add	r25, r24
    49b6:	9a 30       	cpi	r25, 0x0A	; 10
    49b8:	40 f0       	brcs	.+16     	; 0x49ca <CommandLineProcessByte+0x30>
    49ba:	8f 35       	cpi	r24, 0x5F	; 95
    49bc:	31 f0       	breq	.+12     	; 0x49ca <CommandLineProcessByte+0x30>
    49be:	98 2f       	mov	r25, r24
    49c0:	9d 7f       	andi	r25, 0xFD	; 253
    49c2:	9d 33       	cpi	r25, 0x3D	; 61
    49c4:	11 f0       	breq	.+4      	; 0x49ca <CommandLineProcessByte+0x30>
    49c6:	80 32       	cpi	r24, 0x20	; 32
    49c8:	d1 f4       	brne	.+52     	; 0x49fe <CommandLineProcessByte+0x64>
        /* Store uppercase character */
        if (IS_LOWERCASE(Byte)) {
    49ca:	9f e9       	ldi	r25, 0x9F	; 159
    49cc:	98 0f       	add	r25, r24
    49ce:	9a 31       	cpi	r25, 0x1A	; 26
    49d0:	08 f4       	brcc	.+2      	; 0x49d4 <CommandLineProcessByte+0x3a>
            Byte = TO_UPPERCASE(Byte);
    49d2:	80 52       	subi	r24, 0x20	; 32
        }

        /* Prevent buffer overflow and account for '\0' */
        if (BufferIdx < TERMINAL_BUFFER_SIZE - 1) {
    49d4:	20 91 ac 2c 	lds	r18, 0x2CAC	; 0x802cac <BufferIdx>
    49d8:	30 91 ad 2c 	lds	r19, 0x2CAD	; 0x802cad <BufferIdx+0x1>
    49dc:	2f 3f       	cpi	r18, 0xFF	; 255
    49de:	91 e0       	ldi	r25, 0x01	; 1
    49e0:	39 07       	cpc	r19, r25
    49e2:	08 f0       	brcs	.+2      	; 0x49e6 <CommandLineProcessByte+0x4c>
    49e4:	98 c0       	rjmp	.+304    	; 0x4b16 <CommandLineProcessByte+0x17c>
            TerminalBuffer[BufferIdx++] = Byte;
    49e6:	a9 01       	movw	r20, r18
    49e8:	4f 5f       	subi	r20, 0xFF	; 255
    49ea:	5f 4f       	sbci	r21, 0xFF	; 255
    49ec:	40 93 ac 2c 	sts	0x2CAC, r20	; 0x802cac <BufferIdx>
    49f0:	50 93 ad 2c 	sts	0x2CAD, r21	; 0x802cad <BufferIdx+0x1>
    49f4:	f9 01       	movw	r30, r18
    49f6:	e5 5c       	subi	r30, 0xC5	; 197
    49f8:	ff 4c       	sbci	r31, 0xCF	; 207
    49fa:	80 83       	st	Z, r24
    49fc:	8c c0       	rjmp	.+280    	; 0x4b16 <CommandLineProcessByte+0x17c>
        }
    } else if (Byte == '\r') {
    49fe:	8d 30       	cpi	r24, 0x0D	; 13
    4a00:	09 f0       	breq	.+2      	; 0x4a04 <CommandLineProcessByte+0x6a>
    4a02:	75 c0       	rjmp	.+234    	; 0x4aee <CommandLineProcessByte+0x154>
        /* Process on \r. Terminate string and decode. */
        TerminalBuffer[BufferIdx] = '\0';
    4a04:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <BufferIdx>
    4a08:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <BufferIdx+0x1>
    4a0c:	e5 5c       	subi	r30, 0xC5	; 197
    4a0e:	ff 4c       	sbci	r31, 0xCF	; 207
    4a10:	10 82       	st	Z, r1
        BufferIdx = 0;
    4a12:	10 92 ac 2c 	sts	0x2CAC, r1	; 0x802cac <BufferIdx>
    4a16:	10 92 ad 2c 	sts	0x2CAD, r1	; 0x802cad <BufferIdx+0x1>

        if (!TaskPending)
    4a1a:	80 91 ab 2c 	lds	r24, 0x2CAB	; 0x802cab <TaskPending>
    4a1e:	81 11       	cpse	r24, r1
    4a20:	7a c0       	rjmp	.+244    	; 0x4b16 <CommandLineProcessByte+0x17c>
    bool CommandFound = false;
    CommandStatusIdType StatusId = COMMAND_ERR_UNKNOWN_CMD_ID;
    char *pTerminalBuffer = (char *) TerminalBuffer;

    /* Do some sanity check first */
    if (!IS_COMMAND_DELIMITER(pTerminalBuffer[0])) {
    4a22:	80 91 3b 30 	lds	r24, 0x303B	; 0x80303b <TerminalBuffer>
    4a26:	98 2f       	mov	r25, r24
    4a28:	9f 7d       	andi	r25, 0xDF	; 223
    4a2a:	81 f1       	breq	.+96     	; 0x4a8c <CommandLineProcessByte+0xf2>
    4a2c:	8d 7f       	andi	r24, 0xFD	; 253
    4a2e:	8d 33       	cpi	r24, 0x3D	; 61
    4a30:	69 f1       	breq	.+90     	; 0x4a8c <CommandLineProcessByte+0xf2>
    4a32:	eb e3       	ldi	r30, 0x3B	; 59
    4a34:	f0 e3       	ldi	r31, 0x30	; 48
    4a36:	7f 01       	movw	r14, r30
        char *pCommandDelimiter = pTerminalBuffer;
        char CommandDelimiter = '\0';

        /* Search for command delimiter, store it and replace with '\0' */
        while (!(IS_COMMAND_DELIMITER(*pCommandDelimiter)))
    4a38:	11 91       	ld	r17, Z+
    4a3a:	11 23       	and	r17, r17
    4a3c:	31 f0       	breq	.+12     	; 0x4a4a <CommandLineProcessByte+0xb0>
    4a3e:	1f 33       	cpi	r17, 0x3F	; 63
    4a40:	21 f0       	breq	.+8      	; 0x4a4a <CommandLineProcessByte+0xb0>
    4a42:	1d 33       	cpi	r17, 0x3D	; 61
    4a44:	11 f0       	breq	.+4      	; 0x4a4a <CommandLineProcessByte+0xb0>
    4a46:	10 32       	cpi	r17, 0x20	; 32
    4a48:	b1 f7       	brne	.-20     	; 0x4a36 <CommandLineProcessByte+0x9c>
            pCommandDelimiter++;

        CommandDelimiter = *pCommandDelimiter;
        *pCommandDelimiter = '\0';
    4a4a:	f7 01       	movw	r30, r14
    4a4c:	10 82       	st	Z, r1
    4a4e:	cc e5       	ldi	r28, 0x5C	; 92
    4a50:	df e0       	ldi	r29, 0x0F	; 15
    4a52:	8c e4       	ldi	r24, 0x4C	; 76
    4a54:	c8 2e       	mov	r12, r24
    4a56:	83 e1       	ldi	r24, 0x13	; 19
    4a58:	d8 2e       	mov	r13, r24

        /* Search in command table */
        for (i = 0; i < ARRAY_COUNT(CommandTable); i++) {
            if (strcmp_P(pTerminalBuffer, CommandTable[i].Command) == 0) {
    4a5a:	be 01       	movw	r22, r28
    4a5c:	8b e3       	ldi	r24, 0x3B	; 59
    4a5e:	90 e3       	ldi	r25, 0x30	; 48
    4a60:	0e 94 7b 78 	call	0xf0f6	; 0xf0f6 <strcmp_P>
    4a64:	89 2b       	or	r24, r25
    4a66:	71 f4       	brne	.+28     	; 0x4a84 <CommandLineProcessByte+0xea>
                /* Command found. Clear buffer, and call appropriate function */
                char *pParam = ++pCommandDelimiter;

                pTerminalBuffer[0] = '\0';
    4a68:	10 92 3b 30 	sts	0x303B, r1	; 0x80303b <TerminalBuffer>
                CommandFound = true;

                StatusId = CallCommandFunc(&CommandTable[i], CommandDelimiter, pParam);
    4a6c:	a7 01       	movw	r20, r14
    4a6e:	4f 5f       	subi	r20, 0xFF	; 255
    4a70:	5f 4f       	sbci	r21, 0xFF	; 255
    4a72:	61 2f       	mov	r22, r17
    4a74:	ce 01       	movw	r24, r28
    4a76:	38 df       	rcall	.-400    	; 0x48e8 <CallCommandFunc>
    4a78:	c8 2f       	mov	r28, r24
                break;
            }
        }
    }

    if (StatusId == TIMEOUT_COMMAND) // it is a timeout command, so we return
    4a7a:	8f 3f       	cpi	r24, 0xFF	; 255
    4a7c:	09 f4       	brne	.+2      	; 0x4a80 <CommandLineProcessByte+0xe6>
    4a7e:	4b c0       	rjmp	.+150    	; 0x4b16 <CommandLineProcessByte+0x17c>
            if (strcmp_P(pTerminalBuffer, CommandTable[i].Command) == 0) {
                /* Command found. Clear buffer, and call appropriate function */
                char *pParam = ++pCommandDelimiter;

                pTerminalBuffer[0] = '\0';
                CommandFound = true;
    4a80:	d1 e0       	ldi	r29, 0x01	; 1
    4a82:	06 c0       	rjmp	.+12     	; 0x4a90 <CommandLineProcessByte+0xf6>
    4a84:	68 96       	adiw	r28, 0x18	; 24

        CommandDelimiter = *pCommandDelimiter;
        *pCommandDelimiter = '\0';

        /* Search in command table */
        for (i = 0; i < ARRAY_COUNT(CommandTable); i++) {
    4a86:	cc 16       	cp	r12, r28
    4a88:	dd 06       	cpc	r13, r29
    4a8a:	39 f7       	brne	.-50     	; 0x4a5a <CommandLineProcessByte+0xc0>
            if (strcmp_P(pTerminalBuffer, CommandTable[i].Command) == 0) {
                /* Command found. Clear buffer, and call appropriate function */
                char *pParam = ++pCommandDelimiter;

                pTerminalBuffer[0] = '\0';
                CommandFound = true;
    4a8c:	d0 e0       	ldi	r29, 0x00	; 0
    4a8e:	c8 ec       	ldi	r28, 0xC8	; 200
    }

    if (StatusId == TIMEOUT_COMMAND) // it is a timeout command, so we return
        return;

    if (GlobalSettings.ActiveSettingPtr->Configuration == CONFIG_NFC_COMMAND) { //if nfc mode then write status to pages
    4a90:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4a94:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4a98:	85 81       	ldd	r24, Z+5	; 0x05
    4a9a:	81 31       	cpi	r24, 0x11	; 17
    4a9c:	21 f4       	brne	.+8      	; 0x4aa6 <CommandLineProcessByte+0x10c>
        NFCStatusId(GetStatusMessageP(StatusId));
    4a9e:	8c 2f       	mov	r24, r28
    4aa0:	0a df       	rcall	.-492    	; 0x48b6 <GetStatusMessageP>
    4aa2:	0e 94 db 59 	call	0xb3b6	; 0xb3b6 <NFCStatusId>
    }

    /* Send command status message */
    TerminalSendStringP(GetStatusMessageP(StatusId));
    4aa6:	8c 2f       	mov	r24, r28
    4aa8:	06 df       	rcall	.-500    	; 0x48b6 <GetStatusMessageP>
    4aaa:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
    4aae:	80 e3       	ldi	r24, 0x30	; 48
    TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    4ab0:	9e e0       	ldi	r25, 0x0E	; 14
    4ab2:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
    4ab6:	dd 23       	and	r29, r29

    if (CommandFound && (pTerminalBuffer[0] != '\0')) {
    4ab8:	71 f1       	breq	.+92     	; 0x4b16 <CommandLineProcessByte+0x17c>
    4aba:	80 91 3b 30 	lds	r24, 0x303B	; 0x80303b <TerminalBuffer>
    4abe:	88 23       	and	r24, r24
    4ac0:	51 f1       	breq	.+84     	; 0x4b16 <CommandLineProcessByte+0x17c>
    4ac2:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
        /* Send optional answer */
        if (GlobalSettings.ActiveSettingPtr->Configuration == CONFIG_NFC_COMMAND) {
    4ac6:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4aca:	85 81       	ldd	r24, Z+5	; 0x05
    4acc:	81 31       	cpi	r24, 0x11	; 17
    4ace:	31 f4       	brne	.+12     	; 0x4adc <CommandLineProcessByte+0x142>
    4ad0:	8b e3       	ldi	r24, 0x3B	; 59
        NFCResponse = pTerminalBuffer; //send the answer to pages
    4ad2:	90 e3       	ldi	r25, 0x30	; 48
    4ad4:	80 93 3b 32 	sts	0x323B, r24	; 0x80323b <NFCResponse>
    4ad8:	90 93 3c 32 	sts	0x323C, r25	; 0x80323c <NFCResponse+0x1>
    4adc:	8b e3       	ldi	r24, 0x3B	; 59
        }
        TerminalSendString(pTerminalBuffer);
    4ade:	90 e3       	ldi	r25, 0x30	; 48
    4ae0:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>
    4ae4:	8d e2       	ldi	r24, 0x2D	; 45
        TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    4ae6:	9e e0       	ldi	r25, 0x0E	; 14
    4ae8:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
    4aec:	14 c0       	rjmp	.+40     	; 0x4b16 <CommandLineProcessByte+0x17c>
    4aee:	88 30       	cpi	r24, 0x08	; 8
        TerminalBuffer[BufferIdx] = '\0';
        BufferIdx = 0;

        if (!TaskPending)
            DecodeCommand();
    } else if (Byte == '\b') {
    4af0:	61 f4       	brne	.+24     	; 0x4b0a <CommandLineProcessByte+0x170>
    4af2:	80 91 ac 2c 	lds	r24, 0x2CAC	; 0x802cac <BufferIdx>
        /* Backspace. Delete last character in buffer. */
        if (BufferIdx > 0) {
    4af6:	90 91 ad 2c 	lds	r25, 0x2CAD	; 0x802cad <BufferIdx+0x1>
    4afa:	00 97       	sbiw	r24, 0x00	; 0
    4afc:	61 f0       	breq	.+24     	; 0x4b16 <CommandLineProcessByte+0x17c>
    4afe:	01 97       	sbiw	r24, 0x01	; 1
            BufferIdx--;
    4b00:	80 93 ac 2c 	sts	0x2CAC, r24	; 0x802cac <BufferIdx>
    4b04:	90 93 ad 2c 	sts	0x2CAD, r25	; 0x802cad <BufferIdx+0x1>
    4b08:	06 c0       	rjmp	.+12     	; 0x4b16 <CommandLineProcessByte+0x17c>
    4b0a:	8b 31       	cpi	r24, 0x1B	; 27
        }
    } else if (Byte == 0x1B) {
    4b0c:	21 f4       	brne	.+8      	; 0x4b16 <CommandLineProcessByte+0x17c>
    4b0e:	10 92 ac 2c 	sts	0x2CAC, r1	; 0x802cac <BufferIdx>
        /* Drop buffer on escape */
        BufferIdx = 0;
    4b12:	10 92 ad 2c 	sts	0x2CAD, r1	; 0x802cad <BufferIdx+0x1>
    4b16:	81 e0       	ldi	r24, 0x01	; 1
    } else {
        /* Ignore other chars */
    }
    return true;
}
    4b18:	df 91       	pop	r29
    4b1a:	cf 91       	pop	r28
    4b1c:	1f 91       	pop	r17
    4b1e:	ff 90       	pop	r15
    4b20:	ef 90       	pop	r14
    4b22:	df 90       	pop	r13
    4b24:	cf 90       	pop	r12
    4b26:	08 95       	ret

00004b28 <CommandLineTick>:
    4b28:	80 91 ab 2c 	lds	r24, 0x2CAB	; 0x802cab <TaskPending>
        CommandLinePendingTaskTimeout = NO_FUNCTION;
    }
}

void CommandLineTick(void) {
    if (TaskPending &&
    4b2c:	88 23       	and	r24, r24
    4b2e:	99 f1       	breq	.+102    	; 0x4b96 <CommandLineTick+0x6e>
            GlobalSettings.ActiveSettingPtr->PendingTaskTimeout != 0 && // 0 means no timeout
    4b30:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4b34:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4b38:	20 85       	ldd	r18, Z+8	; 0x08
    4b3a:	31 85       	ldd	r19, Z+9	; 0x09
        CommandLinePendingTaskTimeout = NO_FUNCTION;
    }
}

void CommandLineTick(void) {
    if (TaskPending &&
    4b3c:	21 15       	cp	r18, r1
    4b3e:	31 05       	cpc	r19, r1
    4b40:	51 f1       	breq	.+84     	; 0x4b96 <CommandLineTick+0x6e>

    RTC.INTFLAGS = RTC_COMPIF_bm;
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    4b42:	4e b1       	in	r20, 0x0e	; 14
    4b44:	5f b1       	in	r21, 0x0f	; 15
    4b46:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    4b4a:	90 91 09 04 	lds	r25, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
            GlobalSettings.ActiveSettingPtr->PendingTaskTimeout != 0 && // 0 means no timeout
    4b4e:	84 2b       	or	r24, r20
    4b50:	95 2b       	or	r25, r21
    4b52:	40 91 a9 2c 	lds	r20, 0x2CA9	; 0x802ca9 <TaskPendingSince>
    4b56:	50 91 aa 2c 	lds	r21, 0x2CAA	; 0x802caa <TaskPendingSince+0x1>
    4b5a:	84 1b       	sub	r24, r20
    4b5c:	95 0b       	sbc	r25, r21
    4b5e:	64 e6       	ldi	r22, 0x64	; 100
    4b60:	70 e0       	ldi	r23, 0x00	; 0
    4b62:	0e 94 ea 77 	call	0xefd4	; 0xefd4 <__udivmodhi4>
    4b66:	62 17       	cp	r22, r18
    4b68:	73 07       	cpc	r23, r19
    4b6a:	a8 f0       	brcs	.+42     	; 0x4b96 <CommandLineTick+0x6e>
    }
    return true;
}

INLINE void Timeout(void) {
    TaskPending = false;
    4b6c:	10 92 ab 2c 	sts	0x2CAB, r1	; 0x802cab <TaskPending>
    TerminalSendStringP(GetStatusMessageP(COMMAND_ERR_TIMEOUT_ID));
    4b70:	8b ec       	ldi	r24, 0xCB	; 203
    4b72:	a1 de       	rcall	.-702    	; 0x48b6 <GetStatusMessageP>
    4b74:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
    TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    4b78:	8a e2       	ldi	r24, 0x2A	; 42
    4b7a:	9e e0       	ldi	r25, 0x0E	; 14
    4b7c:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>

    if (CommandLinePendingTaskTimeout != NO_FUNCTION) {
    4b80:	e0 91 a7 2c 	lds	r30, 0x2CA7	; 0x802ca7 <CommandLinePendingTaskTimeout>
    4b84:	f0 91 a8 2c 	lds	r31, 0x2CA8	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    4b88:	30 97       	sbiw	r30, 0x00	; 0
    4b8a:	29 f0       	breq	.+10     	; 0x4b96 <CommandLineTick+0x6e>
        CommandLinePendingTaskTimeout(); // call the function that ends the task
    4b8c:	19 95       	eicall
        CommandLinePendingTaskTimeout = NO_FUNCTION;
    4b8e:	10 92 a7 2c 	sts	0x2CA7, r1	; 0x802ca7 <CommandLinePendingTaskTimeout>
    4b92:	10 92 a8 2c 	sts	0x2CA8, r1	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    4b96:	08 95       	ret

00004b98 <CommandLinePendingTaskBreak>:
        Timeout();
    }
}

void CommandLinePendingTaskBreak(void) {
    if (!TaskPending)
    4b98:	80 91 ab 2c 	lds	r24, 0x2CAB	; 0x802cab <TaskPending>
    4b9c:	88 23       	and	r24, r24
    4b9e:	a9 f0       	breq	.+42     	; 0x4bca <CommandLinePendingTaskBreak+0x32>
    }
    return true;
}

INLINE void Timeout(void) {
    TaskPending = false;
    4ba0:	10 92 ab 2c 	sts	0x2CAB, r1	; 0x802cab <TaskPending>
    TerminalSendStringP(GetStatusMessageP(COMMAND_ERR_TIMEOUT_ID));
    4ba4:	8b ec       	ldi	r24, 0xCB	; 203
    4ba6:	87 de       	rcall	.-754    	; 0x48b6 <GetStatusMessageP>
    4ba8:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
    TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    4bac:	8a e2       	ldi	r24, 0x2A	; 42
    4bae:	9e e0       	ldi	r25, 0x0E	; 14
    4bb0:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>

    if (CommandLinePendingTaskTimeout != NO_FUNCTION) {
    4bb4:	e0 91 a7 2c 	lds	r30, 0x2CA7	; 0x802ca7 <CommandLinePendingTaskTimeout>
    4bb8:	f0 91 a8 2c 	lds	r31, 0x2CA8	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    4bbc:	30 97       	sbiw	r30, 0x00	; 0
    4bbe:	29 f0       	breq	.+10     	; 0x4bca <CommandLinePendingTaskBreak+0x32>
        CommandLinePendingTaskTimeout(); // call the function that ends the task
    4bc0:	19 95       	eicall
        CommandLinePendingTaskTimeout = NO_FUNCTION;
    4bc2:	10 92 a7 2c 	sts	0x2CA7, r1	; 0x802ca7 <CommandLinePendingTaskTimeout>
    4bc6:	10 92 a8 2c 	sts	0x2CA8, r1	; 0x802ca8 <CommandLinePendingTaskTimeout+0x1>
    4bca:	08 95       	ret

00004bcc <CommandLinePendingTaskFinished>:
        return;

    Timeout();
}

void CommandLinePendingTaskFinished(CommandStatusIdType ReturnStatusID, char const *const OutMessage) {
    4bcc:	cf 93       	push	r28
    4bce:	df 93       	push	r29
    if (!TaskPending) // if no task is pending, no task can be finished
    4bd0:	90 91 ab 2c 	lds	r25, 0x2CAB	; 0x802cab <TaskPending>
    4bd4:	99 23       	and	r25, r25
    4bd6:	a9 f0       	breq	.+42     	; 0x4c02 <CommandLinePendingTaskFinished+0x36>
    4bd8:	eb 01       	movw	r28, r22
        return;
    TaskPending = false;
    4bda:	10 92 ab 2c 	sts	0x2CAB, r1	; 0x802cab <TaskPending>

    TerminalSendStringP(GetStatusMessageP(ReturnStatusID));
    4bde:	6b de       	rcall	.-810    	; 0x48b6 <GetStatusMessageP>
    4be0:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
    TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    4be4:	87 e2       	ldi	r24, 0x27	; 39
    4be6:	9e e0       	ldi	r25, 0x0E	; 14
    4be8:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>

    if (OutMessage != NULL) {
    4bec:	20 97       	sbiw	r28, 0x00	; 0
    4bee:	49 f0       	breq	.+18     	; 0x4c02 <CommandLinePendingTaskFinished+0x36>
        TerminalSendString(OutMessage);
    4bf0:	ce 01       	movw	r24, r28
    4bf2:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>
        TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    4bf6:	84 e2       	ldi	r24, 0x24	; 36
    4bf8:	9e e0       	ldi	r25, 0x0E	; 14
    }
}
    4bfa:	df 91       	pop	r29
    4bfc:	cf 91       	pop	r28
    TerminalSendStringP(GetStatusMessageP(ReturnStatusID));
    TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));

    if (OutMessage != NULL) {
        TerminalSendString(OutMessage);
        TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    4bfe:	0c 94 d7 1b 	jmp	0x37ae	; 0x37ae <TerminalSendStringP>
    }
}
    4c02:	df 91       	pop	r29
    4c04:	cf 91       	pop	r28
    4c06:	08 95       	ret

00004c08 <CommandLineAppendData>:

void CommandLineAppendData(void const *const Buffer, uint16_t Bytes) {
    4c08:	ef 92       	push	r14
    4c0a:	ff 92       	push	r15
    4c0c:	0f 93       	push	r16
    4c0e:	1f 93       	push	r17
    4c10:	cf 93       	push	r28
    4c12:	7c 01       	movw	r14, r24
    4c14:	9b 01       	movw	r18, r22
    4c16:	61 30       	cpi	r22, 0x01	; 1
    4c18:	81 e0       	ldi	r24, 0x01	; 1
    4c1a:	78 07       	cpc	r23, r24
    4c1c:	10 f0       	brcs	.+4      	; 0x4c22 <CommandLineAppendData+0x1a>
    4c1e:	20 e0       	ldi	r18, 0x00	; 0
    4c20:	31 e0       	ldi	r19, 0x01	; 1
    char *pTerminalBuffer = (char *) TerminalBuffer;

    uint16_t tmpBytes = Bytes;
    if (Bytes > (TERMINAL_BUFFER_SIZE / 2))
        tmpBytes = TERMINAL_BUFFER_SIZE / 2;
    Bytes -= tmpBytes;
    4c22:	8b 01       	movw	r16, r22
    4c24:	02 1b       	sub	r16, r18
    4c26:	13 0b       	sbc	r17, r19

    BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer, tmpBytes);
    4c28:	a7 01       	movw	r20, r14
    4c2a:	60 e0       	ldi	r22, 0x00	; 0
    4c2c:	72 e0       	ldi	r23, 0x02	; 2
    4c2e:	8b e3       	ldi	r24, 0x3B	; 59
    4c30:	90 e3       	ldi	r25, 0x30	; 48
    4c32:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
    TerminalSendString(pTerminalBuffer);
    4c36:	8b e3       	ldi	r24, 0x3B	; 59
    4c38:	90 e3       	ldi	r25, 0x30	; 48
    4c3a:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>

    uint8_t i = 1;
    4c3e:	c1 e0       	ldi	r28, 0x01	; 1
    while (Bytes > (TERMINAL_BUFFER_SIZE / 2)) {
    4c40:	01 30       	cpi	r16, 0x01	; 1
    4c42:	81 e0       	ldi	r24, 0x01	; 1
    4c44:	18 07       	cpc	r17, r24
    4c46:	a8 f0       	brcs	.+42     	; 0x4c72 <CommandLineAppendData+0x6a>
        Bytes -= TERMINAL_BUFFER_SIZE / 2;
    4c48:	1a 95       	dec	r17
        BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer + i * TERMINAL_BUFFER_SIZE / 2, TERMINAL_BUFFER_SIZE);
    4c4a:	4c 2f       	mov	r20, r28
    4c4c:	50 e0       	ldi	r21, 0x00	; 0
    4c4e:	54 2f       	mov	r21, r20
    4c50:	44 27       	eor	r20, r20
    4c52:	4e 0d       	add	r20, r14
    4c54:	5f 1d       	adc	r21, r15
    4c56:	20 e0       	ldi	r18, 0x00	; 0
    4c58:	32 e0       	ldi	r19, 0x02	; 2
    4c5a:	60 e0       	ldi	r22, 0x00	; 0
    4c5c:	72 e0       	ldi	r23, 0x02	; 2
    4c5e:	8b e3       	ldi	r24, 0x3B	; 59
    4c60:	90 e3       	ldi	r25, 0x30	; 48
    4c62:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
        TerminalSendString(pTerminalBuffer);
    4c66:	8b e3       	ldi	r24, 0x3B	; 59
    4c68:	90 e3       	ldi	r25, 0x30	; 48
    4c6a:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>
        i++;
    4c6e:	cf 5f       	subi	r28, 0xFF	; 255
    4c70:	e7 cf       	rjmp	.-50     	; 0x4c40 <CommandLineAppendData+0x38>
    }

    if (Bytes > 0) {
    4c72:	01 15       	cp	r16, r1
    4c74:	11 05       	cpc	r17, r1
    4c76:	89 f0       	breq	.+34     	; 0x4c9a <CommandLineAppendData+0x92>
        BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer + i * TERMINAL_BUFFER_SIZE / 2, Bytes);
    4c78:	4c 2f       	mov	r20, r28
    4c7a:	50 e0       	ldi	r21, 0x00	; 0
    4c7c:	54 2f       	mov	r21, r20
    4c7e:	44 27       	eor	r20, r20
    4c80:	4e 0d       	add	r20, r14
    4c82:	5f 1d       	adc	r21, r15
    4c84:	98 01       	movw	r18, r16
    4c86:	60 e0       	ldi	r22, 0x00	; 0
    4c88:	72 e0       	ldi	r23, 0x02	; 2
    4c8a:	8b e3       	ldi	r24, 0x3B	; 59
    4c8c:	90 e3       	ldi	r25, 0x30	; 48
    4c8e:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
        TerminalSendString(pTerminalBuffer);
    4c92:	8b e3       	ldi	r24, 0x3B	; 59
    4c94:	90 e3       	ldi	r25, 0x30	; 48
    4c96:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>
    }

    TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    4c9a:	81 e2       	ldi	r24, 0x21	; 33
    4c9c:	9e e0       	ldi	r25, 0x0E	; 14
}
    4c9e:	cf 91       	pop	r28
    4ca0:	1f 91       	pop	r17
    4ca2:	0f 91       	pop	r16
    4ca4:	ff 90       	pop	r15
    4ca6:	ef 90       	pop	r14
    if (Bytes > 0) {
        BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer + i * TERMINAL_BUFFER_SIZE / 2, Bytes);
        TerminalSendString(pTerminalBuffer);
    }

    TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    4ca8:	0c 94 d7 1b 	jmp	0x37ae	; 0x37ae <TerminalSendStringP>

00004cac <CodecReaderFieldStart>:

void CodecReaderFieldRestart(uint16_t delay) {
    ReaderFieldFlags.ToBeRestarted = true;
    ReaderFieldRestartTimestamp = SystemGetSysTick();
    ReaderFieldRestartDelay = delay;
    CodecReaderFieldStop();
    4cac:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    4cb0:	81 30       	cpi	r24, 0x01	; 1
    4cb2:	21 f4       	brne	.+8      	; 0x4cbc <CodecReaderFieldStart+0x10>
    4cb4:	90 91 8c 08 	lds	r25, 0x088C	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>
    4cb8:	93 30       	cpi	r25, 0x03	; 3
    4cba:	09 f0       	breq	.+2      	; 0x4cbe <CodecReaderFieldStart+0x12>
    4cbc:	80 e0       	ldi	r24, 0x00	; 0
    4cbe:	80 fd       	sbrc	r24, 0
    4cc0:	1a c0       	rjmp	.+52     	; 0x4cf6 <CodecReaderFieldStart+0x4a>
    4cc2:	80 91 b0 2c 	lds	r24, 0x2CB0	; 0x802cb0 <ReaderFieldFlags+0x2>
    4cc6:	81 11       	cpse	r24, r1
    4cc8:	16 c0       	rjmp	.+44     	; 0x4cf6 <CodecReaderFieldStart+0x4a>
    4cca:	81 e0       	ldi	r24, 0x01	; 1
    4ccc:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    4cd0:	93 e0       	ldi	r25, 0x03	; 3
    4cd2:	90 93 8c 08 	sts	0x088C, r25	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>
    4cd6:	80 93 ae 2c 	sts	0x2CAE, r24	; 0x802cae <ReaderFieldFlags>
    4cda:	10 92 af 2c 	sts	0x2CAF, r1	; 0x802caf <ReaderFieldFlags+0x1>
    4cde:	2e b1       	in	r18, 0x0e	; 14
    4ce0:	3f b1       	in	r19, 0x0f	; 15
    4ce2:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    4ce6:	90 91 09 04 	lds	r25, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    4cea:	82 2b       	or	r24, r18
    4cec:	93 2b       	or	r25, r19
    4cee:	80 93 b5 2c 	sts	0x2CB5, r24	; 0x802cb5 <ReaderFieldStartTimestamp>
    4cf2:	90 93 b6 2c 	sts	0x2CB6, r25	; 0x802cb6 <ReaderFieldStartTimestamp+0x1>
    4cf6:	08 95       	ret

00004cf8 <CodecReaderFieldStop>:
    4cf8:	10 92 8c 08 	sts	0x088C, r1	; 0x80088c <__TEXT_REGION_LENGTH__+0x70088c>
    4cfc:	10 92 00 08 	sts	0x0800, r1	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    4d00:	ee ea       	ldi	r30, 0xAE	; 174
    4d02:	fc e2       	ldi	r31, 0x2C	; 44
    4d04:	10 82       	st	Z, r1
    4d06:	11 82       	std	Z+1, r1	; 0x01
    4d08:	08 95       	ret

00004d0a <CodecIsReaderFieldReady>:
/*
 * This function returns false if and only if the reader field has been turned on in the last READER_FIELD_MIN..._TIME ms.
 * If the reader field is not active, true is returned.
 */
bool CodecIsReaderFieldReady(void) {
    if (!ReaderFieldFlags.Started)
    4d0a:	90 91 ae 2c 	lds	r25, 0x2CAE	; 0x802cae <ReaderFieldFlags>
    4d0e:	99 23       	and	r25, r25
    4d10:	f1 f0       	breq	.+60     	; 0x4d4e <CodecIsReaderFieldReady+0x44>
        return true;
    if (ReaderFieldFlags.Ready || (ReaderFieldFlags.Started && SYSTICK_DIFF(ReaderFieldStartTimestamp) >= READER_FIELD_MINIMUM_WAITING_TIME)) {
    4d12:	80 91 af 2c 	lds	r24, 0x2CAF	; 0x802caf <ReaderFieldFlags+0x1>
    4d16:	81 11       	cpse	r24, r1
    4d18:	15 c0       	rjmp	.+42     	; 0x4d44 <CodecIsReaderFieldReady+0x3a>
    4d1a:	20 91 ae 2c 	lds	r18, 0x2CAE	; 0x802cae <ReaderFieldFlags>
    4d1e:	22 23       	and	r18, r18
    4d20:	b9 f0       	breq	.+46     	; 0x4d50 <CodecIsReaderFieldReady+0x46>

    RTC.INTFLAGS = RTC_COMPIF_bm;
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    4d22:	4e b1       	in	r20, 0x0e	; 14
    4d24:	5f b1       	in	r21, 0x0f	; 15
    4d26:	20 91 08 04 	lds	r18, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    4d2a:	30 91 09 04 	lds	r19, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    4d2e:	24 2b       	or	r18, r20
    4d30:	35 2b       	or	r19, r21
    4d32:	40 91 b5 2c 	lds	r20, 0x2CB5	; 0x802cb5 <ReaderFieldStartTimestamp>
    4d36:	50 91 b6 2c 	lds	r21, 0x2CB6	; 0x802cb6 <ReaderFieldStartTimestamp+0x1>
    4d3a:	24 1b       	sub	r18, r20
    4d3c:	35 0b       	sbc	r19, r21
    4d3e:	26 34       	cpi	r18, 0x46	; 70
    4d40:	31 05       	cpc	r19, r1
    4d42:	30 f0       	brcs	.+12     	; 0x4d50 <CodecIsReaderFieldReady+0x46>
        ReaderFieldFlags.Ready = true;
    4d44:	81 e0       	ldi	r24, 0x01	; 1
    4d46:	80 93 af 2c 	sts	0x2CAF, r24	; 0x802caf <ReaderFieldFlags+0x1>
        return true;
    4d4a:	89 2f       	mov	r24, r25
    4d4c:	08 95       	ret
 * This function returns false if and only if the reader field has been turned on in the last READER_FIELD_MIN..._TIME ms.
 * If the reader field is not active, true is returned.
 */
bool CodecIsReaderFieldReady(void) {
    if (!ReaderFieldFlags.Started)
        return true;
    4d4e:	81 e0       	ldi	r24, 0x01	; 1
    if (ReaderFieldFlags.Ready || (ReaderFieldFlags.Started && SYSTICK_DIFF(ReaderFieldStartTimestamp) >= READER_FIELD_MINIMUM_WAITING_TIME)) {
        ReaderFieldFlags.Ready = true;
        return true;
    }
    return false;
}
    4d50:	08 95       	ret

00004d52 <CodecIsReaderToBeRestarted>:

bool CodecIsReaderToBeRestarted(void) {
    4d52:	cf 93       	push	r28
    if (ReaderFieldFlags.ToBeRestarted) {
    4d54:	c0 91 b0 2c 	lds	r28, 0x2CB0	; 0x802cb0 <ReaderFieldFlags+0x2>
    4d58:	cc 23       	and	r28, r28
    4d5a:	c1 f0       	breq	.+48     	; 0x4d8c <CodecIsReaderToBeRestarted+0x3a>
    4d5c:	2e b1       	in	r18, 0x0e	; 14
    4d5e:	3f b1       	in	r19, 0x0f	; 15
    4d60:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    4d64:	90 91 09 04 	lds	r25, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
        if (SYSTICK_DIFF(ReaderFieldRestartTimestamp) >= ReaderFieldRestartDelay) {
    4d68:	82 2b       	or	r24, r18
    4d6a:	93 2b       	or	r25, r19
    4d6c:	20 91 b3 2c 	lds	r18, 0x2CB3	; 0x802cb3 <ReaderFieldRestartTimestamp>
    4d70:	30 91 b4 2c 	lds	r19, 0x2CB4	; 0x802cb4 <ReaderFieldRestartTimestamp+0x1>
    4d74:	82 1b       	sub	r24, r18
    4d76:	93 0b       	sbc	r25, r19
    4d78:	20 91 b1 2c 	lds	r18, 0x2CB1	; 0x802cb1 <ReaderFieldRestartDelay>
    4d7c:	30 91 b2 2c 	lds	r19, 0x2CB2	; 0x802cb2 <ReaderFieldRestartDelay+0x1>
    4d80:	82 17       	cp	r24, r18
    4d82:	93 07       	cpc	r25, r19
    4d84:	18 f0       	brcs	.+6      	; 0x4d8c <CodecIsReaderToBeRestarted+0x3a>
            ReaderFieldFlags.ToBeRestarted = false;
    4d86:	10 92 b0 2c 	sts	0x2CB0, r1	; 0x802cb0 <ReaderFieldFlags+0x2>
            CodecReaderFieldStart();
    4d8a:	90 df       	rcall	.-224    	; 0x4cac <CodecReaderFieldStart>
        }
        return true;
    }
    return false;
}
    4d8c:	8c 2f       	mov	r24, r28
    4d8e:	cf 91       	pop	r28
    4d90:	08 95       	ret

00004d92 <CodecThresholdSet>:

void CodecThresholdSet(uint16_t th) { // threshold has to be saved back to eeprom by the caller, if wanted
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = th;
    4d92:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4d96:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4d9a:	82 87       	std	Z+10, r24	; 0x0a
    4d9c:	93 87       	std	Z+11, r25	; 0x0b
    DACB.CH0DATA = th;
    4d9e:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <__TEXT_REGION_LENGTH__+0x700338>
    4da2:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <__TEXT_REGION_LENGTH__+0x700339>
    4da6:	08 95       	ret

00004da8 <CodecThresholdIncrement>:
}

uint16_t CodecThresholdIncrement(void) { // threshold has to be saved back to eeprom by the caller, if wanted
    GlobalSettings.ActiveSettingPtr->ReaderThreshold += CODEC_THRESHOLD_CALIBRATE_STEPS;
    4da8:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4dac:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4db0:	82 85       	ldd	r24, Z+10	; 0x0a
    4db2:	93 85       	ldd	r25, Z+11	; 0x0b
    4db4:	40 96       	adiw	r24, 0x10	; 16
    4db6:	82 87       	std	Z+10, r24	; 0x0a
    4db8:	93 87       	std	Z+11, r25	; 0x0b
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold;
    4dba:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <__TEXT_REGION_LENGTH__+0x700338>
    4dbe:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <__TEXT_REGION_LENGTH__+0x700339>
    return GlobalSettings.ActiveSettingPtr->ReaderThreshold;
}
    4dc2:	82 85       	ldd	r24, Z+10	; 0x0a
    4dc4:	93 85       	ldd	r25, Z+11	; 0x0b
    4dc6:	08 95       	ret

00004dc8 <CodecThresholdReset>:

void CodecThresholdReset(void) { // threshold has to be saved back to eeprom by the caller, if wanted
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = DEFAULT_READER_THRESHOLD;
    4dc8:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    4dcc:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    4dd0:	80 e9       	ldi	r24, 0x90	; 144
    4dd2:	91 e0       	ldi	r25, 0x01	; 1
    4dd4:	82 87       	std	Z+10, r24	; 0x0a
    4dd6:	93 87       	std	Z+11, r25	; 0x0b
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold;
    4dd8:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <__TEXT_REGION_LENGTH__+0x700338>
    4ddc:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <__TEXT_REGION_LENGTH__+0x700339>
    4de0:	08 95       	ret

00004de2 <StartDemod>:
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
}

INLINE void CodecSetDemodPower(bool bOnOff) {
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    4de2:	a0 e2       	ldi	r26, 0x20	; 32
    4de4:	b6 e0       	ldi	r27, 0x06	; 6
    4de6:	81 e0       	ldi	r24, 0x01	; 1
    4de8:	15 96       	adiw	r26, 0x05	; 5
    4dea:	8c 93       	st	X, r24
    4dec:	15 97       	sbiw	r26, 0x05	; 5

static void StartDemod(void) {
    /* Activate Power for demodulator */
    CodecSetDemodPower(true);

    CodecBufferPtr = CodecBuffer;
    4dee:	2d e3       	ldi	r18, 0x3D	; 61
    4df0:	32 e3       	ldi	r19, 0x32	; 50
    4df2:	28 b9       	out	0x08, r18	; 8
    4df4:	39 b9       	out	0x09, r19	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    4df6:	2d eb       	ldi	r18, 0xBD	; 189
    4df8:	32 e3       	ldi	r19, 0x32	; 50
    4dfa:	2a b9       	out	0x0a, r18	; 10
    4dfc:	3b b9       	out	0x0b, r19	; 11
    DataRegister = 0;
    4dfe:	10 b8       	out	0x00, r1	; 0
    SampleRegister = 0;
    4e00:	13 b8       	out	0x03, r1	; 3
    SampleIdxRegister = 0;
    4e02:	12 b8       	out	0x02, r1	; 2
    BitCount = 0;
    4e04:	16 b8       	out	0x06, r1	; 6
    4e06:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    4e08:	11 b8       	out	0x01, r1	; 1

    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    4e0a:	e0 e0       	ldi	r30, 0x00	; 0
    4e0c:	f9 e0       	ldi	r31, 0x09	; 9
    4e0e:	10 a2       	std	Z+32, r1	; 0x20
    4e10:	11 a2       	std	Z+33, r1	; 0x21
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    4e12:	2f ef       	ldi	r18, 0xFF	; 255
    4e14:	30 e0       	ldi	r19, 0x00	; 0
    4e16:	26 a3       	std	Z+38, r18	; 0x26
    4e18:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_TIMER_SAMPLING.CCA = 0xFFFF; /* CCA Interrupt is not active! */
    4e1a:	2f ef       	ldi	r18, 0xFF	; 255
    4e1c:	3f ef       	ldi	r19, 0xFF	; 255
    4e1e:	20 a7       	std	Z+40, r18	; 0x28
    4e20:	31 a7       	std	Z+41, r19	; 0x29
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    4e22:	80 83       	st	Z, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    4e24:	98 e8       	ldi	r25, 0x88	; 136
    4e26:	93 83       	std	Z+3, r25	; 0x03
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCAIF_bm;
    4e28:	90 e1       	ldi	r25, 0x10	; 16
    4e2a:	94 87       	std	Z+12, r25	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCAINTLVL_HI_gc;
    4e2c:	93 e0       	ldi	r25, 0x03	; 3
    4e2e:	97 83       	std	Z+7, r25	; 0x07

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT0IF_bm;
    4e30:	1c 96       	adiw	r26, 0x0c	; 12
    4e32:	8c 93       	st	X, r24
    4e34:	1c 97       	sbiw	r26, 0x0c	; 12
    CODEC_DEMOD_IN_PORT.INT0MASK = CODEC_DEMOD_IN_MASK0;
    4e36:	82 e0       	ldi	r24, 0x02	; 2
    4e38:	1a 96       	adiw	r26, 0x0a	; 10
    4e3a:	8c 93       	st	X, r24
    4e3c:	08 95       	ret

00004e3e <isr_ISO14443_2A_TCD0_CCC_vect>:
}

// Find first pause and start sampling
ISR_SHARED isr_ISO14443_2A_TCD0_CCC_vect(void) {
    4e3e:	1f 92       	push	r1
    4e40:	0f 92       	push	r0
    4e42:	0f b6       	in	r0, 0x3f	; 63
    4e44:	0f 92       	push	r0
    4e46:	11 24       	eor	r1, r1
    4e48:	08 b6       	in	r0, 0x38	; 56
    4e4a:	0f 92       	push	r0
    4e4c:	18 be       	out	0x38, r1	; 56
    4e4e:	0b b6       	in	r0, 0x3b	; 59
    4e50:	0f 92       	push	r0
    4e52:	1b be       	out	0x3b, r1	; 59
    4e54:	8f 93       	push	r24
    4e56:	9f 93       	push	r25
    4e58:	ef 93       	push	r30
    4e5a:	ff 93       	push	r31
     * XYZBUF mechanism of the xmega to automatically double the sampling rate on the
     * next overflow. For this we have to temporarily deactivate the automatical alignment
     * in order to catch next overflow event for updating the BUF registers.
     * We want to sample the demodulated data stream in the first quarter of the half-bit
     * where the pulsed miller encoded is located. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    4e5c:	e0 e0       	ldi	r30, 0x00	; 0
    4e5e:	f9 e0       	ldi	r31, 0x09	; 9
    4e60:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.PERBUF = SAMPLE_RATE_SYSTEM_CYCLES / 2 - 1; /* Half bit width */
    4e62:	8f e7       	ldi	r24, 0x7F	; 127
    4e64:	90 e0       	ldi	r25, 0x00	; 0
    4e66:	86 ab       	std	Z+54, r24	; 0x36
    4e68:	97 ab       	std	Z+55, r25	; 0x37
    CODEC_TIMER_SAMPLING.CCABUF = SAMPLE_RATE_SYSTEM_CYCLES / 8 - 14 - 1; /* Compensate for DIGFILT and ISR prolog */
    4e6a:	81 e1       	ldi	r24, 0x11	; 17
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	80 af       	std	Z+56, r24	; 0x38
    4e70:	91 af       	std	Z+57, r25	; 0x39
    /* Setup Frame Delay Timer and wire to EVSYS. Frame delay time is
     * measured from last change in RF field, therefore we use
     * the event channel 1 (end of modulation pause) as the restart event.
     * The preliminary frame delay time chosen here is irrelevant, because
     * the correct FDT gets set automatically after demodulation. */
    CODEC_TIMER_LOADMOD.CNT = 0;
    4e72:	e0 e0       	ldi	r30, 0x00	; 0
    4e74:	fa e0       	ldi	r31, 0x0A	; 10
    4e76:	10 a2       	std	Z+32, r1	; 0x20
    4e78:	11 a2       	std	Z+33, r1	; 0x21
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    4e7a:	8f ef       	ldi	r24, 0xFF	; 255
    4e7c:	9f ef       	ldi	r25, 0xFF	; 255
    4e7e:	86 a3       	std	Z+38, r24	; 0x26
    4e80:	97 a3       	std	Z+39, r25	; 0x27
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODEND_EVSEL;
    4e82:	89 e8       	ldi	r24, 0x89	; 137
    4e84:	83 83       	std	Z+3, r24	; 0x03
    CODEC_TIMER_LOADMOD.INTCTRLA = TC_OVFINTLVL_OFF_gc;
    4e86:	16 82       	std	Z+6, r1	; 0x06
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_OVFIF_bm;
    4e88:	81 e0       	ldi	r24, 0x01	; 1
    4e8a:	84 87       	std	Z+12, r24	; 0x0c
    CODEC_TIMER_LOADMOD.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    4e8c:	8e e0       	ldi	r24, 0x0E	; 14
    4e8e:	80 83       	st	Z, r24

    /* Disable this interrupt */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    4e90:	10 92 2a 06 	sts	0x062A, r1	; 0x80062a <__TEXT_REGION_LENGTH__+0x70062a>
}
    4e94:	ff 91       	pop	r31
    4e96:	ef 91       	pop	r30
    4e98:	9f 91       	pop	r25
    4e9a:	8f 91       	pop	r24
    4e9c:	0f 90       	pop	r0
    4e9e:	0b be       	out	0x3b, r0	; 59
    4ea0:	0f 90       	pop	r0
    4ea2:	08 be       	out	0x38, r0	; 56
    4ea4:	0f 90       	pop	r0
    4ea6:	0f be       	out	0x3f, r0	; 63
    4ea8:	0f 90       	pop	r0
    4eaa:	1f 90       	pop	r1
    4eac:	18 95       	reti

00004eae <__vector_79>:

// Sampling with timer and demod
ISR(CODEC_TIMER_SAMPLING_CCA_VECT) {
    4eae:	1f 92       	push	r1
    4eb0:	0f 92       	push	r0
    4eb2:	0f b6       	in	r0, 0x3f	; 63
    4eb4:	0f 92       	push	r0
    4eb6:	11 24       	eor	r1, r1
    4eb8:	08 b6       	in	r0, 0x38	; 56
    4eba:	0f 92       	push	r0
    4ebc:	18 be       	out	0x38, r1	; 56
    4ebe:	0b b6       	in	r0, 0x3b	; 59
    4ec0:	0f 92       	push	r0
    4ec2:	1b be       	out	0x3b, r1	; 59
    4ec4:	2f 93       	push	r18
    4ec6:	3f 93       	push	r19
    4ec8:	8f 93       	push	r24
    4eca:	9f 93       	push	r25
    4ecc:	ef 93       	push	r30
    4ece:	ff 93       	push	r31
    /* This interrupt gets called twice for every bit to sample it. */
    uint8_t SamplePin = CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK;
    4ed0:	20 91 28 06 	lds	r18, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>

    /* Shift sampled bit into sampling register */
    SampleRegister = (SampleRegister << 1) | (!SamplePin ? 0x01 : 0x00);
    4ed4:	93 b1       	in	r25, 0x03	; 3
    4ed6:	26 70       	andi	r18, 0x06	; 6
    4ed8:	81 e0       	ldi	r24, 0x01	; 1
    4eda:	09 f0       	breq	.+2      	; 0x4ede <__vector_79+0x30>
    4edc:	80 e0       	ldi	r24, 0x00	; 0
    4ede:	99 0f       	add	r25, r25
    4ee0:	89 2b       	or	r24, r25
    4ee2:	83 b9       	out	0x03, r24	; 3

    if (SampleIdxRegister) {
    4ee4:	82 b1       	in	r24, 0x02	; 2
    4ee6:	88 23       	and	r24, r24
    4ee8:	09 f4       	brne	.+2      	; 0x4eec <__vector_79+0x3e>
    4eea:	63 c0       	rjmp	.+198    	; 0x4fb2 <__vector_79+0x104>
        SampleIdxRegister = 0;
    4eec:	12 b8       	out	0x02, r1	; 2
        /* Analyze the sampling register after 2 samples. */
        if ((SampleRegister & 0x07) == 0x07) {
    4eee:	83 b1       	in	r24, 0x03	; 3
    4ef0:	87 70       	andi	r24, 0x07	; 7
    4ef2:	87 30       	cpi	r24, 0x07	; 7
    4ef4:	59 f5       	brne	.+86     	; 0x4f4c <__vector_79+0x9e>
            /* No carrier modulation for 3 sample points. EOC! */
            CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    4ef6:	10 92 00 09 	sts	0x0900, r1	; 0x800900 <__TEXT_REGION_LENGTH__+0x700900>
            CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCAIF_bm;
    4efa:	80 e1       	ldi	r24, 0x10	; 16
    4efc:	80 93 0c 09 	sts	0x090C, r24	; 0x80090c <__TEXT_REGION_LENGTH__+0x70090c>

            /* By this time, the FDT timer is aligned to the last modulation
             * edge of the reader. So we disable the auto-synchronization and
             * let it count the frame delay time in the background, and generate
             * an interrupt once it has reached the FDT. */
            CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_OFF_gc;
    4f00:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>

            if (SampleRegister & 0x08) {
    4f04:	1b 9b       	sbis	0x03, 3	; 3
    4f06:	03 c0       	rjmp	.+6      	; 0x4f0e <__vector_79+0x60>
                CODEC_TIMER_LOADMOD.PER = ISO14443A_FRAME_DELAY_PREV1 - 40; /* compensate for ISR prolog */
    4f08:	8c ea       	ldi	r24, 0xAC	; 172
    4f0a:	94 e0       	ldi	r25, 0x04	; 4
    4f0c:	02 c0       	rjmp	.+4      	; 0x4f12 <__vector_79+0x64>
            } else {
                CODEC_TIMER_LOADMOD.PER = ISO14443A_FRAME_DELAY_PREV0 - 40; /* compensate for ISR prolog */
    4f0e:	8c e6       	ldi	r24, 0x6C	; 108
    4f10:	94 e0       	ldi	r25, 0x04	; 4
    4f12:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    4f16:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
            }

            StateRegister = LOADMOD_FDT;
    4f1a:	82 e0       	ldi	r24, 0x02	; 2
    4f1c:	81 b9       	out	0x01, r24	; 1

            CODEC_TIMER_LOADMOD.INTFLAGS = TC0_OVFIF_bm;
    4f1e:	81 e0       	ldi	r24, 0x01	; 1
    4f20:	80 93 0c 0a 	sts	0x0A0C, r24	; 0x800a0c <__TEXT_REGION_LENGTH__+0x700a0c>
            CODEC_TIMER_LOADMOD.INTCTRLA = TC_OVFINTLVL_HI_gc;
    4f24:	83 e0       	ldi	r24, 0x03	; 3
    4f26:	80 93 06 0a 	sts	0x0A06, r24	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>

            /* Determine if we did not receive a multiple of 8 bits.
             * If this is the case, right-align the remaining data and
             * store it into the buffer. */
            uint8_t RemainingBits = BitCount % 8;
    4f2a:	86 b1       	in	r24, 0x06	; 6
    4f2c:	97 b1       	in	r25, 0x07	; 7
    4f2e:	87 70       	andi	r24, 0x07	; 7
            if (RemainingBits != 0) {
    4f30:	49 f0       	breq	.+18     	; 0x4f44 <__vector_79+0x96>
                uint8_t NewDataRegister = DataRegister;
    4f32:	90 b1       	in	r25, 0x00	; 0

                while (RemainingBits++ < 8) {
    4f34:	8f 5f       	subi	r24, 0xFF	; 255
    4f36:	89 30       	cpi	r24, 0x09	; 9
    4f38:	11 f0       	breq	.+4      	; 0x4f3e <__vector_79+0x90>
                    /* Pad with zeroes to right-align. */
                    NewDataRegister >>= 1;
    4f3a:	96 95       	lsr	r25
    4f3c:	fb cf       	rjmp	.-10     	; 0x4f34 <__vector_79+0x86>
                }

                /* TODO: Prevent buffer overflow */
                *CodecBufferPtr = NewDataRegister;
    4f3e:	e8 b1       	in	r30, 0x08	; 8
    4f40:	f9 b1       	in	r31, 0x09	; 9
    4f42:	90 83       	st	Z, r25
            }

            /* Signal, that we have finished sampling */
            Flags.DemodFinished = 1;
    4f44:	81 e0       	ldi	r24, 0x01	; 1
    4f46:	80 93 b7 2c 	sts	0x2CB7, r24	; 0x802cb7 <Flags>
    4f4a:	36 c0       	rjmp	.+108    	; 0x4fb8 <__vector_79+0x10a>
        } else {
            /* Otherwise, we check the two sample bits from the bit before. */
            uint8_t BitSample = SampleRegister & 0xC;
    4f4c:	83 b1       	in	r24, 0x03	; 3
            uint8_t Bit = 0;

            if (BitSample != (0x0 << 2)) {
    4f4e:	98 2f       	mov	r25, r24
    4f50:	9c 70       	andi	r25, 0x0C	; 12
    4f52:	91 f1       	breq	.+100    	; 0x4fb8 <__vector_79+0x10a>
    4f54:	84 70       	andi	r24, 0x04	; 4
                } else {
                    /* 10 sequence -> This is a one bit */
                    Bit = 1;
                }

                if (StateRegister == DEMOD_DATA_BIT) {
    4f56:	91 b1       	in	r25, 0x01	; 1
    4f58:	91 11       	cpse	r25, r1
    4f5a:	1c c0       	rjmp	.+56     	; 0x4f94 <__vector_79+0xe6>
                    /* This is a data bit, so shift it into the data register and
                     * hold a local copy of it. */
                    uint8_t NewDataRegister = DataRegister >> 1;
    4f5c:	20 b1       	in	r18, 0x00	; 0
    4f5e:	26 95       	lsr	r18
                    NewDataRegister |= (Bit ? 0x80 : 0x00);
    4f60:	88 23       	and	r24, r24
    4f62:	11 f0       	breq	.+4      	; 0x4f68 <__vector_79+0xba>
    4f64:	80 e0       	ldi	r24, 0x00	; 0
    4f66:	01 c0       	rjmp	.+2      	; 0x4f6a <__vector_79+0xbc>
    4f68:	80 e8       	ldi	r24, 0x80	; 128
    4f6a:	28 2b       	or	r18, r24
                    DataRegister = NewDataRegister;
    4f6c:	20 b9       	out	0x00, r18	; 0

                    /* Update bitcount */
                    uint16_t NewBitCount = ++BitCount;
    4f6e:	86 b1       	in	r24, 0x06	; 6
    4f70:	97 b1       	in	r25, 0x07	; 7
    4f72:	01 96       	adiw	r24, 0x01	; 1
    4f74:	86 b9       	out	0x06, r24	; 6
    4f76:	97 b9       	out	0x07, r25	; 7
                    if ((NewBitCount & 0x07) == 0) {
    4f78:	87 70       	andi	r24, 0x07	; 7
    4f7a:	99 27       	eor	r25, r25
    4f7c:	89 2b       	or	r24, r25
    4f7e:	e1 f4       	brne	.+56     	; 0x4fb8 <__vector_79+0x10a>
                        /* We have reached a byte boundary! Store the data register. */
                        /* TODO: Prevent buffer overflow */
                        *CodecBufferPtr++ = NewDataRegister;
    4f80:	e8 b1       	in	r30, 0x08	; 8
    4f82:	f9 b1       	in	r31, 0x09	; 9
    4f84:	cf 01       	movw	r24, r30
    4f86:	01 96       	adiw	r24, 0x01	; 1
    4f88:	88 b9       	out	0x08, r24	; 8
    4f8a:	99 b9       	out	0x09, r25	; 9
    4f8c:	20 83       	st	Z, r18

                        /* Store bit for determining FDT at EOC and enable parity
                         * handling on next bit. */
                        StateRegister = DEMOD_PARITY_BIT;
    4f8e:	81 e0       	ldi	r24, 0x01	; 1
    4f90:	81 b9       	out	0x01, r24	; 1
    4f92:	12 c0       	rjmp	.+36     	; 0x4fb8 <__vector_79+0x10a>
                    }

                } else if (StateRegister == DEMOD_PARITY_BIT) {
    4f94:	91 b1       	in	r25, 0x01	; 1
    4f96:	91 30       	cpi	r25, 0x01	; 1
    4f98:	79 f4       	brne	.+30     	; 0x4fb8 <__vector_79+0x10a>
                    /* This is a parity bit. Store it */
                    *ParityBufferPtr++ = Bit;
    4f9a:	ea b1       	in	r30, 0x0a	; 10
    4f9c:	fb b1       	in	r31, 0x0b	; 11
    4f9e:	9f 01       	movw	r18, r30
    4fa0:	2f 5f       	subi	r18, 0xFF	; 255
    4fa2:	3f 4f       	sbci	r19, 0xFF	; 255
    4fa4:	2a b9       	out	0x0a, r18	; 10
    4fa6:	3b b9       	out	0x0b, r19	; 11

            if (BitSample != (0x0 << 2)) {
                /* We have a valid bit. decode and process it. */
                if (BitSample & (0x1 << 2)) {
                    /* 01 sequence or 11 sequence -> This is a zero bit */
                    Bit = 0;
    4fa8:	81 11       	cpse	r24, r1
    4faa:	90 e0       	ldi	r25, 0x00	; 0
                        StateRegister = DEMOD_PARITY_BIT;
                    }

                } else if (StateRegister == DEMOD_PARITY_BIT) {
                    /* This is a parity bit. Store it */
                    *ParityBufferPtr++ = Bit;
    4fac:	90 83       	st	Z, r25
                    StateRegister = DEMOD_DATA_BIT;
    4fae:	11 b8       	out	0x01, r1	; 1
    4fb0:	03 c0       	rjmp	.+6      	; 0x4fb8 <__vector_79+0x10a>
                 * sampling and have sampled less than 2 bits yet. Thus ignore. */
            }
        }
    } else {
        /* On odd sample position just sample. */
        SampleIdxRegister = ~SampleIdxRegister;
    4fb2:	82 b1       	in	r24, 0x02	; 2
    4fb4:	80 95       	com	r24
    4fb6:	82 b9       	out	0x02, r24	; 2

    /* Make sure the sampling timer gets automatically aligned to the
     * modulation pauses by using the RESTART event.
     * This can be understood as a "poor mans PLL" and makes sure that we are
     * never too far out the bit-grid while sampling. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    4fb8:	88 e8       	ldi	r24, 0x88	; 136
    4fba:	80 93 03 09 	sts	0x0903, r24	; 0x800903 <__TEXT_REGION_LENGTH__+0x700903>
}
    4fbe:	ff 91       	pop	r31
    4fc0:	ef 91       	pop	r30
    4fc2:	9f 91       	pop	r25
    4fc4:	8f 91       	pop	r24
    4fc6:	3f 91       	pop	r19
    4fc8:	2f 91       	pop	r18
    4fca:	0f 90       	pop	r0
    4fcc:	0b be       	out	0x3b, r0	; 59
    4fce:	0f 90       	pop	r0
    4fd0:	08 be       	out	0x38, r0	; 56
    4fd2:	0f 90       	pop	r0
    4fd4:	0f be       	out	0x3f, r0	; 63
    4fd6:	0f 90       	pop	r0
    4fd8:	1f 90       	pop	r1
    4fda:	18 95       	reti

00004fdc <__vector_47>:

// Enumulate as a card to send card responds
ISR(CODEC_TIMER_LOADMOD_OVF_VECT) {
    4fdc:	1f 92       	push	r1
    4fde:	0f 92       	push	r0
    4fe0:	0f b6       	in	r0, 0x3f	; 63
    4fe2:	0f 92       	push	r0
    4fe4:	11 24       	eor	r1, r1
    4fe6:	08 b6       	in	r0, 0x38	; 56
    4fe8:	0f 92       	push	r0
    4fea:	18 be       	out	0x38, r1	; 56
    4fec:	0b b6       	in	r0, 0x3b	; 59
    4fee:	0f 92       	push	r0
    4ff0:	1b be       	out	0x3b, r1	; 59
    4ff2:	2f 93       	push	r18
    4ff4:	3f 93       	push	r19
    4ff6:	8f 93       	push	r24
    4ff8:	9f 93       	push	r25
    4ffa:	ef 93       	push	r30
    4ffc:	ff 93       	push	r31
        [LOADMOD_STOP_BIT0] = && LOADMOD_STOP_BIT0_LABEL,
        [LOADMOD_STOP_BIT1] = && LOADMOD_STOP_BIT1_LABEL,
        [LOADMOD_FINISHED] = && LOADMOD_FINISHED_LABEL
    };

    if ((StateRegister >= LOADMOD_FDT) && (StateRegister <= LOADMOD_FINISHED)) {
    4ffe:	81 b1       	in	r24, 0x01	; 1
    5000:	82 30       	cpi	r24, 0x02	; 2
    5002:	08 f4       	brcc	.+2      	; 0x5006 <__vector_47+0x2a>
    5004:	9d c0       	rjmp	.+314    	; 0x5140 <__vector_47+0x164>
    5006:	81 b1       	in	r24, 0x01	; 1
    5008:	8d 30       	cpi	r24, 0x0D	; 13
    500a:	08 f0       	brcs	.+2      	; 0x500e <__vector_47+0x32>
    500c:	99 c0       	rjmp	.+306    	; 0x5140 <__vector_47+0x164>
        goto *JumpTable[StateRegister];
    500e:	e1 b1       	in	r30, 0x01	; 1
    5010:	f0 e0       	ldi	r31, 0x00	; 0
    5012:	ee 0f       	add	r30, r30
    5014:	ff 1f       	adc	r31, r31
    5016:	ea 5d       	subi	r30, 0xDA	; 218
    5018:	ff 4d       	sbci	r31, 0xDF	; 223
    501a:	01 90       	ld	r0, Z+
    501c:	f0 81       	ld	r31, Z
    501e:	e0 2d       	mov	r30, r0
    5020:	19 94       	eijmp
        return;
    }

LOADMOD_FDT_LABEL:
    /* No data has been produced, but FDT has ended. Switch over to bit-grid aligning. */
    CODEC_TIMER_LOADMOD.PER = ISO14443A_BIT_GRID_CYCLES - 1;
    5022:	8f e7       	ldi	r24, 0x7F	; 127
    5024:	90 e0       	ldi	r25, 0x00	; 0
    5026:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    502a:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    return;
    502e:	88 c0       	rjmp	.+272    	; 0x5140 <__vector_47+0x164>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    5030:	8e 9a       	sbi	0x11, 6	; 17
INLINE void CodecChangeDivider(uint16_t Divider) {
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
}

INLINE void CodecStartSubcarrier(void) {
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    5032:	8e e0       	ldi	r24, 0x0E	; 14
    5034:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
LOADMOD_START_BIT0_LABEL:
    /* Start subcarrier generation, output startbit and align to bitrate. */
    CodecSetLoadmodState(true);
    CodecStartSubcarrier();

    CODEC_TIMER_LOADMOD.PER = ISO14443A_BIT_RATE_CYCLES / 2 - 1;
    5038:	8f e3       	ldi	r24, 0x3F	; 63
    503a:	90 e0       	ldi	r25, 0x00	; 0
    503c:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    5040:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    StateRegister = LOADMOD_START_BIT1;
    5044:	85 e0       	ldi	r24, 0x05	; 5
    5046:	6f c0       	rjmp	.+222    	; 0x5126 <__vector_47+0x14a>

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    5048:	8e 98       	cbi	0x11, 6	; 17
    return;


LOADMOD_START_BIT1_LABEL:
    CodecSetLoadmodState(false);
    StateRegister = LOADMOD_DATA0;
    504a:	86 e0       	ldi	r24, 0x06	; 6
    504c:	81 b9       	out	0x01, r24	; 1
    ParityRegister = ~0;
    504e:	8f ef       	ldi	r24, 0xFF	; 255
    5050:	82 b9       	out	0x02, r24	; 2
    BitSent = 0;
    5052:	14 b8       	out	0x04, r1	; 4
    5054:	15 b8       	out	0x05, r1	; 5

    /* Prefetch first byte */
    DataRegister = *CodecBufferPtr;
    5056:	e8 b1       	in	r30, 0x08	; 8
    5058:	f9 b1       	in	r31, 0x09	; 9
    505a:	80 81       	ld	r24, Z
    505c:	80 b9       	out	0x00, r24	; 0
    return;
    505e:	70 c0       	rjmp	.+224    	; 0x5140 <__vector_47+0x164>

LOADMOD_DATA0_LABEL:
    if (DataRegister & 1) {
    5060:	00 9b       	sbis	0x00, 0	; 0
    5062:	05 c0       	rjmp	.+10     	; 0x506e <__vector_47+0x92>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    5064:	8e 9a       	sbi	0x11, 6	; 17
        CodecSetLoadmodState(true);
        ParityRegister = ~ParityRegister;
    5066:	82 b1       	in	r24, 0x02	; 2
    5068:	80 95       	com	r24
    506a:	82 b9       	out	0x02, r24	; 2
    506c:	01 c0       	rjmp	.+2      	; 0x5070 <__vector_47+0x94>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    506e:	8e 98       	cbi	0x11, 6	; 17
    } else {
        CodecSetLoadmodState(false);
    }

    StateRegister = LOADMOD_DATA1;
    5070:	87 e0       	ldi	r24, 0x07	; 7
    5072:	59 c0       	rjmp	.+178    	; 0x5126 <__vector_47+0x14a>
    return;

LOADMOD_DATA1_LABEL:
    if (DataRegister & 1) {
    5074:	00 9b       	sbis	0x00, 0	; 0
    5076:	02 c0       	rjmp	.+4      	; 0x507c <__vector_47+0xa0>
    5078:	8e 98       	cbi	0x11, 6	; 17
    507a:	01 c0       	rjmp	.+2      	; 0x507e <__vector_47+0xa2>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    507c:	8e 9a       	sbi	0x11, 6	; 17
        CodecSetLoadmodState(false);
    } else {
        CodecSetLoadmodState(true);
    }

    DataRegister = DataRegister >> 1;
    507e:	80 b1       	in	r24, 0x00	; 0
    5080:	86 95       	lsr	r24
    5082:	80 b9       	out	0x00, r24	; 0
    BitSent++;
    5084:	84 b1       	in	r24, 0x04	; 4
    5086:	95 b1       	in	r25, 0x05	; 5
    5088:	01 96       	adiw	r24, 0x01	; 1
    508a:	84 b9       	out	0x04, r24	; 4
    508c:	95 b9       	out	0x05, r25	; 5

    if ((BitSent % 8) == 0) {
    508e:	84 b1       	in	r24, 0x04	; 4
    5090:	95 b1       	in	r25, 0x05	; 5
    5092:	87 70       	andi	r24, 0x07	; 7
    5094:	99 27       	eor	r25, r25
    5096:	89 2b       	or	r24, r25
    5098:	11 f4       	brne	.+4      	; 0x509e <__vector_47+0xc2>
        /* Byte boundary. Load parity bit and output it later. */
        StateRegister = LOADMOD_PARITY0;
    509a:	88 e0       	ldi	r24, 0x08	; 8
    509c:	44 c0       	rjmp	.+136    	; 0x5126 <__vector_47+0x14a>
    } else if (BitSent == BitCount) {
    509e:	24 b1       	in	r18, 0x04	; 4
    50a0:	35 b1       	in	r19, 0x05	; 5
    50a2:	86 b1       	in	r24, 0x06	; 6
    50a4:	97 b1       	in	r25, 0x07	; 7
    50a6:	28 17       	cp	r18, r24
    50a8:	39 07       	cpc	r19, r25
    50aa:	b1 f5       	brne	.+108    	; 0x5118 <__vector_47+0x13c>
    50ac:	2b c0       	rjmp	.+86     	; 0x5104 <__vector_47+0x128>
    }

    return;

LOADMOD_PARITY0_LABEL:
    if (ParityBufferPtr != NULL) {
    50ae:	ea b1       	in	r30, 0x0a	; 10
    50b0:	fb b1       	in	r31, 0x0b	; 11
    50b2:	30 97       	sbiw	r30, 0x00	; 0
    50b4:	11 f0       	breq	.+4      	; 0x50ba <__vector_47+0xde>
        if (*ParityBufferPtr) {
    50b6:	80 81       	ld	r24, Z
    50b8:	01 c0       	rjmp	.+2      	; 0x50bc <__vector_47+0xe0>
            CodecSetLoadmodState(true);
        } else {
            CodecSetLoadmodState(false);
        }
    } else {
        if (ParityRegister) {
    50ba:	82 b1       	in	r24, 0x02	; 2
    50bc:	88 23       	and	r24, r24
    50be:	11 f0       	breq	.+4      	; 0x50c4 <__vector_47+0xe8>
    50c0:	8e 9a       	sbi	0x11, 6	; 17
    50c2:	01 c0       	rjmp	.+2      	; 0x50c6 <__vector_47+0xea>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    50c4:	8e 98       	cbi	0x11, 6	; 17
            CodecSetLoadmodState(true);
        } else {
            CodecSetLoadmodState(false);
        }
    }
    StateRegister = LOADMOD_PARITY1;
    50c6:	89 e0       	ldi	r24, 0x09	; 9
    50c8:	2e c0       	rjmp	.+92     	; 0x5126 <__vector_47+0x14a>
    return;

LOADMOD_PARITY1_LABEL:
    if (ParityBufferPtr != NULL) {
    50ca:	ea b1       	in	r30, 0x0a	; 10
    50cc:	fb b1       	in	r31, 0x0b	; 11
    50ce:	30 97       	sbiw	r30, 0x00	; 0
    50d0:	51 f0       	breq	.+20     	; 0x50e6 <__vector_47+0x10a>
        if (*ParityBufferPtr) {
    50d2:	80 81       	ld	r24, Z
    50d4:	88 23       	and	r24, r24
    50d6:	11 f0       	breq	.+4      	; 0x50dc <__vector_47+0x100>
    50d8:	8e 98       	cbi	0x11, 6	; 17
    50da:	01 c0       	rjmp	.+2      	; 0x50de <__vector_47+0x102>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    50dc:	8e 9a       	sbi	0x11, 6	; 17
            CodecSetLoadmodState(false);
        } else {
            CodecSetLoadmodState(true);
        }

        ParityBufferPtr++;
    50de:	31 96       	adiw	r30, 0x01	; 1
    50e0:	ea b9       	out	0x0a, r30	; 10
    50e2:	fb b9       	out	0x0b, r31	; 11
    50e4:	08 c0       	rjmp	.+16     	; 0x50f6 <__vector_47+0x11a>
    } else {
        if (ParityRegister) {
    50e6:	82 b1       	in	r24, 0x02	; 2
    50e8:	88 23       	and	r24, r24
    50ea:	11 f0       	breq	.+4      	; 0x50f0 <__vector_47+0x114>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    50ec:	8e 98       	cbi	0x11, 6	; 17
    50ee:	01 c0       	rjmp	.+2      	; 0x50f2 <__vector_47+0x116>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    50f0:	8e 9a       	sbi	0x11, 6	; 17
            CodecSetLoadmodState(false);
        } else {
            CodecSetLoadmodState(true);
        }

        ParityRegister = ~0;
    50f2:	8f ef       	ldi	r24, 0xFF	; 255
    50f4:	82 b9       	out	0x02, r24	; 2
    }

    if (BitSent == BitCount) {
    50f6:	24 b1       	in	r18, 0x04	; 4
    50f8:	35 b1       	in	r19, 0x05	; 5
    50fa:	86 b1       	in	r24, 0x06	; 6
    50fc:	97 b1       	in	r25, 0x07	; 7
    50fe:	28 17       	cp	r18, r24
    5100:	39 07       	cpc	r19, r25
    5102:	11 f4       	brne	.+4      	; 0x5108 <__vector_47+0x12c>
        /* No data left */
        StateRegister = LOADMOD_STOP_BIT0;
    5104:	8a e0       	ldi	r24, 0x0A	; 10
    5106:	0f c0       	rjmp	.+30     	; 0x5126 <__vector_47+0x14a>
    } else {
        /* Fetch next data and continue sending bits. */
        DataRegister = *++CodecBufferPtr;
    5108:	e8 b1       	in	r30, 0x08	; 8
    510a:	f9 b1       	in	r31, 0x09	; 9
    510c:	cf 01       	movw	r24, r30
    510e:	01 96       	adiw	r24, 0x01	; 1
    5110:	88 b9       	out	0x08, r24	; 8
    5112:	99 b9       	out	0x09, r25	; 9
    5114:	81 81       	ldd	r24, Z+1	; 0x01
    5116:	80 b9       	out	0x00, r24	; 0
        StateRegister = LOADMOD_DATA0;
    5118:	86 e0       	ldi	r24, 0x06	; 6
    511a:	05 c0       	rjmp	.+10     	; 0x5126 <__vector_47+0x14a>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    511c:	8e 98       	cbi	0x11, 6	; 17

    return;

LOADMOD_STOP_BIT0_LABEL:
    CodecSetLoadmodState(false);
    StateRegister = LOADMOD_STOP_BIT1;
    511e:	8b e0       	ldi	r24, 0x0B	; 11
    5120:	02 c0       	rjmp	.+4      	; 0x5126 <__vector_47+0x14a>
    5122:	8e 98       	cbi	0x11, 6	; 17
    return;

LOADMOD_STOP_BIT1_LABEL:
    CodecSetLoadmodState(false);
    StateRegister = LOADMOD_FINISHED;
    5124:	8c e0       	ldi	r24, 0x0C	; 12
    5126:	81 b9       	out	0x01, r24	; 1
    return;
    5128:	0b c0       	rjmp	.+22     	; 0x5140 <__vector_47+0x164>

LOADMOD_FINISHED_LABEL:
    /* We have written all of our bits. Deactivate the loadmod
     * timer. Also disable the bit-rate interrupt again. And
     * stop the subcarrier divider. */
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    512a:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    512e:	10 92 06 0a 	sts	0x0A06, r1	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider) {
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    5132:	10 92 40 08 	sts	0x0840, r1	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    5136:	10 92 41 08 	sts	0x0841, r1	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OFF, ISO14443A_SUBCARRIER_DIVIDER);

    /* Signal application that we have finished loadmod */
    Flags.LoadmodFinished = 1;
    513a:	81 e0       	ldi	r24, 0x01	; 1
    513c:	80 93 b8 2c 	sts	0x2CB8, r24	; 0x802cb8 <Flags+0x1>
    return;
}
    5140:	ff 91       	pop	r31
    5142:	ef 91       	pop	r30
    5144:	9f 91       	pop	r25
    5146:	8f 91       	pop	r24
    5148:	3f 91       	pop	r19
    514a:	2f 91       	pop	r18
    514c:	0f 90       	pop	r0
    514e:	0b be       	out	0x3b, r0	; 59
    5150:	0f 90       	pop	r0
    5152:	08 be       	out	0x38, r0	; 56
    5154:	0f 90       	pop	r0
    5156:	0f be       	out	0x3f, r0	; 63
    5158:	0f 90       	pop	r0
    515a:	1f 90       	pop	r1
    515c:	18 95       	reti

0000515e <ISO14443ACodecInit>:

void ISO14443ACodecInit(void) {
    515e:	cf 93       	push	r28
    5160:	df 93       	push	r29
    /* Initialize some global vars and start looking out for reader commands */
    Flags.DemodFinished = 0;
    5162:	e7 eb       	ldi	r30, 0xB7	; 183
    5164:	fc e2       	ldi	r31, 0x2C	; 44
    5166:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    5168:	11 82       	std	Z+1, r1	; 0x01

    isr_func_TCD0_CCC_vect = &isr_Reader14443_2A_TCD0_CCC_vect;
    516a:	80 ee       	ldi	r24, 0xE0	; 224
    516c:	99 e2       	ldi	r25, 0x29	; 41
    516e:	80 93 b7 2e 	sts	0x2EB7, r24	; 0x802eb7 <isr_func_TCD0_CCC_vect>
    5172:	90 93 b8 2e 	sts	0x2EB8, r25	; 0x802eb8 <isr_func_TCD0_CCC_vect+0x1>
    isr_func_CODEC_DEMOD_IN_INT0_VECT = &isr_ISO14443_2A_TCD0_CCC_vect;
    5176:	8f e1       	ldi	r24, 0x1F	; 31
    5178:	97 e2       	ldi	r25, 0x27	; 39
    517a:	80 93 b9 2f 	sts	0x2FB9, r24	; 0x802fb9 <isr_func_CODEC_DEMOD_IN_INT0_VECT>
    517e:	90 93 ba 2f 	sts	0x2FBA, r25	; 0x802fba <isr_func_CODEC_DEMOD_IN_INT0_VECT+0x1>
INLINE void CodecInitCommon(void) {
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    5182:	e0 e4       	ldi	r30, 0x40	; 64
    5184:	f6 e0       	ldi	r31, 0x06	; 6
    5186:	12 8a       	std	Z+18, r1	; 0x12
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    5188:	84 e0       	ldi	r24, 0x04	; 4
    518a:	82 83       	std	Z+2, r24	; 0x02
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    518c:	c0 e8       	ldi	r28, 0x80	; 128
    518e:	d1 e0       	ldi	r29, 0x01	; 1
    5190:	82 e6       	ldi	r24, 0x62	; 98
    5192:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    5194:	a0 e2       	ldi	r26, 0x20	; 32
    5196:	b6 e0       	ldi	r27, 0x06	; 6
    5198:	81 e0       	ldi	r24, 0x01	; 1
    519a:	16 96       	adiw	r26, 0x06	; 6
    519c:	8c 93       	st	X, r24
    519e:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    51a0:	11 96       	adiw	r26, 0x01	; 1
    51a2:	8c 93       	st	X, r24
    51a4:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    51a6:	96 e0       	ldi	r25, 0x06	; 6
    51a8:	12 96       	adiw	r26, 0x02	; 2
    51aa:	9c 93       	st	X, r25
    51ac:	12 97       	sbiw	r26, 0x02	; 2
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    51ae:	51 96       	adiw	r26, 0x11	; 17
    51b0:	8c 93       	st	X, r24
    51b2:	51 97       	sbiw	r26, 0x11	; 17
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    51b4:	32 e0       	ldi	r19, 0x02	; 2
    51b6:	52 96       	adiw	r26, 0x12	; 18
    51b8:	3c 93       	st	X, r19
    51ba:	52 97       	sbiw	r26, 0x12	; 18
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    51bc:	1a 96       	adiw	r26, 0x0a	; 10
    51be:	1c 92       	st	X, r1
    51c0:	1a 97       	sbiw	r26, 0x0a	; 10
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    51c2:	1b 96       	adiw	r26, 0x0b	; 11
    51c4:	1c 92       	st	X, r1
    51c6:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    51c8:	9f e0       	ldi	r25, 0x0F	; 15
    51ca:	19 96       	adiw	r26, 0x09	; 9
    51cc:	9c 93       	st	X, r25
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    51ce:	99 e5       	ldi	r25, 0x59	; 89
    51d0:	98 83       	st	Y, r25
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    51d2:	2a e5       	ldi	r18, 0x5A	; 90
    51d4:	29 83       	std	Y+1, r18	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    51d6:	9a 83       	std	Y+2, r25	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    51d8:	90 e4       	ldi	r25, 0x40	; 64
    51da:	91 83       	std	Z+1, r25	; 0x01
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    51dc:	96 83       	std	Z+6, r25	; 0x06
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    51de:	a0 eb       	ldi	r26, 0xB0	; 176
    51e0:	b0 e0       	ldi	r27, 0x00	; 0
    51e2:	12 96       	adiw	r26, 0x02	; 2
    51e4:	2c 91       	ld	r18, X
    51e6:	12 97       	sbiw	r26, 0x02	; 2
    51e8:	20 7f       	andi	r18, 0xF0	; 240
    51ea:	12 96       	adiw	r26, 0x02	; 2
    51ec:	2c 93       	st	X, r18
    51ee:	12 97       	sbiw	r26, 0x02	; 2
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    51f0:	12 96       	adiw	r26, 0x02	; 2
    51f2:	2c 91       	ld	r18, X
    51f4:	12 97       	sbiw	r26, 0x02	; 2
    51f6:	22 60       	ori	r18, 0x02	; 2
    51f8:	12 96       	adiw	r26, 0x02	; 2
    51fa:	2c 93       	st	X, r18

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    51fc:	20 e3       	ldi	r18, 0x30	; 48
    51fe:	21 83       	std	Z+1, r18	; 0x01
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    5200:	26 83       	std	Z+6, r18	; 0x06

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    5202:	90 8b       	std	Z+16, r25	; 0x10
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    5204:	86 83       	std	Z+6, r24	; 0x06
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    5206:	35 83       	std	Z+5, r19	; 0x05
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    5208:	83 e0       	ldi	r24, 0x03	; 3
    520a:	81 83       	std	Z+1, r24	; 0x01

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    520c:	e0 e0       	ldi	r30, 0x00	; 0
    520e:	f8 e0       	ldi	r31, 0x08	; 8
    5210:	83 e1       	ldi	r24, 0x13	; 19
    5212:	81 83       	std	Z+1, r24	; 0x01
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    5214:	21 e0       	ldi	r18, 0x01	; 1
    5216:	30 e0       	ldi	r19, 0x00	; 0
    5218:	26 a3       	std	Z+38, r18	; 0x26
    521a:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    521c:	20 a7       	std	Z+40, r18	; 0x28
    521e:	31 a7       	std	Z+41, r19	; 0x29

    AWEXC.OUTOVEN = 0x00;
    5220:	e0 e8       	ldi	r30, 0x80	; 128
    5222:	f8 e0       	ldi	r31, 0x08	; 8
    5224:	14 86       	std	Z+12, r1	; 0x0c
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    5226:	80 83       	st	Z, r24

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    5228:	e0 e2       	ldi	r30, 0x20	; 32
    522a:	f3 e0       	ldi	r31, 0x03	; 3
    522c:	13 82       	std	Z+3, r1	; 0x03
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    522e:	11 82       	std	Z+1, r1	; 0x01
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    5230:	88 e0       	ldi	r24, 0x08	; 8
    5232:	82 83       	std	Z+2, r24	; 0x02
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    5234:	91 e1       	ldi	r25, 0x11	; 17
    5236:	90 83       	st	Z, r25
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    5238:	a0 91 d9 2f 	lds	r26, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    523c:	b0 91 da 2f 	lds	r27, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    5240:	1a 96       	adiw	r26, 0x0a	; 10
    5242:	2d 91       	ld	r18, X+
    5244:	3c 91       	ld	r19, X
    5246:	1b 97       	sbiw	r26, 0x0b	; 11
    5248:	20 8f       	std	Z+24, r18	; 0x18
    524a:	31 8f       	std	Z+25, r19	; 0x19

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    524c:	e0 e8       	ldi	r30, 0x80	; 128
    524e:	f3 e0       	ldi	r31, 0x03	; 3
    5250:	9c e3       	ldi	r25, 0x3C	; 60
    5252:	92 83       	std	Z+2, r25	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    5254:	80 83       	st	Z, r24

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    5256:	93 83       	std	Z+3, r25	; 0x03
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    5258:	81 83       	std	Z+1, r24	; 0x01
    CodecInitCommon();
    StartDemod();
}
    525a:	df 91       	pop	r29
    525c:	cf 91       	pop	r28
    Flags.LoadmodFinished = 0;

    isr_func_TCD0_CCC_vect = &isr_Reader14443_2A_TCD0_CCC_vect;
    isr_func_CODEC_DEMOD_IN_INT0_VECT = &isr_ISO14443_2A_TCD0_CCC_vect;
    CodecInitCommon();
    StartDemod();
    525e:	c1 cd       	rjmp	.-1150   	; 0x4de2 <StartDemod>

00005260 <ISO14443ACodecDeInit>:
}

void ISO14443ACodecDeInit(void) {
    /* Gracefully shutdown codec */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    5260:	a0 e2       	ldi	r26, 0x20	; 32
    5262:	b6 e0       	ldi	r27, 0x06	; 6
    5264:	1a 96       	adiw	r26, 0x0a	; 10
    5266:	1c 92       	st	X, r1
    5268:	1a 97       	sbiw	r26, 0x0a	; 10

    Flags.DemodFinished = 0;
    526a:	e7 eb       	ldi	r30, 0xB7	; 183
    526c:	fc e2       	ldi	r31, 0x2C	; 44
    526e:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    5270:	11 82       	std	Z+1, r1	; 0x01

    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    5272:	e0 e0       	ldi	r30, 0x00	; 0
    5274:	f9 e0       	ldi	r31, 0x09	; 9
    5276:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    5278:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCAINTLVL_OFF_gc;
    527a:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCAIF_bm;
    527c:	80 e1       	ldi	r24, 0x10	; 16
    527e:	84 87       	std	Z+12, r24	; 0x0c


    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    5280:	e0 e0       	ldi	r30, 0x00	; 0
    5282:	fa e0       	ldi	r31, 0x0A	; 10
    5284:	10 82       	st	Z, r1
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_OFF_gc;
    5286:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_LOADMOD.INTCTRLA = TC_OVFINTLVL_OFF_gc;
    5288:	16 82       	std	Z+6, r1	; 0x06
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_OVFIF_bm;
    528a:	81 e0       	ldi	r24, 0x01	; 1
    528c:	84 87       	std	Z+12, r24	; 0x0c
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider) {
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    528e:	e0 e4       	ldi	r30, 0x40	; 64
    5290:	f8 e0       	ldi	r31, 0x08	; 8
    5292:	10 82       	st	Z, r1
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    5294:	11 82       	std	Z+1, r1	; 0x01

INLINE void CodecSetDemodPower(bool bOnOff) {
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    5296:	16 96       	adiw	r26, 0x06	; 6
    5298:	8c 93       	st	X, r24

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    529a:	8e 98       	cbi	0x11, 6	; 17
    529c:	08 95       	ret

0000529e <ISO14443ACodecTask>:
    CodecSetDemodPower(false);
    CodecSetLoadmodState(false);

}

void ISO14443ACodecTask(void) {
    529e:	cf 93       	push	r28
    52a0:	df 93       	push	r29
    if (Flags.DemodFinished) {
    52a2:	80 91 b7 2c 	lds	r24, 0x2CB7	; 0x802cb7 <Flags>
    52a6:	88 23       	and	r24, r24
    52a8:	09 f4       	brne	.+2      	; 0x52ac <ISO14443ACodecTask+0xe>
    52aa:	7e c0       	rjmp	.+252    	; 0x53a8 <ISO14443ACodecTask+0x10a>
        Flags.DemodFinished = 0;
    52ac:	10 92 b7 2c 	sts	0x2CB7, r1	; 0x802cb7 <Flags>
        /* Reception finished. Process the received bytes */
        uint16_t DemodBitCount = BitCount;
    52b0:	c6 b1       	in	r28, 0x06	; 6
    52b2:	d7 b1       	in	r29, 0x07	; 7
        uint16_t AnswerBitCount = ISO14443A_APP_NO_RESPONSE;

        if (DemodBitCount >= ISO14443A_MIN_BITS_PER_FRAME) {
    52b4:	c7 30       	cpi	r28, 0x07	; 7
    52b6:	d1 05       	cpc	r29, r1
    52b8:	08 f4       	brcc	.+2      	; 0x52bc <ISO14443ACodecTask+0x1e>
    52ba:	71 c0       	rjmp	.+226    	; 0x539e <ISO14443ACodecTask+0x100>
void LogGetModeByName(char *Mode, uint16_t BufferSize);
void LogGetModeList(char *List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void *Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    52bc:	ae 01       	movw	r20, r28
    52be:	49 5f       	subi	r20, 0xF9	; 249
    52c0:	5f 4f       	sbci	r21, 0xFF	; 255
    52c2:	93 e0       	ldi	r25, 0x03	; 3
    52c4:	56 95       	lsr	r21
    52c6:	47 95       	ror	r20
    52c8:	9a 95       	dec	r25
    52ca:	e1 f7       	brne	.-8      	; 0x52c4 <ISO14443ACodecTask+0x26>
    52cc:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    52d0:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    52d4:	6d e3       	ldi	r22, 0x3D	; 61
    52d6:	72 e3       	ldi	r23, 0x32	; 50
    52d8:	80 e4       	ldi	r24, 0x40	; 64
    52da:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    52dc:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    52e0:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    52e4:	87 81       	ldd	r24, Z+7	; 0x07
    52e6:	88 30       	cpi	r24, 0x08	; 8
    52e8:	19 f4       	brne	.+6      	; 0x52f0 <ISO14443ACodecTask+0x52>
        LEDGreenAction = Action;
    52ea:	83 e1       	ldi	r24, 0x13	; 19
    52ec:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    52f0:	86 81       	ldd	r24, Z+6	; 0x06
    52f2:	88 30       	cpi	r24, 0x08	; 8
    52f4:	19 f4       	brne	.+6      	; 0x52fc <ISO14443ACodecTask+0x5e>
        LEDRedAction = Action;
    52f6:	83 e1       	ldi	r24, 0x13	; 19
    52f8:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
INLINE void ApplicationTick(void) {
    ActiveConfiguration.ApplicationTickFunc();
}

INLINE uint16_t ApplicationProcess(uint8_t *ByteBuffer, uint16_t ByteCount) {
    return ActiveConfiguration.ApplicationProcessFunc(ByteBuffer, ByteCount);
    52fc:	e0 91 cb 2f 	lds	r30, 0x2FCB	; 0x802fcb <ActiveConfiguration+0xe>
    5300:	f0 91 cc 2f 	lds	r31, 0x2FCC	; 0x802fcc <ActiveConfiguration+0xf>
    5304:	be 01       	movw	r22, r28
    5306:	8d e3       	ldi	r24, 0x3D	; 61
    5308:	92 e3       	ldi	r25, 0x32	; 50
    530a:	19 95       	eicall
    530c:	ec 01       	movw	r28, r24
            LEDHook(LED_CODEC_RX, LED_PULSE);

            /* Call application if we received data */
            AnswerBitCount = ApplicationProcess(CodecBuffer, DemodBitCount);

            if (AnswerBitCount & ISO14443A_APP_CUSTOM_PARITY) {
    530e:	94 ff       	sbrs	r25, 4
    5310:	06 c0       	rjmp	.+12     	; 0x531e <ISO14443ACodecTask+0x80>
                /* Application has generated it's own parity bits.
                 * Clear this option bit. */
                AnswerBitCount &= ~ISO14443A_APP_CUSTOM_PARITY;
    5312:	df 7e       	andi	r29, 0xEF	; 239
                ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    5314:	8d eb       	ldi	r24, 0xBD	; 189
    5316:	92 e3       	ldi	r25, 0x32	; 50
    5318:	8a b9       	out	0x0a, r24	; 10
    531a:	9b b9       	out	0x0b, r25	; 11
    531c:	02 c0       	rjmp	.+4      	; 0x5322 <ISO14443ACodecTask+0x84>
            } else {
                /* We have to generate the parity bits ourself */
                ParityBufferPtr = 0;
    531e:	1a b8       	out	0x0a, r1	; 10
    5320:	1b b8       	out	0x0b, r1	; 11
            }
        }

        if (AnswerBitCount != ISO14443A_APP_NO_RESPONSE) {
    5322:	20 97       	sbiw	r28, 0x00	; 0
    5324:	e1 f1       	breq	.+120    	; 0x539e <ISO14443ACodecTask+0x100>
    5326:	ae 01       	movw	r20, r28
    5328:	49 5f       	subi	r20, 0xF9	; 249
    532a:	5f 4f       	sbci	r21, 0xFF	; 255
    532c:	83 e0       	ldi	r24, 0x03	; 3
    532e:	56 95       	lsr	r21
    5330:	47 95       	ror	r20
    5332:	8a 95       	dec	r24
    5334:	e1 f7       	brne	.-8      	; 0x532e <ISO14443ACodecTask+0x90>
    5336:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    533a:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    533e:	6d e3       	ldi	r22, 0x3D	; 61
    5340:	72 e3       	ldi	r23, 0x32	; 50
    5342:	81 e4       	ldi	r24, 0x41	; 65
    5344:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    5346:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    534a:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    534e:	87 81       	ldd	r24, Z+7	; 0x07
    5350:	89 30       	cpi	r24, 0x09	; 9
    5352:	19 f4       	brne	.+6      	; 0x535a <ISO14443ACodecTask+0xbc>
        LEDGreenAction = Action;
    5354:	83 e1       	ldi	r24, 0x13	; 19
    5356:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    535a:	86 81       	ldd	r24, Z+6	; 0x06
    535c:	89 30       	cpi	r24, 0x09	; 9
    535e:	19 f4       	brne	.+6      	; 0x5366 <ISO14443ACodecTask+0xc8>
        LEDRedAction = Action;
    5360:	83 e1       	ldi	r24, 0x13	; 19
    5362:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
            LogEntry(LOG_INFO_CODEC_TX_DATA, CodecBuffer, (AnswerBitCount + 7) / 8);
            LEDHook(LED_CODEC_TX, LED_PULSE);

            BitCount = AnswerBitCount;
    5366:	c6 b9       	out	0x06, r28	; 6
    5368:	d7 b9       	out	0x07, r29	; 7
            CodecBufferPtr = CodecBuffer;
    536a:	8d e3       	ldi	r24, 0x3D	; 61
    536c:	92 e3       	ldi	r25, 0x32	; 50
    536e:	88 b9       	out	0x08, r24	; 8
    5370:	99 b9       	out	0x09, r25	; 9
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    } else if (ModType == CODEC_SUBCARRIERMOD_OOK) {
        /* Configure subcarrier generation with 50% DC output using OOK */
        CODEC_SUBCARRIER_TIMER.CNT = 0;
    5372:	10 92 60 08 	sts	0x0860, r1	; 0x800860 <__TEXT_REGION_LENGTH__+0x700860>
    5376:	10 92 61 08 	sts	0x0861, r1	; 0x800861 <__TEXT_REGION_LENGTH__+0x700861>
        CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    537a:	8f e0       	ldi	r24, 0x0F	; 15
    537c:	90 e0       	ldi	r25, 0x00	; 0
    537e:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    5382:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
        CODEC_SUBCARRIER_TIMER.CODEC_SUBCARRIER_CC_OOK = Divider / 2;
    5386:	88 e0       	ldi	r24, 0x08	; 8
    5388:	90 e0       	ldi	r25, 0x00	; 0
    538a:	80 93 6a 08 	sts	0x086A, r24	; 0x80086a <__TEXT_REGION_LENGTH__+0x70086a>
    538e:	90 93 6b 08 	sts	0x086B, r25	; 0x80086b <__TEXT_REGION_LENGTH__+0x70086b>
        CODEC_SUBCARRIER_TIMER.CTRLB = CODEC_SUBCARRIER_CCEN_OOK | TC_WGMODE_SINGLESLOPE_gc;
    5392:	83 e2       	ldi	r24, 0x23	; 35
    5394:	80 93 41 08 	sts	0x0841, r24	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
            CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OOK, ISO14443A_SUBCARRIER_DIVIDER);

            StateRegister = LOADMOD_START;
    5398:	83 e0       	ldi	r24, 0x03	; 3
    539a:	81 b9       	out	0x01, r24	; 1
    539c:	05 c0       	rjmp	.+10     	; 0x53a8 <ISO14443ACodecTask+0x10a>
        } else {
            /* No data to be processed. Disable loadmodding and start listening again */
            CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    539e:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
            CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    53a2:	10 92 06 0a 	sts	0x0A06, r1	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>

            StartDemod();
    53a6:	1d dd       	rcall	.-1478   	; 0x4de2 <StartDemod>
        }
    }

    if (Flags.LoadmodFinished) {
    53a8:	80 91 b8 2c 	lds	r24, 0x2CB8	; 0x802cb8 <Flags+0x1>
    53ac:	88 23       	and	r24, r24
    53ae:	29 f0       	breq	.+10     	; 0x53ba <ISO14443ACodecTask+0x11c>
        Flags.LoadmodFinished = 0;
    53b0:	10 92 b8 2c 	sts	0x2CB8, r1	; 0x802cb8 <Flags+0x1>
        /* Load modulation has been finished. Stop it and start to listen
         * for incoming data again. */
        StartDemod();
    }
}
    53b4:	df 91       	pop	r29

    if (Flags.LoadmodFinished) {
        Flags.LoadmodFinished = 0;
        /* Load modulation has been finished. Stop it and start to listen
         * for incoming data again. */
        StartDemod();
    53b6:	cf 91       	pop	r28
    53b8:	14 cd       	rjmp	.-1496   	; 0x4de2 <StartDemod>
    }
}
    53ba:	df 91       	pop	r29
    53bc:	cf 91       	pop	r28
    53be:	08 95       	ret

000053c0 <isr_Reader14443_2A_TCD0_CCC_vect>:
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
}

// ISR (TCD0_CCC_vect)
// Frame Delay Time PCD to PICC ends
ISR_SHARED isr_Reader14443_2A_TCD0_CCC_vect(void) {
    53c0:	1f 92       	push	r1
    53c2:	0f 92       	push	r0
    53c4:	0f b6       	in	r0, 0x3f	; 63
    53c6:	0f 92       	push	r0
    53c8:	11 24       	eor	r1, r1
    53ca:	08 b6       	in	r0, 0x38	; 56
    53cc:	0f 92       	push	r0
    53ce:	18 be       	out	0x38, r1	; 56
    53d0:	0b b6       	in	r0, 0x3b	; 59
    53d2:	0f 92       	push	r0
    53d4:	1b be       	out	0x3b, r1	; 59
    53d6:	2f 93       	push	r18
    53d8:	3f 93       	push	r19
    53da:	8f 93       	push	r24
    53dc:	9f 93       	push	r25
    53de:	ef 93       	push	r30
    53e0:	ff 93       	push	r31
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    53e2:	e0 e0       	ldi	r30, 0x00	; 0
    53e4:	f9 e0       	ldi	r31, 0x09	; 9
    53e6:	80 e4       	ldi	r24, 0x40	; 64
    53e8:	84 87       	std	Z+12, r24	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_OFF_gc;
    53ea:	17 82       	std	Z+7, r1	; 0x07

    /* Enable the AC interrupt, which either finds the SOC and then starts the pause-finding timer,
     * or it is triggered before the SOC, which mostly isn't bad at all, since the first pause
     * needs to be found. */
    ACA.STATUS = AC_AC1IF_bm;
    53ec:	e0 e8       	ldi	r30, 0x80	; 128
    53ee:	f3 e0       	ldi	r31, 0x03	; 3
    53f0:	82 e0       	ldi	r24, 0x02	; 2
    53f2:	87 83       	std	Z+7, r24	; 0x07
    ACA.AC1CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_INTLVL_HI_gc | AC_ENABLE_bm;
    53f4:	89 eb       	ldi	r24, 0xB9	; 185
    53f6:	81 83       	std	Z+1, r24	; 0x01

    CodecBufferPtr = CodecBuffer; // use GPIOR for faster access
    53f8:	8d e3       	ldi	r24, 0x3D	; 61
    53fa:	92 e3       	ldi	r25, 0x32	; 50
    53fc:	8a b9       	out	0x0a, r24	; 10
    53fe:	9b b9       	out	0x0b, r25	; 11
    BitCount = 1; // FALSCH todo the first modulation of the SOC is "found" implicitly
    5400:	81 e0       	ldi	r24, 0x01	; 1
    5402:	90 e0       	ldi	r25, 0x00	; 0
    5404:	84 b9       	out	0x04, r24	; 4
    5406:	95 b9       	out	0x05, r25	; 5
    SampleRegister = 0x00;
    5408:	16 b8       	out	0x06, r1	; 6
    540a:	2e b1       	in	r18, 0x0e	; 14
    540c:	3f b1       	in	r19, 0x0f	; 15
    540e:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    5412:	90 91 09 04 	lds	r25, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    5416:	82 2b       	or	r24, r18
    5418:	93 2b       	or	r25, r19

    RxPendingSince = SystemGetSysTick();
    541a:	80 93 ba 2c 	sts	0x2CBA, r24	; 0x802cba <RxPendingSince>
    541e:	90 93 bb 2c 	sts	0x2CBB, r25	; 0x802cbb <RxPendingSince+0x1>
    Flags.RxPending = true;
    5422:	81 e0       	ldi	r24, 0x01	; 1
    5424:	80 93 be 2c 	sts	0x2CBE, r24	; 0x802cbe <Flags+0x2>

    // reset for future use
    CodecBufferIdx = 0;
    5428:	18 b8       	out	0x08, r1	; 8
    BitCountUp = 0;
    542a:	17 b8       	out	0x07, r1	; 7

    State = STATE_IDLE;
    542c:	10 92 b9 2c 	sts	0x2CB9, r1	; 0x802cb9 <State>
    PORTE.OUTTGL = PIN3_bm;
    5430:	88 e0       	ldi	r24, 0x08	; 8
    5432:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <__TEXT_REGION_LENGTH__+0x700687>
}
    5436:	ff 91       	pop	r31
    5438:	ef 91       	pop	r30
    543a:	9f 91       	pop	r25
    543c:	8f 91       	pop	r24
    543e:	3f 91       	pop	r19
    5440:	2f 91       	pop	r18
    5442:	0f 90       	pop	r0
    5444:	0b be       	out	0x3b, r0	; 59
    5446:	0f 90       	pop	r0
    5448:	08 be       	out	0x38, r0	; 56
    544a:	0f 90       	pop	r0
    544c:	0f be       	out	0x3f, r0	; 63
    544e:	0f 90       	pop	r0
    5450:	1f 90       	pop	r1
    5452:	18 95       	reti

00005454 <Reader14443ACodecInit>:
#define CodecBufferIdx	GPIOR8
#define CodecBufferPtr	CodecPtrRegister2

#define UINT8DIFF(a,b) ((uint8_t) (a-b))

void Reader14443ACodecInit(void) {
    5454:	cf 93       	push	r28
    5456:	df 93       	push	r29
INLINE void CodecInitCommon(void) {
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    5458:	e0 e4       	ldi	r30, 0x40	; 64
    545a:	f6 e0       	ldi	r31, 0x06	; 6
    545c:	12 8a       	std	Z+18, r1	; 0x12
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    545e:	84 e0       	ldi	r24, 0x04	; 4
    5460:	82 83       	std	Z+2, r24	; 0x02
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    5462:	c0 e8       	ldi	r28, 0x80	; 128
    5464:	d1 e0       	ldi	r29, 0x01	; 1
    5466:	82 e6       	ldi	r24, 0x62	; 98
    5468:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    546a:	a0 e2       	ldi	r26, 0x20	; 32
    546c:	b6 e0       	ldi	r27, 0x06	; 6
    546e:	81 e0       	ldi	r24, 0x01	; 1
    5470:	16 96       	adiw	r26, 0x06	; 6
    5472:	8c 93       	st	X, r24
    5474:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    5476:	11 96       	adiw	r26, 0x01	; 1
    5478:	8c 93       	st	X, r24
    547a:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    547c:	96 e0       	ldi	r25, 0x06	; 6
    547e:	12 96       	adiw	r26, 0x02	; 2
    5480:	9c 93       	st	X, r25
    5482:	12 97       	sbiw	r26, 0x02	; 2
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    5484:	51 96       	adiw	r26, 0x11	; 17
    5486:	8c 93       	st	X, r24
    5488:	51 97       	sbiw	r26, 0x11	; 17
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    548a:	32 e0       	ldi	r19, 0x02	; 2
    548c:	52 96       	adiw	r26, 0x12	; 18
    548e:	3c 93       	st	X, r19
    5490:	52 97       	sbiw	r26, 0x12	; 18
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    5492:	1a 96       	adiw	r26, 0x0a	; 10
    5494:	1c 92       	st	X, r1
    5496:	1a 97       	sbiw	r26, 0x0a	; 10
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    5498:	1b 96       	adiw	r26, 0x0b	; 11
    549a:	1c 92       	st	X, r1
    549c:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    549e:	9f e0       	ldi	r25, 0x0F	; 15
    54a0:	19 96       	adiw	r26, 0x09	; 9
    54a2:	9c 93       	st	X, r25
    54a4:	19 97       	sbiw	r26, 0x09	; 9
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    54a6:	99 e5       	ldi	r25, 0x59	; 89
    54a8:	98 83       	st	Y, r25
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    54aa:	2a e5       	ldi	r18, 0x5A	; 90
    54ac:	29 83       	std	Y+1, r18	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    54ae:	9a 83       	std	Y+2, r25	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    54b0:	90 e4       	ldi	r25, 0x40	; 64
    54b2:	91 83       	std	Z+1, r25	; 0x01
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    54b4:	96 83       	std	Z+6, r25	; 0x06
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    54b6:	c0 eb       	ldi	r28, 0xB0	; 176
    54b8:	d0 e0       	ldi	r29, 0x00	; 0
    54ba:	2a 81       	ldd	r18, Y+2	; 0x02
    54bc:	20 7f       	andi	r18, 0xF0	; 240
    54be:	2a 83       	std	Y+2, r18	; 0x02
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    54c0:	2a 81       	ldd	r18, Y+2	; 0x02
    54c2:	22 60       	ori	r18, 0x02	; 2
    54c4:	2a 83       	std	Y+2, r18	; 0x02

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    54c6:	20 e3       	ldi	r18, 0x30	; 48
    54c8:	21 83       	std	Z+1, r18	; 0x01
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    54ca:	26 83       	std	Z+6, r18	; 0x06

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    54cc:	90 8b       	std	Z+16, r25	; 0x10
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    54ce:	86 83       	std	Z+6, r24	; 0x06
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    54d0:	35 83       	std	Z+5, r19	; 0x05
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    54d2:	93 e0       	ldi	r25, 0x03	; 3
    54d4:	91 83       	std	Z+1, r25	; 0x01

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    54d6:	e0 e0       	ldi	r30, 0x00	; 0
    54d8:	f8 e0       	ldi	r31, 0x08	; 8
    54da:	93 e1       	ldi	r25, 0x13	; 19
    54dc:	91 83       	std	Z+1, r25	; 0x01
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    54de:	21 e0       	ldi	r18, 0x01	; 1
    54e0:	30 e0       	ldi	r19, 0x00	; 0
    54e2:	26 a3       	std	Z+38, r18	; 0x26
    54e4:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    54e6:	20 a7       	std	Z+40, r18	; 0x28
    54e8:	31 a7       	std	Z+41, r19	; 0x29

    AWEXC.OUTOVEN = 0x00;
    54ea:	e0 e8       	ldi	r30, 0x80	; 128
    54ec:	f8 e0       	ldi	r31, 0x08	; 8
    54ee:	14 86       	std	Z+12, r1	; 0x0c
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    54f0:	90 83       	st	Z, r25

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    54f2:	e0 e2       	ldi	r30, 0x20	; 32
    54f4:	f3 e0       	ldi	r31, 0x03	; 3
    54f6:	13 82       	std	Z+3, r1	; 0x03
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    54f8:	11 82       	std	Z+1, r1	; 0x01
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    54fa:	98 e0       	ldi	r25, 0x08	; 8
    54fc:	92 83       	std	Z+2, r25	; 0x02
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    54fe:	21 e1       	ldi	r18, 0x11	; 17
    5500:	20 83       	st	Z, r18
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    5502:	c0 91 d9 2f 	lds	r28, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    5506:	d0 91 da 2f 	lds	r29, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    550a:	2a 85       	ldd	r18, Y+10	; 0x0a
    550c:	3b 85       	ldd	r19, Y+11	; 0x0b
    550e:	20 8f       	std	Z+24, r18	; 0x18
    5510:	31 8f       	std	Z+25, r19	; 0x19

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    5512:	e0 e8       	ldi	r30, 0x80	; 128
    5514:	f3 e0       	ldi	r31, 0x03	; 3
    5516:	2c e3       	ldi	r18, 0x3C	; 60
    5518:	22 83       	std	Z+2, r18	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    551a:	90 83       	st	Z, r25

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    551c:	23 83       	std	Z+3, r18	; 0x03
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    551e:	91 83       	std	Z+1, r25	; 0x01
    /* Initialize common peripherals and start listening
     * for incoming data. */
    CodecInitCommon();
    isr_func_TCD0_CCC_vect = &isr_Reader14443_2A_TCD0_CCC_vect;
    5520:	20 ee       	ldi	r18, 0xE0	; 224
    5522:	39 e2       	ldi	r19, 0x29	; 41
    5524:	20 93 b7 2e 	sts	0x2EB7, r18	; 0x802eb7 <isr_func_TCD0_CCC_vect>
    5528:	30 93 b8 2e 	sts	0x2EB8, r19	; 0x802eb8 <isr_func_TCD0_CCC_vect+0x1>
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
}

INLINE void CodecSetDemodPower(bool bOnOff) {
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    552c:	15 96       	adiw	r26, 0x05	; 5
    552e:	8c 93       	st	X, r24
    CodecSetDemodPower(true);

    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;
    5530:	e0 e0       	ldi	r30, 0x00	; 0
    5532:	f9 e0       	ldi	r31, 0x09	; 9
    5534:	2f ef       	ldi	r18, 0xFF	; 255
    5536:	30 e0       	ldi	r19, 0x00	; 0
    5538:	26 a3       	std	Z+38, r18	; 0x26
    553a:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_TIMER_SAMPLING.CCB = 0;
    553c:	12 a6       	std	Z+42, r1	; 0x2a
    553e:	13 a6       	std	Z+43, r1	; 0x2b
    CODEC_TIMER_SAMPLING.CCC = 0;
    5540:	14 a6       	std	Z+44, r1	; 0x2c
    5542:	15 a6       	std	Z+45, r1	; 0x2d
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    5544:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.INTCTRLA = 0;
    5546:	16 82       	std	Z+6, r1	; 0x06
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCBINTLVL_OFF_gc;
    5548:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    554a:	80 83       	st	Z, r24

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    554c:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    State = STATE_IDLE;
    5550:	10 92 b9 2c 	sts	0x2CB9, r1	; 0x802cb9 <State>

    Flags.Start = false;
    5554:	ec eb       	ldi	r30, 0xBC	; 188
    5556:	fc e2       	ldi	r31, 0x2C	; 44
    5558:	10 82       	st	Z, r1
    Flags.RxPending = false;
    555a:	12 82       	std	Z+2, r1	; 0x02
    Flags.RxDone = false;
    555c:	11 82       	std	Z+1, r1	; 0x01
}
    555e:	df 91       	pop	r29
    5560:	cf 91       	pop	r28
    5562:	08 95       	ret

00005564 <Reader14443ACodecDeInit>:
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    5564:	81 e0       	ldi	r24, 0x01	; 1
    5566:	80 93 26 06 	sts	0x0626, r24	; 0x800626 <__TEXT_REGION_LENGTH__+0x700626>

void Reader14443ACodecDeInit(void) {
    CodecSetDemodPower(false);
    CodecReaderFieldStop();
    556a:	c6 db       	rcall	.-2164   	; 0x4cf8 <CodecReaderFieldStop>
    CODEC_TIMER_SAMPLING.CTRLA = 0;
    556c:	e0 e0       	ldi	r30, 0x00	; 0
    556e:	f9 e0       	ldi	r31, 0x09	; 9
    5570:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.INTCTRLB = 0;
    5572:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_LOADMOD.CTRLA = 0;
    5574:	e0 e0       	ldi	r30, 0x00	; 0
    5576:	fa e0       	ldi	r31, 0x0A	; 10
    5578:	10 82       	st	Z, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    557a:	17 82       	std	Z+7, r1	; 0x07
    Flags.RxDone = false;
    557c:	ec eb       	ldi	r30, 0xBC	; 188
    557e:	fc e2       	ldi	r31, 0x2C	; 44
    5580:	11 82       	std	Z+1, r1	; 0x01
    Flags.RxPending = false;
    5582:	12 82       	std	Z+2, r1	; 0x02
    Flags.Start = false;
    5584:	10 82       	st	Z, r1
    5586:	08 95       	ret

00005588 <Reader14443AMillerEOC>:
}

// Reader -> card send bits finished
// Start Frame delay time PCD to PICC
void Reader14443AMillerEOC(void) {
    CODEC_TIMER_SAMPLING.PER = 5 * SAMPLE_RATE_SYSTEM_CYCLES - 1;
    5588:	e0 e0       	ldi	r30, 0x00	; 0
    558a:	f9 e0       	ldi	r31, 0x09	; 9
    558c:	8f ef       	ldi	r24, 0xFF	; 255
    558e:	94 e0       	ldi	r25, 0x04	; 4
    5590:	86 a3       	std	Z+38, r24	; 0x26
    5592:	97 a3       	std	Z+39, r25	; 0x27
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCBIF_bm | TC0_CCCIF_bm;
    5594:	80 e6       	ldi	r24, 0x60	; 96
    5596:	84 87       	std	Z+12, r24	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCBINTLVL_OFF_gc | TC_CCCINTLVL_HI_gc;
    5598:	80 e3       	ldi	r24, 0x30	; 48
    559a:	87 83       	std	Z+7, r24	; 0x07
    CODEC_TIMER_SAMPLING.PERBUF = SAMPLE_RATE_SYSTEM_CYCLES - 1;
    559c:	8f ef       	ldi	r24, 0xFF	; 255
    559e:	90 e0       	ldi	r25, 0x00	; 0
    55a0:	86 ab       	std	Z+54, r24	; 0x36
    55a2:	97 ab       	std	Z+55, r25	; 0x37
    PORTE.OUTTGL = PIN3_bm;
    55a4:	88 e0       	ldi	r24, 0x08	; 8
    55a6:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <__TEXT_REGION_LENGTH__+0x700687>
    55aa:	08 95       	ret

000055ac <__vector_85>:
}

// EOC of Card->Reader found
ISR(CODEC_TIMER_TIMESTAMPS_CCA_VECT) { // EOC found
    55ac:	1f 92       	push	r1
    55ae:	0f 92       	push	r0
    55b0:	0f b6       	in	r0, 0x3f	; 63
    55b2:	0f 92       	push	r0
    55b4:	11 24       	eor	r1, r1
    55b6:	08 b6       	in	r0, 0x38	; 56
    55b8:	0f 92       	push	r0
    55ba:	18 be       	out	0x38, r1	; 56
    55bc:	0b b6       	in	r0, 0x3b	; 59
    55be:	0f 92       	push	r0
    55c0:	1b be       	out	0x3b, r1	; 59
    55c2:	2f 93       	push	r18
    55c4:	3f 93       	push	r19
    55c6:	4f 93       	push	r20
    55c8:	5f 93       	push	r21
    55ca:	8f 93       	push	r24
    55cc:	9f 93       	push	r25
    55ce:	ef 93       	push	r30
    55d0:	ff 93       	push	r31
}


// End of Card-> reader communication and enter frame delay time
INLINE void Reader14443A_EOC(void) {
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    55d2:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    55d6:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    55da:	10 92 47 09 	sts	0x0947, r1	; 0x800947 <__TEXT_REGION_LENGTH__+0x700947>
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    55de:	10 92 40 09 	sts	0x0940, r1	; 0x800940 <__TEXT_REGION_LENGTH__+0x700940>
    ACA.AC1CTRL &= ~AC_ENABLE_bm;
    55e2:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>
    55e6:	8e 7f       	andi	r24, 0xFE	; 254
    55e8:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>

    if (BitCount & 1) {
    55ec:	84 b1       	in	r24, 0x04	; 4
    55ee:	95 b1       	in	r25, 0x05	; 5
    55f0:	80 ff       	sbrs	r24, 0
    55f2:	1a c0       	rjmp	.+52     	; 0x5628 <__vector_85+0x7c>
        if (SampleRegister & 0x80)
    55f4:	37 9b       	sbis	0x06, 7	; 6
    55f6:	03 c0       	rjmp	.+6      	; 0x55fe <__vector_85+0x52>
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    55f8:	86 b1       	in	r24, 0x06	; 6
    55fa:	86 95       	lsr	r24
    55fc:	03 c0       	rjmp	.+6      	; 0x5604 <__vector_85+0x58>
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    55fe:	86 b1       	in	r24, 0x06	; 6
    5600:	86 95       	lsr	r24
    5602:	80 68       	ori	r24, 0x80	; 128
    5604:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5606:	84 b1       	in	r24, 0x04	; 4
    5608:	95 b1       	in	r25, 0x05	; 5
    560a:	01 96       	adiw	r24, 0x01	; 1
    560c:	84 b9       	out	0x04, r24	; 4
    560e:	95 b9       	out	0x05, r25	; 5
    5610:	87 70       	andi	r24, 0x07	; 7
    5612:	99 27       	eor	r25, r25
    5614:	89 2b       	or	r24, r25
    5616:	41 f4       	brne	.+16     	; 0x5628 <__vector_85+0x7c>
        return;
    *CodecBufferPtr++ = SampleRegister;
    5618:	ea b1       	in	r30, 0x0a	; 10
    561a:	fb b1       	in	r31, 0x0b	; 11
    561c:	cf 01       	movw	r24, r30
    561e:	01 96       	adiw	r24, 0x01	; 1
    5620:	8a b9       	out	0x0a, r24	; 10
    5622:	9b b9       	out	0x0b, r25	; 11
    5624:	86 b1       	in	r24, 0x06	; 6
    5626:	80 83       	st	Z, r24
            Insert0();
        else
            Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    5628:	84 b1       	in	r24, 0x04	; 4
    562a:	95 b1       	in	r25, 0x05	; 5
    562c:	87 70       	andi	r24, 0x07	; 7
    562e:	99 27       	eor	r25, r25
    5630:	89 2b       	or	r24, r25
    5632:	c9 f0       	breq	.+50     	; 0x5666 <__vector_85+0xba>
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5634:	e4 b1       	in	r30, 0x04	; 4
    5636:	f5 b1       	in	r31, 0x05	; 5
    5638:	86 b1       	in	r24, 0x06	; 6
    563a:	44 b1       	in	r20, 0x04	; 4
    563c:	55 b1       	in	r21, 0x05	; 5
    563e:	93 e0       	ldi	r25, 0x03	; 3
    5640:	f6 95       	lsr	r31
    5642:	e7 95       	ror	r30
    5644:	9a 95       	dec	r25
    5646:	e1 f7       	brne	.-8      	; 0x5640 <__vector_85+0x94>
    5648:	e3 5c       	subi	r30, 0xC3	; 195
    564a:	fd 4c       	sbci	r31, 0xCD	; 205
    564c:	90 e0       	ldi	r25, 0x00	; 0
    564e:	47 70       	andi	r20, 0x07	; 7
    5650:	55 27       	eor	r21, r21
    5652:	28 e0       	ldi	r18, 0x08	; 8
    5654:	30 e0       	ldi	r19, 0x00	; 0
    5656:	24 1b       	sub	r18, r20
    5658:	35 0b       	sbc	r19, r21
    565a:	02 c0       	rjmp	.+4      	; 0x5660 <__vector_85+0xb4>
    565c:	95 95       	asr	r25
    565e:	87 95       	ror	r24
    5660:	2a 95       	dec	r18
    5662:	e2 f7       	brpl	.-8      	; 0x565c <__vector_85+0xb0>
    5664:	80 83       	st	Z, r24
    Flags.RxDone = true;
    5666:	81 e0       	ldi	r24, 0x01	; 1
    5668:	80 93 bd 2c 	sts	0x2CBD, r24	; 0x802cbd <Flags+0x1>
    Flags.RxPending = false;
    566c:	10 92 be 2c 	sts	0x2CBE, r1	; 0x802cbe <Flags+0x2>

    // set up timer that forces the minimum frame delay time from PICC to PCD
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    5670:	8f ef       	ldi	r24, 0xFF	; 255
    5672:	9f ef       	ldi	r25, 0xFF	; 255
    5674:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    5678:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    CODEC_TIMER_LOADMOD.CNT = 0;
    567c:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
    5680:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    5684:	10 92 06 0a 	sts	0x0A06, r1	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5688:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    CODEC_TIMER_LOADMOD.CTRLD = 0;
    568c:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>
    CODEC_TIMER_LOADMOD.CTRLA = ISO14443A_PICC_TO_PCD_FDT_PRESCALER;
    5690:	84 e0       	ldi	r24, 0x04	; 4
    5692:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>

    State = STATE_FDT;
    5696:	83 e0       	ldi	r24, 0x03	; 3
    5698:	80 93 b9 2c 	sts	0x2CB9, r24	; 0x802cb9 <State>
}

// EOC of Card->Reader found
ISR(CODEC_TIMER_TIMESTAMPS_CCA_VECT) { // EOC found
    Reader14443A_EOC();
}
    569c:	ff 91       	pop	r31
    569e:	ef 91       	pop	r30
    56a0:	9f 91       	pop	r25
    56a2:	8f 91       	pop	r24
    56a4:	5f 91       	pop	r21
    56a6:	4f 91       	pop	r20
    56a8:	3f 91       	pop	r19
    56aa:	2f 91       	pop	r18
    56ac:	0f 90       	pop	r0
    56ae:	0b be       	out	0x3b, r0	; 59
    56b0:	0f 90       	pop	r0
    56b2:	08 be       	out	0x38, r0	; 56
    56b4:	0f 90       	pop	r0
    56b6:	0f be       	out	0x3f, r0	; 63
    56b8:	0f 90       	pop	r0
    56ba:	1f 90       	pop	r1
    56bc:	18 95       	reti

000056be <__vector_69>:

// This interrupt find Card -> Reader SOC
ISR(ACA_AC1_vect) { // this interrupt either finds the SOC or gets triggered before
    56be:	1f 92       	push	r1
    56c0:	0f 92       	push	r0
    56c2:	0f b6       	in	r0, 0x3f	; 63
    56c4:	0f 92       	push	r0
    56c6:	11 24       	eor	r1, r1
    56c8:	08 b6       	in	r0, 0x38	; 56
    56ca:	0f 92       	push	r0
    56cc:	18 be       	out	0x38, r1	; 56
    56ce:	0b b6       	in	r0, 0x3b	; 59
    56d0:	0f 92       	push	r0
    56d2:	1b be       	out	0x3b, r1	; 59
    56d4:	8f 93       	push	r24
    56d6:	ef 93       	push	r30
    56d8:	ff 93       	push	r31
    ACA.AC1CTRL &= ~AC_INTLVL_HI_gc; // disable this interrupt
    56da:	e0 e8       	ldi	r30, 0x80	; 128
    56dc:	f3 e0       	ldi	r31, 0x03	; 3
    56de:	81 81       	ldd	r24, Z+1	; 0x01
    56e0:	8f 7c       	andi	r24, 0xCF	; 207
    56e2:	81 83       	std	Z+1, r24	; 0x01
    // enable the pause-finding timer
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | TC_EVSEL_CH0_gc;
    56e4:	e0 e0       	ldi	r30, 0x00	; 0
    56e6:	fa e0       	ldi	r31, 0x0A	; 10
    56e8:	88 e8       	ldi	r24, 0x88	; 136
    56ea:	83 83       	std	Z+3, r24	; 0x03
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_DIV1_gc;
    56ec:	81 e0       	ldi	r24, 0x01	; 1
    56ee:	80 83       	st	Z, r24
}
    56f0:	ff 91       	pop	r31
    56f2:	ef 91       	pop	r30
    56f4:	8f 91       	pop	r24
    56f6:	0f 90       	pop	r0
    56f8:	0b be       	out	0x3b, r0	; 59
    56fa:	0f 90       	pop	r0
    56fc:	08 be       	out	0x38, r0	; 56
    56fe:	0f 90       	pop	r0
    5700:	0f be       	out	0x3f, r0	; 63
    5702:	0f 90       	pop	r0
    5704:	1f 90       	pop	r1
    5706:	18 95       	reti

00005708 <__vector_49>:

// Decode the Card -> Reader signal
// according to the pause and modulated period
// if the half bit duration is modulated, then add 1 to buffer
// if the half bit duration is not modulated, then add 0 to buffer
ISR(CODEC_TIMER_LOADMOD_CCA_VECT) { // pause found
    5708:	1f 92       	push	r1
    570a:	0f 92       	push	r0
    570c:	0f b6       	in	r0, 0x3f	; 63
    570e:	0f 92       	push	r0
    5710:	11 24       	eor	r1, r1
    5712:	08 b6       	in	r0, 0x38	; 56
    5714:	0f 92       	push	r0
    5716:	18 be       	out	0x38, r1	; 56
    5718:	0b b6       	in	r0, 0x3b	; 59
    571a:	0f 92       	push	r0
    571c:	1b be       	out	0x3b, r1	; 59
    571e:	8f 93       	push	r24
    5720:	9f 93       	push	r25
    5722:	ef 93       	push	r30
    5724:	ff 93       	push	r31
    uint8_t tmp = CODEC_TIMER_TIMESTAMPS.CNTL;
    5726:	80 91 60 09 	lds	r24, 0x0960	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>
    CODEC_TIMER_TIMESTAMPS.CNT = 0;
    572a:	10 92 60 09 	sts	0x0960, r1	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>
    572e:	10 92 61 09 	sts	0x0961, r1	; 0x800961 <__TEXT_REGION_LENGTH__+0x700961>

    /* This needs to be done only on the first call,
     * but doing this only on a condition means wasting time, so we do it every time. */
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_DIV4_gc;
    5732:	93 e0       	ldi	r25, 0x03	; 3
    5734:	90 93 40 09 	sts	0x0940, r25	; 0x800940 <__TEXT_REGION_LENGTH__+0x700940>

    switch (tmp) { // decide how many half bit periods have been modulations
    5738:	81 35       	cpi	r24, 0x51	; 81
    573a:	20 f4       	brcc	.+8      	; 0x5744 <__vector_49+0x3c>
    573c:	81 33       	cpi	r24, 0x31	; 49
    573e:	08 f4       	brcc	.+2      	; 0x5742 <__vector_49+0x3a>
    5740:	72 c0       	rjmp	.+228    	; 0x5826 <__vector_49+0x11e>
    5742:	1b c0       	rjmp	.+54     	; 0x577a <__vector_49+0x72>
    5744:	81 37       	cpi	r24, 0x71	; 113
    5746:	e8 f4       	brcc	.+58     	; 0x5782 <__vector_49+0x7a>
            Insert1();
            Insert0();
            return;

        case 81 ... 112: // 96 ticks are 3 half bit periods
            if (BitCount & 1) {
    5748:	84 b1       	in	r24, 0x04	; 4
    574a:	95 b1       	in	r25, 0x05	; 5
    574c:	80 ff       	sbrs	r24, 0
    574e:	2e c0       	rjmp	.+92     	; 0x57ac <__vector_49+0xa4>
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5750:	86 b1       	in	r24, 0x06	; 6
    5752:	86 95       	lsr	r24
    5754:	80 68       	ori	r24, 0x80	; 128
    5756:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5758:	84 b1       	in	r24, 0x04	; 4
    575a:	95 b1       	in	r25, 0x05	; 5
    575c:	01 96       	adiw	r24, 0x01	; 1
    575e:	84 b9       	out	0x04, r24	; 4
    5760:	95 b9       	out	0x05, r25	; 5
    5762:	87 70       	andi	r24, 0x07	; 7
    5764:	99 27       	eor	r25, r25
    5766:	89 2b       	or	r24, r25
    5768:	41 f4       	brne	.+16     	; 0x577a <__vector_49+0x72>
        return;
    *CodecBufferPtr++ = SampleRegister;
    576a:	ea b1       	in	r30, 0x0a	; 10
    576c:	fb b1       	in	r31, 0x0b	; 11
    576e:	cf 01       	movw	r24, r30
    5770:	01 96       	adiw	r24, 0x01	; 1
    5772:	8a b9       	out	0x0a, r24	; 10
    5774:	9b b9       	out	0x0b, r25	; 11
    5776:	86 b1       	in	r24, 0x06	; 6
    5778:	80 83       	st	Z, r24
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    577a:	86 b1       	in	r24, 0x06	; 6
    577c:	86 95       	lsr	r24
    577e:	80 68       	ori	r24, 0x80	; 128
    5780:	2c c0       	rjmp	.+88     	; 0x57da <__vector_49+0xd2>
    5782:	86 b1       	in	r24, 0x06	; 6
    5784:	86 95       	lsr	r24
    5786:	80 68       	ori	r24, 0x80	; 128
    5788:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    578a:	84 b1       	in	r24, 0x04	; 4
    578c:	95 b1       	in	r25, 0x05	; 5
    578e:	01 96       	adiw	r24, 0x01	; 1
    5790:	84 b9       	out	0x04, r24	; 4
    5792:	95 b9       	out	0x05, r25	; 5
    5794:	87 70       	andi	r24, 0x07	; 7
    5796:	99 27       	eor	r25, r25
    5798:	89 2b       	or	r24, r25
    579a:	41 f4       	brne	.+16     	; 0x57ac <__vector_49+0xa4>
        return;
    *CodecBufferPtr++ = SampleRegister;
    579c:	ea b1       	in	r30, 0x0a	; 10
    579e:	fb b1       	in	r31, 0x0b	; 11
    57a0:	cf 01       	movw	r24, r30
    57a2:	01 96       	adiw	r24, 0x01	; 1
    57a4:	8a b9       	out	0x0a, r24	; 10
    57a6:	9b b9       	out	0x0b, r25	; 11
    57a8:	86 b1       	in	r24, 0x06	; 6
    57aa:	80 83       	st	Z, r24
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    57ac:	86 b1       	in	r24, 0x06	; 6
    57ae:	86 95       	lsr	r24
    57b0:	80 68       	ori	r24, 0x80	; 128
    57b2:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    57b4:	84 b1       	in	r24, 0x04	; 4
    57b6:	95 b1       	in	r25, 0x05	; 5
    57b8:	01 96       	adiw	r24, 0x01	; 1
    57ba:	84 b9       	out	0x04, r24	; 4
    57bc:	95 b9       	out	0x05, r25	; 5
    57be:	87 70       	andi	r24, 0x07	; 7
    57c0:	99 27       	eor	r25, r25
    57c2:	89 2b       	or	r24, r25
    57c4:	41 f4       	brne	.+16     	; 0x57d6 <__vector_49+0xce>
        return;
    *CodecBufferPtr++ = SampleRegister;
    57c6:	ea b1       	in	r30, 0x0a	; 10
    57c8:	fb b1       	in	r31, 0x0b	; 11
    57ca:	cf 01       	movw	r24, r30
    57cc:	01 96       	adiw	r24, 0x01	; 1
    57ce:	8a b9       	out	0x0a, r24	; 10
    57d0:	9b b9       	out	0x0b, r25	; 11
    57d2:	86 b1       	in	r24, 0x06	; 6
    57d4:	80 83       	st	Z, r24
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    57d6:	86 b1       	in	r24, 0x06	; 6
    57d8:	86 95       	lsr	r24
    57da:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    57dc:	84 b1       	in	r24, 0x04	; 4
    57de:	95 b1       	in	r25, 0x05	; 5
    57e0:	01 96       	adiw	r24, 0x01	; 1
    57e2:	84 b9       	out	0x04, r24	; 4
    57e4:	95 b9       	out	0x05, r25	; 5
    57e6:	87 70       	andi	r24, 0x07	; 7
    57e8:	99 27       	eor	r25, r25
    57ea:	89 2b       	or	r24, r25
    57ec:	41 f4       	brne	.+16     	; 0x57fe <__vector_49+0xf6>
        return;
    *CodecBufferPtr++ = SampleRegister;
    57ee:	ea b1       	in	r30, 0x0a	; 10
    57f0:	fb b1       	in	r31, 0x0b	; 11
    57f2:	cf 01       	movw	r24, r30
    57f4:	01 96       	adiw	r24, 0x01	; 1
    57f6:	8a b9       	out	0x0a, r24	; 10
    57f8:	9b b9       	out	0x0b, r25	; 11
    57fa:	86 b1       	in	r24, 0x06	; 6
    57fc:	80 83       	st	Z, r24
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    57fe:	86 b1       	in	r24, 0x06	; 6
    5800:	86 95       	lsr	r24
    5802:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5804:	84 b1       	in	r24, 0x04	; 4
    5806:	95 b1       	in	r25, 0x05	; 5
    5808:	01 96       	adiw	r24, 0x01	; 1
    580a:	84 b9       	out	0x04, r24	; 4
    580c:	95 b9       	out	0x05, r25	; 5
    580e:	87 70       	andi	r24, 0x07	; 7
    5810:	99 27       	eor	r25, r25
    5812:	89 2b       	or	r24, r25
    5814:	41 f4       	brne	.+16     	; 0x5826 <__vector_49+0x11e>
        return;
    *CodecBufferPtr++ = SampleRegister;
    5816:	ea b1       	in	r30, 0x0a	; 10
    5818:	fb b1       	in	r31, 0x0b	; 11
    581a:	cf 01       	movw	r24, r30
    581c:	01 96       	adiw	r24, 0x01	; 1
    581e:	8a b9       	out	0x0a, r24	; 10
    5820:	9b b9       	out	0x0b, r25	; 11
    5822:	86 b1       	in	r24, 0x06	; 6
    5824:	80 83       	st	Z, r24
            Insert0();
            Insert0();
            return;
    }
    return;
}
    5826:	ff 91       	pop	r31
    5828:	ef 91       	pop	r30
    582a:	9f 91       	pop	r25
    582c:	8f 91       	pop	r24
    582e:	0f 90       	pop	r0
    5830:	0b be       	out	0x3b, r0	; 59
    5832:	0f 90       	pop	r0
    5834:	08 be       	out	0x38, r0	; 56
    5836:	0f 90       	pop	r0
    5838:	0f be       	out	0x3f, r0	; 63
    583a:	0f 90       	pop	r0
    583c:	1f 90       	pop	r1
    583e:	18 95       	reti

00005840 <Reader14443ACodecTask>:

void Reader14443ACodecTask(void) {
    5840:	0f 93       	push	r16
    5842:	1f 93       	push	r17
    5844:	cf 93       	push	r28
    5846:	df 93       	push	r29
    5848:	cd b7       	in	r28, 0x3d	; 61
    584a:	de b7       	in	r29, 0x3e	; 62
    584c:	da 95       	dec	r29
    584e:	cd bf       	out	0x3d, r28	; 61
    5850:	de bf       	out	0x3e, r29	; 62
    if (Flags.RxPending && SYSTICK_DIFF(RxPendingSince) > Reader_FWT + 1) {
    5852:	80 91 be 2c 	lds	r24, 0x2CBE	; 0x802cbe <Flags+0x2>
    5856:	88 23       	and	r24, r24
    5858:	09 f4       	brne	.+2      	; 0x585c <Reader14443ACodecTask+0x1c>
    585a:	83 c0       	rjmp	.+262    	; 0x5962 <Reader14443ACodecTask+0x122>
    585c:	4e b1       	in	r20, 0x0e	; 14
    585e:	5f b1       	in	r21, 0x0f	; 15
    5860:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    5864:	90 91 09 04 	lds	r25, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    5868:	20 91 ba 2c 	lds	r18, 0x2CBA	; 0x802cba <RxPendingSince>
    586c:	30 91 bb 2c 	lds	r19, 0x2CBB	; 0x802cbb <RxPendingSince+0x1>
    5870:	84 2b       	or	r24, r20
    5872:	95 2b       	or	r25, r21
    5874:	82 1b       	sub	r24, r18
    5876:	93 0b       	sbc	r25, r19
    5878:	20 91 1e 20 	lds	r18, 0x201E	; 0x80201e <Reader_FWT>
    587c:	30 91 1f 20 	lds	r19, 0x201F	; 0x80201f <Reader_FWT+0x1>
    5880:	2f 5f       	subi	r18, 0xFF	; 255
    5882:	3f 4f       	sbci	r19, 0xFF	; 255
    5884:	28 17       	cp	r18, r24
    5886:	39 07       	cpc	r19, r25
    5888:	08 f0       	brcs	.+2      	; 0x588c <Reader14443ACodecTask+0x4c>
    588a:	6b c0       	rjmp	.+214    	; 0x5962 <Reader14443ACodecTask+0x122>
}


// End of Card-> reader communication and enter frame delay time
INLINE void Reader14443A_EOC(void) {
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    588c:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    5890:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    5894:	10 92 47 09 	sts	0x0947, r1	; 0x800947 <__TEXT_REGION_LENGTH__+0x700947>
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    5898:	10 92 40 09 	sts	0x0940, r1	; 0x800940 <__TEXT_REGION_LENGTH__+0x700940>
    ACA.AC1CTRL &= ~AC_ENABLE_bm;
    589c:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>
    58a0:	8e 7f       	andi	r24, 0xFE	; 254
    58a2:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>

    if (BitCount & 1) {
    58a6:	84 b1       	in	r24, 0x04	; 4
    58a8:	95 b1       	in	r25, 0x05	; 5
    58aa:	80 ff       	sbrs	r24, 0
    58ac:	1a c0       	rjmp	.+52     	; 0x58e2 <Reader14443ACodecTask+0xa2>
        if (SampleRegister & 0x80)
    58ae:	37 9b       	sbis	0x06, 7	; 6
    58b0:	03 c0       	rjmp	.+6      	; 0x58b8 <Reader14443ACodecTask+0x78>
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    58b2:	86 b1       	in	r24, 0x06	; 6
    58b4:	86 95       	lsr	r24
    58b6:	03 c0       	rjmp	.+6      	; 0x58be <Reader14443ACodecTask+0x7e>
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    58b8:	86 b1       	in	r24, 0x06	; 6
    58ba:	86 95       	lsr	r24
    58bc:	80 68       	ori	r24, 0x80	; 128
    58be:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    58c0:	84 b1       	in	r24, 0x04	; 4
    58c2:	95 b1       	in	r25, 0x05	; 5
    58c4:	01 96       	adiw	r24, 0x01	; 1
    58c6:	84 b9       	out	0x04, r24	; 4
    58c8:	95 b9       	out	0x05, r25	; 5
    58ca:	87 70       	andi	r24, 0x07	; 7
    58cc:	99 27       	eor	r25, r25
    58ce:	89 2b       	or	r24, r25
    58d0:	41 f4       	brne	.+16     	; 0x58e2 <Reader14443ACodecTask+0xa2>
        return;
    *CodecBufferPtr++ = SampleRegister;
    58d2:	ea b1       	in	r30, 0x0a	; 10
    58d4:	fb b1       	in	r31, 0x0b	; 11
    58d6:	cf 01       	movw	r24, r30
    58d8:	01 96       	adiw	r24, 0x01	; 1
    58da:	8a b9       	out	0x0a, r24	; 10
    58dc:	9b b9       	out	0x0b, r25	; 11
    58de:	86 b1       	in	r24, 0x06	; 6
    58e0:	80 83       	st	Z, r24
            Insert0();
        else
            Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    58e2:	84 b1       	in	r24, 0x04	; 4
    58e4:	95 b1       	in	r25, 0x05	; 5
    58e6:	87 70       	andi	r24, 0x07	; 7
    58e8:	99 27       	eor	r25, r25
    58ea:	89 2b       	or	r24, r25
    58ec:	c9 f0       	breq	.+50     	; 0x5920 <Reader14443ACodecTask+0xe0>
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    58ee:	e4 b1       	in	r30, 0x04	; 4
    58f0:	f5 b1       	in	r31, 0x05	; 5
    58f2:	86 b1       	in	r24, 0x06	; 6
    58f4:	44 b1       	in	r20, 0x04	; 4
    58f6:	55 b1       	in	r21, 0x05	; 5
    58f8:	13 e0       	ldi	r17, 0x03	; 3
    58fa:	f6 95       	lsr	r31
    58fc:	e7 95       	ror	r30
    58fe:	1a 95       	dec	r17
    5900:	e1 f7       	brne	.-8      	; 0x58fa <Reader14443ACodecTask+0xba>
    5902:	e3 5c       	subi	r30, 0xC3	; 195
    5904:	fd 4c       	sbci	r31, 0xCD	; 205
    5906:	90 e0       	ldi	r25, 0x00	; 0
    5908:	47 70       	andi	r20, 0x07	; 7
    590a:	55 27       	eor	r21, r21
    590c:	28 e0       	ldi	r18, 0x08	; 8
    590e:	30 e0       	ldi	r19, 0x00	; 0
    5910:	24 1b       	sub	r18, r20
    5912:	35 0b       	sbc	r19, r21
    5914:	02 c0       	rjmp	.+4      	; 0x591a <Reader14443ACodecTask+0xda>
    5916:	95 95       	asr	r25
    5918:	87 95       	ror	r24
    591a:	2a 95       	dec	r18
    591c:	e2 f7       	brpl	.-8      	; 0x5916 <Reader14443ACodecTask+0xd6>
    591e:	80 83       	st	Z, r24
    Flags.RxDone = true;
    5920:	81 e0       	ldi	r24, 0x01	; 1
    5922:	80 93 bd 2c 	sts	0x2CBD, r24	; 0x802cbd <Flags+0x1>
    Flags.RxPending = false;
    5926:	10 92 be 2c 	sts	0x2CBE, r1	; 0x802cbe <Flags+0x2>

    // set up timer that forces the minimum frame delay time from PICC to PCD
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    592a:	2f ef       	ldi	r18, 0xFF	; 255
    592c:	3f ef       	ldi	r19, 0xFF	; 255
    592e:	20 93 26 0a 	sts	0x0A26, r18	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    5932:	30 93 27 0a 	sts	0x0A27, r19	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    CODEC_TIMER_LOADMOD.CNT = 0;
    5936:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
    593a:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    593e:	10 92 06 0a 	sts	0x0A06, r1	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5942:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    CODEC_TIMER_LOADMOD.CTRLD = 0;
    5946:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>
    CODEC_TIMER_LOADMOD.CTRLA = ISO14443A_PICC_TO_PCD_FDT_PRESCALER;
    594a:	94 e0       	ldi	r25, 0x04	; 4
    594c:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>

    State = STATE_FDT;
    5950:	93 e0       	ldi	r25, 0x03	; 3
    5952:	90 93 b9 2c 	sts	0x2CB9, r25	; 0x802cb9 <State>
}

void Reader14443ACodecTask(void) {
    if (Flags.RxPending && SYSTICK_DIFF(RxPendingSince) > Reader_FWT + 1) {
        Reader14443A_EOC();
        BitCount = 0;
    5956:	14 b8       	out	0x04, r1	; 4
    5958:	15 b8       	out	0x05, r1	; 5
        Flags.RxDone = true;
    595a:	80 93 bd 2c 	sts	0x2CBD, r24	; 0x802cbd <Flags+0x1>
        Flags.RxPending = false;
    595e:	10 92 be 2c 	sts	0x2CBE, r1	; 0x802cbe <Flags+0x2>
    }
    if (CodecIsReaderToBeRestarted() || !CodecIsReaderFieldReady())
    5962:	f7 d9       	rcall	.-3090   	; 0x4d52 <CodecIsReaderToBeRestarted>
    5964:	81 11       	cpse	r24, r1
    5966:	6f c2       	rjmp	.+1246   	; 0x5e46 <Reader14443ACodecTask+0x606>
    5968:	d0 d9       	rcall	.-3168   	; 0x4d0a <CodecIsReaderFieldReady>
    596a:	88 23       	and	r24, r24
    596c:	09 f4       	brne	.+2      	; 0x5970 <Reader14443ACodecTask+0x130>
    596e:	6b c2       	rjmp	.+1238   	; 0x5e46 <Reader14443ACodecTask+0x606>
    5970:	80 91 be 2c 	lds	r24, 0x2CBE	; 0x802cbe <Flags+0x2>
        return;
    if (!Flags.RxPending && (Flags.Start || Flags.RxDone)) {
    5974:	81 11       	cpse	r24, r1
    5976:	67 c2       	rjmp	.+1230   	; 0x5e46 <Reader14443ACodecTask+0x606>
    5978:	80 91 bc 2c 	lds	r24, 0x2CBC	; 0x802cbc <Flags>
    597c:	81 11       	cpse	r24, r1
    597e:	05 c0       	rjmp	.+10     	; 0x598a <Reader14443ACodecTask+0x14a>
    5980:	80 91 bd 2c 	lds	r24, 0x2CBD	; 0x802cbd <Flags+0x1>
    5984:	88 23       	and	r24, r24
    5986:	09 f4       	brne	.+2      	; 0x598a <Reader14443ACodecTask+0x14a>
    5988:	5e c2       	rjmp	.+1212   	; 0x5e46 <Reader14443ACodecTask+0x606>
    598a:	80 91 b9 2c 	lds	r24, 0x2CB9	; 0x802cb9 <State>
        if (State == STATE_FDT && CODEC_TIMER_LOADMOD.CNT < ISO14443A_PICC_TO_PCD_MIN_FDT) // we are in frame delay time, so we can return later
    598e:	83 30       	cpi	r24, 0x03	; 3
    5990:	41 f4       	brne	.+16     	; 0x59a2 <Reader14443ACodecTask+0x162>
    5992:	80 91 20 0a 	lds	r24, 0x0A20	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
    5996:	90 91 21 0a 	lds	r25, 0x0A21	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
    599a:	85 32       	cpi	r24, 0x25	; 37
    599c:	91 40       	sbci	r25, 0x01	; 1
    599e:	08 f4       	brcc	.+2      	; 0x59a2 <Reader14443ACodecTask+0x162>
    59a0:	52 c2       	rjmp	.+1188   	; 0x5e46 <Reader14443ACodecTask+0x606>
    59a2:	80 91 bd 2c 	lds	r24, 0x2CBD	; 0x802cbd <Flags+0x1>
            return;
        if (Flags.RxDone && BitCount > 0) { // decode the raw received data
    59a6:	88 23       	and	r24, r24
    59a8:	09 f4       	brne	.+2      	; 0x59ac <Reader14443ACodecTask+0x16c>
    59aa:	a2 c0       	rjmp	.+324    	; 0x5af0 <Reader14443ACodecTask+0x2b0>
    59ac:	84 b1       	in	r24, 0x04	; 4
    59ae:	95 b1       	in	r25, 0x05	; 5
    59b0:	89 2b       	or	r24, r25
    59b2:	09 f4       	brne	.+2      	; 0x59b6 <Reader14443ACodecTask+0x176>
    59b4:	9d c0       	rjmp	.+314    	; 0x5af0 <Reader14443ACodecTask+0x2b0>
    59b6:	84 b1       	in	r24, 0x04	; 4
            if (BitCount < ISO14443A_RX_MINIMUM_BITCOUNT * 2) {
    59b8:	95 b1       	in	r25, 0x05	; 5
    59ba:	08 97       	sbiw	r24, 0x08	; 8
    59bc:	18 f4       	brcc	.+6      	; 0x59c4 <Reader14443ACodecTask+0x184>
    59be:	14 b8       	out	0x04, r1	; 4
                BitCount = 0;
    59c0:	15 b8       	out	0x05, r1	; 5
    59c2:	96 c0       	rjmp	.+300    	; 0x5af0 <Reader14443ACodecTask+0x2b0>
    59c4:	44 b1       	in	r20, 0x04	; 4
            } else {
                uint8_t TmpCodecBuffer[CODEC_BUFFER_SIZE];
                memcpy(TmpCodecBuffer, CodecBuffer, (BitCount + 7) / 8);
    59c6:	55 b1       	in	r21, 0x05	; 5
    59c8:	49 5f       	subi	r20, 0xF9	; 249
    59ca:	5f 4f       	sbci	r21, 0xFF	; 255
    59cc:	b3 e0       	ldi	r27, 0x03	; 3
    59ce:	56 95       	lsr	r21
    59d0:	47 95       	ror	r20
    59d2:	ba 95       	dec	r27
    59d4:	e1 f7       	brne	.-8      	; 0x59ce <Reader14443ACodecTask+0x18e>
    59d6:	6d e3       	ldi	r22, 0x3D	; 61
    59d8:	72 e3       	ldi	r23, 0x32	; 50
    59da:	ce 01       	movw	r24, r28
    59dc:	01 96       	adiw	r24, 0x01	; 1
    59de:	0e 94 a0 78 	call	0xf140	; 0xf140 <memcpy>
    59e2:	8d e3       	ldi	r24, 0x3D	; 61

                CodecBufferPtr = CodecBuffer;
    59e4:	92 e3       	ldi	r25, 0x32	; 50
    59e6:	8a b9       	out	0x0a, r24	; 10
    59e8:	9b b9       	out	0x0b, r25	; 11
    59ea:	44 b1       	in	r20, 0x04	; 4
                uint16_t BitCountTmp = 2, TotalBitCount = BitCount;
    59ec:	55 b1       	in	r21, 0x05	; 5
    59ee:	14 b8       	out	0x04, r1	; 4
                BitCount = 0;
    59f0:	15 b8       	out	0x05, r1	; 5
    59f2:	89 81       	ldd	r24, Y+1	; 0x01

                bool breakflag = false;
                TmpCodecBuffer[0] >>= 2; // with this (and BitCountTmp = 2), the SOC is ignored
    59f4:	86 95       	lsr	r24
    59f6:	86 95       	lsr	r24
    59f8:	89 83       	std	Y+1, r24	; 0x01
    59fa:	22 e0       	ldi	r18, 0x02	; 2
            } else {
                uint8_t TmpCodecBuffer[CODEC_BUFFER_SIZE];
                memcpy(TmpCodecBuffer, CodecBuffer, (BitCount + 7) / 8);

                CodecBufferPtr = CodecBuffer;
                uint16_t BitCountTmp = 2, TotalBitCount = BitCount;
    59fc:	30 e0       	ldi	r19, 0x00	; 0
    59fe:	24 17       	cp	r18, r20

                bool breakflag = false;
                TmpCodecBuffer[0] >>= 2; // with this (and BitCountTmp = 2), the SOC is ignored

                // Manchester Code ISO14443-2 8.2.5
                while (!breakflag && BitCountTmp < TotalBitCount) {
    5a00:	35 07       	cpc	r19, r21
    5a02:	b0 f5       	brcc	.+108    	; 0x5a70 <Reader14443ACodecTask+0x230>
    5a04:	f9 01       	movw	r30, r18
                    uint8_t Bit = TmpCodecBuffer[BitCountTmp / 8] & 0x03;
    5a06:	a3 e0       	ldi	r26, 0x03	; 3
    5a08:	f6 95       	lsr	r31
    5a0a:	e7 95       	ror	r30
    5a0c:	aa 95       	dec	r26
    5a0e:	e1 f7       	brne	.-8      	; 0x5a08 <Reader14443ACodecTask+0x1c8>
    5a10:	81 e0       	ldi	r24, 0x01	; 1
    5a12:	90 e0       	ldi	r25, 0x00	; 0
    5a14:	8c 0f       	add	r24, r28
    5a16:	9d 1f       	adc	r25, r29
    5a18:	e8 0f       	add	r30, r24
    5a1a:	f9 1f       	adc	r31, r25
    5a1c:	80 81       	ld	r24, Z
    5a1e:	98 2f       	mov	r25, r24
                    TmpCodecBuffer[BitCountTmp / 8] >>= 2;
    5a20:	96 95       	lsr	r25
    5a22:	96 95       	lsr	r25
    5a24:	90 83       	st	Z, r25
    5a26:	83 70       	andi	r24, 0x03	; 3
                    switch (Bit) {
    5a28:	81 30       	cpi	r24, 0x01	; 1
    5a2a:	49 f0       	breq	.+18     	; 0x5a3e <Reader14443ACodecTask+0x1fe>
    5a2c:	30 f0       	brcs	.+12     	; 0x5a3a <Reader14443ACodecTask+0x1fa>
    5a2e:	82 30       	cpi	r24, 0x02	; 2
    5a30:	d1 f4       	brne	.+52     	; 0x5a66 <Reader14443ACodecTask+0x226>
    5a32:	86 b1       	in	r24, 0x06	; 6
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5a34:	86 95       	lsr	r24
    5a36:	80 68       	ori	r24, 0x80	; 128
    5a38:	04 c0       	rjmp	.+8      	; 0x5a42 <Reader14443ACodecTask+0x202>
    5a3a:	81 e0       	ldi	r24, 0x01	; 1
                        case 0b01:
                            Insert0();
                            break;

                        case 0b00: // EOC
                            breakflag = true;
    5a3c:	15 c0       	rjmp	.+42     	; 0x5a68 <Reader14443ACodecTask+0x228>
    5a3e:	86 b1       	in	r24, 0x06	; 6
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5a40:	86 95       	lsr	r24
    5a42:	86 b9       	out	0x06, r24	; 6
    5a44:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5a46:	95 b1       	in	r25, 0x05	; 5
    5a48:	01 96       	adiw	r24, 0x01	; 1
    5a4a:	84 b9       	out	0x04, r24	; 4
    5a4c:	95 b9       	out	0x05, r25	; 5
    5a4e:	87 70       	andi	r24, 0x07	; 7
    5a50:	99 27       	eor	r25, r25
    5a52:	89 2b       	or	r24, r25
    5a54:	41 f4       	brne	.+16     	; 0x5a66 <Reader14443ACodecTask+0x226>
    5a56:	ea b1       	in	r30, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5a58:	fb b1       	in	r31, 0x0b	; 11
    5a5a:	cf 01       	movw	r24, r30
    5a5c:	01 96       	adiw	r24, 0x01	; 1
    5a5e:	8a b9       	out	0x0a, r24	; 10
    5a60:	9b b9       	out	0x0b, r25	; 11
    5a62:	86 b1       	in	r24, 0x06	; 6
    5a64:	80 83       	st	Z, r24
    5a66:	80 e0       	ldi	r24, 0x00	; 0

                // Manchester Code ISO14443-2 8.2.5
                while (!breakflag && BitCountTmp < TotalBitCount) {
                    uint8_t Bit = TmpCodecBuffer[BitCountTmp / 8] & 0x03;
                    TmpCodecBuffer[BitCountTmp / 8] >>= 2;
                    switch (Bit) {
    5a68:	2e 5f       	subi	r18, 0xFE	; 254

                        default:
                            // error, should not happen, TODO handle this
                            break;
                    }
                    BitCountTmp += 2;
    5a6a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a6c:	88 23       	and	r24, r24

                bool breakflag = false;
                TmpCodecBuffer[0] >>= 2; // with this (and BitCountTmp = 2), the SOC is ignored

                // Manchester Code ISO14443-2 8.2.5
                while (!breakflag && BitCountTmp < TotalBitCount) {
    5a6e:	39 f2       	breq	.-114    	; 0x59fe <Reader14443ACodecTask+0x1be>
    5a70:	84 b1       	in	r24, 0x04	; 4
                            // error, should not happen, TODO handle this
                            break;
                    }
                    BitCountTmp += 2;
                }
                if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    5a72:	95 b1       	in	r25, 0x05	; 5
    5a74:	87 70       	andi	r24, 0x07	; 7
    5a76:	99 27       	eor	r25, r25
    5a78:	89 2b       	or	r24, r25
    5a7a:	c9 f0       	breq	.+50     	; 0x5aae <Reader14443ACodecTask+0x26e>
    5a7c:	e4 b1       	in	r30, 0x04	; 4
                    CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5a7e:	f5 b1       	in	r31, 0x05	; 5
    5a80:	86 b1       	in	r24, 0x06	; 6
    5a82:	44 b1       	in	r20, 0x04	; 4
    5a84:	55 b1       	in	r21, 0x05	; 5
    5a86:	73 e0       	ldi	r23, 0x03	; 3
    5a88:	f6 95       	lsr	r31
    5a8a:	e7 95       	ror	r30
    5a8c:	7a 95       	dec	r23
    5a8e:	e1 f7       	brne	.-8      	; 0x5a88 <Reader14443ACodecTask+0x248>
    5a90:	e3 5c       	subi	r30, 0xC3	; 195
    5a92:	fd 4c       	sbci	r31, 0xCD	; 205
    5a94:	90 e0       	ldi	r25, 0x00	; 0
    5a96:	47 70       	andi	r20, 0x07	; 7
    5a98:	55 27       	eor	r21, r21
    5a9a:	28 e0       	ldi	r18, 0x08	; 8
    5a9c:	30 e0       	ldi	r19, 0x00	; 0
    5a9e:	24 1b       	sub	r18, r20
    5aa0:	35 0b       	sbc	r19, r21
    5aa2:	02 c0       	rjmp	.+4      	; 0x5aa8 <Reader14443ACodecTask+0x268>
    5aa4:	95 95       	asr	r25
    5aa6:	87 95       	ror	r24
    5aa8:	2a 95       	dec	r18
    5aaa:	e2 f7       	brpl	.-8      	; 0x5aa4 <Reader14443ACodecTask+0x264>
    5aac:	80 83       	st	Z, r24
    5aae:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    5ab2:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    5ab6:	87 81       	ldd	r24, Z+7	; 0x07
    5ab8:	88 30       	cpi	r24, 0x08	; 8
    5aba:	19 f4       	brne	.+6      	; 0x5ac2 <Reader14443ACodecTask+0x282>
    5abc:	83 e1       	ldi	r24, 0x13	; 19
        LEDGreenAction = Action;
    5abe:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    5ac2:	86 81       	ldd	r24, Z+6	; 0x06
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    5ac4:	88 30       	cpi	r24, 0x08	; 8
    5ac6:	19 f4       	brne	.+6      	; 0x5ace <Reader14443ACodecTask+0x28e>
    5ac8:	83 e1       	ldi	r24, 0x13	; 19
        LEDRedAction = Action;
    5aca:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    5ace:	44 b1       	in	r20, 0x04	; 4
                LEDHook(LED_CODEC_RX, LED_PULSE);
                LogEntry(LOG_INFO_CODEC_RX_DATA_W_PARITY, CodecBuffer, (BitCount + 7) / 8);
    5ad0:	55 b1       	in	r21, 0x05	; 5
    5ad2:	49 5f       	subi	r20, 0xF9	; 249
    5ad4:	5f 4f       	sbci	r21, 0xFF	; 255
    5ad6:	63 e0       	ldi	r22, 0x03	; 3
    5ad8:	56 95       	lsr	r21
    5ada:	47 95       	ror	r20
    5adc:	6a 95       	dec	r22
    5ade:	e1 f7       	brne	.-8      	; 0x5ad8 <Reader14443ACodecTask+0x298>
    5ae0:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    5ae4:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    5ae8:	6d e3       	ldi	r22, 0x3D	; 61
    5aea:	72 e3       	ldi	r23, 0x32	; 50
    5aec:	82 e4       	ldi	r24, 0x42	; 66
    5aee:	19 95       	eicall
    5af0:	10 92 bc 2c 	sts	0x2CBC, r1	; 0x802cbc <Flags>
            }
        }
        Flags.Start = false;
    5af4:	10 92 bd 2c 	sts	0x2CBD, r1	; 0x802cbd <Flags+0x1>
        Flags.RxDone = false;
    5af8:	64 b1       	in	r22, 0x04	; 4

        /* Call application with received data */
        BitCount = ApplicationProcess(CodecBuffer, BitCount);
    5afa:	75 b1       	in	r23, 0x05	; 5
    5afc:	e0 91 cb 2f 	lds	r30, 0x2FCB	; 0x802fcb <ActiveConfiguration+0xe>
    5b00:	f0 91 cc 2f 	lds	r31, 0x2FCC	; 0x802fcc <ActiveConfiguration+0xf>
    5b04:	8d e3       	ldi	r24, 0x3D	; 61
    5b06:	92 e3       	ldi	r25, 0x32	; 50
    5b08:	19 95       	eicall
    5b0a:	84 b9       	out	0x04, r24	; 4
    5b0c:	95 b9       	out	0x05, r25	; 5
    5b0e:	84 b1       	in	r24, 0x04	; 4

        if (BitCount > 0) {
    5b10:	95 b1       	in	r25, 0x05	; 5
    5b12:	89 2b       	or	r24, r25
    5b14:	09 f4       	brne	.+2      	; 0x5b18 <Reader14443ACodecTask+0x2d8>
    5b16:	97 c1       	rjmp	.+814    	; 0x5e46 <Reader14443ACodecTask+0x606>
    5b18:	89 e8       	ldi	r24, 0x89	; 137
             * assume there is a pause. Now we read the second timers count value and can decide how many
             * bit halves had modulations since the last pause.
             */

            /* Configure and enable the analog comparator for finding pauses in the DEMOD signal. */
            ACA.AC1CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_ENABLE_bm;
    5b1a:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>
    5b1e:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>

            /* This timer will be used to detect the pauses between the modulation sequences. */
            CODEC_TIMER_LOADMOD.CTRLA = 0;
    5b22:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
            CODEC_TIMER_LOADMOD.CNT = 0;
    5b26:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
    5b2a:	2f ef       	ldi	r18, 0xFF	; 255
            CODEC_TIMER_LOADMOD.PER = 0xFFFF; // with 27.12 MHz this is exactly one half bit width
    5b2c:	3f ef       	ldi	r19, 0xFF	; 255
    5b2e:	20 93 26 0a 	sts	0x0A26, r18	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    5b32:	30 93 27 0a 	sts	0x0A27, r19	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    5b36:	8f e5       	ldi	r24, 0x5F	; 95
            CODEC_TIMER_LOADMOD.CCA = 95; // with 27.12 MHz this is 3/4 of a half bit width
    5b38:	90 e0       	ldi	r25, 0x00	; 0
    5b3a:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    5b3e:	90 93 29 0a 	sts	0x0A29, r25	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    5b42:	10 92 06 0a 	sts	0x0A06, r1	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>
            CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    5b46:	80 e1       	ldi	r24, 0x10	; 16
            CODEC_TIMER_LOADMOD.INTFLAGS = TC1_CCAIF_bm;
    5b48:	80 93 0c 0a 	sts	0x0A0C, r24	; 0x800a0c <__TEXT_REGION_LENGTH__+0x700a0c>
    5b4c:	93 e0       	ldi	r25, 0x03	; 3
            CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCAINTLVL_HI_gc;
    5b4e:	90 93 07 0a 	sts	0x0A07, r25	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    5b52:	10 92 60 09 	sts	0x0960, r1	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>

            /* This timer will be used to find out how many bit halfs since the last pause have been passed. */
            CODEC_TIMER_TIMESTAMPS.CNT = 0;
    5b56:	10 92 61 09 	sts	0x0961, r1	; 0x800961 <__TEXT_REGION_LENGTH__+0x700961>
    5b5a:	20 93 66 09 	sts	0x0966, r18	; 0x800966 <__TEXT_REGION_LENGTH__+0x700966>
            CODEC_TIMER_TIMESTAMPS.PER = 0xFFFF;
    5b5e:	30 93 67 09 	sts	0x0967, r19	; 0x800967 <__TEXT_REGION_LENGTH__+0x700967>
    5b62:	20 ea       	ldi	r18, 0xA0	; 160
            CODEC_TIMER_TIMESTAMPS.CCA = 160;
    5b64:	30 e0       	ldi	r19, 0x00	; 0
    5b66:	20 93 68 09 	sts	0x0968, r18	; 0x800968 <__TEXT_REGION_LENGTH__+0x700968>
    5b6a:	30 93 69 09 	sts	0x0969, r19	; 0x800969 <__TEXT_REGION_LENGTH__+0x700969>
    5b6e:	10 92 46 09 	sts	0x0946, r1	; 0x800946 <__TEXT_REGION_LENGTH__+0x700946>
            CODEC_TIMER_TIMESTAMPS.INTCTRLA = 0;
    5b72:	80 93 4c 09 	sts	0x094C, r24	; 0x80094c <__TEXT_REGION_LENGTH__+0x70094c>
            CODEC_TIMER_TIMESTAMPS.INTFLAGS = TC1_CCAIF_bm;
    5b76:	81 e0       	ldi	r24, 0x01	; 1
            CODEC_TIMER_TIMESTAMPS.INTCTRLB = TC_CCAINTLVL_LO_gc;
    5b78:	80 93 47 09 	sts	0x0947, r24	; 0x800947 <__TEXT_REGION_LENGTH__+0x700947>
    5b7c:	81 e1       	ldi	r24, 0x11	; 17

            /* Use the event system for resetting the pause-detecting timer. */
            EVSYS.CH0MUX = EVSYS_CHMUX_ACA_CH1_gc; // on every ACA_AC1 INT
    5b7e:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>
    5b82:	10 92 88 01 	sts	0x0188, r1	; 0x800188 <__TEXT_REGION_LENGTH__+0x700188>
            EVSYS.CH0CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
    5b86:	10 92 80 03 	sts	0x0380, r1	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>

            ACA.AC0CTRL = 0;
    5b8a:	10 92 29 06 	sts	0x0629, r1	; 0x800629 <__TEXT_REGION_LENGTH__+0x700629>
            CODEC_DEMOD_IN_PORT.INTCTRL = 0;
    5b8e:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    5b92:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    5b96:	87 81       	ldd	r24, Z+7	; 0x07
    5b98:	89 30       	cpi	r24, 0x09	; 9
    5b9a:	19 f4       	brne	.+6      	; 0x5ba2 <Reader14443ACodecTask+0x362>
    5b9c:	83 e1       	ldi	r24, 0x13	; 19
        LEDGreenAction = Action;
    5b9e:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    5ba2:	86 81       	ldd	r24, Z+6	; 0x06
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    5ba4:	89 30       	cpi	r24, 0x09	; 9
    5ba6:	19 f4       	brne	.+6      	; 0x5bae <Reader14443ACodecTask+0x36e>
    5ba8:	83 e1       	ldi	r24, 0x13	; 19
        LEDRedAction = Action;
    5baa:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    5bae:	44 b1       	in	r20, 0x04	; 4

            LEDHook(LED_CODEC_TX, LED_PULSE);
            LogEntry(LOG_INFO_CODEC_TX_DATA_W_PARITY, CodecBuffer, (BitCount + 7) / 8);
    5bb0:	55 b1       	in	r21, 0x05	; 5
    5bb2:	49 5f       	subi	r20, 0xF9	; 249
    5bb4:	5f 4f       	sbci	r21, 0xFF	; 255
    5bb6:	33 e0       	ldi	r19, 0x03	; 3
    5bb8:	56 95       	lsr	r21
    5bba:	47 95       	ror	r20
    5bbc:	3a 95       	dec	r19
    5bbe:	e1 f7       	brne	.-8      	; 0x5bb8 <Reader14443ACodecTask+0x378>
    5bc0:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    5bc4:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    5bc8:	6d e3       	ldi	r22, 0x3D	; 61
    5bca:	72 e3       	ldi	r23, 0x32	; 50
    5bcc:	83 e4       	ldi	r24, 0x43	; 67
    5bce:	19 95       	eicall
    5bd0:	04 b1       	in	r16, 0x04	; 4

    State = STATE_FDT;
}

INLINE void BufferToSequence(void) {
    uint16_t count = BitCount;
    5bd2:	15 b1       	in	r17, 0x05	; 5
    5bd4:	01 30       	cpi	r16, 0x01	; 1
    if (count > BITS_PER_BYTE * CODEC_BUFFER_SIZE / 2) // todo is this correct?
    5bd6:	94 e0       	ldi	r25, 0x04	; 4
    5bd8:	19 07       	cpc	r17, r25
    5bda:	08 f0       	brcs	.+2      	; 0x5bde <Reader14443ACodecTask+0x39e>
    5bdc:	24 c1       	rjmp	.+584    	; 0x5e26 <Reader14443ACodecTask+0x5e6>
    5bde:	14 b8       	out	0x04, r1	; 4
        return;

    BitCount = 0;
    5be0:	15 b8       	out	0x05, r1	; 5
    5be2:	a8 01       	movw	r20, r16

    memcpy(CodecBuffer + CODEC_BUFFER_SIZE / 2, CodecBuffer, (count + 7) / 8);
    5be4:	49 5f       	subi	r20, 0xF9	; 249
    5be6:	5f 4f       	sbci	r21, 0xFF	; 255
    5be8:	23 e0       	ldi	r18, 0x03	; 3
    5bea:	56 95       	lsr	r21
    5bec:	47 95       	ror	r20
    5bee:	2a 95       	dec	r18
    5bf0:	e1 f7       	brne	.-8      	; 0x5bea <Reader14443ACodecTask+0x3aa>
    5bf2:	6d e3       	ldi	r22, 0x3D	; 61
    5bf4:	72 e3       	ldi	r23, 0x32	; 50
    5bf6:	8d eb       	ldi	r24, 0xBD	; 189
    5bf8:	92 e3       	ldi	r25, 0x32	; 50
    5bfa:	0e 94 a0 78 	call	0xf140	; 0xf140 <memcpy>
    5bfe:	8d e3       	ldi	r24, 0x3D	; 61
    uint8_t *Buffer = CodecBuffer + CODEC_BUFFER_SIZE / 2;
    CodecBufferPtr = CodecBuffer;
    5c00:	92 e3       	ldi	r25, 0x32	; 50
    5c02:	8a b9       	out	0x0a, r24	; 10
    5c04:	9b b9       	out	0x0b, r25	; 11
    5c06:	86 b1       	in	r24, 0x06	; 6
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5c08:	86 95       	lsr	r24
    5c0a:	80 68       	ori	r24, 0x80	; 128
    5c0c:	86 b9       	out	0x06, r24	; 6
    5c0e:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5c10:	95 b1       	in	r25, 0x05	; 5
    5c12:	01 96       	adiw	r24, 0x01	; 1
    5c14:	84 b9       	out	0x04, r24	; 4
    5c16:	95 b9       	out	0x05, r25	; 5
    5c18:	87 70       	andi	r24, 0x07	; 7
    5c1a:	99 27       	eor	r25, r25
    5c1c:	89 2b       	or	r24, r25
    5c1e:	39 f4       	brne	.+14     	; 0x5c2e <Reader14443ACodecTask+0x3ee>
    5c20:	8e e3       	ldi	r24, 0x3E	; 62
        return;
    *CodecBufferPtr++ = SampleRegister;
    5c22:	92 e3       	ldi	r25, 0x32	; 50
    5c24:	8a b9       	out	0x0a, r24	; 10
    5c26:	9b b9       	out	0x0b, r25	; 11
    5c28:	86 b1       	in	r24, 0x06	; 6
    5c2a:	80 93 3d 32 	sts	0x323D, r24	; 0x80323d <CodecBuffer>
    5c2e:	86 b1       	in	r24, 0x06	; 6
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5c30:	86 95       	lsr	r24
    5c32:	86 b9       	out	0x06, r24	; 6
    5c34:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5c36:	95 b1       	in	r25, 0x05	; 5
    5c38:	01 96       	adiw	r24, 0x01	; 1
    5c3a:	84 b9       	out	0x04, r24	; 4
    5c3c:	95 b9       	out	0x05, r25	; 5
    5c3e:	87 70       	andi	r24, 0x07	; 7
    5c40:	99 27       	eor	r25, r25
    5c42:	89 2b       	or	r24, r25
    5c44:	41 f4       	brne	.+16     	; 0x5c56 <Reader14443ACodecTask+0x416>
    5c46:	ea b1       	in	r30, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5c48:	fb b1       	in	r31, 0x0b	; 11
    5c4a:	cf 01       	movw	r24, r30
    5c4c:	01 96       	adiw	r24, 0x01	; 1
    5c4e:	8a b9       	out	0x0a, r24	; 10
    5c50:	9b b9       	out	0x0b, r25	; 11
    5c52:	86 b1       	in	r24, 0x06	; 6
    5c54:	80 83       	st	Z, r24
    5c56:	80 e0       	ldi	r24, 0x00	; 0
                Insert0();
            } else {
                Insert1();
                Insert0();
            }
            last = 0;
    5c58:	41 e0       	ldi	r20, 0x01	; 1
    5c5a:	50 e0       	ldi	r21, 0x00	; 0
    5c5c:	ed eb       	ldi	r30, 0xBD	; 189
    5c5e:	f2 e3       	ldi	r31, 0x32	; 50
    5c60:	04 17       	cp	r16, r20
    Insert1(); // SOC
    Insert0();

    uint16_t i;
    uint8_t last = 0;
    for (i = 1; i <= count; i++) {
    5c62:	15 07       	cpc	r17, r21
    5c64:	08 f4       	brcc	.+2      	; 0x5c68 <Reader14443ACodecTask+0x428>
    5c66:	95 c0       	rjmp	.+298    	; 0x5d92 <Reader14443ACodecTask+0x552>
    5c68:	90 81       	ld	r25, Z
        if ((*Buffer) & 1) {
    5c6a:	90 ff       	sbrs	r25, 0
    5c6c:	2b c0       	rjmp	.+86     	; 0x5cc4 <Reader14443ACodecTask+0x484>
    5c6e:	86 b1       	in	r24, 0x06	; 6
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5c70:	86 95       	lsr	r24
    5c72:	86 b9       	out	0x06, r24	; 6
    5c74:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5c76:	95 b1       	in	r25, 0x05	; 5
    5c78:	01 96       	adiw	r24, 0x01	; 1
    5c7a:	84 b9       	out	0x04, r24	; 4
    5c7c:	95 b9       	out	0x05, r25	; 5
    5c7e:	87 70       	andi	r24, 0x07	; 7
    5c80:	99 27       	eor	r25, r25
    5c82:	89 2b       	or	r24, r25
    5c84:	41 f4       	brne	.+16     	; 0x5c96 <Reader14443ACodecTask+0x456>
    5c86:	aa b1       	in	r26, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5c88:	bb b1       	in	r27, 0x0b	; 11
    5c8a:	cd 01       	movw	r24, r26
    5c8c:	01 96       	adiw	r24, 0x01	; 1
    5c8e:	8a b9       	out	0x0a, r24	; 10
    5c90:	9b b9       	out	0x0b, r25	; 11
    5c92:	86 b1       	in	r24, 0x06	; 6
    5c94:	8c 93       	st	X, r24
    5c96:	86 b1       	in	r24, 0x06	; 6
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5c98:	86 95       	lsr	r24
    5c9a:	80 68       	ori	r24, 0x80	; 128
    5c9c:	86 b9       	out	0x06, r24	; 6
    5c9e:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5ca0:	95 b1       	in	r25, 0x05	; 5
    5ca2:	01 96       	adiw	r24, 0x01	; 1
    5ca4:	84 b9       	out	0x04, r24	; 4
    5ca6:	95 b9       	out	0x05, r25	; 5
    5ca8:	87 70       	andi	r24, 0x07	; 7
    5caa:	99 27       	eor	r25, r25
    5cac:	89 2b       	or	r24, r25
    5cae:	09 f0       	breq	.+2      	; 0x5cb2 <Reader14443ACodecTask+0x472>
    5cb0:	63 c0       	rjmp	.+198    	; 0x5d78 <Reader14443ACodecTask+0x538>
    5cb2:	aa b1       	in	r26, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5cb4:	bb b1       	in	r27, 0x0b	; 11
    5cb6:	cd 01       	movw	r24, r26
    5cb8:	01 96       	adiw	r24, 0x01	; 1
    5cba:	8a b9       	out	0x0a, r24	; 10
    5cbc:	9b b9       	out	0x0b, r25	; 11
    5cbe:	86 b1       	in	r24, 0x06	; 6
    5cc0:	8c 93       	st	X, r24
    5cc2:	5a c0       	rjmp	.+180    	; 0x5d78 <Reader14443ACodecTask+0x538>
    5cc4:	88 23       	and	r24, r24
        if ((*Buffer) & 1) {
            Insert0();
            Insert1();
            last = 1;
        } else {
            if (last) {
    5cc6:	51 f1       	breq	.+84     	; 0x5d1c <Reader14443ACodecTask+0x4dc>
    5cc8:	86 b1       	in	r24, 0x06	; 6
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5cca:	86 95       	lsr	r24
    5ccc:	86 b9       	out	0x06, r24	; 6
    5cce:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5cd0:	95 b1       	in	r25, 0x05	; 5
    5cd2:	01 96       	adiw	r24, 0x01	; 1
    5cd4:	84 b9       	out	0x04, r24	; 4
    5cd6:	95 b9       	out	0x05, r25	; 5
    5cd8:	87 70       	andi	r24, 0x07	; 7
    5cda:	99 27       	eor	r25, r25
    5cdc:	89 2b       	or	r24, r25
    5cde:	41 f4       	brne	.+16     	; 0x5cf0 <Reader14443ACodecTask+0x4b0>
    5ce0:	aa b1       	in	r26, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5ce2:	bb b1       	in	r27, 0x0b	; 11
    5ce4:	cd 01       	movw	r24, r26
    5ce6:	01 96       	adiw	r24, 0x01	; 1
    5ce8:	8a b9       	out	0x0a, r24	; 10
    5cea:	9b b9       	out	0x0b, r25	; 11
    5cec:	86 b1       	in	r24, 0x06	; 6
    5cee:	8c 93       	st	X, r24
    5cf0:	86 b1       	in	r24, 0x06	; 6
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5cf2:	86 95       	lsr	r24
    5cf4:	86 b9       	out	0x06, r24	; 6
    5cf6:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5cf8:	95 b1       	in	r25, 0x05	; 5
    5cfa:	01 96       	adiw	r24, 0x01	; 1
    5cfc:	84 b9       	out	0x04, r24	; 4
    5cfe:	95 b9       	out	0x05, r25	; 5
    5d00:	87 70       	andi	r24, 0x07	; 7
    5d02:	99 27       	eor	r25, r25
    5d04:	89 2b       	or	r24, r25
    5d06:	41 f4       	brne	.+16     	; 0x5d18 <Reader14443ACodecTask+0x4d8>
    5d08:	aa b1       	in	r26, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5d0a:	bb b1       	in	r27, 0x0b	; 11
    5d0c:	cd 01       	movw	r24, r26
    5d0e:	01 96       	adiw	r24, 0x01	; 1
    5d10:	8a b9       	out	0x0a, r24	; 10
    5d12:	9b b9       	out	0x0b, r25	; 11
    5d14:	86 b1       	in	r24, 0x06	; 6
    5d16:	8c 93       	st	X, r24
    5d18:	80 e0       	ldi	r24, 0x00	; 0
                Insert0();
            } else {
                Insert1();
                Insert0();
            }
            last = 0;
    5d1a:	2f c0       	rjmp	.+94     	; 0x5d7a <Reader14443ACodecTask+0x53a>
    5d1c:	96 b1       	in	r25, 0x06	; 6
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5d1e:	96 95       	lsr	r25
    5d20:	90 68       	ori	r25, 0x80	; 128
    5d22:	96 b9       	out	0x06, r25	; 6
    5d24:	24 b1       	in	r18, 0x04	; 4
    if (++BitCount % 8)
    5d26:	35 b1       	in	r19, 0x05	; 5
    5d28:	2f 5f       	subi	r18, 0xFF	; 255
    5d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    5d2c:	24 b9       	out	0x04, r18	; 4
    5d2e:	35 b9       	out	0x05, r19	; 5
    5d30:	27 70       	andi	r18, 0x07	; 7
    5d32:	33 27       	eor	r19, r19
    5d34:	23 2b       	or	r18, r19
    5d36:	49 f4       	brne	.+18     	; 0x5d4a <Reader14443ACodecTask+0x50a>
    5d38:	aa b1       	in	r26, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5d3a:	bb b1       	in	r27, 0x0b	; 11
    5d3c:	9d 01       	movw	r18, r26
    5d3e:	2f 5f       	subi	r18, 0xFF	; 255
    5d40:	3f 4f       	sbci	r19, 0xFF	; 255
    5d42:	2a b9       	out	0x0a, r18	; 10
    5d44:	3b b9       	out	0x0b, r19	; 11
    5d46:	96 b1       	in	r25, 0x06	; 6
    5d48:	9c 93       	st	X, r25
    5d4a:	96 b1       	in	r25, 0x06	; 6
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5d4c:	96 95       	lsr	r25
    5d4e:	96 b9       	out	0x06, r25	; 6
    5d50:	24 b1       	in	r18, 0x04	; 4
    if (++BitCount % 8)
    5d52:	35 b1       	in	r19, 0x05	; 5
    5d54:	2f 5f       	subi	r18, 0xFF	; 255
    5d56:	3f 4f       	sbci	r19, 0xFF	; 255
    5d58:	24 b9       	out	0x04, r18	; 4
    5d5a:	35 b9       	out	0x05, r19	; 5
    5d5c:	27 70       	andi	r18, 0x07	; 7
    5d5e:	33 27       	eor	r19, r19
    5d60:	23 2b       	or	r18, r19
    5d62:	d1 f6       	brne	.-76     	; 0x5d18 <Reader14443ACodecTask+0x4d8>
    5d64:	aa b1       	in	r26, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5d66:	bb b1       	in	r27, 0x0b	; 11
    5d68:	9d 01       	movw	r18, r26
    5d6a:	2f 5f       	subi	r18, 0xFF	; 255
    5d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    5d6e:	2a b9       	out	0x0a, r18	; 10
    5d70:	3b b9       	out	0x0b, r19	; 11
    5d72:	96 b1       	in	r25, 0x06	; 6
    5d74:	9c 93       	st	X, r25
    5d76:	01 c0       	rjmp	.+2      	; 0x5d7a <Reader14443ACodecTask+0x53a>
    5d78:	81 e0       	ldi	r24, 0x01	; 1
    uint8_t last = 0;
    for (i = 1; i <= count; i++) {
        if ((*Buffer) & 1) {
            Insert0();
            Insert1();
            last = 1;
    5d7a:	90 81       	ld	r25, Z
                Insert1();
                Insert0();
            }
            last = 0;
        }
        *Buffer >>= 1;
    5d7c:	96 95       	lsr	r25
    5d7e:	90 83       	st	Z, r25
    5d80:	9a 01       	movw	r18, r20
        if ((i % 8) == 0)
    5d82:	27 70       	andi	r18, 0x07	; 7
    5d84:	33 27       	eor	r19, r19
    5d86:	23 2b       	or	r18, r19
    5d88:	09 f4       	brne	.+2      	; 0x5d8c <Reader14443ACodecTask+0x54c>
    5d8a:	31 96       	adiw	r30, 0x01	; 1
            Buffer++;
    5d8c:	4f 5f       	subi	r20, 0xFF	; 255
    Insert1(); // SOC
    Insert0();

    uint16_t i;
    uint8_t last = 0;
    for (i = 1; i <= count; i++) {
    5d8e:	5f 4f       	sbci	r21, 0xFF	; 255
    5d90:	67 cf       	rjmp	.-306    	; 0x5c60 <Reader14443ACodecTask+0x420>
    5d92:	81 11       	cpse	r24, r1
        *Buffer >>= 1;
        if ((i % 8) == 0)
            Buffer++;
    }

    if (last == 0) { // EOC
    5d94:	29 c0       	rjmp	.+82     	; 0x5de8 <Reader14443ACodecTask+0x5a8>
    5d96:	86 b1       	in	r24, 0x06	; 6
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5d98:	86 95       	lsr	r24
    5d9a:	80 68       	ori	r24, 0x80	; 128
    5d9c:	86 b9       	out	0x06, r24	; 6
    5d9e:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5da0:	95 b1       	in	r25, 0x05	; 5
    5da2:	01 96       	adiw	r24, 0x01	; 1
    5da4:	84 b9       	out	0x04, r24	; 4
    5da6:	95 b9       	out	0x05, r25	; 5
    5da8:	87 70       	andi	r24, 0x07	; 7
    5daa:	99 27       	eor	r25, r25
    5dac:	89 2b       	or	r24, r25
    5dae:	41 f4       	brne	.+16     	; 0x5dc0 <Reader14443ACodecTask+0x580>
    5db0:	ea b1       	in	r30, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5db2:	fb b1       	in	r31, 0x0b	; 11
    5db4:	cf 01       	movw	r24, r30
    5db6:	01 96       	adiw	r24, 0x01	; 1
    5db8:	8a b9       	out	0x0a, r24	; 10
    5dba:	9b b9       	out	0x0b, r25	; 11
    5dbc:	86 b1       	in	r24, 0x06	; 6
    5dbe:	80 83       	st	Z, r24
    5dc0:	86 b1       	in	r24, 0x06	; 6
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5dc2:	86 95       	lsr	r24
    5dc4:	86 b9       	out	0x06, r24	; 6
    5dc6:	84 b1       	in	r24, 0x04	; 4
    if (++BitCount % 8)
    5dc8:	95 b1       	in	r25, 0x05	; 5
    5dca:	01 96       	adiw	r24, 0x01	; 1
    5dcc:	84 b9       	out	0x04, r24	; 4
    5dce:	95 b9       	out	0x05, r25	; 5
    5dd0:	87 70       	andi	r24, 0x07	; 7
    5dd2:	99 27       	eor	r25, r25
    5dd4:	89 2b       	or	r24, r25
    5dd6:	41 f4       	brne	.+16     	; 0x5de8 <Reader14443ACodecTask+0x5a8>
    5dd8:	ea b1       	in	r30, 0x0a	; 10
        return;
    *CodecBufferPtr++ = SampleRegister;
    5dda:	fb b1       	in	r31, 0x0b	; 11
    5ddc:	cf 01       	movw	r24, r30
    5dde:	01 96       	adiw	r24, 0x01	; 1
    5de0:	8a b9       	out	0x0a, r24	; 10
    5de2:	9b b9       	out	0x0b, r25	; 11
    5de4:	86 b1       	in	r24, 0x06	; 6
    5de6:	80 83       	st	Z, r24
    5de8:	84 b1       	in	r24, 0x04	; 4
    if (last == 0) { // EOC
        Insert1();
        Insert0();
    }

    if (BitCount % 8)
    5dea:	95 b1       	in	r25, 0x05	; 5
    5dec:	87 70       	andi	r24, 0x07	; 7
    5dee:	99 27       	eor	r25, r25
    5df0:	89 2b       	or	r24, r25
    5df2:	c9 f0       	breq	.+50     	; 0x5e26 <Reader14443ACodecTask+0x5e6>
    5df4:	e4 b1       	in	r30, 0x04	; 4
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5df6:	f5 b1       	in	r31, 0x05	; 5
    5df8:	86 b1       	in	r24, 0x06	; 6
    5dfa:	44 b1       	in	r20, 0x04	; 4
    5dfc:	55 b1       	in	r21, 0x05	; 5
    5dfe:	93 e0       	ldi	r25, 0x03	; 3
    5e00:	f6 95       	lsr	r31
    5e02:	e7 95       	ror	r30
    5e04:	9a 95       	dec	r25
    5e06:	e1 f7       	brne	.-8      	; 0x5e00 <Reader14443ACodecTask+0x5c0>
    5e08:	e3 5c       	subi	r30, 0xC3	; 195
    5e0a:	fd 4c       	sbci	r31, 0xCD	; 205
    5e0c:	90 e0       	ldi	r25, 0x00	; 0
    5e0e:	47 70       	andi	r20, 0x07	; 7
    5e10:	55 27       	eor	r21, r21
    5e12:	28 e0       	ldi	r18, 0x08	; 8
    5e14:	30 e0       	ldi	r19, 0x00	; 0
    5e16:	24 1b       	sub	r18, r20
    5e18:	35 0b       	sbc	r19, r21
    5e1a:	02 c0       	rjmp	.+4      	; 0x5e20 <Reader14443ACodecTask+0x5e0>
    5e1c:	95 95       	asr	r25
    5e1e:	87 95       	ror	r24
    5e20:	2a 95       	dec	r18
    5e22:	e2 f7       	brpl	.-8      	; 0x5e1c <Reader14443ACodecTask+0x5dc>
    5e24:	80 83       	st	Z, r24
    5e26:	81 e0       	ldi	r24, 0x01	; 1
            LogEntry(LOG_INFO_CODEC_TX_DATA_W_PARITY, CodecBuffer, (BitCount + 7) / 8);

            /* Set state and start timer for Miller encoding. */
            // Send bits to card using TCD0_CCB interrupt (See Reader14443-ISR.S)
            BufferToSequence();
            State = STATE_MILLER_SEND;
    5e28:	80 93 b9 2c 	sts	0x2CB9, r24	; 0x802cb9 <State>
    5e2c:	8d e3       	ldi	r24, 0x3D	; 61
            CodecBufferPtr = CodecBuffer;
    5e2e:	92 e3       	ldi	r25, 0x32	; 50
    5e30:	8a b9       	out	0x0a, r24	; 10
    5e32:	9b b9       	out	0x0b, r25	; 11
    5e34:	80 e2       	ldi	r24, 0x20	; 32
            CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCBIF_bm;
    5e36:	80 93 0c 09 	sts	0x090C, r24	; 0x80090c <__TEXT_REGION_LENGTH__+0x70090c>
    5e3a:	8c e0       	ldi	r24, 0x0C	; 12
            CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCBINTLVL_HI_gc;
    5e3c:	80 93 07 09 	sts	0x0907, r24	; 0x800907 <__TEXT_REGION_LENGTH__+0x700907>
    5e40:	85 e5       	ldi	r24, 0x55	; 85
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5e42:	8a 95       	dec	r24
    5e44:	f1 f7       	brne	.-4      	; 0x5e42 <Reader14443ACodecTask+0x602>
    5e46:	d3 95       	inc	r29
            _delay_loop_1(85);
        }
    }
}
    5e48:	cd bf       	out	0x3d, r28	; 61
    5e4a:	de bf       	out	0x3e, r29	; 62
    5e4c:	df 91       	pop	r29
    5e4e:	cf 91       	pop	r28
    5e50:	1f 91       	pop	r17
    5e52:	0f 91       	pop	r16
    5e54:	08 95       	ret

00005e56 <Reader14443ACodecStart>:
    5e56:	14 b8       	out	0x04, r1	; 4

void Reader14443ACodecStart(void) {
    /* Application wants us to start a card transaction */
    BitCount = 0;
    5e58:	15 b8       	out	0x05, r1	; 5
    Flags.Start = true;
    5e5a:	81 e0       	ldi	r24, 0x01	; 1
    5e5c:	80 93 bc 2c 	sts	0x2CBC, r24	; 0x802cbc <Flags>

    CodecReaderFieldStart();
    5e60:	0c 94 56 26 	jmp	0x4cac	; 0x4cac <CodecReaderFieldStart>

00005e64 <Reader14443ACodecReset>:
}


// End of Card-> reader communication and enter frame delay time
INLINE void Reader14443A_EOC(void) {
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5e64:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    5e68:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    5e6c:	10 92 47 09 	sts	0x0947, r1	; 0x800947 <__TEXT_REGION_LENGTH__+0x700947>
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    5e70:	10 92 40 09 	sts	0x0940, r1	; 0x800940 <__TEXT_REGION_LENGTH__+0x700940>
    ACA.AC1CTRL &= ~AC_ENABLE_bm;
    5e74:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>
    5e78:	8e 7f       	andi	r24, 0xFE	; 254
    5e7a:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>

    if (BitCount & 1) {
    5e7e:	84 b1       	in	r24, 0x04	; 4
    5e80:	95 b1       	in	r25, 0x05	; 5
    5e82:	80 ff       	sbrs	r24, 0
    5e84:	1a c0       	rjmp	.+52     	; 0x5eba <Reader14443ACodecReset+0x56>
        if (SampleRegister & 0x80)
    5e86:	37 9b       	sbis	0x06, 7	; 6
    5e88:	03 c0       	rjmp	.+6      	; 0x5e90 <Reader14443ACodecReset+0x2c>
    Flags.RxPending = false;
    Flags.Start = false;
}

INLINE void Insert0(void) {
    SampleRegister >>= 1;
    5e8a:	86 b1       	in	r24, 0x06	; 6
    5e8c:	86 95       	lsr	r24
    5e8e:	03 c0       	rjmp	.+6      	; 0x5e96 <Reader14443ACodecReset+0x32>
        return;
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void) {
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5e90:	86 b1       	in	r24, 0x06	; 6
    5e92:	86 95       	lsr	r24
    5e94:	80 68       	ori	r24, 0x80	; 128
    5e96:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5e98:	84 b1       	in	r24, 0x04	; 4
    5e9a:	95 b1       	in	r25, 0x05	; 5
    5e9c:	01 96       	adiw	r24, 0x01	; 1
    5e9e:	84 b9       	out	0x04, r24	; 4
    5ea0:	95 b9       	out	0x05, r25	; 5
    5ea2:	87 70       	andi	r24, 0x07	; 7
    5ea4:	99 27       	eor	r25, r25
    5ea6:	89 2b       	or	r24, r25
    5ea8:	41 f4       	brne	.+16     	; 0x5eba <Reader14443ACodecReset+0x56>
        return;
    *CodecBufferPtr++ = SampleRegister;
    5eaa:	ea b1       	in	r30, 0x0a	; 10
    5eac:	fb b1       	in	r31, 0x0b	; 11
    5eae:	cf 01       	movw	r24, r30
    5eb0:	01 96       	adiw	r24, 0x01	; 1
    5eb2:	8a b9       	out	0x0a, r24	; 10
    5eb4:	9b b9       	out	0x0b, r25	; 11
    5eb6:	86 b1       	in	r24, 0x06	; 6
    5eb8:	80 83       	st	Z, r24
            Insert0();
        else
            Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    5eba:	84 b1       	in	r24, 0x04	; 4
    5ebc:	95 b1       	in	r25, 0x05	; 5
    5ebe:	87 70       	andi	r24, 0x07	; 7
    5ec0:	99 27       	eor	r25, r25
    5ec2:	89 2b       	or	r24, r25
    5ec4:	c9 f0       	breq	.+50     	; 0x5ef8 <Reader14443ACodecReset+0x94>
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5ec6:	e4 b1       	in	r30, 0x04	; 4
    5ec8:	f5 b1       	in	r31, 0x05	; 5
    5eca:	86 b1       	in	r24, 0x06	; 6
    5ecc:	44 b1       	in	r20, 0x04	; 4
    5ece:	55 b1       	in	r21, 0x05	; 5
    5ed0:	93 e0       	ldi	r25, 0x03	; 3
    5ed2:	f6 95       	lsr	r31
    5ed4:	e7 95       	ror	r30
    5ed6:	9a 95       	dec	r25
    5ed8:	e1 f7       	brne	.-8      	; 0x5ed2 <Reader14443ACodecReset+0x6e>
    5eda:	e3 5c       	subi	r30, 0xC3	; 195
    5edc:	fd 4c       	sbci	r31, 0xCD	; 205
    5ede:	90 e0       	ldi	r25, 0x00	; 0
    5ee0:	47 70       	andi	r20, 0x07	; 7
    5ee2:	55 27       	eor	r21, r21
    5ee4:	28 e0       	ldi	r18, 0x08	; 8
    5ee6:	30 e0       	ldi	r19, 0x00	; 0
    5ee8:	24 1b       	sub	r18, r20
    5eea:	35 0b       	sbc	r19, r21
    5eec:	02 c0       	rjmp	.+4      	; 0x5ef2 <Reader14443ACodecReset+0x8e>
    5eee:	95 95       	asr	r25
    5ef0:	87 95       	ror	r24
    5ef2:	2a 95       	dec	r18
    5ef4:	e2 f7       	brpl	.-8      	; 0x5eee <Reader14443ACodecReset+0x8a>
    5ef6:	80 83       	st	Z, r24
    Flags.RxDone = true;
    5ef8:	81 e0       	ldi	r24, 0x01	; 1
    5efa:	80 93 bd 2c 	sts	0x2CBD, r24	; 0x802cbd <Flags+0x1>
    Flags.RxPending = false;
    5efe:	10 92 be 2c 	sts	0x2CBE, r1	; 0x802cbe <Flags+0x2>

    // set up timer that forces the minimum frame delay time from PICC to PCD
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    5f02:	8f ef       	ldi	r24, 0xFF	; 255
    5f04:	9f ef       	ldi	r25, 0xFF	; 255
    5f06:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    5f0a:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    CODEC_TIMER_LOADMOD.CNT = 0;
    5f0e:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
    5f12:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    5f16:	10 92 06 0a 	sts	0x0A06, r1	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5f1a:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    CODEC_TIMER_LOADMOD.CTRLD = 0;
    5f1e:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>
    CODEC_TIMER_LOADMOD.CTRLA = ISO14443A_PICC_TO_PCD_FDT_PRESCALER;
    5f22:	84 e0       	ldi	r24, 0x04	; 4
    5f24:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>

    State = STATE_FDT;
    5f28:	83 e0       	ldi	r24, 0x03	; 3
    5f2a:	80 93 b9 2c 	sts	0x2CB9, r24	; 0x802cb9 <State>
    CodecReaderFieldStart();
}

void Reader14443ACodecReset(void) {
    Reader14443A_EOC(); // this breaks every interrupt etc.
    State = STATE_IDLE;
    5f2e:	10 92 b9 2c 	sts	0x2CB9, r1	; 0x802cb9 <State>
    Flags.RxDone = false;
    5f32:	10 92 bd 2c 	sts	0x2CBD, r1	; 0x802cbd <Flags+0x1>
    Flags.Start = false;
    5f36:	10 92 bc 2c 	sts	0x2CBC, r1	; 0x802cbc <Flags>
    CodecReaderFieldStop();
    5f3a:	0c 94 7c 26 	jmp	0x4cf8	; 0x4cf8 <CodecReaderFieldStop>

00005f3e <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT>:
// according to the pause and modulated period
// if the half bit duration is modulated, then add 1 to buffer
// if the half bit duration is not modulated, then add 0 to buffer
//ISR(CODEC_TIMER_LOADMOD_CCB_VECT) // pause found
void isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT(void) {
    uint8_t tmp = CODEC_TIMER_TIMESTAMPS.CNTL;
    5f3e:	80 91 60 09 	lds	r24, 0x0960	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>
    CODEC_TIMER_TIMESTAMPS.CNT = 0;
    5f42:	10 92 60 09 	sts	0x0960, r1	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>
    5f46:	10 92 61 09 	sts	0x0961, r1	; 0x800961 <__TEXT_REGION_LENGTH__+0x700961>

    /* This needs to be done only on the first call,
     * but doing this only on a condition means wasting time, so we do it every time. */
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_DIV4_gc;
    5f4a:	93 e0       	ldi	r25, 0x03	; 3
    5f4c:	90 93 40 09 	sts	0x0940, r25	; 0x800940 <__TEXT_REGION_LENGTH__+0x700940>

    // Remember, LSB is send first
    // If current raw bit count is odd, then the previous raw bit must be 0
    switch (tmp) { // decide how many half bit periods have been modulations
    5f50:	81 35       	cpi	r24, 0x51	; 81
    5f52:	20 f4       	brcc	.+8      	; 0x5f5c <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x1e>
    5f54:	81 33       	cpi	r24, 0x31	; 49
    5f56:	08 f4       	brcc	.+2      	; 0x5f5a <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x1c>
    5f58:	a7 c0       	rjmp	.+334    	; 0x60a8 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x16a>
    5f5a:	03 c0       	rjmp	.+6      	; 0x5f62 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x24>
    5f5c:	81 37       	cpi	r24, 0x71	; 113
    5f5e:	58 f1       	brcs	.+86     	; 0x5fb6 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x78>
    5f60:	65 c0       	rjmp	.+202    	; 0x602c <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xee>
        case 0 ... 48: // 32 ticks is one half of a bit period
            return;

        case 49 ... 80: // 64 ticks are a full bit period
            // Got 01
            if (rawBitCount & 1) {
    5f62:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    5f66:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    5f6a:	80 ff       	sbrs	r24, 0
    5f6c:	0a c0       	rjmp	.+20     	; 0x5f82 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x44>
                // 01 + 0 -> 0 10
                // 10 -> 1, last 0 is ignored
                if (rawBitCount > 1) {
    5f6e:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    5f72:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    5f76:	02 97       	sbiw	r24, 0x02	; 2
    5f78:	c0 f0       	brcs	.+48     	; 0x5faa <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x6c>
        return;
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void) {
    CardSampleR = (CardSampleR >> 1) | 0x80;
    5f7a:	85 b1       	in	r24, 0x05	; 5
    5f7c:	86 95       	lsr	r24
    5f7e:	80 68       	ori	r24, 0x80	; 128
    5f80:	02 c0       	rjmp	.+4      	; 0x5f86 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x48>
}



INLINE void Insert0(void) {
    CardSampleR >>= 1;
    5f82:	85 b1       	in	r24, 0x05	; 5
    5f84:	86 95       	lsr	r24
    5f86:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5f88:	86 b1       	in	r24, 0x06	; 6
    5f8a:	97 b1       	in	r25, 0x07	; 7
    5f8c:	01 96       	adiw	r24, 0x01	; 1
    5f8e:	86 b9       	out	0x06, r24	; 6
    5f90:	97 b9       	out	0x07, r25	; 7
    5f92:	87 70       	andi	r24, 0x07	; 7
    5f94:	99 27       	eor	r25, r25
    5f96:	89 2b       	or	r24, r25
    5f98:	41 f4       	brne	.+16     	; 0x5faa <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x6c>
        return;
    *CardBufferPtr++ = CardSampleR;
    5f9a:	ec b1       	in	r30, 0x0c	; 12
    5f9c:	fd b1       	in	r31, 0x0d	; 13
    5f9e:	cf 01       	movw	r24, r30
    5fa0:	01 96       	adiw	r24, 0x01	; 1
    5fa2:	8c b9       	out	0x0c, r24	; 12
    5fa4:	9d b9       	out	0x0d, r25	; 13
    5fa6:	85 b1       	in	r24, 0x05	; 5
    5fa8:	80 83       	st	Z, r24
            } else {
                // Current sampled bit count is even, decode directly
                // 01 -> 0
                Insert0();
            }
            rawBitCount += 2;
    5faa:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    5fae:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    5fb2:	02 96       	adiw	r24, 0x02	; 2
    5fb4:	75 c0       	rjmp	.+234    	; 0x60a0 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x162>
            return;

        case 81 ... 112: // 96 ticks are 3 half bit periods
            if (rawBitCount & 1) {
    5fb6:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    5fba:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    5fbe:	80 ff       	sbrs	r24, 0
    5fc0:	1b c0       	rjmp	.+54     	; 0x5ff8 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xba>
                // Current sampled bit count is odd
                // Got 011
                // 011 + 0 -> 01 10 -> 01
                if (rawBitCount > 1) {
    5fc2:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    5fc6:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    5fca:	02 97       	sbiw	r24, 0x02	; 2
    5fcc:	a8 f0       	brcs	.+42     	; 0x5ff8 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xba>
        return;
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void) {
    CardSampleR = (CardSampleR >> 1) | 0x80;
    5fce:	85 b1       	in	r24, 0x05	; 5
    5fd0:	86 95       	lsr	r24
    5fd2:	80 68       	ori	r24, 0x80	; 128
    5fd4:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5fd6:	86 b1       	in	r24, 0x06	; 6
    5fd8:	97 b1       	in	r25, 0x07	; 7
    5fda:	01 96       	adiw	r24, 0x01	; 1
    5fdc:	86 b9       	out	0x06, r24	; 6
    5fde:	97 b9       	out	0x07, r25	; 7
    5fe0:	87 70       	andi	r24, 0x07	; 7
    5fe2:	99 27       	eor	r25, r25
    5fe4:	89 2b       	or	r24, r25
    5fe6:	41 f4       	brne	.+16     	; 0x5ff8 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xba>
        return;
    *CardBufferPtr++ = CardSampleR;
    5fe8:	ec b1       	in	r30, 0x0c	; 12
    5fea:	fd b1       	in	r31, 0x0d	; 13
    5fec:	cf 01       	movw	r24, r30
    5fee:	01 96       	adiw	r24, 0x01	; 1
    5ff0:	8c b9       	out	0x0c, r24	; 12
    5ff2:	9d b9       	out	0x0d, r25	; 13
    5ff4:	85 b1       	in	r24, 0x05	; 5
    5ff6:	80 83       	st	Z, r24
}



INLINE void Insert0(void) {
    CardSampleR >>= 1;
    5ff8:	85 b1       	in	r24, 0x05	; 5
    5ffa:	86 95       	lsr	r24
    5ffc:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5ffe:	86 b1       	in	r24, 0x06	; 6
    6000:	97 b1       	in	r25, 0x07	; 7
    6002:	01 96       	adiw	r24, 0x01	; 1
    6004:	86 b9       	out	0x06, r24	; 6
    6006:	97 b9       	out	0x07, r25	; 7
    6008:	87 70       	andi	r24, 0x07	; 7
    600a:	99 27       	eor	r25, r25
    600c:	89 2b       	or	r24, r25
    600e:	41 f4       	brne	.+16     	; 0x6020 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xe2>
        return;
    *CardBufferPtr++ = CardSampleR;
    6010:	ec b1       	in	r30, 0x0c	; 12
    6012:	fd b1       	in	r31, 0x0d	; 13
    6014:	cf 01       	movw	r24, r30
    6016:	01 96       	adiw	r24, 0x01	; 1
    6018:	8c b9       	out	0x0c, r24	; 12
    601a:	9d b9       	out	0x0d, r25	; 13
    601c:	85 b1       	in	r24, 0x05	; 5
    601e:	80 83       	st	Z, r24
                // Got 001
                // 001 -> 0 01, The last 0 is ignored
                // 01 -> 0
                Insert0();
            }
            rawBitCount += 3;
    6020:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    6024:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    6028:	03 96       	adiw	r24, 0x03	; 3
    602a:	3a c0       	rjmp	.+116    	; 0x60a0 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x162>

            return;

        default: // every value over 96 + 16 (tolerance) is considered to be 4 half bit periods
            // Got 00 11
            if (rawBitCount & 1) {
    602c:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    6030:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    6034:	80 ff       	sbrs	r24, 0
    6036:	2f c0       	rjmp	.+94     	; 0x6096 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x158>
                // 00 11 + 0 -> 0 01 10
                // 01 -> 0, 10 -> 1, Ignore last 0
                if (rawBitCount > 1) {
    6038:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    603c:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    6040:	02 97       	sbiw	r24, 0x02	; 2
    6042:	a8 f0       	brcs	.+42     	; 0x606e <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x130>
        return;
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void) {
    CardSampleR = (CardSampleR >> 1) | 0x80;
    6044:	85 b1       	in	r24, 0x05	; 5
    6046:	86 95       	lsr	r24
    6048:	80 68       	ori	r24, 0x80	; 128
    604a:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    604c:	86 b1       	in	r24, 0x06	; 6
    604e:	97 b1       	in	r25, 0x07	; 7
    6050:	01 96       	adiw	r24, 0x01	; 1
    6052:	86 b9       	out	0x06, r24	; 6
    6054:	97 b9       	out	0x07, r25	; 7
    6056:	87 70       	andi	r24, 0x07	; 7
    6058:	99 27       	eor	r25, r25
    605a:	89 2b       	or	r24, r25
    605c:	41 f4       	brne	.+16     	; 0x606e <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x130>
        return;
    *CardBufferPtr++ = CardSampleR;
    605e:	ec b1       	in	r30, 0x0c	; 12
    6060:	fd b1       	in	r31, 0x0d	; 13
    6062:	cf 01       	movw	r24, r30
    6064:	01 96       	adiw	r24, 0x01	; 1
    6066:	8c b9       	out	0x0c, r24	; 12
    6068:	9d b9       	out	0x0d, r25	; 13
    606a:	85 b1       	in	r24, 0x05	; 5
    606c:	80 83       	st	Z, r24
}



INLINE void Insert0(void) {
    CardSampleR >>= 1;
    606e:	85 b1       	in	r24, 0x05	; 5
    6070:	86 95       	lsr	r24
    6072:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    6074:	86 b1       	in	r24, 0x06	; 6
    6076:	97 b1       	in	r25, 0x07	; 7
    6078:	01 96       	adiw	r24, 0x01	; 1
    607a:	86 b9       	out	0x06, r24	; 6
    607c:	97 b9       	out	0x07, r25	; 7
    607e:	87 70       	andi	r24, 0x07	; 7
    6080:	99 27       	eor	r25, r25
    6082:	89 2b       	or	r24, r25
    6084:	41 f4       	brne	.+16     	; 0x6096 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x158>
        return;
    *CardBufferPtr++ = CardSampleR;
    6086:	ec b1       	in	r30, 0x0c	; 12
    6088:	fd b1       	in	r31, 0x0d	; 13
    608a:	cf 01       	movw	r24, r30
    608c:	01 96       	adiw	r24, 0x01	; 1
    608e:	8c b9       	out	0x0c, r24	; 12
    6090:	9d b9       	out	0x0d, r25	; 13
    6092:	85 b1       	in	r24, 0x05	; 5
    6094:	80 83       	st	Z, r24
            } else {
                // Should not happen
                // If modulation is correct,
                // there should not be a full bit period modulation in even bit count
            }
            rawBitCount += 4;
    6096:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    609a:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    609e:	04 96       	adiw	r24, 0x04	; 4
    60a0:	80 93 bf 2c 	sts	0x2CBF, r24	; 0x802cbf <rawBitCount>
    60a4:	90 93 c0 2c 	sts	0x2CC0, r25	; 0x802cc0 <rawBitCount+0x1>
    60a8:	08 95       	ret

000060aa <__vector_35>:
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
}


// Find first pause and start sampling
ISR(CODEC_DEMOD_IN_INT1_VECT) {
    60aa:	1f 92       	push	r1
    60ac:	0f 92       	push	r0
    60ae:	0f b6       	in	r0, 0x3f	; 63
    60b0:	0f 92       	push	r0
    60b2:	11 24       	eor	r1, r1
    60b4:	08 b6       	in	r0, 0x38	; 56
    60b6:	0f 92       	push	r0
    60b8:	18 be       	out	0x38, r1	; 56
    60ba:	0b b6       	in	r0, 0x3b	; 59
    60bc:	0f 92       	push	r0
    60be:	1b be       	out	0x3b, r1	; 59
    60c0:	8f 93       	push	r24
    60c2:	9f 93       	push	r25
    60c4:	ef 93       	push	r30
    60c6:	ff 93       	push	r31
    PORTE.OUTSET = PIN2_bm;
    60c8:	84 e0       	ldi	r24, 0x04	; 4
    60ca:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
     * XYZBUF mechanism of the xmega to automatically double the sampling rate on the
     * next overflow. For this we have to temporarily deactivate the automatical alignment
     * in order to catch next overflow event for updating the BUF registers.
     * We want to sample the demodulated data stream in the first quarter of the half-bit
     * where the pulsed miller encoded is located. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    60ce:	e0 e0       	ldi	r30, 0x00	; 0
    60d0:	f9 e0       	ldi	r31, 0x09	; 9
    60d2:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.PERBUF = SAMPLE_RATE_SYSTEM_CYCLES / 2 - 1; /* Half bit width */
    60d4:	8f e7       	ldi	r24, 0x7F	; 127
    60d6:	90 e0       	ldi	r25, 0x00	; 0
    60d8:	86 ab       	std	Z+54, r24	; 0x36
    60da:	97 ab       	std	Z+55, r25	; 0x37
    CODEC_TIMER_SAMPLING.CCDBUF = SAMPLE_RATE_SYSTEM_CYCLES / 8 - 14 - 1; /* Compensate for DIGFILT and ISR prolog */
    60dc:	81 e1       	ldi	r24, 0x11	; 17
    60de:	90 e0       	ldi	r25, 0x00	; 0
    60e0:	86 af       	std	Z+62, r24	; 0x3e
    60e2:	97 af       	std	Z+63, r25	; 0x3f

    /* Disable this interrupt */
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    60e4:	10 92 2b 06 	sts	0x062B, r1	; 0x80062b <__TEXT_REGION_LENGTH__+0x70062b>
}
    60e8:	ff 91       	pop	r31
    60ea:	ef 91       	pop	r30
    60ec:	9f 91       	pop	r25
    60ee:	8f 91       	pop	r24
    60f0:	0f 90       	pop	r0
    60f2:	0b be       	out	0x3b, r0	; 59
    60f4:	0f 90       	pop	r0
    60f6:	08 be       	out	0x38, r0	; 56
    60f8:	0f 90       	pop	r0
    60fa:	0f be       	out	0x3f, r0	; 63
    60fc:	0f 90       	pop	r0
    60fe:	1f 90       	pop	r1
    6100:	18 95       	reti

00006102 <__vector_82>:

// Sampling with timer and demod
ISR(CODEC_TIMER_SAMPLING_CCD_VECT) {
    6102:	1f 92       	push	r1
    6104:	0f 92       	push	r0
    6106:	0f b6       	in	r0, 0x3f	; 63
    6108:	0f 92       	push	r0
    610a:	11 24       	eor	r1, r1
    610c:	08 b6       	in	r0, 0x38	; 56
    610e:	0f 92       	push	r0
    6110:	18 be       	out	0x38, r1	; 56
    6112:	0b b6       	in	r0, 0x3b	; 59
    6114:	0f 92       	push	r0
    6116:	1b be       	out	0x3b, r1	; 59
    6118:	2f 93       	push	r18
    611a:	3f 93       	push	r19
    611c:	4f 93       	push	r20
    611e:	5f 93       	push	r21
    6120:	8f 93       	push	r24
    6122:	9f 93       	push	r25
    6124:	ef 93       	push	r30
    6126:	ff 93       	push	r31
    /* This interrupt gets called twice for every bit to sample it. */
    uint8_t SamplePin = CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK;
    6128:	20 91 28 06 	lds	r18, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>

    /* Shift sampled bit into sampling register */
    ReaderSampleR = (ReaderSampleR << 1) | (!SamplePin ? 0x01 : 0x00);
    612c:	94 b1       	in	r25, 0x04	; 4
    612e:	26 70       	andi	r18, 0x06	; 6
    6130:	81 e0       	ldi	r24, 0x01	; 1
    6132:	09 f0       	breq	.+2      	; 0x6136 <__vector_82+0x34>
    6134:	80 e0       	ldi	r24, 0x00	; 0
    6136:	99 0f       	add	r25, r25
    6138:	89 2b       	or	r24, r25
    613a:	84 b9       	out	0x04, r24	; 4

    if (SampleIdxRegister) {
    613c:	83 b1       	in	r24, 0x03	; 3
    613e:	88 23       	and	r24, r24
    6140:	09 f4       	brne	.+2      	; 0x6144 <__vector_82+0x42>
    6142:	e3 c0       	rjmp	.+454    	; 0x630a <__vector_82+0x208>
        SampleIdxRegister = 0;
    6144:	13 b8       	out	0x03, r1	; 3
        /* Analyze the sampling register after 2 samples. */
        if ((ReaderSampleR & 0x07) == 0x07) {
    6146:	84 b1       	in	r24, 0x04	; 4
    6148:	87 70       	andi	r24, 0x07	; 7
    614a:	87 30       	cpi	r24, 0x07	; 7
    614c:	09 f0       	breq	.+2      	; 0x6150 <__vector_82+0x4e>
    614e:	b5 c0       	rjmp	.+362    	; 0x62ba <__vector_82+0x1b8>
            /* No carrier modulation for 3 sample points. EOC! */

            // Shutdown the Reader->Card Sniffing,
            // disable the sampling timer
            PORTE.OUTCLR = PIN2_bm;
    6150:	84 e0       	ldi	r24, 0x04	; 4
    6152:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>



            CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    6156:	10 92 00 09 	sts	0x0900, r1	; 0x800900 <__TEXT_REGION_LENGTH__+0x700900>
            CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    615a:	80 e8       	ldi	r24, 0x80	; 128
    615c:	80 93 0c 09 	sts	0x090C, r24	; 0x80090c <__TEXT_REGION_LENGTH__+0x70090c>
            CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_OFF_gc;
    6160:	10 92 07 09 	sts	0x0907, r1	; 0x800907 <__TEXT_REGION_LENGTH__+0x700907>
            CODEC_DEMOD_IN_PORT.INTCTRL = 0;                        // Disable CODEC_DEMOD_IN_PORT interrupt
    6164:	10 92 29 06 	sts	0x0629, r1	; 0x800629 <__TEXT_REGION_LENGTH__+0x700629>
            // so no need to disable it again it here

            /* Determine if we did not receive a multiple of 8 bits.
             * If this is the case, right-align the remaining data and
             * store it into the buffer. */
            uint8_t RemainingBits = BitCount % 8;
    6168:	86 b1       	in	r24, 0x06	; 6
    616a:	97 b1       	in	r25, 0x07	; 7
    616c:	87 70       	andi	r24, 0x07	; 7
            if (RemainingBits != 0) {
    616e:	49 f0       	breq	.+18     	; 0x6182 <__vector_82+0x80>
                uint8_t NewDataRegister = DataRegister;
    6170:	90 b1       	in	r25, 0x00	; 0

                while (RemainingBits++ < 8) {
    6172:	8f 5f       	subi	r24, 0xFF	; 255
    6174:	89 30       	cpi	r24, 0x09	; 9
    6176:	11 f0       	breq	.+4      	; 0x617c <__vector_82+0x7a>
                    /* Pad with zeroes to right-align. */
                    NewDataRegister >>= 1;
    6178:	96 95       	lsr	r25
    617a:	fb cf       	rjmp	.-10     	; 0x6172 <__vector_82+0x70>
                }

                /* TODO: Prevent buffer overflow */
                *ReaderBufferPtr = NewDataRegister;
    617c:	e8 b1       	in	r30, 0x08	; 8
    617e:	f9 b1       	in	r31, 0x09	; 9
    6180:	90 83       	st	Z, r25
            }

            /* Signal, that we have finished sampling */
            ReaderBitCount = BitCount;
    6182:	86 b1       	in	r24, 0x06	; 6
    6184:	97 b1       	in	r25, 0x07	; 7
    6186:	80 93 c3 2c 	sts	0x2CC3, r24	; 0x802cc3 <ReaderBitCount>
    618a:	90 93 c4 2c 	sts	0x2CC4, r25	; 0x802cc4 <ReaderBitCount+0x1>

            // If we are have got data
            // Start Card->Reader Sniffing without waiting for the complete of CodecTask
            // Otherwise some bit will not be captured
            if (ReaderBitCount >= ISO14443A_MIN_BITS_PER_FRAME) {
    618e:	80 91 c3 2c 	lds	r24, 0x2CC3	; 0x802cc3 <ReaderBitCount>
    6192:	90 91 c4 2c 	lds	r25, 0x2CC4	; 0x802cc4 <ReaderBitCount+0x1>
    6196:	07 97       	sbiw	r24, 0x07	; 7
    6198:	08 f4       	brcc	.+2      	; 0x619c <__vector_82+0x9a>
    619a:	5c c0       	rjmp	.+184    	; 0x6254 <__vector_82+0x152>
                Flags.ReaderDataAvaliable = true;
    619c:	81 e0       	ldi	r24, 0x01	; 1
    619e:	80 93 c7 2c 	sts	0x2CC7, r24	; 0x802cc7 <Flags>
INLINE void CardSniffInit(void) {

    /* Initialize common peripherals and start listening
     * for incoming data. */

    CardBufferPtr = CodecBuffer2; // use GPIOR for faster access
    61a2:	2d e3       	ldi	r18, 0x3D	; 61
    61a4:	33 e3       	ldi	r19, 0x33	; 51
    61a6:	2c b9       	out	0x0c, r18	; 12
    61a8:	3d b9       	out	0x0d, r19	; 13
    rawBitCount = 1; // FALSCH todo the first modulation of the SOC is "found" implicitly
    61aa:	21 e0       	ldi	r18, 0x01	; 1
    61ac:	30 e0       	ldi	r19, 0x00	; 0
    61ae:	20 93 bf 2c 	sts	0x2CBF, r18	; 0x802cbf <rawBitCount>
    61b2:	30 93 c0 2c 	sts	0x2CC0, r19	; 0x802cc0 <rawBitCount+0x1>
    BitCount = 0;
    61b6:	16 b8       	out	0x06, r1	; 6
    61b8:	17 b8       	out	0x07, r1	; 7
    CardSampleR = 0x00;
    61ba:	15 b8       	out	0x05, r1	; 5
     * bit halves had modulations since the last pause.
     */

    // Comparator ADC
    /* Configure and enable the analog comparator for finding pauses in the DEMOD signal. */
    ACA.AC0CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_ENABLE_bm;
    61bc:	99 e8       	ldi	r25, 0x89	; 137
    61be:	90 93 80 03 	sts	0x0380, r25	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>

    /* This timer will be used to detect the pauses between the modulation sequences. */
    CODEC_TIMER_LOADMOD.CTRLA = 0;
    61c2:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_LOADMOD.CNT = 0;
    61c6:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
    61ca:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
    CODEC_TIMER_LOADMOD.PER = 0xFFFF; // with 27.12 MHz this is exactly one half bit width
    61ce:	4f ef       	ldi	r20, 0xFF	; 255
    61d0:	5f ef       	ldi	r21, 0xFF	; 255
    61d2:	40 93 26 0a 	sts	0x0A26, r20	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    61d6:	50 93 27 0a 	sts	0x0A27, r21	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    CODEC_TIMER_LOADMOD.CCB = 95; // with 27.12 MHz this is 3/4 of a half bit width
    61da:	2f e5       	ldi	r18, 0x5F	; 95
    61dc:	30 e0       	ldi	r19, 0x00	; 0
    61de:	20 93 2a 0a 	sts	0x0A2A, r18	; 0x800a2a <__TEXT_REGION_LENGTH__+0x700a2a>
    61e2:	30 93 2b 0a 	sts	0x0A2B, r19	; 0x800a2b <__TEXT_REGION_LENGTH__+0x700a2b>
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    61e6:	10 92 06 0a 	sts	0x0A06, r1	; 0x800a06 <__TEXT_REGION_LENGTH__+0x700a06>
    CODEC_TIMER_LOADMOD.INTFLAGS = TC1_CCBIF_bm;
    61ea:	20 e2       	ldi	r18, 0x20	; 32
    61ec:	20 93 0c 0a 	sts	0x0A0C, r18	; 0x800a0c <__TEXT_REGION_LENGTH__+0x700a0c>
    CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCBINTLVL_HI_gc;
    61f0:	9c e0       	ldi	r25, 0x0C	; 12
    61f2:	90 93 07 0a 	sts	0x0A07, r25	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>

    /* This timer will be used to find out how many bit halfs since the last pause have been passed. */
    CODEC_TIMER_TIMESTAMPS.CNT = 0;                         // Reset timer
    61f6:	10 92 60 09 	sts	0x0960, r1	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>
    61fa:	10 92 61 09 	sts	0x0961, r1	; 0x800961 <__TEXT_REGION_LENGTH__+0x700961>
    CODEC_TIMER_TIMESTAMPS.PER = 0xFFFF;
    61fe:	40 93 66 09 	sts	0x0966, r20	; 0x800966 <__TEXT_REGION_LENGTH__+0x700966>
    6202:	50 93 67 09 	sts	0x0967, r21	; 0x800967 <__TEXT_REGION_LENGTH__+0x700967>
    CODEC_TIMER_TIMESTAMPS.CCB = 160;
    6206:	40 ea       	ldi	r20, 0xA0	; 160
    6208:	50 e0       	ldi	r21, 0x00	; 0
    620a:	40 93 6a 09 	sts	0x096A, r20	; 0x80096a <__TEXT_REGION_LENGTH__+0x70096a>
    620e:	50 93 6b 09 	sts	0x096B, r21	; 0x80096b <__TEXT_REGION_LENGTH__+0x70096b>
    CODEC_TIMER_TIMESTAMPS.INTCTRLA = 0;
    6212:	10 92 46 09 	sts	0x0946, r1	; 0x800946 <__TEXT_REGION_LENGTH__+0x700946>
    CODEC_TIMER_TIMESTAMPS.INTFLAGS = TC1_CCBIF_bm;         // Clear interrupt flag
    6216:	20 93 4c 09 	sts	0x094C, r18	; 0x80094c <__TEXT_REGION_LENGTH__+0x70094c>
//    CODEC_TIMER_TIMESTAMPS.INTCTRLB = TC_CCBINTLVL_LO_gc;
    CODEC_TIMER_TIMESTAMPS.INTCTRLB = TC_CCBINTLVL_HI_gc;
    621a:	90 93 47 09 	sts	0x0947, r25	; 0x800947 <__TEXT_REGION_LENGTH__+0x700947>

    /* Use the event system for resetting the pause-detecting timer. */
    EVSYS.CH2MUX = EVSYS_CHMUX_ACA_CH0_gc; // on every ACA_AC0 INT
    621e:	90 e1       	ldi	r25, 0x10	; 16
    6220:	90 93 82 01 	sts	0x0182, r25	; 0x800182 <__TEXT_REGION_LENGTH__+0x700182>
    EVSYS.CH2CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
    6224:	10 92 8a 01 	sts	0x018A, r1	; 0x80018a <__TEXT_REGION_LENGTH__+0x70018a>

    /* Enable the AC interrupt, which either finds the SOC and then starts the pause-finding timer,
     * or it is triggered before the SOC, which mostly isn't bad at all, since the first pause
     * needs to be found. */
    ACA.AC1CTRL = 0;
    6228:	10 92 81 03 	sts	0x0381, r1	; 0x800381 <__TEXT_REGION_LENGTH__+0x700381>
    ACA.STATUS = AC_AC0IF_bm;
    622c:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <__TEXT_REGION_LENGTH__+0x700387>
    ACA.AC0CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_INTLVL_HI_gc | AC_ENABLE_bm;
    6230:	89 eb       	ldi	r24, 0xB9	; 185
    6232:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>
    6236:	2e b1       	in	r18, 0x0e	; 14
    6238:	3f b1       	in	r19, 0x0f	; 15
    623a:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    623e:	90 91 09 04 	lds	r25, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    6242:	82 2b       	or	r24, r18
    6244:	93 2b       	or	r25, r19

    RxPendingSince = SystemGetSysTick();
    6246:	80 93 c5 2c 	sts	0x2CC5, r24	; 0x802cc5 <RxPendingSince>
    624a:	90 93 c6 2c 	sts	0x2CC6, r25	; 0x802cc6 <RxPendingSince+0x1>
    StateRegister = PCD_PICC_FDT;
    624e:	82 e0       	ldi	r24, 0x02	; 2
    6250:	81 b9       	out	0x01, r24	; 1
    6252:	61 c0       	rjmp	.+194    	; 0x6316 <__vector_82+0x214>

INLINE void ReaderSniffInit(void) {
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    6254:	8c e0       	ldi	r24, 0x0C	; 12
    6256:	80 93 29 06 	sts	0x0629, r24	; 0x800629 <__TEXT_REGION_LENGTH__+0x700629>

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    625a:	8d e3       	ldi	r24, 0x3D	; 61
    625c:	92 e3       	ldi	r25, 0x32	; 50
    625e:	88 b9       	out	0x08, r24	; 8
    6260:	99 b9       	out	0x09, r25	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    6262:	8d eb       	ldi	r24, 0xBD	; 189
    6264:	92 e3       	ldi	r25, 0x32	; 50
    6266:	8a b9       	out	0x0a, r24	; 10
    6268:	9b b9       	out	0x0b, r25	; 11
    DataRegister = 0;
    626a:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    626c:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    626e:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    6270:	16 b8       	out	0x06, r1	; 6
    6272:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    6274:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    6276:	10 92 20 09 	sts	0x0920, r1	; 0x800920 <__TEXT_REGION_LENGTH__+0x700920>
    627a:	10 92 21 09 	sts	0x0921, r1	; 0x800921 <__TEXT_REGION_LENGTH__+0x700921>
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    627e:	8f ef       	ldi	r24, 0xFF	; 255
    6280:	90 e0       	ldi	r25, 0x00	; 0
    6282:	80 93 26 09 	sts	0x0926, r24	; 0x800926 <__TEXT_REGION_LENGTH__+0x700926>
    6286:	90 93 27 09 	sts	0x0927, r25	; 0x800927 <__TEXT_REGION_LENGTH__+0x700927>
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    628a:	8f ef       	ldi	r24, 0xFF	; 255
    628c:	9f ef       	ldi	r25, 0xFF	; 255
    628e:	80 93 2e 09 	sts	0x092E, r24	; 0x80092e <__TEXT_REGION_LENGTH__+0x70092e>
    6292:	90 93 2f 09 	sts	0x092F, r25	; 0x80092f <__TEXT_REGION_LENGTH__+0x70092f>
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    6296:	81 e0       	ldi	r24, 0x01	; 1
    6298:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <__TEXT_REGION_LENGTH__+0x700900>
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    629c:	88 e8       	ldi	r24, 0x88	; 136
    629e:	80 93 03 09 	sts	0x0903, r24	; 0x800903 <__TEXT_REGION_LENGTH__+0x700903>
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    62a2:	80 e8       	ldi	r24, 0x80	; 128
    62a4:	80 93 0c 09 	sts	0x090C, r24	; 0x80090c <__TEXT_REGION_LENGTH__+0x70090c>
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    62a8:	80 ec       	ldi	r24, 0xC0	; 192
    62aa:	80 93 07 09 	sts	0x0907, r24	; 0x800907 <__TEXT_REGION_LENGTH__+0x700907>

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    62ae:	82 e0       	ldi	r24, 0x02	; 2
    62b0:	80 93 2c 06 	sts	0x062C, r24	; 0x80062c <__TEXT_REGION_LENGTH__+0x70062c>
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    62b4:	80 93 2b 06 	sts	0x062B, r24	; 0x80062b <__TEXT_REGION_LENGTH__+0x70062b>
    62b8:	2e c0       	rjmp	.+92     	; 0x6316 <__vector_82+0x214>

            return;

        } else {
            /* Otherwise, we check the two sample bits from the bit before. */
            uint8_t BitSample = ReaderSampleR & 0xC;
    62ba:	84 b1       	in	r24, 0x04	; 4
            uint8_t Bit = 0;

            if (BitSample != (0x0 << 2)) {
    62bc:	98 2f       	mov	r25, r24
    62be:	9c 70       	andi	r25, 0x0C	; 12
    62c0:	39 f1       	breq	.+78     	; 0x6310 <__vector_82+0x20e>
                } else {
                    /* 10 sequence -> This is a one bit */
                    Bit = 1;
                }

                if (StateRegister == DEMOD_DATA_BIT) {
    62c2:	91 b1       	in	r25, 0x01	; 1
    62c4:	91 11       	cpse	r25, r1
    62c6:	1c c0       	rjmp	.+56     	; 0x6300 <__vector_82+0x1fe>
                    /* This is a data bit, so shift it into the data register and
                     * hold a local copy of it. */
                    uint8_t NewDataRegister = DataRegister >> 1;
    62c8:	20 b1       	in	r18, 0x00	; 0
    62ca:	26 95       	lsr	r18
                    NewDataRegister |= (Bit ? 0x80 : 0x00);
    62cc:	82 ff       	sbrs	r24, 2
    62ce:	02 c0       	rjmp	.+4      	; 0x62d4 <__vector_82+0x1d2>
    62d0:	80 e0       	ldi	r24, 0x00	; 0
    62d2:	01 c0       	rjmp	.+2      	; 0x62d6 <__vector_82+0x1d4>
    62d4:	80 e8       	ldi	r24, 0x80	; 128
    62d6:	28 2b       	or	r18, r24
                    DataRegister = NewDataRegister;
    62d8:	20 b9       	out	0x00, r18	; 0

                    /* Update bitcount */
                    uint16_t NewBitCount = ++BitCount;
    62da:	86 b1       	in	r24, 0x06	; 6
    62dc:	97 b1       	in	r25, 0x07	; 7
    62de:	01 96       	adiw	r24, 0x01	; 1
    62e0:	86 b9       	out	0x06, r24	; 6
    62e2:	97 b9       	out	0x07, r25	; 7
                    if ((NewBitCount & 0x07) == 0) {
    62e4:	87 70       	andi	r24, 0x07	; 7
    62e6:	99 27       	eor	r25, r25
    62e8:	89 2b       	or	r24, r25
    62ea:	91 f4       	brne	.+36     	; 0x6310 <__vector_82+0x20e>
                        /* We have reached a byte boundary! Store the data register. */
                        /* TODO: Prevent buffer overflow */
                        *ReaderBufferPtr++ = NewDataRegister;
    62ec:	e8 b1       	in	r30, 0x08	; 8
    62ee:	f9 b1       	in	r31, 0x09	; 9
    62f0:	cf 01       	movw	r24, r30
    62f2:	01 96       	adiw	r24, 0x01	; 1
    62f4:	88 b9       	out	0x08, r24	; 8
    62f6:	99 b9       	out	0x09, r25	; 9
    62f8:	20 83       	st	Z, r18

                        /* Store bit for determining FDT at EOC and enable parity
                         * handling on next bit. */
                        StateRegister = DEMOD_PARITY_BIT;
    62fa:	81 e0       	ldi	r24, 0x01	; 1
    62fc:	81 b9       	out	0x01, r24	; 1
    62fe:	08 c0       	rjmp	.+16     	; 0x6310 <__vector_82+0x20e>
                    }

                } else if (StateRegister == DEMOD_PARITY_BIT) {
    6300:	81 b1       	in	r24, 0x01	; 1
    6302:	81 30       	cpi	r24, 0x01	; 1
    6304:	29 f4       	brne	.+10     	; 0x6310 <__vector_82+0x20e>
                    /* This is a parity bit. Store it */
//                    *ParityBufferPtr++ = Bit;
                    StateRegister = DEMOD_DATA_BIT;
    6306:	11 b8       	out	0x01, r1	; 1
    6308:	03 c0       	rjmp	.+6      	; 0x6310 <__vector_82+0x20e>
                 * sampling and have sampled less than 2 bits yet. Thus ignore. */
            }
        }
    } else {
        /* On odd sample position just sample. */
        SampleIdxRegister = ~SampleIdxRegister;
    630a:	83 b1       	in	r24, 0x03	; 3
    630c:	80 95       	com	r24
    630e:	83 b9       	out	0x03, r24	; 3

    /* Make sure the sampling timer gets automatically aligned to the
     * modulation pauses by using the RESTART event.
     * This can be understood as a "poor mans PLL" and makes sure that we are
     * never too far out the bit-grid while sampling. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    6310:	88 e8       	ldi	r24, 0x88	; 136
    6312:	80 93 03 09 	sts	0x0903, r24	; 0x800903 <__TEXT_REGION_LENGTH__+0x700903>
}
    6316:	ff 91       	pop	r31
    6318:	ef 91       	pop	r30
    631a:	9f 91       	pop	r25
    631c:	8f 91       	pop	r24
    631e:	5f 91       	pop	r21
    6320:	4f 91       	pop	r20
    6322:	3f 91       	pop	r19
    6324:	2f 91       	pop	r18
    6326:	0f 90       	pop	r0
    6328:	0b be       	out	0x3b, r0	; 59
    632a:	0f 90       	pop	r0
    632c:	08 be       	out	0x38, r0	; 56
    632e:	0f 90       	pop	r0
    6330:	0f be       	out	0x3f, r0	; 63
    6332:	0f 90       	pop	r0
    6334:	1f 90       	pop	r1
    6336:	18 95       	reti

00006338 <__vector_68>:
        return;
    *CardBufferPtr++ = CardSampleR;
}

// This interrupt find Card -> Reader SOC
ISR(ACA_AC0_vect) { // this interrupt either finds the SOC or gets triggered before
    6338:	1f 92       	push	r1
    633a:	0f 92       	push	r0
    633c:	0f b6       	in	r0, 0x3f	; 63
    633e:	0f 92       	push	r0
    6340:	11 24       	eor	r1, r1
    6342:	08 b6       	in	r0, 0x38	; 56
    6344:	0f 92       	push	r0
    6346:	18 be       	out	0x38, r1	; 56
    6348:	0b b6       	in	r0, 0x3b	; 59
    634a:	0f 92       	push	r0
    634c:	1b be       	out	0x3b, r1	; 59
    634e:	8f 93       	push	r24
    6350:	ef 93       	push	r30
    6352:	ff 93       	push	r31

    ACA.AC0CTRL &= ~AC_INTLVL_HI_gc; // disable this interrupt
    6354:	e0 e8       	ldi	r30, 0x80	; 128
    6356:	f3 e0       	ldi	r31, 0x03	; 3
    6358:	80 81       	ld	r24, Z
    635a:	8f 7c       	andi	r24, 0xCF	; 207
    635c:	80 83       	st	Z, r24
    // enable the pause-finding timer
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | TC_EVSEL_CH2_gc;
    635e:	e0 e0       	ldi	r30, 0x00	; 0
    6360:	fa e0       	ldi	r31, 0x0A	; 10
    6362:	8a e8       	ldi	r24, 0x8A	; 138
    6364:	83 83       	std	Z+3, r24	; 0x03
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_DIV1_gc;
    6366:	81 e0       	ldi	r24, 0x01	; 1
    6368:	80 83       	st	Z, r24
    StateRegister = PICC_FRAME;
    636a:	83 e0       	ldi	r24, 0x03	; 3
    636c:	81 b9       	out	0x01, r24	; 1
}
    636e:	ff 91       	pop	r31
    6370:	ef 91       	pop	r30
    6372:	8f 91       	pop	r24
    6374:	0f 90       	pop	r0
    6376:	0b be       	out	0x3b, r0	; 59
    6378:	0f 90       	pop	r0
    637a:	08 be       	out	0x38, r0	; 56
    637c:	0f 90       	pop	r0
    637e:	0f be       	out	0x3f, r0	; 63
    6380:	0f 90       	pop	r0
    6382:	1f 90       	pop	r1
    6384:	18 95       	reti

00006386 <__vector_50>:

ISR(CODEC_TIMER_LOADMOD_CCB_VECT) { // pause found
    6386:	1f 92       	push	r1
    6388:	0f 92       	push	r0
    638a:	0f b6       	in	r0, 0x3f	; 63
    638c:	0f 92       	push	r0
    638e:	11 24       	eor	r1, r1
    6390:	08 b6       	in	r0, 0x38	; 56
    6392:	0f 92       	push	r0
    6394:	18 be       	out	0x38, r1	; 56
    6396:	09 b6       	in	r0, 0x39	; 57
    6398:	0f 92       	push	r0
    639a:	19 be       	out	0x39, r1	; 57
    639c:	0b b6       	in	r0, 0x3b	; 59
    639e:	0f 92       	push	r0
    63a0:	1b be       	out	0x3b, r1	; 59
    63a2:	2f 93       	push	r18
    63a4:	3f 93       	push	r19
    63a6:	4f 93       	push	r20
    63a8:	5f 93       	push	r21
    63aa:	6f 93       	push	r22
    63ac:	7f 93       	push	r23
    63ae:	8f 93       	push	r24
    63b0:	9f 93       	push	r25
    63b2:	af 93       	push	r26
    63b4:	bf 93       	push	r27
    63b6:	ef 93       	push	r30
    63b8:	ff 93       	push	r31
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT();
    63ba:	e0 91 b5 2e 	lds	r30, 0x2EB5	; 0x802eb5 <isr_func_CODEC_TIMER_LOADMOD_CCB_VECT>
    63be:	f0 91 b6 2e 	lds	r31, 0x2EB6	; 0x802eb6 <isr_func_CODEC_TIMER_LOADMOD_CCB_VECT+0x1>
    63c2:	19 95       	eicall
}
    63c4:	ff 91       	pop	r31
    63c6:	ef 91       	pop	r30
    63c8:	bf 91       	pop	r27
    63ca:	af 91       	pop	r26
    63cc:	9f 91       	pop	r25
    63ce:	8f 91       	pop	r24
    63d0:	7f 91       	pop	r23
    63d2:	6f 91       	pop	r22
    63d4:	5f 91       	pop	r21
    63d6:	4f 91       	pop	r20
    63d8:	3f 91       	pop	r19
    63da:	2f 91       	pop	r18
    63dc:	0f 90       	pop	r0
    63de:	0b be       	out	0x3b, r0	; 59
    63e0:	0f 90       	pop	r0
    63e2:	09 be       	out	0x39, r0	; 57
    63e4:	0f 90       	pop	r0
    63e6:	08 be       	out	0x38, r0	; 56
    63e8:	0f 90       	pop	r0
    63ea:	0f be       	out	0x3f, r0	; 63
    63ec:	0f 90       	pop	r0
    63ee:	1f 90       	pop	r1
    63f0:	18 95       	reti

000063f2 <__vector_86>:

            return;
    }
}
// EOC of Card->Reader found
ISR(CODEC_TIMER_TIMESTAMPS_CCB_VECT) { // EOC found
    63f2:	1f 92       	push	r1
    63f4:	0f 92       	push	r0
    63f6:	0f b6       	in	r0, 0x3f	; 63
    63f8:	0f 92       	push	r0
    63fa:	11 24       	eor	r1, r1
    63fc:	08 b6       	in	r0, 0x38	; 56
    63fe:	0f 92       	push	r0
    6400:	18 be       	out	0x38, r1	; 56
    6402:	0b b6       	in	r0, 0x3b	; 59
    6404:	0f 92       	push	r0
    6406:	1b be       	out	0x3b, r1	; 59
    6408:	2f 93       	push	r18
    640a:	3f 93       	push	r19
    640c:	4f 93       	push	r20
    640e:	5f 93       	push	r21
    6410:	8f 93       	push	r24
    6412:	9f 93       	push	r25
    6414:	ef 93       	push	r30
    6416:	ff 93       	push	r31

    // Disable LOADMOD Timer
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;               // Disable Interrupt
    6418:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;   // Disable Clock
    641c:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_LOADMOD.CTRLD = 0;                  // Disable connection to event channel
    6420:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>

    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    6424:	10 92 47 09 	sts	0x0947, r1	; 0x800947 <__TEXT_REGION_LENGTH__+0x700947>
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    6428:	10 92 40 09 	sts	0x0940, r1	; 0x800940 <__TEXT_REGION_LENGTH__+0x700940>
    ACA.AC0CTRL &= ~AC_ENABLE_bm;
    642c:	80 91 80 03 	lds	r24, 0x0380	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>
    6430:	8e 7f       	andi	r24, 0xFE	; 254
    6432:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>

    // If finished in odd sample count
    // There must been an incomplete decoded bit
    // Since only EOC is no modulation in full bit period, and previous raw bit must be 0
    // so the last not modulated bit must be 1
    if (rawBitCount & 1) {
    6436:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <rawBitCount>
    643a:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <rawBitCount+0x1>
    643e:	80 ff       	sbrs	r24, 0
    6440:	15 c0       	rjmp	.+42     	; 0x646c <__vector_86+0x7a>
        return;
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void) {
    CardSampleR = (CardSampleR >> 1) | 0x80;
    6442:	85 b1       	in	r24, 0x05	; 5
    6444:	86 95       	lsr	r24
    6446:	80 68       	ori	r24, 0x80	; 128
    6448:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    644a:	86 b1       	in	r24, 0x06	; 6
    644c:	97 b1       	in	r25, 0x07	; 7
    644e:	01 96       	adiw	r24, 0x01	; 1
    6450:	86 b9       	out	0x06, r24	; 6
    6452:	97 b9       	out	0x07, r25	; 7
    6454:	87 70       	andi	r24, 0x07	; 7
    6456:	99 27       	eor	r25, r25
    6458:	89 2b       	or	r24, r25
    645a:	41 f4       	brne	.+16     	; 0x646c <__vector_86+0x7a>
        return;
    *CardBufferPtr++ = CardSampleR;
    645c:	ec b1       	in	r30, 0x0c	; 12
    645e:	fd b1       	in	r31, 0x0d	; 13
    6460:	cf 01       	movw	r24, r30
    6462:	01 96       	adiw	r24, 0x01	; 1
    6464:	8c b9       	out	0x0c, r24	; 12
    6466:	9d b9       	out	0x0d, r25	; 13
    6468:	85 b1       	in	r24, 0x05	; 5
    646a:	80 83       	st	Z, r24
        // The previous raw bit must be 0
        // 1 + 0 -> 10 -> 1
        Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    646c:	86 b1       	in	r24, 0x06	; 6
    646e:	97 b1       	in	r25, 0x07	; 7
    6470:	87 70       	andi	r24, 0x07	; 7
    6472:	99 27       	eor	r25, r25
    6474:	89 2b       	or	r24, r25
    6476:	c9 f0       	breq	.+50     	; 0x64aa <__vector_86+0xb8>
        CodecBuffer2[BitCount / 8] = CardSampleR >> (8 - (BitCount % 8));
    6478:	e6 b1       	in	r30, 0x06	; 6
    647a:	f7 b1       	in	r31, 0x07	; 7
    647c:	85 b1       	in	r24, 0x05	; 5
    647e:	46 b1       	in	r20, 0x06	; 6
    6480:	57 b1       	in	r21, 0x07	; 7
    6482:	93 e0       	ldi	r25, 0x03	; 3
    6484:	f6 95       	lsr	r31
    6486:	e7 95       	ror	r30
    6488:	9a 95       	dec	r25
    648a:	e1 f7       	brne	.-8      	; 0x6484 <__vector_86+0x92>
    648c:	e3 5c       	subi	r30, 0xC3	; 195
    648e:	fc 4c       	sbci	r31, 0xCC	; 204
    6490:	90 e0       	ldi	r25, 0x00	; 0
    6492:	47 70       	andi	r20, 0x07	; 7
    6494:	55 27       	eor	r21, r21
    6496:	28 e0       	ldi	r18, 0x08	; 8
    6498:	30 e0       	ldi	r19, 0x00	; 0
    649a:	24 1b       	sub	r18, r20
    649c:	35 0b       	sbc	r19, r21
    649e:	02 c0       	rjmp	.+4      	; 0x64a4 <__vector_86+0xb2>
    64a0:	95 95       	asr	r25
    64a2:	87 95       	ror	r24
    64a4:	2a 95       	dec	r18
    64a6:	e2 f7       	brpl	.-8      	; 0x64a0 <__vector_86+0xae>
    64a8:	80 83       	st	Z, r24

    CardBitCount = BitCount;
    64aa:	86 b1       	in	r24, 0x06	; 6
    64ac:	97 b1       	in	r25, 0x07	; 7
    64ae:	80 93 c1 2c 	sts	0x2CC1, r24	; 0x802cc1 <CardBitCount>
    64b2:	90 93 c2 2c 	sts	0x2CC2, r25	; 0x802cc2 <CardBitCount+0x1>
    if (BitCount >= ISO14443A_RX_MINIMUM_BITCOUNT) {
    64b6:	86 b1       	in	r24, 0x06	; 6
    64b8:	97 b1       	in	r25, 0x07	; 7
    64ba:	04 97       	sbiw	r24, 0x04	; 4
    64bc:	18 f0       	brcs	.+6      	; 0x64c4 <__vector_86+0xd2>
        Flags.CardDataAvaliable = true;
    64be:	81 e0       	ldi	r24, 0x01	; 1
    64c0:	80 93 c8 2c 	sts	0x2CC8, r24	; 0x802cc8 <Flags+0x1>

}

INLINE void CardSniffDeinit(void) {

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    64c4:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    64c8:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>

    // Disable event system CH2
    EVSYS.CH2MUX = 0;
    64cc:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <__TEXT_REGION_LENGTH__+0x700182>
    EVSYS.CH2CTRL = 0;
    64d0:	10 92 8a 01 	sts	0x018A, r1	; 0x80018a <__TEXT_REGION_LENGTH__+0x70018a>
    // Reset ACA AC0 to default setting
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    64d4:	8c e3       	ldi	r24, 0x3C	; 60
    64d6:	80 93 82 03 	sts	0x0382, r24	; 0x800382 <__TEXT_REGION_LENGTH__+0x700382>
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    64da:	88 e0       	ldi	r24, 0x08	; 8
    64dc:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>

INLINE void ReaderSniffInit(void) {
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    64e0:	8c e0       	ldi	r24, 0x0C	; 12
    64e2:	80 93 29 06 	sts	0x0629, r24	; 0x800629 <__TEXT_REGION_LENGTH__+0x700629>

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    64e6:	8d e3       	ldi	r24, 0x3D	; 61
    64e8:	92 e3       	ldi	r25, 0x32	; 50
    64ea:	88 b9       	out	0x08, r24	; 8
    64ec:	99 b9       	out	0x09, r25	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    64ee:	8d eb       	ldi	r24, 0xBD	; 189
    64f0:	92 e3       	ldi	r25, 0x32	; 50
    64f2:	8a b9       	out	0x0a, r24	; 10
    64f4:	9b b9       	out	0x0b, r25	; 11
    DataRegister = 0;
    64f6:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    64f8:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    64fa:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    64fc:	16 b8       	out	0x06, r1	; 6
    64fe:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    6500:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    6502:	10 92 20 09 	sts	0x0920, r1	; 0x800920 <__TEXT_REGION_LENGTH__+0x700920>
    6506:	10 92 21 09 	sts	0x0921, r1	; 0x800921 <__TEXT_REGION_LENGTH__+0x700921>
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    650a:	8f ef       	ldi	r24, 0xFF	; 255
    650c:	90 e0       	ldi	r25, 0x00	; 0
    650e:	80 93 26 09 	sts	0x0926, r24	; 0x800926 <__TEXT_REGION_LENGTH__+0x700926>
    6512:	90 93 27 09 	sts	0x0927, r25	; 0x800927 <__TEXT_REGION_LENGTH__+0x700927>
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    6516:	8f ef       	ldi	r24, 0xFF	; 255
    6518:	9f ef       	ldi	r25, 0xFF	; 255
    651a:	80 93 2e 09 	sts	0x092E, r24	; 0x80092e <__TEXT_REGION_LENGTH__+0x70092e>
    651e:	90 93 2f 09 	sts	0x092F, r25	; 0x80092f <__TEXT_REGION_LENGTH__+0x70092f>
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    6522:	81 e0       	ldi	r24, 0x01	; 1
    6524:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <__TEXT_REGION_LENGTH__+0x700900>
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    6528:	88 e8       	ldi	r24, 0x88	; 136
    652a:	80 93 03 09 	sts	0x0903, r24	; 0x800903 <__TEXT_REGION_LENGTH__+0x700903>
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    652e:	80 e8       	ldi	r24, 0x80	; 128
    6530:	80 93 0c 09 	sts	0x090C, r24	; 0x80090c <__TEXT_REGION_LENGTH__+0x70090c>
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    6534:	80 ec       	ldi	r24, 0xC0	; 192
    6536:	80 93 07 09 	sts	0x0907, r24	; 0x800907 <__TEXT_REGION_LENGTH__+0x700907>

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    653a:	82 e0       	ldi	r24, 0x02	; 2
    653c:	80 93 2c 06 	sts	0x062C, r24	; 0x80062c <__TEXT_REGION_LENGTH__+0x70062c>
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    6540:	80 93 2b 06 	sts	0x062B, r24	; 0x80062b <__TEXT_REGION_LENGTH__+0x70062b>
    }

    CardSniffDeinit();
    ReaderSniffInit();

}
    6544:	ff 91       	pop	r31
    6546:	ef 91       	pop	r30
    6548:	9f 91       	pop	r25
    654a:	8f 91       	pop	r24
    654c:	5f 91       	pop	r21
    654e:	4f 91       	pop	r20
    6550:	3f 91       	pop	r19
    6552:	2f 91       	pop	r18
    6554:	0f 90       	pop	r0
    6556:	0b be       	out	0x3b, r0	; 59
    6558:	0f 90       	pop	r0
    655a:	08 be       	out	0x38, r0	; 56
    655c:	0f 90       	pop	r0
    655e:	0f be       	out	0x3f, r0	; 63
    6560:	0f 90       	pop	r0
    6562:	1f 90       	pop	r1
    6564:	18 95       	reti

00006566 <Sniff14443ACodecInit>:

/////////////////////////////////////////////////
// Init and deInit, task, functions for this codec
/////////////////////////////////////////////////

void Sniff14443ACodecInit(void) {
    6566:	cf 93       	push	r28
    6568:	df 93       	push	r29

    PORTE.DIRSET = PIN3_bm | PIN2_bm;
    656a:	4c e0       	ldi	r20, 0x0C	; 12
    656c:	40 93 81 06 	sts	0x0681, r20	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
INLINE void CodecInitCommon(void) {
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    6570:	a0 e4       	ldi	r26, 0x40	; 64
    6572:	b6 e0       	ldi	r27, 0x06	; 6
    6574:	52 96       	adiw	r26, 0x12	; 18
    6576:	1c 92       	st	X, r1
    6578:	52 97       	sbiw	r26, 0x12	; 18
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    657a:	84 e0       	ldi	r24, 0x04	; 4
    657c:	12 96       	adiw	r26, 0x02	; 2
    657e:	8c 93       	st	X, r24
    6580:	12 97       	sbiw	r26, 0x02	; 2
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    6582:	c0 e8       	ldi	r28, 0x80	; 128
    6584:	d1 e0       	ldi	r29, 0x01	; 1
    6586:	82 e6       	ldi	r24, 0x62	; 98
    6588:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    658a:	e0 e2       	ldi	r30, 0x20	; 32
    658c:	f6 e0       	ldi	r31, 0x06	; 6
    658e:	81 e0       	ldi	r24, 0x01	; 1
    6590:	86 83       	std	Z+6, r24	; 0x06
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    6592:	81 83       	std	Z+1, r24	; 0x01
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    6594:	96 e0       	ldi	r25, 0x06	; 6
    6596:	92 83       	std	Z+2, r25	; 0x02
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    6598:	81 8b       	std	Z+17, r24	; 0x11
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    659a:	92 e0       	ldi	r25, 0x02	; 2
    659c:	92 8b       	std	Z+18, r25	; 0x12
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    659e:	12 86       	std	Z+10, r1	; 0x0a
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    65a0:	13 86       	std	Z+11, r1	; 0x0b
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    65a2:	2f e0       	ldi	r18, 0x0F	; 15
    65a4:	21 87       	std	Z+9, r18	; 0x09
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    65a6:	29 e5       	ldi	r18, 0x59	; 89
    65a8:	28 83       	st	Y, r18
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    65aa:	3a e5       	ldi	r19, 0x5A	; 90
    65ac:	39 83       	std	Y+1, r19	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    65ae:	2a 83       	std	Y+2, r18	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    65b0:	20 e4       	ldi	r18, 0x40	; 64
    65b2:	11 96       	adiw	r26, 0x01	; 1
    65b4:	2c 93       	st	X, r18
    65b6:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    65b8:	16 96       	adiw	r26, 0x06	; 6
    65ba:	2c 93       	st	X, r18
    65bc:	16 97       	sbiw	r26, 0x06	; 6
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    65be:	c0 eb       	ldi	r28, 0xB0	; 176
    65c0:	d0 e0       	ldi	r29, 0x00	; 0
    65c2:	3a 81       	ldd	r19, Y+2	; 0x02
    65c4:	30 7f       	andi	r19, 0xF0	; 240
    65c6:	3a 83       	std	Y+2, r19	; 0x02
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    65c8:	3a 81       	ldd	r19, Y+2	; 0x02
    65ca:	32 60       	ori	r19, 0x02	; 2
    65cc:	3a 83       	std	Y+2, r19	; 0x02

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    65ce:	30 e3       	ldi	r19, 0x30	; 48
    65d0:	11 96       	adiw	r26, 0x01	; 1
    65d2:	3c 93       	st	X, r19
    65d4:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    65d6:	16 96       	adiw	r26, 0x06	; 6
    65d8:	3c 93       	st	X, r19
    65da:	16 97       	sbiw	r26, 0x06	; 6

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    65dc:	50 96       	adiw	r26, 0x10	; 16
    65de:	2c 93       	st	X, r18
    65e0:	50 97       	sbiw	r26, 0x10	; 16
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    65e2:	16 96       	adiw	r26, 0x06	; 6
    65e4:	8c 93       	st	X, r24
    65e6:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    65e8:	15 96       	adiw	r26, 0x05	; 5
    65ea:	9c 93       	st	X, r25
    65ec:	15 97       	sbiw	r26, 0x05	; 5
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    65ee:	23 e0       	ldi	r18, 0x03	; 3
    65f0:	11 96       	adiw	r26, 0x01	; 1
    65f2:	2c 93       	st	X, r18

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    65f4:	a0 e0       	ldi	r26, 0x00	; 0
    65f6:	b8 e0       	ldi	r27, 0x08	; 8
    65f8:	23 e1       	ldi	r18, 0x13	; 19
    65fa:	11 96       	adiw	r26, 0x01	; 1
    65fc:	2c 93       	st	X, r18
    65fe:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    6600:	61 e0       	ldi	r22, 0x01	; 1
    6602:	70 e0       	ldi	r23, 0x00	; 0
    6604:	96 96       	adiw	r26, 0x26	; 38
    6606:	6d 93       	st	X+, r22
    6608:	7c 93       	st	X, r23
    660a:	97 97       	sbiw	r26, 0x27	; 39
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    660c:	98 96       	adiw	r26, 0x28	; 40
    660e:	6d 93       	st	X+, r22
    6610:	7c 93       	st	X, r23
    6612:	99 97       	sbiw	r26, 0x29	; 41

    AWEXC.OUTOVEN = 0x00;
    6614:	a0 e8       	ldi	r26, 0x80	; 128
    6616:	b8 e0       	ldi	r27, 0x08	; 8
    6618:	1c 96       	adiw	r26, 0x0c	; 12
    661a:	1c 92       	st	X, r1
    661c:	1c 97       	sbiw	r26, 0x0c	; 12
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    661e:	2c 93       	st	X, r18

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    6620:	a0 e2       	ldi	r26, 0x20	; 32
    6622:	b3 e0       	ldi	r27, 0x03	; 3
    6624:	13 96       	adiw	r26, 0x03	; 3
    6626:	1c 92       	st	X, r1
    6628:	13 97       	sbiw	r26, 0x03	; 3
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    662a:	11 96       	adiw	r26, 0x01	; 1
    662c:	1c 92       	st	X, r1
    662e:	11 97       	sbiw	r26, 0x01	; 1
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    6630:	28 e0       	ldi	r18, 0x08	; 8
    6632:	12 96       	adiw	r26, 0x02	; 2
    6634:	2c 93       	st	X, r18
    6636:	12 97       	sbiw	r26, 0x02	; 2
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    6638:	31 e1       	ldi	r19, 0x11	; 17
    663a:	3c 93       	st	X, r19
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    663c:	c0 91 d9 2f 	lds	r28, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    6640:	d0 91 da 2f 	lds	r29, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    6644:	6a 85       	ldd	r22, Y+10	; 0x0a
    6646:	7b 85       	ldd	r23, Y+11	; 0x0b
    6648:	58 96       	adiw	r26, 0x18	; 24
    664a:	6d 93       	st	X+, r22
    664c:	7c 93       	st	X, r23
    664e:	59 97       	sbiw	r26, 0x19	; 25

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    6650:	a0 e8       	ldi	r26, 0x80	; 128
    6652:	b3 e0       	ldi	r27, 0x03	; 3
    6654:	3c e3       	ldi	r19, 0x3C	; 60
    6656:	12 96       	adiw	r26, 0x02	; 2
    6658:	3c 93       	st	X, r19
    665a:	12 97       	sbiw	r26, 0x02	; 2
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    665c:	2c 93       	st	X, r18

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    665e:	13 96       	adiw	r26, 0x03	; 3
    6660:	3c 93       	st	X, r19
    6662:	13 97       	sbiw	r26, 0x03	; 3
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    6664:	11 96       	adiw	r26, 0x01	; 1
    6666:	2c 93       	st	X, r18
    // Common Codec Register settings
    CodecInitCommon();
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT = &isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT;
    6668:	2f e9       	ldi	r18, 0x9F	; 159
    666a:	3f e2       	ldi	r19, 0x2F	; 47
    666c:	20 93 b5 2e 	sts	0x2EB5, r18	; 0x802eb5 <isr_func_CODEC_TIMER_LOADMOD_CCB_VECT>
    6670:	30 93 b6 2e 	sts	0x2EB6, r19	; 0x802eb6 <isr_func_CODEC_TIMER_LOADMOD_CCB_VECT+0x1>
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
}

INLINE void CodecSetDemodPower(bool bOnOff) {
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    6674:	85 83       	std	Z+5, r24	; 0x05
    // Enable demodulator power
    CodecSetDemodPower(true);

    // Start with sniffing Reader->Card direction traffic
    Flags.ReaderDataAvaliable = false;
    6676:	a7 ec       	ldi	r26, 0xC7	; 199
    6678:	bc e2       	ldi	r27, 0x2C	; 44
    667a:	1c 92       	st	X, r1
    Flags.CardDataAvaliable = false;
    667c:	11 96       	adiw	r26, 0x01	; 1
    667e:	1c 92       	st	X, r1

INLINE void ReaderSniffInit(void) {
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    6680:	41 87       	std	Z+9, r20	; 0x09

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    6682:	2d e3       	ldi	r18, 0x3D	; 61
    6684:	32 e3       	ldi	r19, 0x32	; 50
    6686:	28 b9       	out	0x08, r18	; 8
    6688:	39 b9       	out	0x09, r19	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    668a:	2d eb       	ldi	r18, 0xBD	; 189
    668c:	32 e3       	ldi	r19, 0x32	; 50
    668e:	2a b9       	out	0x0a, r18	; 10
    6690:	3b b9       	out	0x0b, r19	; 11
    DataRegister = 0;
    6692:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    6694:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    6696:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    6698:	16 b8       	out	0x06, r1	; 6
    669a:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    669c:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    669e:	a0 e0       	ldi	r26, 0x00	; 0
    66a0:	b9 e0       	ldi	r27, 0x09	; 9
    66a2:	90 96       	adiw	r26, 0x20	; 32
    66a4:	1d 92       	st	X+, r1
    66a6:	1c 92       	st	X, r1
    66a8:	91 97       	sbiw	r26, 0x21	; 33
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    66aa:	2f ef       	ldi	r18, 0xFF	; 255
    66ac:	30 e0       	ldi	r19, 0x00	; 0
    66ae:	96 96       	adiw	r26, 0x26	; 38
    66b0:	2d 93       	st	X+, r18
    66b2:	3c 93       	st	X, r19
    66b4:	97 97       	sbiw	r26, 0x27	; 39
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    66b6:	2f ef       	ldi	r18, 0xFF	; 255
    66b8:	3f ef       	ldi	r19, 0xFF	; 255
    66ba:	9e 96       	adiw	r26, 0x2e	; 46
    66bc:	2d 93       	st	X+, r18
    66be:	3c 93       	st	X, r19
    66c0:	9f 97       	sbiw	r26, 0x2f	; 47
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    66c2:	8c 93       	st	X, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    66c4:	88 e8       	ldi	r24, 0x88	; 136
    66c6:	13 96       	adiw	r26, 0x03	; 3
    66c8:	8c 93       	st	X, r24
    66ca:	13 97       	sbiw	r26, 0x03	; 3
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    66cc:	80 e8       	ldi	r24, 0x80	; 128
    66ce:	1c 96       	adiw	r26, 0x0c	; 12
    66d0:	8c 93       	st	X, r24
    66d2:	1c 97       	sbiw	r26, 0x0c	; 12
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    66d4:	80 ec       	ldi	r24, 0xC0	; 192
    66d6:	17 96       	adiw	r26, 0x07	; 7
    66d8:	8c 93       	st	X, r24

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    66da:	94 87       	std	Z+12, r25	; 0x0c
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    66dc:	93 87       	std	Z+11, r25	; 0x0b
    // Start with sniffing Reader->Card direction traffic
    Flags.ReaderDataAvaliable = false;
    Flags.CardDataAvaliable = false;

    ReaderSniffInit();
}
    66de:	df 91       	pop	r29
    66e0:	cf 91       	pop	r28
    66e2:	08 95       	ret

000066e4 <Sniff14443ACodecDeInit>:

}

INLINE void CardSniffDeinit(void) {

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    66e4:	e0 e0       	ldi	r30, 0x00	; 0
    66e6:	fa e0       	ldi	r31, 0x0A	; 10
    66e8:	10 82       	st	Z, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    66ea:	17 82       	std	Z+7, r1	; 0x07

    // Disable event system CH2
    EVSYS.CH2MUX = 0;
    66ec:	e0 e8       	ldi	r30, 0x80	; 128
    66ee:	f1 e0       	ldi	r31, 0x01	; 1
    66f0:	12 82       	std	Z+2, r1	; 0x02
    EVSYS.CH2CTRL = 0;
    66f2:	12 86       	std	Z+10, r1	; 0x0a
    // Reset ACA AC0 to default setting
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    66f4:	e0 e8       	ldi	r30, 0x80	; 128
    66f6:	f3 e0       	ldi	r31, 0x03	; 3
    66f8:	8c e3       	ldi	r24, 0x3C	; 60
    66fa:	82 83       	std	Z+2, r24	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    66fc:	88 e0       	ldi	r24, 0x08	; 8
    66fe:	80 83       	st	Z, r24
}
INLINE void ReaderSniffDeInit(void) {
//    PORTE.OUTCLR = PIN3_bm;

    /* Gracefully shutdown codec */
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    6700:	a0 e2       	ldi	r26, 0x20	; 32
    6702:	b6 e0       	ldi	r27, 0x06	; 6
    6704:	1b 96       	adiw	r26, 0x0b	; 11
    6706:	1c 92       	st	X, r1
    6708:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = 0;
    670a:	19 96       	adiw	r26, 0x09	; 9
    670c:	1c 92       	st	X, r1
    670e:	19 97       	sbiw	r26, 0x09	; 9

    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    6710:	e0 e0       	ldi	r30, 0x00	; 0
    6712:	f9 e0       	ldi	r31, 0x09	; 9
    6714:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    6716:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_OFF_gc;
    6718:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    671a:	80 e8       	ldi	r24, 0x80	; 128
    671c:	84 87       	std	Z+12, r24	; 0x0c
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    671e:	81 e0       	ldi	r24, 0x01	; 1
    6720:	16 96       	adiw	r26, 0x06	; 6
    6722:	8c 93       	st	X, r24
    6724:	08 95       	ret

00006726 <Sniff14443ACodecTask>:
    CodecSetDemodPower(false);
}


void Sniff14443ACodecTask(void) {
    PORTE.OUTSET = PIN3_bm;
    6726:	88 e0       	ldi	r24, 0x08	; 8
    6728:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    if (Flags.ReaderDataAvaliable) {
    672c:	80 91 c7 2c 	lds	r24, 0x2CC7	; 0x802cc7 <Flags>
    6730:	88 23       	and	r24, r24
    6732:	91 f1       	breq	.+100    	; 0x6798 <Sniff14443ACodecTask+0x72>
        Flags.ReaderDataAvaliable = false;
    6734:	10 92 c7 2c 	sts	0x2CC7, r1	; 0x802cc7 <Flags>

        LogEntry(LOG_INFO_CODEC_SNI_READER_DATA, CodecBuffer, (ReaderBitCount + 7) / 8);
    6738:	40 91 c3 2c 	lds	r20, 0x2CC3	; 0x802cc3 <ReaderBitCount>
    673c:	50 91 c4 2c 	lds	r21, 0x2CC4	; 0x802cc4 <ReaderBitCount+0x1>
    6740:	49 5f       	subi	r20, 0xF9	; 249
    6742:	5f 4f       	sbci	r21, 0xFF	; 255
    6744:	93 e0       	ldi	r25, 0x03	; 3
    6746:	56 95       	lsr	r21
    6748:	47 95       	ror	r20
    674a:	9a 95       	dec	r25
    674c:	e1 f7       	brne	.-8      	; 0x6746 <Sniff14443ACodecTask+0x20>
    674e:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    6752:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    6756:	6d e3       	ldi	r22, 0x3D	; 61
    6758:	72 e3       	ldi	r23, 0x32	; 50
    675a:	84 e4       	ldi	r24, 0x44	; 68
    675c:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    675e:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    6762:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    6766:	87 81       	ldd	r24, Z+7	; 0x07
    6768:	88 30       	cpi	r24, 0x08	; 8
    676a:	19 f4       	brne	.+6      	; 0x6772 <Sniff14443ACodecTask+0x4c>
        LEDGreenAction = Action;
    676c:	83 e1       	ldi	r24, 0x13	; 19
    676e:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    6772:	86 81       	ldd	r24, Z+6	; 0x06
    6774:	88 30       	cpi	r24, 0x08	; 8
    6776:	19 f4       	brne	.+6      	; 0x677e <Sniff14443ACodecTask+0x58>
        LEDRedAction = Action;
    6778:	83 e1       	ldi	r24, 0x13	; 19
    677a:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
        // Let the Application layer know where this data comes from
        LEDHook(LED_CODEC_RX, LED_PULSE);

        TrafficSource = TRAFFIC_READER;
    677e:	10 92 b4 2e 	sts	0x2EB4, r1	; 0x802eb4 <TrafficSource>
        ApplicationProcess(CodecBuffer, ReaderBitCount);
    6782:	60 91 c3 2c 	lds	r22, 0x2CC3	; 0x802cc3 <ReaderBitCount>
    6786:	70 91 c4 2c 	lds	r23, 0x2CC4	; 0x802cc4 <ReaderBitCount+0x1>
    678a:	e0 91 cb 2f 	lds	r30, 0x2FCB	; 0x802fcb <ActiveConfiguration+0xe>
    678e:	f0 91 cc 2f 	lds	r31, 0x2FCC	; 0x802fcc <ActiveConfiguration+0xf>
    6792:	8d e3       	ldi	r24, 0x3D	; 61
    6794:	92 e3       	ldi	r25, 0x32	; 50
    6796:	19 95       	eicall
    }


    if (Flags.CardDataAvaliable) {
    6798:	80 91 c8 2c 	lds	r24, 0x2CC8	; 0x802cc8 <Flags+0x1>
    679c:	88 23       	and	r24, r24
    679e:	99 f1       	breq	.+102    	; 0x6806 <Sniff14443ACodecTask+0xe0>
        Flags.CardDataAvaliable = false;
    67a0:	10 92 c8 2c 	sts	0x2CC8, r1	; 0x802cc8 <Flags+0x1>

//        CardBitCount = removeParityBits(CodecBuffer2,CardBitCount );
        LogEntry(LOG_INFO_CODEC_SNI_CARD_DATA_W_PARITY, CodecBuffer2, (CardBitCount + 7) / 8);
    67a4:	40 91 c1 2c 	lds	r20, 0x2CC1	; 0x802cc1 <CardBitCount>
    67a8:	50 91 c2 2c 	lds	r21, 0x2CC2	; 0x802cc2 <CardBitCount+0x1>
    67ac:	49 5f       	subi	r20, 0xF9	; 249
    67ae:	5f 4f       	sbci	r21, 0xFF	; 255
    67b0:	83 e0       	ldi	r24, 0x03	; 3
    67b2:	56 95       	lsr	r21
    67b4:	47 95       	ror	r20
    67b6:	8a 95       	dec	r24
    67b8:	e1 f7       	brne	.-8      	; 0x67b2 <Sniff14443ACodecTask+0x8c>
    67ba:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    67be:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    67c2:	6d e3       	ldi	r22, 0x3D	; 61
    67c4:	73 e3       	ldi	r23, 0x33	; 51
    67c6:	87 e4       	ldi	r24, 0x47	; 71
    67c8:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    67ca:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    67ce:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    67d2:	87 81       	ldd	r24, Z+7	; 0x07
    67d4:	88 30       	cpi	r24, 0x08	; 8
    67d6:	19 f4       	brne	.+6      	; 0x67de <Sniff14443ACodecTask+0xb8>
        LEDGreenAction = Action;
    67d8:	83 e1       	ldi	r24, 0x13	; 19
    67da:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    67de:	86 81       	ldd	r24, Z+6	; 0x06
    67e0:	88 30       	cpi	r24, 0x08	; 8
    67e2:	19 f4       	brne	.+6      	; 0x67ea <Sniff14443ACodecTask+0xc4>
        LEDRedAction = Action;
    67e4:	83 e1       	ldi	r24, 0x13	; 19
    67e6:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
        LEDHook(LED_CODEC_RX, LED_PULSE);

        // Let the Application layer know where this data comes from
        TrafficSource = TRAFFIC_CARD;
    67ea:	81 e0       	ldi	r24, 0x01	; 1
    67ec:	80 93 b4 2e 	sts	0x2EB4, r24	; 0x802eb4 <TrafficSource>
        ApplicationProcess(CodecBuffer2, CardBitCount);
    67f0:	60 91 c1 2c 	lds	r22, 0x2CC1	; 0x802cc1 <CardBitCount>
    67f4:	70 91 c2 2c 	lds	r23, 0x2CC2	; 0x802cc2 <CardBitCount+0x1>
    67f8:	e0 91 cb 2f 	lds	r30, 0x2FCB	; 0x802fcb <ActiveConfiguration+0xe>
    67fc:	f0 91 cc 2f 	lds	r31, 0x2FCC	; 0x802fcc <ActiveConfiguration+0xf>
    6800:	8d e3       	ldi	r24, 0x3D	; 61
    6802:	93 e3       	ldi	r25, 0x33	; 51
    6804:	19 95       	eicall
    }


    if (StateRegister == PCD_PICC_FDT && (SYSTICK_DIFF(RxPendingSince) > Reader_FWT)) {
    6806:	21 b1       	in	r18, 0x01	; 1
    6808:	22 30       	cpi	r18, 0x02	; 2
    680a:	09 f0       	breq	.+2      	; 0x680e <Sniff14443ACodecTask+0xe8>
    680c:	55 c0       	rjmp	.+170    	; 0x68b8 <Sniff14443ACodecTask+0x192>
    680e:	6e b1       	in	r22, 0x0e	; 14
    6810:	7f b1       	in	r23, 0x0f	; 15
    6812:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    6816:	90 91 09 04 	lds	r25, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
    681a:	40 91 c5 2c 	lds	r20, 0x2CC5	; 0x802cc5 <RxPendingSince>
    681e:	50 91 c6 2c 	lds	r21, 0x2CC6	; 0x802cc6 <RxPendingSince+0x1>
    6822:	86 2b       	or	r24, r22
    6824:	97 2b       	or	r25, r23
    6826:	84 1b       	sub	r24, r20
    6828:	95 0b       	sbc	r25, r21
    682a:	40 91 1e 20 	lds	r20, 0x201E	; 0x80201e <Reader_FWT>
    682e:	50 91 1f 20 	lds	r21, 0x201F	; 0x80201f <Reader_FWT+0x1>
    6832:	48 17       	cp	r20, r24
    6834:	59 07       	cpc	r21, r25
    6836:	08 f0       	brcs	.+2      	; 0x683a <Sniff14443ACodecTask+0x114>
    6838:	3f c0       	rjmp	.+126    	; 0x68b8 <Sniff14443ACodecTask+0x192>

}

INLINE void CardSniffDeinit(void) {

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    683a:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    683e:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>

    // Disable event system CH2
    EVSYS.CH2MUX = 0;
    6842:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <__TEXT_REGION_LENGTH__+0x700182>
    EVSYS.CH2CTRL = 0;
    6846:	10 92 8a 01 	sts	0x018A, r1	; 0x80018a <__TEXT_REGION_LENGTH__+0x70018a>
    // Reset ACA AC0 to default setting
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    684a:	8c e3       	ldi	r24, 0x3C	; 60
    684c:	80 93 82 03 	sts	0x0382, r24	; 0x800382 <__TEXT_REGION_LENGTH__+0x700382>
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    6850:	88 e0       	ldi	r24, 0x08	; 8
    6852:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <__TEXT_REGION_LENGTH__+0x700380>

INLINE void ReaderSniffInit(void) {
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    6856:	8c e0       	ldi	r24, 0x0C	; 12
    6858:	80 93 29 06 	sts	0x0629, r24	; 0x800629 <__TEXT_REGION_LENGTH__+0x700629>

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    685c:	8d e3       	ldi	r24, 0x3D	; 61
    685e:	92 e3       	ldi	r25, 0x32	; 50
    6860:	88 b9       	out	0x08, r24	; 8
    6862:	99 b9       	out	0x09, r25	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    6864:	8d eb       	ldi	r24, 0xBD	; 189
    6866:	92 e3       	ldi	r25, 0x32	; 50
    6868:	8a b9       	out	0x0a, r24	; 10
    686a:	9b b9       	out	0x0b, r25	; 11
    DataRegister = 0;
    686c:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    686e:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    6870:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    6872:	16 b8       	out	0x06, r1	; 6
    6874:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    6876:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    6878:	10 92 20 09 	sts	0x0920, r1	; 0x800920 <__TEXT_REGION_LENGTH__+0x700920>
    687c:	10 92 21 09 	sts	0x0921, r1	; 0x800921 <__TEXT_REGION_LENGTH__+0x700921>
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    6880:	8f ef       	ldi	r24, 0xFF	; 255
    6882:	90 e0       	ldi	r25, 0x00	; 0
    6884:	80 93 26 09 	sts	0x0926, r24	; 0x800926 <__TEXT_REGION_LENGTH__+0x700926>
    6888:	90 93 27 09 	sts	0x0927, r25	; 0x800927 <__TEXT_REGION_LENGTH__+0x700927>
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    688c:	8f ef       	ldi	r24, 0xFF	; 255
    688e:	9f ef       	ldi	r25, 0xFF	; 255
    6890:	80 93 2e 09 	sts	0x092E, r24	; 0x80092e <__TEXT_REGION_LENGTH__+0x70092e>
    6894:	90 93 2f 09 	sts	0x092F, r25	; 0x80092f <__TEXT_REGION_LENGTH__+0x70092f>
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    6898:	81 e0       	ldi	r24, 0x01	; 1
    689a:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <__TEXT_REGION_LENGTH__+0x700900>
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    689e:	88 e8       	ldi	r24, 0x88	; 136
    68a0:	80 93 03 09 	sts	0x0903, r24	; 0x800903 <__TEXT_REGION_LENGTH__+0x700903>
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    68a4:	80 e8       	ldi	r24, 0x80	; 128
    68a6:	80 93 0c 09 	sts	0x090C, r24	; 0x80090c <__TEXT_REGION_LENGTH__+0x70090c>
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    68aa:	80 ec       	ldi	r24, 0xC0	; 192
    68ac:	80 93 07 09 	sts	0x0907, r24	; 0x800907 <__TEXT_REGION_LENGTH__+0x700907>

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    68b0:	20 93 2c 06 	sts	0x062C, r18	; 0x80062c <__TEXT_REGION_LENGTH__+0x70062c>
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    68b4:	20 93 2b 06 	sts	0x062B, r18	; 0x80062b <__TEXT_REGION_LENGTH__+0x70062b>

    if (StateRegister == PCD_PICC_FDT && (SYSTICK_DIFF(RxPendingSince) > Reader_FWT)) {
        CardSniffDeinit();
        ReaderSniffInit();
    }
    PORTE.OUTCLR = PIN3_bm;
    68b8:	88 e0       	ldi	r24, 0x08	; 8
    68ba:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>
    68be:	08 95       	ret

000068c0 <VerifyAuthentication>:
}
void MifareUltralightAppTask(void) {

}

static bool VerifyAuthentication(uint8_t PageAddress) {
    68c0:	98 2f       	mov	r25, r24
    /* No authentication for EV0 cards; always pass */
    if (Flavor < UL_C) {
    68c2:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <Flavor>
    68c6:	88 23       	and	r24, r24
    68c8:	59 f0       	breq	.+22     	; 0x68e0 <VerifyAuthentication+0x20>
        return true;
    }
    /* If authenticated, no verification needed */
    if (Authenticated) {
    68ca:	80 91 eb 2c 	lds	r24, 0x2CEB	; 0x802ceb <Authenticated>
    68ce:	81 11       	cpse	r24, r1
    68d0:	08 c0       	rjmp	.+16     	; 0x68e2 <VerifyAuthentication+0x22>
        return true;
    }
    /* Otherwise, verify the accessed page is below the limit */
    return PageAddress < FirstAuthenticatedPage;
    68d2:	81 e0       	ldi	r24, 0x01	; 1
    68d4:	20 91 ea 2c 	lds	r18, 0x2CEA	; 0x802cea <FirstAuthenticatedPage>
    68d8:	92 17       	cp	r25, r18
    68da:	18 f0       	brcs	.+6      	; 0x68e2 <VerifyAuthentication+0x22>
    68dc:	80 e0       	ldi	r24, 0x00	; 0
    68de:	08 95       	ret
}

static bool VerifyAuthentication(uint8_t PageAddress) {
    /* No authentication for EV0 cards; always pass */
    if (Flavor < UL_C) {
        return true;
    68e0:	81 e0       	ldi	r24, 0x01	; 1
    if (Authenticated) {
        return true;
    }
    /* Otherwise, verify the accessed page is below the limit */
    return PageAddress < FirstAuthenticatedPage;
}
    68e2:	08 95       	ret

000068e4 <AppInitEV1Common>:
    FirstAuthenticatedPage = 0xFF;
    ReadAccessProtected = false;
    AppInitCommon();
}

static void AppInitEV1Common(void) {
    68e4:	0f 93       	push	r16
    68e6:	1f 93       	push	r17
    68e8:	cf 93       	push	r28
    68ea:	df 93       	push	r29
    68ec:	1f 92       	push	r1
    68ee:	cd b7       	in	r28, 0x3d	; 61
    68f0:	de b7       	in	r29, 0x3e	; 62
    uint8_t ConfigAreaAddress = PageCount * MIFARE_ULTRALIGHT_PAGE_SIZE - CONFIG_AREA_SIZE;
    68f2:	00 91 ee 2c 	lds	r16, 0x2CEE	; 0x802cee <PageCount>
    68f6:	00 0f       	add	r16, r16
    68f8:	00 0f       	add	r16, r16
    68fa:	00 51       	subi	r16, 0x10	; 16
    uint8_t Access;

    /* Set up the emulation flavor */
    Flavor = UL_EV1;
    68fc:	82 e0       	ldi	r24, 0x02	; 2
    68fe:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <Flavor>
    /* Fetch some of the configuration into RAM */
    MemoryReadBlock(&FirstAuthenticatedPage, ConfigAreaAddress + CONF_AUTH0_OFFSET, 1);
    6902:	10 e0       	ldi	r17, 0x00	; 0
    6904:	b8 01       	movw	r22, r16
    6906:	6d 5f       	subi	r22, 0xFD	; 253
    6908:	7f 4f       	sbci	r23, 0xFF	; 255
    690a:	41 e0       	ldi	r20, 0x01	; 1
    690c:	50 e0       	ldi	r21, 0x00	; 0
    690e:	8a ee       	ldi	r24, 0xEA	; 234
    6910:	9c e2       	ldi	r25, 0x2C	; 44
    6912:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    MemoryReadBlock(&Access, ConfigAreaAddress + CONF_ACCESS_OFFSET, 1);
    6916:	b8 01       	movw	r22, r16
    6918:	6c 5f       	subi	r22, 0xFC	; 252
    691a:	7f 4f       	sbci	r23, 0xFF	; 255
    691c:	41 e0       	ldi	r20, 0x01	; 1
    691e:	50 e0       	ldi	r21, 0x00	; 0
    6920:	ce 01       	movw	r24, r28
    6922:	01 96       	adiw	r24, 0x01	; 1
    6924:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    ReadAccessProtected = !!(Access & CONF_ACCESS_PROT);
    6928:	89 81       	ldd	r24, Y+1	; 0x01
    692a:	88 1f       	adc	r24, r24
    692c:	88 27       	eor	r24, r24
    692e:	88 1f       	adc	r24, r24
    6930:	80 93 e9 2c 	sts	0x2CE9, r24	; 0x802ce9 <ReadAccessProtected>
            RNDBBuff [6] == InMessage [5] &&
            RNDBBuff [7] == InMessage [6]);
}

static void AppInitCommon(void) {
    State = STATE_IDLE;
    6934:	81 e0       	ldi	r24, 0x01	; 1
    6936:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
    FromHalt = false;
    693a:	10 92 ef 2c 	sts	0x2CEF, r1	; 0x802cef <FromHalt>
    Authenticated = false;
    693e:	10 92 eb 2c 	sts	0x2CEB, r1	; 0x802ceb <Authenticated>
    ArmedForCompatWrite = false;
    6942:	10 92 ed 2c 	sts	0x2CED, r1	; 0x802ced <ArmedForCompatWrite>
    /* Fetch some of the configuration into RAM */
    MemoryReadBlock(&FirstAuthenticatedPage, ConfigAreaAddress + CONF_AUTH0_OFFSET, 1);
    MemoryReadBlock(&Access, ConfigAreaAddress + CONF_ACCESS_OFFSET, 1);
    ReadAccessProtected = !!(Access & CONF_ACCESS_PROT);
    AppInitCommon();
}
    6946:	0f 90       	pop	r0
    6948:	df 91       	pop	r29
    694a:	cf 91       	pop	r28
    694c:	1f 91       	pop	r17
    694e:	0f 91       	pop	r16
    6950:	08 95       	ret

00006952 <IncrementCounter>:
    }
    /* Otherwise, verify the accessed page is below the limit */
    return PageAddress < FirstAuthenticatedPage;
}

static bool IncrementCounter(uint8_t *IncrementValue) {
    6952:	0f 93       	push	r16
    6954:	1f 93       	push	r17
    6956:	cf 93       	push	r28
    6958:	df 93       	push	r29
    695a:	1f 92       	push	r1
    695c:	1f 92       	push	r1
    695e:	cd b7       	in	r28, 0x3d	; 61
    6960:	de b7       	in	r29, 0x3e	; 62
    6962:	8c 01       	movw	r16, r24
    uint16_t CounterValue;
    MemoryReadBlock(&CounterValue, MF_ULC_COUNTER_ADDRESS, 2);
    6964:	42 e0       	ldi	r20, 0x02	; 2
    6966:	50 e0       	ldi	r21, 0x00	; 0
    6968:	69 e2       	ldi	r22, 0x29	; 41
    696a:	70 e0       	ldi	r23, 0x00	; 0
    696c:	ce 01       	movw	r24, r28
    696e:	01 96       	adiw	r24, 0x01	; 1
    6970:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    if (CounterValue == 0) {
    6974:	29 81       	ldd	r18, Y+1	; 0x01
    6976:	3a 81       	ldd	r19, Y+2	; 0x02
    6978:	f8 01       	movw	r30, r16
    697a:	90 81       	ld	r25, Z
    697c:	21 15       	cp	r18, r1
    697e:	31 05       	cpc	r19, r1
    6980:	49 f4       	brne	.+18     	; 0x6994 <IncrementCounter+0x42>
        CounterValue = IncrementValue[0] + (IncrementValue[1] << 8);
    6982:	21 81       	ldd	r18, Z+1	; 0x01
    6984:	30 e0       	ldi	r19, 0x00	; 0
    6986:	32 2f       	mov	r19, r18
    6988:	22 27       	eor	r18, r18
    698a:	a9 01       	movw	r20, r18
    698c:	49 0f       	add	r20, r25
    698e:	51 1d       	adc	r21, r1
    6990:	ca 01       	movw	r24, r20
    6992:	0d c0       	rjmp	.+26     	; 0x69ae <IncrementCounter+0x5c>
        MemoryWriteBlock(&CounterValue, MF_ULC_COUNTER_ADDRESS, 2);
        return true;
    } else {
        IncrementValue[0] &= 0x0f;
    6994:	9f 70       	andi	r25, 0x0F	; 15
    6996:	f8 01       	movw	r30, r16
    6998:	90 83       	st	Z, r25
        if (IncrementValue[0] <= (0xffff - CounterValue)) {
    699a:	89 2f       	mov	r24, r25
    699c:	90 e0       	ldi	r25, 0x00	; 0
    699e:	a9 01       	movw	r20, r18
    69a0:	40 95       	com	r20
    69a2:	50 95       	com	r21
    69a4:	48 17       	cp	r20, r24
    69a6:	59 07       	cpc	r21, r25
    69a8:	70 f0       	brcs	.+28     	; 0x69c6 <IncrementCounter+0x74>
            CounterValue += IncrementValue[0];
    69aa:	82 0f       	add	r24, r18
    69ac:	93 1f       	adc	r25, r19
    69ae:	89 83       	std	Y+1, r24	; 0x01
    69b0:	9a 83       	std	Y+2, r25	; 0x02
            MemoryWriteBlock(&CounterValue, MF_ULC_COUNTER_ADDRESS, 2);
    69b2:	42 e0       	ldi	r20, 0x02	; 2
    69b4:	50 e0       	ldi	r21, 0x00	; 0
    69b6:	69 e2       	ldi	r22, 0x29	; 41
    69b8:	70 e0       	ldi	r23, 0x00	; 0
    69ba:	ce 01       	movw	r24, r28
    69bc:	01 96       	adiw	r24, 0x01	; 1
    69be:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
            return true;
    69c2:	81 e0       	ldi	r24, 0x01	; 1
    69c4:	01 c0       	rjmp	.+2      	; 0x69c8 <IncrementCounter+0x76>
        }
        return false;
    69c6:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    69c8:	0f 90       	pop	r0
    69ca:	0f 90       	pop	r0
    69cc:	df 91       	pop	r29
    69ce:	cf 91       	pop	r28
    69d0:	1f 91       	pop	r17
    69d2:	0f 91       	pop	r16
    69d4:	08 95       	ret

000069d6 <MifareUltralightCAppInit>:
    State = STATE_IDLE;
    FromHalt = false;
    Authenticated = false;
    ArmedForCompatWrite = false;
}
void MifareUltralightCAppInit(void) {
    69d6:	cf 93       	push	r28
    69d8:	df 93       	push	r29
    69da:	1f 92       	push	r1
    69dc:	cd b7       	in	r28, 0x3d	; 61
    69de:	de b7       	in	r29, 0x3e	; 62
    Flavor = UL_C;
    69e0:	81 e0       	ldi	r24, 0x01	; 1
    69e2:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <Flavor>
    uint8_t ReadAccessAddress = 0x2b * MIFARE_ULTRALIGHTC_PAGE_SIZE;
    uint8_t KeyAddress = 0x2c * MIFARE_ULTRALIGHTC_PAGE_SIZE;
    uint8_t Access;

    /*Get and rotate Keys*/
    MemoryReadBlock(TripleDesKey, KeyAddress, CRYPTO_2KTDEA_KEY_SIZE);
    69e6:	40 e1       	ldi	r20, 0x10	; 16
    69e8:	50 e0       	ldi	r21, 0x00	; 0
    69ea:	60 eb       	ldi	r22, 0xB0	; 176
    69ec:	70 e0       	ldi	r23, 0x00	; 0
    69ee:	89 ec       	ldi	r24, 0xC9	; 201
    69f0:	9c e2       	ldi	r25, 0x2C	; 44
    69f2:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
}
/* Keys are stored in little Endian Order but we need them in Big  */
static void rotateKey(uint8_t *Key) {
    uint8_t tmpstorage [8] ;
    tmpstorage [0] = Key[7];
    tmpstorage [1] = Key[6];
    69f6:	60 91 cf 2c 	lds	r22, 0x2CCF	; 0x802ccf <TripleDesKey+0x6>
    tmpstorage [2] = Key[5];
    69fa:	50 91 ce 2c 	lds	r21, 0x2CCE	; 0x802cce <TripleDesKey+0x5>
    tmpstorage [3] = Key[4];
    69fe:	40 91 cd 2c 	lds	r20, 0x2CCD	; 0x802ccd <TripleDesKey+0x4>
    tmpstorage [4] = Key[3];
    6a02:	30 91 cc 2c 	lds	r19, 0x2CCC	; 0x802ccc <TripleDesKey+0x3>
    tmpstorage [5] = Key[2];
    6a06:	20 91 cb 2c 	lds	r18, 0x2CCB	; 0x802ccb <TripleDesKey+0x2>
    tmpstorage [6] = Key[1];
    6a0a:	90 91 ca 2c 	lds	r25, 0x2CCA	; 0x802cca <TripleDesKey+0x1>
    tmpstorage [7] = Key[0];
    6a0e:	80 91 c9 2c 	lds	r24, 0x2CC9	; 0x802cc9 <TripleDesKey>
    memcpy(Key, tmpstorage, 8);
    6a12:	70 91 d0 2c 	lds	r23, 0x2CD0	; 0x802cd0 <TripleDesKey+0x7>
    6a16:	70 93 c9 2c 	sts	0x2CC9, r23	; 0x802cc9 <TripleDesKey>
    6a1a:	60 93 ca 2c 	sts	0x2CCA, r22	; 0x802cca <TripleDesKey+0x1>
    6a1e:	50 93 cb 2c 	sts	0x2CCB, r21	; 0x802ccb <TripleDesKey+0x2>
    6a22:	40 93 cc 2c 	sts	0x2CCC, r20	; 0x802ccc <TripleDesKey+0x3>
    6a26:	30 93 cd 2c 	sts	0x2CCD, r19	; 0x802ccd <TripleDesKey+0x4>
    6a2a:	20 93 ce 2c 	sts	0x2CCE, r18	; 0x802cce <TripleDesKey+0x5>
    6a2e:	90 93 cf 2c 	sts	0x2CCF, r25	; 0x802ccf <TripleDesKey+0x6>
    6a32:	80 93 d0 2c 	sts	0x2CD0, r24	; 0x802cd0 <TripleDesKey+0x7>
}
/* Keys are stored in little Endian Order but we need them in Big  */
static void rotateKey(uint8_t *Key) {
    uint8_t tmpstorage [8] ;
    tmpstorage [0] = Key[7];
    tmpstorage [1] = Key[6];
    6a36:	60 91 d7 2c 	lds	r22, 0x2CD7	; 0x802cd7 <TripleDesKey+0xe>
    tmpstorage [2] = Key[5];
    6a3a:	50 91 d6 2c 	lds	r21, 0x2CD6	; 0x802cd6 <TripleDesKey+0xd>
    tmpstorage [3] = Key[4];
    6a3e:	40 91 d5 2c 	lds	r20, 0x2CD5	; 0x802cd5 <TripleDesKey+0xc>
    tmpstorage [4] = Key[3];
    6a42:	30 91 d4 2c 	lds	r19, 0x2CD4	; 0x802cd4 <TripleDesKey+0xb>
    tmpstorage [5] = Key[2];
    6a46:	20 91 d3 2c 	lds	r18, 0x2CD3	; 0x802cd3 <TripleDesKey+0xa>
    tmpstorage [6] = Key[1];
    6a4a:	90 91 d2 2c 	lds	r25, 0x2CD2	; 0x802cd2 <TripleDesKey+0x9>
    tmpstorage [7] = Key[0];
    6a4e:	80 91 d1 2c 	lds	r24, 0x2CD1	; 0x802cd1 <TripleDesKey+0x8>
    memcpy(Key, tmpstorage, 8);
    6a52:	70 91 d8 2c 	lds	r23, 0x2CD8	; 0x802cd8 <TripleDesKey+0xf>
    6a56:	70 93 d1 2c 	sts	0x2CD1, r23	; 0x802cd1 <TripleDesKey+0x8>
    6a5a:	60 93 d2 2c 	sts	0x2CD2, r22	; 0x802cd2 <TripleDesKey+0x9>
    6a5e:	50 93 d3 2c 	sts	0x2CD3, r21	; 0x802cd3 <TripleDesKey+0xa>
    6a62:	40 93 d4 2c 	sts	0x2CD4, r20	; 0x802cd4 <TripleDesKey+0xb>
    6a66:	30 93 d5 2c 	sts	0x2CD5, r19	; 0x802cd5 <TripleDesKey+0xc>
    6a6a:	20 93 d6 2c 	sts	0x2CD6, r18	; 0x802cd6 <TripleDesKey+0xd>
    6a6e:	90 93 d7 2c 	sts	0x2CD7, r25	; 0x802cd7 <TripleDesKey+0xe>
    6a72:	80 93 d8 2c 	sts	0x2CD8, r24	; 0x802cd8 <TripleDesKey+0xf>
    /*Get and rotate Keys*/
    MemoryReadBlock(TripleDesKey, KeyAddress, CRYPTO_2KTDEA_KEY_SIZE);
    rotateKey(TripleDesKey);
    rotateKey(&TripleDesKey[8]);

    PageCount = MIFARE_ULTRALIGHTC_PAGES;
    6a76:	80 e3       	ldi	r24, 0x30	; 48
    6a78:	80 93 ee 2c 	sts	0x2CEE, r24	; 0x802cee <PageCount>

    MemoryReadBlock(&FirstAuthenticatedPage, AuthentificationAddress, 1);
    6a7c:	41 e0       	ldi	r20, 0x01	; 1
    6a7e:	50 e0       	ldi	r21, 0x00	; 0
    6a80:	68 ea       	ldi	r22, 0xA8	; 168
    6a82:	70 e0       	ldi	r23, 0x00	; 0
    6a84:	8a ee       	ldi	r24, 0xEA	; 234
    6a86:	9c e2       	ldi	r25, 0x2C	; 44
    6a88:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    MemoryReadBlock(&Access, ReadAccessAddress, 1);
    6a8c:	41 e0       	ldi	r20, 0x01	; 1
    6a8e:	50 e0       	ldi	r21, 0x00	; 0
    6a90:	6c ea       	ldi	r22, 0xAC	; 172
    6a92:	70 e0       	ldi	r23, 0x00	; 0
    6a94:	ce 01       	movw	r24, r28
    6a96:	01 96       	adiw	r24, 0x01	; 1
    6a98:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    ReadAccessProtected = (Access == 0x00);
    6a9c:	81 e0       	ldi	r24, 0x01	; 1
    6a9e:	99 81       	ldd	r25, Y+1	; 0x01
    6aa0:	91 11       	cpse	r25, r1
    6aa2:	80 e0       	ldi	r24, 0x00	; 0
    6aa4:	80 93 e9 2c 	sts	0x2CE9, r24	; 0x802ce9 <ReadAccessProtected>
    State = STATE_IDLE;
    6aa8:	81 e0       	ldi	r24, 0x01	; 1
    6aaa:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
    FromHalt = false;
    6aae:	10 92 ef 2c 	sts	0x2CEF, r1	; 0x802cef <FromHalt>
    Authenticated = false;
    6ab2:	10 92 eb 2c 	sts	0x2CEB, r1	; 0x802ceb <Authenticated>
    ArmedForCompatWrite = false;
    6ab6:	10 92 ed 2c 	sts	0x2CED, r1	; 0x802ced <ArmedForCompatWrite>
}
    6aba:	0f 90       	pop	r0
    6abc:	df 91       	pop	r29
    6abe:	cf 91       	pop	r28
    6ac0:	08 95       	ret

00006ac2 <MifareUltralightAppInit>:

void MifareUltralightAppInit(void) {
    /* Set up the emulation flavor */
    Flavor = UL_EV0;
    6ac2:	10 92 f1 2c 	sts	0x2CF1, r1	; 0x802cf1 <Flavor>
    /* EV0 cards have fixed size */
    PageCount = MIFARE_ULTRALIGHT_PAGES;
    6ac6:	80 e1       	ldi	r24, 0x10	; 16
    6ac8:	80 93 ee 2c 	sts	0x2CEE, r24	; 0x802cee <PageCount>
    /* Default values */
    FirstAuthenticatedPage = 0xFF;
    6acc:	8f ef       	ldi	r24, 0xFF	; 255
    6ace:	80 93 ea 2c 	sts	0x2CEA, r24	; 0x802cea <FirstAuthenticatedPage>
    ReadAccessProtected = false;
    6ad2:	10 92 e9 2c 	sts	0x2CE9, r1	; 0x802ce9 <ReadAccessProtected>
            RNDBBuff [6] == InMessage [5] &&
            RNDBBuff [7] == InMessage [6]);
}

static void AppInitCommon(void) {
    State = STATE_IDLE;
    6ad6:	81 e0       	ldi	r24, 0x01	; 1
    6ad8:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
    FromHalt = false;
    6adc:	10 92 ef 2c 	sts	0x2CEF, r1	; 0x802cef <FromHalt>
    Authenticated = false;
    6ae0:	10 92 eb 2c 	sts	0x2CEB, r1	; 0x802ceb <Authenticated>
    ArmedForCompatWrite = false;
    6ae4:	10 92 ed 2c 	sts	0x2CED, r1	; 0x802ced <ArmedForCompatWrite>
    6ae8:	08 95       	ret

00006aea <MifareUltralightEV11AppInit>:
    ReadAccessProtected = !!(Access & CONF_ACCESS_PROT);
    AppInitCommon();
}

void MifareUltralightEV11AppInit(void) {
    PageCount = MIFARE_ULTRALIGHT_EV11_PAGES;
    6aea:	84 e1       	ldi	r24, 0x14	; 20
    6aec:	80 93 ee 2c 	sts	0x2CEE, r24	; 0x802cee <PageCount>
    AppInitEV1Common();
    6af0:	f9 ce       	rjmp	.-526    	; 0x68e4 <AppInitEV1Common>

00006af2 <MifareUltralightEV12AppInit>:
}

void MifareUltralightEV12AppInit(void) {
    PageCount = MIFARE_ULTRALIGHT_EV12_PAGES;
    6af2:	89 e2       	ldi	r24, 0x29	; 41
    6af4:	80 93 ee 2c 	sts	0x2CEE, r24	; 0x802cee <PageCount>
    AppInitEV1Common();
    6af8:	f5 ce       	rjmp	.-534    	; 0x68e4 <AppInitEV1Common>

00006afa <MifareUltralightAppReset>:
}

void MifareUltralightAppReset(void) {
    State = STATE_IDLE;
    6afa:	81 e0       	ldi	r24, 0x01	; 1
    6afc:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
    6b00:	08 95       	ret

00006b02 <MifareUltralightCAppReset>:
}
void MifareUltralightCAppReset(void) {
    Authenticated = false;
    6b02:	10 92 eb 2c 	sts	0x2CEB, r1	; 0x802ceb <Authenticated>
    State = STATE_IDLE;
    6b06:	81 e0       	ldi	r24, 0x01	; 1
    6b08:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
    6b0c:	08 95       	ret

00006b0e <MifareUltralightAppTask>:
}
void MifareUltralightAppTask(void) {
    6b0e:	08 95       	ret

00006b10 <MifareUltralightAppProcess>:
    /* Command not handled. Switch to idle. */
    State = STATE_IDLE;
    return ISO14443A_APP_NO_RESPONSE;
}

uint16_t MifareUltralightAppProcess(uint8_t *Buffer, uint16_t BitCount) {
    6b10:	8f 92       	push	r8
    6b12:	9f 92       	push	r9
    6b14:	af 92       	push	r10
    6b16:	bf 92       	push	r11
    6b18:	cf 92       	push	r12
    6b1a:	df 92       	push	r13
    6b1c:	ef 92       	push	r14
    6b1e:	ff 92       	push	r15
    6b20:	0f 93       	push	r16
    6b22:	1f 93       	push	r17
    6b24:	cf 93       	push	r28
    6b26:	df 93       	push	r29
    6b28:	cd b7       	in	r28, 0x3d	; 61
    6b2a:	de b7       	in	r29, 0x3e	; 62
    6b2c:	60 97       	sbiw	r28, 0x10	; 16
    6b2e:	cd bf       	out	0x3d, r28	; 61
    6b30:	de bf       	out	0x3e, r29	; 62
    6b32:	7c 01       	movw	r14, r24
    uint8_t Cmd = Buffer[0];
    6b34:	dc 01       	movw	r26, r24
    6b36:	8c 91       	ld	r24, X
    uint16_t ByteCount;

    switch (State) {
    6b38:	90 91 f0 2c 	lds	r25, 0x2CF0	; 0x802cf0 <State>
    6b3c:	92 30       	cpi	r25, 0x02	; 2
    6b3e:	f1 f0       	breq	.+60     	; 0x6b7c <MifareUltralightAppProcess+0x6c>
    6b40:	38 f0       	brcs	.+14     	; 0x6b50 <MifareUltralightAppProcess+0x40>
    6b42:	94 30       	cpi	r25, 0x04	; 4
    6b44:	79 f1       	breq	.+94     	; 0x6ba4 <MifareUltralightAppProcess+0x94>
    6b46:	20 f1       	brcs	.+72     	; 0x6b90 <MifareUltralightAppProcess+0x80>
    6b48:	96 30       	cpi	r25, 0x06	; 6
    6b4a:	09 f4       	brne	.+2      	; 0x6b4e <MifareUltralightAppProcess+0x3e>
    6b4c:	55 c0       	rjmp	.+170    	; 0x6bf8 <MifareUltralightAppProcess+0xe8>
    6b4e:	e7 c0       	rjmp	.+462    	; 0x6d1e <MifareUltralightAppProcess+0x20e>
        case STATE_IDLE:
        case STATE_HALT:
            FromHalt = State == STATE_HALT;
    6b50:	29 2f       	mov	r18, r25
    6b52:	20 95       	com	r18
    6b54:	21 70       	andi	r18, 0x01	; 1
    6b56:	20 93 ef 2c 	sts	0x2CEF, r18	; 0x802cef <FromHalt>

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    6b5a:	99 23       	and	r25, r25
    6b5c:	11 f0       	breq	.+4      	; 0x6b62 <MifareUltralightAppProcess+0x52>
    6b5e:	86 32       	cpi	r24, 0x26	; 38
    6b60:	19 f0       	breq	.+6      	; 0x6b68 <MifareUltralightAppProcess+0x58>
    6b62:	82 35       	cpi	r24, 0x52	; 82
    6b64:	09 f0       	breq	.+2      	; 0x6b68 <MifareUltralightAppProcess+0x58>
    6b66:	db c0       	rjmp	.+438    	; 0x6d1e <MifareUltralightAppProcess+0x20e>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    6b68:	84 e4       	ldi	r24, 0x44	; 68
    6b6a:	f7 01       	movw	r30, r14
    6b6c:	80 83       	st	Z, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    6b6e:	11 82       	std	Z+1, r1	; 0x01
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                /* We received a REQA or WUPA command, so wake up. */
                State = STATE_READY1;
    6b70:	82 e0       	ldi	r24, 0x02	; 2
    6b72:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;
    6b76:	80 e1       	ldi	r24, 0x10	; 16
    6b78:	90 e0       	ldi	r25, 0x00	; 0
                return BitCount;
    6b7a:	c9 c3       	rjmp	.+1938   	; 0x730e <MifareUltralightAppProcess+0x7fe>
            }
            break;

        case STATE_READY1:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    6b7c:	90 91 ef 2c 	lds	r25, 0x2CEF	; 0x802cef <FromHalt>

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    6b80:	91 11       	cpse	r25, r1
    6b82:	02 c0       	rjmp	.+4      	; 0x6b88 <MifareUltralightAppProcess+0x78>
    6b84:	86 32       	cpi	r24, 0x26	; 38
    6b86:	b9 f0       	breq	.+46     	; 0x6bb6 <MifareUltralightAppProcess+0xa6>
    6b88:	82 35       	cpi	r24, 0x52	; 82
    6b8a:	09 f0       	breq	.+2      	; 0x6b8e <MifareUltralightAppProcess+0x7e>
    6b8c:	cb c0       	rjmp	.+406    	; 0x6d24 <MifareUltralightAppProcess+0x214>
    6b8e:	13 c0       	rjmp	.+38     	; 0x6bb6 <MifareUltralightAppProcess+0xa6>
                State = STATE_IDLE;
            }
            break;

        case STATE_READY2:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    6b90:	90 91 ef 2c 	lds	r25, 0x2CEF	; 0x802cef <FromHalt>
    6b94:	91 11       	cpse	r25, r1
    6b96:	02 c0       	rjmp	.+4      	; 0x6b9c <MifareUltralightAppProcess+0x8c>
    6b98:	86 32       	cpi	r24, 0x26	; 38
    6b9a:	69 f0       	breq	.+26     	; 0x6bb6 <MifareUltralightAppProcess+0xa6>
    6b9c:	82 35       	cpi	r24, 0x52	; 82
    6b9e:	09 f0       	breq	.+2      	; 0x6ba2 <MifareUltralightAppProcess+0x92>
    6ba0:	f3 c0       	rjmp	.+486    	; 0x6d88 <MifareUltralightAppProcess+0x278>
    6ba2:	09 c0       	rjmp	.+18     	; 0x6bb6 <MifareUltralightAppProcess+0xa6>
            break;

        case STATE_ACTIVE:
            /* Preserve incoming data length */
            ByteCount = (BitCount + 7) >> 3;
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    6ba4:	90 91 ef 2c 	lds	r25, 0x2CEF	; 0x802cef <FromHalt>
    6ba8:	91 11       	cpse	r25, r1
    6baa:	02 c0       	rjmp	.+4      	; 0x6bb0 <MifareUltralightAppProcess+0xa0>
    6bac:	86 32       	cpi	r24, 0x26	; 38
    6bae:	19 f0       	breq	.+6      	; 0x6bb6 <MifareUltralightAppProcess+0xa6>
    6bb0:	82 35       	cpi	r24, 0x52	; 82
    6bb2:	09 f0       	breq	.+2      	; 0x6bb6 <MifareUltralightAppProcess+0xa6>
    6bb4:	9b c1       	rjmp	.+822    	; 0x6eec <MifareUltralightAppProcess+0x3dc>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    6bb6:	84 e4       	ldi	r24, 0x44	; 68
    6bb8:	d7 01       	movw	r26, r14
    6bba:	8c 93       	st	X, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    6bbc:	11 96       	adiw	r26, 0x01	; 1
    6bbe:	1c 92       	st	X, r1
                State = FromHalt ? STATE_HALT : STATE_IDLE;
    6bc0:	81 e0       	ldi	r24, 0x01	; 1
    6bc2:	89 27       	eor	r24, r25
    6bc4:	16 c0       	rjmp	.+44     	; 0x6bf2 <MifareUltralightAppProcess+0xe2>
/* Handles processing of MF commands */
static uint16_t AppProcess(uint8_t *const Buffer, uint16_t ByteCount) {
    uint8_t Cmd = Buffer[0];

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
    6bc6:	80 91 ed 2c 	lds	r24, 0x2CED	; 0x802ced <ArmedForCompatWrite>
    6bca:	81 11       	cpse	r24, r1
    6bcc:	a3 c1       	rjmp	.+838    	; 0x6f14 <MifareUltralightAppProcess+0x404>
    return 0;
}

/* Handles processing of MF commands */
static uint16_t AppProcess(uint8_t *const Buffer, uint16_t ByteCount) {
    uint8_t Cmd = Buffer[0];
    6bce:	d7 01       	movw	r26, r14
    6bd0:	8c 91       	ld	r24, X
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

    /* Handle EV0 commands */
    switch (Cmd) {
    6bd2:	80 35       	cpi	r24, 0x50	; 80
    6bd4:	09 f4       	brne	.+2      	; 0x6bd8 <MifareUltralightAppProcess+0xc8>
    6bd6:	9c c0       	rjmp	.+312    	; 0x6d10 <MifareUltralightAppProcess+0x200>
    6bd8:	08 f0       	brcs	.+2      	; 0x6bdc <MifareUltralightAppProcess+0xcc>
    6bda:	ad c1       	rjmp	.+858    	; 0x6f36 <MifareUltralightAppProcess+0x426>
    6bdc:	80 33       	cpi	r24, 0x30	; 48
    6bde:	09 f4       	brne	.+2      	; 0x6be2 <MifareUltralightAppProcess+0xd2>
    6be0:	c8 c1       	rjmp	.+912    	; 0x6f72 <MifareUltralightAppProcess+0x462>
            }
        }
        default:
            break;
    }
    if (Flavor == UL_C) {
    6be2:	90 91 f1 2c 	lds	r25, 0x2CF1	; 0x802cf1 <Flavor>
    6be6:	91 30       	cpi	r25, 0x01	; 1
    6be8:	09 f4       	brne	.+2      	; 0x6bec <MifareUltralightAppProcess+0xdc>
    6bea:	30 c2       	rjmp	.+1120   	; 0x704c <MifareUltralightAppProcess+0x53c>
            ISO14443AAppendCRCA(Buffer, 9);
            return (9 + ISO14443A_CRCA_SIZE) * 8;
        }
    }
    /* Handle EV1 commands */
    if (Flavor >= UL_EV1) {
    6bec:	08 f0       	brcs	.+2      	; 0x6bf0 <MifareUltralightAppProcess+0xe0>
    6bee:	55 c2       	rjmp	.+1194   	; 0x709a <MifareUltralightAppProcess+0x58a>
            default:
                break;
        }
    }
    /* Command not handled. Switch to idle. */
    State = STATE_IDLE;
    6bf0:	81 e0       	ldi	r24, 0x01	; 1
    6bf2:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
    6bf6:	93 c0       	rjmp	.+294    	; 0x6d1e <MifareUltralightAppProcess+0x20e>
            return AppProcess(Buffer, ByteCount);

        case STATE_AUTH: // ULC Authing
            ByteCount = (BitCount + 7) >> 3;
            /* We check if we received an auth message */
            if (Buffer[0] == CMD_ULC_AUTH_2 && ISO14443ACheckCRCA(Buffer, ByteCount - 2)) {
    6bf8:	8f 3a       	cpi	r24, 0xAF	; 175
    6bfa:	09 f0       	breq	.+2      	; 0x6bfe <MifareUltralightAppProcess+0xee>
    6bfc:	80 c0       	rjmp	.+256    	; 0x6cfe <MifareUltralightAppProcess+0x1ee>
    6bfe:	69 5f       	subi	r22, 0xF9	; 249
    6c00:	7f 4f       	sbci	r23, 0xFF	; 255
    6c02:	93 e0       	ldi	r25, 0x03	; 3
    6c04:	76 95       	lsr	r23
    6c06:	67 95       	ror	r22
    6c08:	9a 95       	dec	r25
    6c0a:	e1 f7       	brne	.-8      	; 0x6c04 <MifareUltralightAppProcess+0xf4>
    6c0c:	62 50       	subi	r22, 0x02	; 2
    6c0e:	71 09       	sbc	r23, r1
    6c10:	c7 01       	movw	r24, r14
    6c12:	0e 94 8b 41 	call	0x8316	; 0x8316 <ISO14443ACheckCRCA>
    6c16:	88 23       	and	r24, r24
    6c18:	09 f4       	brne	.+2      	; 0x6c1c <MifareUltralightAppProcess+0x10c>
    6c1a:	71 c0       	rjmp	.+226    	; 0x6cfe <MifareUltralightAppProcess+0x1ee>
                uint8_t tmpBuff [8];
                uint8_t RNDA [8] = {0};
    6c1c:	fe 01       	movw	r30, r28
    6c1e:	31 96       	adiw	r30, 0x01	; 1
    6c20:	6f 01       	movw	r12, r30
    6c22:	88 e0       	ldi	r24, 0x08	; 8
    6c24:	df 01       	movw	r26, r30
    6c26:	1d 92       	st	X+, r1
    6c28:	8a 95       	dec	r24
    6c2a:	e9 f7       	brne	.-6      	; 0x6c26 <MifareUltralightAppProcess+0x116>
                CryptoDecrypt2KTDEA_CBCReceive(1, &Buffer[1], RNDA, InitialVector, TripleDesKey);
    6c2c:	57 01       	movw	r10, r14
    6c2e:	bf ef       	ldi	r27, 0xFF	; 255
    6c30:	ab 1a       	sub	r10, r27
    6c32:	bb 0a       	sbc	r11, r27
    6c34:	09 ec       	ldi	r16, 0xC9	; 201
    6c36:	1c e2       	ldi	r17, 0x2C	; 44
    6c38:	29 ed       	ldi	r18, 0xD9	; 217
    6c3a:	3c e2       	ldi	r19, 0x2C	; 44
    6c3c:	af 01       	movw	r20, r30
    6c3e:	b5 01       	movw	r22, r10
    6c40:	81 e0       	ldi	r24, 0x01	; 1
    6c42:	90 e0       	ldi	r25, 0x00	; 0
    6c44:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <CryptoDecrypt2KTDEA_CBCReceive>

                CryptoDecrypt2KTDEA_CBCReceive(1, &Buffer[9], tmpBuff, InitialVector, TripleDesKey);
    6c48:	29 ed       	ldi	r18, 0xD9	; 217
    6c4a:	3c e2       	ldi	r19, 0x2C	; 44
    6c4c:	ae 01       	movw	r20, r28
    6c4e:	47 5f       	subi	r20, 0xF7	; 247
    6c50:	5f 4f       	sbci	r21, 0xFF	; 255
    6c52:	b7 01       	movw	r22, r14
    6c54:	67 5f       	subi	r22, 0xF7	; 247
    6c56:	7f 4f       	sbci	r23, 0xFF	; 255
    6c58:	81 e0       	ldi	r24, 0x01	; 1
    6c5a:	90 e0       	ldi	r25, 0x00	; 0
    6c5c:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <CryptoDecrypt2KTDEA_CBCReceive>
            RNDBBuff [1] == InMessage [0] &&
            RNDBBuff [2] == InMessage [1] &&
            RNDBBuff [3] == InMessage [2] &&
            RNDBBuff [4] == InMessage [3] &&
            RNDBBuff [5] == InMessage [4] &&
            RNDBBuff [6] == InMessage [5] &&
    6c60:	90 91 e1 2c 	lds	r25, 0x2CE1	; 0x802ce1 <RNDBBuff>
    6c64:	88 89       	ldd	r24, Y+16	; 0x10
    6c66:	98 13       	cpse	r25, r24
    6c68:	23 c0       	rjmp	.+70     	; 0x6cb0 <MifareUltralightAppProcess+0x1a0>
    memcpy(Key, tmpstorage, 8);
}

static bool MifareUltralightcCheckRNDB(const uint8_t *InMessage) {
    /*Checks if RNDB of Card is equal to decrypted RNDB' send by reader shifted left one Byte */
    return (RNDBBuff [0] == InMessage [7] &&
    6c6a:	90 91 e2 2c 	lds	r25, 0x2CE2	; 0x802ce2 <RNDBBuff+0x1>
    6c6e:	89 85       	ldd	r24, Y+9	; 0x09
    6c70:	98 13       	cpse	r25, r24
    6c72:	1e c0       	rjmp	.+60     	; 0x6cb0 <MifareUltralightAppProcess+0x1a0>
            RNDBBuff [1] == InMessage [0] &&
    6c74:	90 91 e3 2c 	lds	r25, 0x2CE3	; 0x802ce3 <RNDBBuff+0x2>
    6c78:	8a 85       	ldd	r24, Y+10	; 0x0a
    6c7a:	98 13       	cpse	r25, r24
    6c7c:	19 c0       	rjmp	.+50     	; 0x6cb0 <MifareUltralightAppProcess+0x1a0>
            RNDBBuff [2] == InMessage [1] &&
    6c7e:	90 91 e4 2c 	lds	r25, 0x2CE4	; 0x802ce4 <RNDBBuff+0x3>
    6c82:	8b 85       	ldd	r24, Y+11	; 0x0b
    6c84:	98 13       	cpse	r25, r24
    6c86:	14 c0       	rjmp	.+40     	; 0x6cb0 <MifareUltralightAppProcess+0x1a0>
            RNDBBuff [3] == InMessage [2] &&
    6c88:	90 91 e5 2c 	lds	r25, 0x2CE5	; 0x802ce5 <RNDBBuff+0x4>
    6c8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    6c8e:	98 13       	cpse	r25, r24
    6c90:	0f c0       	rjmp	.+30     	; 0x6cb0 <MifareUltralightAppProcess+0x1a0>
            RNDBBuff [4] == InMessage [3] &&
    6c92:	90 91 e6 2c 	lds	r25, 0x2CE6	; 0x802ce6 <RNDBBuff+0x5>
    6c96:	8d 85       	ldd	r24, Y+13	; 0x0d
    6c98:	98 13       	cpse	r25, r24
    6c9a:	0a c0       	rjmp	.+20     	; 0x6cb0 <MifareUltralightAppProcess+0x1a0>
            RNDBBuff [5] == InMessage [4] &&
    6c9c:	90 91 e7 2c 	lds	r25, 0x2CE7	; 0x802ce7 <RNDBBuff+0x6>
    6ca0:	8e 85       	ldd	r24, Y+14	; 0x0e
    6ca2:	98 13       	cpse	r25, r24
    6ca4:	05 c0       	rjmp	.+10     	; 0x6cb0 <MifareUltralightAppProcess+0x1a0>
            RNDBBuff [6] == InMessage [5] &&
    6ca6:	81 e0       	ldi	r24, 0x01	; 1
    6ca8:	20 91 e8 2c 	lds	r18, 0x2CE8	; 0x802ce8 <RNDBBuff+0x7>
    6cac:	9f 85       	ldd	r25, Y+15	; 0x0f
    6cae:	29 13       	cpse	r18, r25
    6cb0:	80 e0       	ldi	r24, 0x00	; 0
                uint8_t RNDA [8] = {0};
                CryptoDecrypt2KTDEA_CBCReceive(1, &Buffer[1], RNDA, InitialVector, TripleDesKey);

                CryptoDecrypt2KTDEA_CBCReceive(1, &Buffer[9], tmpBuff, InitialVector, TripleDesKey);

                if (MifareUltralightcCheckRNDB(tmpBuff)) {
    6cb2:	80 ff       	sbrs	r24, 0
    6cb4:	24 c0       	rjmp	.+72     	; 0x6cfe <MifareUltralightAppProcess+0x1ee>
static uint8_t InitialVector[8] = {0};
static uint8_t TripleDesKey [16];

static void leftshift1byte(uint8_t *Input) {
    uint8_t tmpstorage;
    tmpstorage = Input[0];
    6cb6:	19 81       	ldd	r17, Y+1	; 0x01
    memmove(Input, &Input[1], 7);
    6cb8:	47 e0       	ldi	r20, 0x07	; 7
    6cba:	50 e0       	ldi	r21, 0x00	; 0
    6cbc:	be 01       	movw	r22, r28
    6cbe:	6e 5f       	subi	r22, 0xFE	; 254
    6cc0:	7f 4f       	sbci	r23, 0xFF	; 255
    6cc2:	c6 01       	movw	r24, r12
    6cc4:	0e 94 a9 78 	call	0xf152	; 0xf152 <memmove>
    Input[7] = tmpstorage;
    6cc8:	18 87       	std	Y+8, r17	; 0x08

                CryptoDecrypt2KTDEA_CBCReceive(1, &Buffer[9], tmpBuff, InitialVector, TripleDesKey);

                if (MifareUltralightcCheckRNDB(tmpBuff)) {
                    leftshift1byte(RNDA);
                    CryptoEncrypt2KTDEA_CBCSend(1, RNDA, &Buffer[1], InitialVector, TripleDesKey);
    6cca:	09 ec       	ldi	r16, 0xC9	; 201
    6ccc:	1c e2       	ldi	r17, 0x2C	; 44
    6cce:	29 ed       	ldi	r18, 0xD9	; 217
    6cd0:	3c e2       	ldi	r19, 0x2C	; 44
    6cd2:	a5 01       	movw	r20, r10
    6cd4:	b6 01       	movw	r22, r12
    6cd6:	81 e0       	ldi	r24, 0x01	; 1
    6cd8:	90 e0       	ldi	r25, 0x00	; 0
    6cda:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <CryptoEncrypt2KTDEA_CBCSend>

                    Buffer[0] = CMD_ULC_AUTH_FINISHED;
    6cde:	f7 01       	movw	r30, r14
    6ce0:	10 82       	st	Z, r1
                    ISO14443AAppendCRCA(Buffer, 9);
    6ce2:	69 e0       	ldi	r22, 0x09	; 9
    6ce4:	70 e0       	ldi	r23, 0x00	; 0
    6ce6:	c7 01       	movw	r24, r14
    6ce8:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                    Authenticated = true;
    6cec:	81 e0       	ldi	r24, 0x01	; 1
    6cee:	80 93 eb 2c 	sts	0x2CEB, r24	; 0x802ceb <Authenticated>
                    State = STATE_ACTIVE;
    6cf2:	84 e0       	ldi	r24, 0x04	; 4
    6cf4:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
                    return (9 + ISO14443A_CRCA_SIZE) * 8;
    6cf8:	88 e5       	ldi	r24, 0x58	; 88
    6cfa:	90 e0       	ldi	r25, 0x00	; 0
    6cfc:	08 c3       	rjmp	.+1552   	; 0x730e <MifareUltralightAppProcess+0x7fe>
                }

            }
            State = STATE_IDLE;
    6cfe:	81 e0       	ldi	r24, 0x01	; 1
    6d00:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
            Buffer[0] = NAK_AUTH_FAILED;
    6d04:	86 e0       	ldi	r24, 0x06	; 6
    6d06:	d7 01       	movw	r26, r14
    6d08:	8c 93       	st	X, r24
            return NAK_FRAME_SIZE;
    6d0a:	84 e0       	ldi	r24, 0x04	; 4
    6d0c:	90 e0       	ldi	r25, 0x00	; 0
    6d0e:	ff c2       	rjmp	.+1534   	; 0x730e <MifareUltralightAppProcess+0x7fe>
        }

        case CMD_HALT: {
            /* Halts the tag. According to the ISO14443, the second
            * byte is supposed to be 0. */
            if (Buffer[1] == 0) {
    6d10:	d7 01       	movw	r26, r14
    6d12:	11 96       	adiw	r26, 0x01	; 1
    6d14:	8c 91       	ld	r24, X
    6d16:	81 11       	cpse	r24, r1
    6d18:	1d c1       	rjmp	.+570    	; 0x6f54 <MifareUltralightAppProcess+0x444>
                /* According to ISO14443, we must not send anything
                * in order to acknowledge the HALT command. */
                State = STATE_HALT;
    6d1a:	10 92 f0 2c 	sts	0x2CF0, r1	; 0x802cf0 <State>
            /* Unknown state? Should never happen. */
            break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
    6d1e:	80 e0       	ldi	r24, 0x00	; 0
    6d20:	90 e0       	ldi	r25, 0x00	; 0
    6d22:	f5 c2       	rjmp	.+1514   	; 0x730e <MifareUltralightAppProcess+0x7fe>

        case STATE_READY1:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Cmd == ISO14443A_CMD_SELECT_CL1) {
    6d24:	83 39       	cpi	r24, 0x93	; 147
    6d26:	09 f0       	breq	.+2      	; 0x6d2a <MifareUltralightAppProcess+0x21a>
    6d28:	63 cf       	rjmp	.-314    	; 0x6bf0 <MifareUltralightAppProcess+0xe0>
                /* Load UID CL1 and perform anticollision. Since
                * MF Ultralight use a double-sized UID, the first byte
                * of CL1 has to be the cascade-tag byte. */
                uint8_t UidCL1[ISO14443A_CL_UID_SIZE] = { [0] = ISO14443A_UID0_CT };
    6d2a:	19 82       	std	Y+1, r1	; 0x01
    6d2c:	1a 82       	std	Y+2, r1	; 0x02
    6d2e:	1b 82       	std	Y+3, r1	; 0x03
    6d30:	1c 82       	std	Y+4, r1	; 0x04
    6d32:	88 e8       	ldi	r24, 0x88	; 136
    6d34:	89 83       	std	Y+1, r24	; 0x01

                MemoryReadBlock(&UidCL1[1], UID_CL1_ADDRESS, UID_CL1_SIZE);
    6d36:	43 e0       	ldi	r20, 0x03	; 3
    6d38:	50 e0       	ldi	r21, 0x00	; 0
    6d3a:	60 e0       	ldi	r22, 0x00	; 0
    6d3c:	70 e0       	ldi	r23, 0x00	; 0
    6d3e:	ce 01       	movw	r24, r28
    6d40:	02 96       	adiw	r24, 0x02	; 2
    6d42:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    6d46:	f7 01       	movw	r30, r14
    6d48:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    6d4a:	80 32       	cpi	r24, 0x20	; 32
    6d4c:	61 f1       	breq	.+88     	; 0x6da6 <MifareUltralightAppProcess+0x296>
    6d4e:	80 37       	cpi	r24, 0x70	; 112
    6d50:	09 f0       	breq	.+2      	; 0x6d54 <MifareUltralightAppProcess+0x244>
    6d52:	5c c0       	rjmp	.+184    	; 0x6e0c <MifareUltralightAppProcess+0x2fc>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    6d54:	f7 01       	movw	r30, r14
    6d56:	92 81       	ldd	r25, Z+2	; 0x02
    6d58:	89 81       	ldd	r24, Y+1	; 0x01
    6d5a:	98 13       	cpse	r25, r24
    6d5c:	c2 c0       	rjmp	.+388    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
    6d5e:	93 81       	ldd	r25, Z+3	; 0x03
    6d60:	8a 81       	ldd	r24, Y+2	; 0x02
    6d62:	98 13       	cpse	r25, r24
    6d64:	be c0       	rjmp	.+380    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                    (DataPtr[3] == UidCL[1]) &&
    6d66:	94 81       	ldd	r25, Z+4	; 0x04
    6d68:	8b 81       	ldd	r24, Y+3	; 0x03
    6d6a:	98 13       	cpse	r25, r24
    6d6c:	ba c0       	rjmp	.+372    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                    (DataPtr[4] == UidCL[2]) &&
    6d6e:	95 81       	ldd	r25, Z+5	; 0x05
    6d70:	8c 81       	ldd	r24, Y+4	; 0x04
    6d72:	98 13       	cpse	r25, r24
    6d74:	b6 c0       	rjmp	.+364    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    6d76:	84 e0       	ldi	r24, 0x04	; 4
    6d78:	80 83       	st	Z, r24
                ISO14443AAppendCRCA(Buffer, 1);
    6d7a:	61 e0       	ldi	r22, 0x01	; 1
    6d7c:	70 e0       	ldi	r23, 0x00	; 0
    6d7e:	c7 01       	movw	r24, r14
    6d80:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>

                if (ISO14443ASelect(Buffer, &BitCount, UidCL1, SAK_CL1_VALUE)) {
                    /* CL1 stage has ended successfully */
                    State = STATE_READY2;
    6d84:	83 e0       	ldi	r24, 0x03	; 3
    6d86:	3e c0       	rjmp	.+124    	; 0x6e04 <MifareUltralightAppProcess+0x2f4>

        case STATE_READY2:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Cmd == ISO14443A_CMD_SELECT_CL2) {
    6d88:	85 39       	cpi	r24, 0x95	; 149
    6d8a:	09 f0       	breq	.+2      	; 0x6d8e <MifareUltralightAppProcess+0x27e>
    6d8c:	31 cf       	rjmp	.-414    	; 0x6bf0 <MifareUltralightAppProcess+0xe0>
                /* Load UID CL2 and perform anticollision */
                uint8_t UidCL2[ISO14443A_CL_UID_SIZE];

                MemoryReadBlock(UidCL2, UID_CL2_ADDRESS, UID_CL2_SIZE);
    6d8e:	44 e0       	ldi	r20, 0x04	; 4
    6d90:	50 e0       	ldi	r21, 0x00	; 0
    6d92:	64 e0       	ldi	r22, 0x04	; 4
    6d94:	70 e0       	ldi	r23, 0x00	; 0
    6d96:	ce 01       	movw	r24, r28
    6d98:	01 96       	adiw	r24, 0x01	; 1
    6d9a:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    6d9e:	f7 01       	movw	r30, r14
    6da0:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    6da2:	80 32       	cpi	r24, 0x20	; 32
    6da4:	a9 f4       	brne	.+42     	; 0x6dd0 <MifareUltralightAppProcess+0x2c0>
        case ISO14443A_NVB_AC_START:
            /* Start of anticollision procedure.
            * Send whole UID CLn + BCC */
            DataPtr[0] = UidCL[0];
    6da6:	39 81       	ldd	r19, Y+1	; 0x01
    6da8:	d7 01       	movw	r26, r14
    6daa:	3c 93       	st	X, r19
            DataPtr[1] = UidCL[1];
    6dac:	2a 81       	ldd	r18, Y+2	; 0x02
    6dae:	11 96       	adiw	r26, 0x01	; 1
    6db0:	2c 93       	st	X, r18
    6db2:	11 97       	sbiw	r26, 0x01	; 1
            DataPtr[2] = UidCL[2];
    6db4:	9b 81       	ldd	r25, Y+3	; 0x03
    6db6:	12 96       	adiw	r26, 0x02	; 2
    6db8:	9c 93       	st	X, r25
    6dba:	12 97       	sbiw	r26, 0x02	; 2
            DataPtr[3] = UidCL[3];
    6dbc:	8c 81       	ldd	r24, Y+4	; 0x04
    6dbe:	13 96       	adiw	r26, 0x03	; 3
    6dc0:	8c 93       	st	X, r24
    6dc2:	13 97       	sbiw	r26, 0x03	; 3
            DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    6dc4:	23 27       	eor	r18, r19
    6dc6:	92 27       	eor	r25, r18
    6dc8:	89 27       	eor	r24, r25
    6dca:	14 96       	adiw	r26, 0x04	; 4
    6dcc:	8c 93       	st	X, r24
    6dce:	87 c0       	rjmp	.+270    	; 0x6ede <MifareUltralightAppProcess+0x3ce>
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    6dd0:	80 37       	cpi	r24, 0x70	; 112
    6dd2:	e1 f4       	brne	.+56     	; 0x6e0c <MifareUltralightAppProcess+0x2fc>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    6dd4:	f7 01       	movw	r30, r14
    6dd6:	92 81       	ldd	r25, Z+2	; 0x02
    6dd8:	89 81       	ldd	r24, Y+1	; 0x01
    6dda:	98 13       	cpse	r25, r24
    6ddc:	82 c0       	rjmp	.+260    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
    6dde:	93 81       	ldd	r25, Z+3	; 0x03
    6de0:	8a 81       	ldd	r24, Y+2	; 0x02
    6de2:	98 13       	cpse	r25, r24
    6de4:	7e c0       	rjmp	.+252    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                    (DataPtr[3] == UidCL[1]) &&
    6de6:	94 81       	ldd	r25, Z+4	; 0x04
    6de8:	8b 81       	ldd	r24, Y+3	; 0x03
    6dea:	98 13       	cpse	r25, r24
    6dec:	7a c0       	rjmp	.+244    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                    (DataPtr[4] == UidCL[2]) &&
    6dee:	95 81       	ldd	r25, Z+5	; 0x05
    6df0:	8c 81       	ldd	r24, Y+4	; 0x04
    6df2:	98 13       	cpse	r25, r24
    6df4:	76 c0       	rjmp	.+236    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    6df6:	10 82       	st	Z, r1
                ISO14443AAppendCRCA(Buffer, 1);
    6df8:	61 e0       	ldi	r22, 0x01	; 1
    6dfa:	70 e0       	ldi	r23, 0x00	; 0
    6dfc:	c7 01       	movw	r24, r14
    6dfe:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>

                if (ISO14443ASelect(Buffer, &BitCount, UidCL2, SAK_CL2_VALUE)) {
                    /* CL2 stage has ended successfully. This means
                    * our complete UID has been sent to the reader. */
                    State = STATE_ACTIVE;
    6e02:	84 e0       	ldi	r24, 0x04	; 4
    6e04:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>
    6e08:	38 e1       	ldi	r19, 0x18	; 24
    6e0a:	6c c0       	rjmp	.+216    	; 0x6ee4 <MifareUltralightAppProcess+0x3d4>
                /* We have not been selected. Don't send anything. */
                *BitCount = 0;
                return false;
            }
        default: {
            uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    6e0c:	08 2f       	mov	r16, r24
    6e0e:	02 95       	swap	r16
    6e10:	0f 70       	andi	r16, 0x0F	; 15
    6e12:	02 50       	subi	r16, 0x02	; 2
            uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    6e14:	18 2f       	mov	r17, r24
    6e16:	1f 70       	andi	r17, 0x0F	; 15
            uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    6e18:	88 e0       	ldi	r24, 0x08	; 8
    6e1a:	90 e0       	ldi	r25, 0x00	; 0
    6e1c:	81 1b       	sub	r24, r17
    6e1e:	91 09       	sbc	r25, r1
    6e20:	2f ef       	ldi	r18, 0xFF	; 255
    6e22:	30 e0       	ldi	r19, 0x00	; 0
    6e24:	69 01       	movw	r12, r18
    6e26:	02 c0       	rjmp	.+4      	; 0x6e2c <MifareUltralightAppProcess+0x31c>
    6e28:	d5 94       	asr	r13
    6e2a:	c7 94       	ror	r12
    6e2c:	8a 95       	dec	r24
    6e2e:	e2 f7       	brpl	.-8      	; 0x6e28 <MifareUltralightAppProcess+0x318>
            // Since the UidCL does not contain the BCC, we have to distinguish here
            if (
    6e30:	05 30       	cpi	r16, 0x05	; 5
    6e32:	21 f0       	breq	.+8      	; 0x6e3c <MifareUltralightAppProcess+0x32c>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    6e34:	04 30       	cpi	r16, 0x04	; 4
    6e36:	51 f5       	brne	.+84     	; 0x6e8c <MifareUltralightAppProcess+0x37c>
    6e38:	11 23       	and	r17, r17
    6e3a:	e1 f0       	breq	.+56     	; 0x6e74 <MifareUltralightAppProcess+0x364>
    6e3c:	44 e0       	ldi	r20, 0x04	; 4
    6e3e:	50 e0       	ldi	r21, 0x00	; 0
    6e40:	b7 01       	movw	r22, r14
    6e42:	6e 5f       	subi	r22, 0xFE	; 254
    6e44:	7f 4f       	sbci	r23, 0xFF	; 255
    6e46:	ce 01       	movw	r24, r28
    6e48:	01 96       	adiw	r24, 0x01	; 1
    6e4a:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    6e4e:	89 2b       	or	r24, r25
    6e50:	69 f4       	brne	.+26     	; 0x6e6c <MifareUltralightAppProcess+0x35c>
    6e52:	99 81       	ldd	r25, Y+1	; 0x01
    6e54:	8a 81       	ldd	r24, Y+2	; 0x02
    6e56:	89 27       	eor	r24, r25
    6e58:	9b 81       	ldd	r25, Y+3	; 0x03
    6e5a:	89 27       	eor	r24, r25
    6e5c:	9c 81       	ldd	r25, Y+4	; 0x04
    6e5e:	89 27       	eor	r24, r25
    6e60:	d7 01       	movw	r26, r14
    6e62:	16 96       	adiw	r26, 0x06	; 6
    6e64:	9c 91       	ld	r25, X
    6e66:	89 27       	eor	r24, r25
    6e68:	8c 21       	and	r24, r12
    6e6a:	61 f1       	breq	.+88     	; 0x6ec4 <MifareUltralightAppProcess+0x3b4>
                ||
    6e6c:	04 30       	cpi	r16, 0x04	; 4
    6e6e:	71 f4       	brne	.+28     	; 0x6e8c <MifareUltralightAppProcess+0x37c>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    6e70:	11 11       	cpse	r17, r1
    6e72:	37 c0       	rjmp	.+110    	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
    6e74:	44 e0       	ldi	r20, 0x04	; 4
    6e76:	50 e0       	ldi	r21, 0x00	; 0
    6e78:	b7 01       	movw	r22, r14
    6e7a:	6e 5f       	subi	r22, 0xFE	; 254
    6e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    6e7e:	ce 01       	movw	r24, r28
    6e80:	01 96       	adiw	r24, 0x01	; 1
    6e82:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    6e86:	89 2b       	or	r24, r25
    6e88:	e9 f0       	breq	.+58     	; 0x6ec4 <MifareUltralightAppProcess+0x3b4>
    6e8a:	2b c0       	rjmp	.+86     	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                ||
    6e8c:	04 30       	cpi	r16, 0x04	; 4
    6e8e:	48 f5       	brcc	.+82     	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    6e90:	10 e0       	ldi	r17, 0x00	; 0
    6e92:	a8 01       	movw	r20, r16
    6e94:	b7 01       	movw	r22, r14
    6e96:	6e 5f       	subi	r22, 0xFE	; 254
    6e98:	7f 4f       	sbci	r23, 0xFF	; 255
    6e9a:	ce 01       	movw	r24, r28
    6e9c:	01 96       	adiw	r24, 0x01	; 1
    6e9e:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    6ea2:	89 2b       	or	r24, r25
    6ea4:	f1 f4       	brne	.+60     	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
    6ea6:	d7 01       	movw	r26, r14
    6ea8:	a0 0f       	add	r26, r16
    6eaa:	b1 1f       	adc	r27, r17
    6eac:	e1 e0       	ldi	r30, 0x01	; 1
    6eae:	f0 e0       	ldi	r31, 0x00	; 0
    6eb0:	ec 0f       	add	r30, r28
    6eb2:	fd 1f       	adc	r31, r29
    6eb4:	e0 0f       	add	r30, r16
    6eb6:	f1 1f       	adc	r31, r17
    6eb8:	12 96       	adiw	r26, 0x02	; 2
    6eba:	9c 91       	ld	r25, X
    6ebc:	80 81       	ld	r24, Z
    6ebe:	89 27       	eor	r24, r25
    6ec0:	c8 22       	and	r12, r24
    6ec2:	79 f4       	brne	.+30     	; 0x6ee2 <MifareUltralightAppProcess+0x3d2>
            ) {
                DataPtr[0] = UidCL[0];
    6ec4:	39 81       	ldd	r19, Y+1	; 0x01
    6ec6:	f7 01       	movw	r30, r14
    6ec8:	30 83       	st	Z, r19
                DataPtr[1] = UidCL[1];
    6eca:	2a 81       	ldd	r18, Y+2	; 0x02
    6ecc:	21 83       	std	Z+1, r18	; 0x01
                DataPtr[2] = UidCL[2];
    6ece:	9b 81       	ldd	r25, Y+3	; 0x03
    6ed0:	92 83       	std	Z+2, r25	; 0x02
                DataPtr[3] = UidCL[3];
    6ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    6ed4:	83 83       	std	Z+3, r24	; 0x03
                DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    6ed6:	23 27       	eor	r18, r19
    6ed8:	92 27       	eor	r25, r18
    6eda:	89 27       	eor	r24, r25
    6edc:	84 83       	std	Z+4, r24	; 0x04

                *BitCount = ISO14443A_CL_FRAME_SIZE;
    6ede:	38 e2       	ldi	r19, 0x28	; 40
    6ee0:	01 c0       	rjmp	.+2      	; 0x6ee4 <MifareUltralightAppProcess+0x3d4>
            uint8_t mask = 0xFF >> (8 - CollisionBitCount);
            // Since the UidCL does not contain the BCC, we have to distinguish here
            if (
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
                ||
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    6ee2:	30 e0       	ldi	r19, 0x00	; 0
    6ee4:	20 e0       	ldi	r18, 0x00	; 0
    6ee6:	83 2f       	mov	r24, r19
    6ee8:	92 2f       	mov	r25, r18
    6eea:	11 c2       	rjmp	.+1058   	; 0x730e <MifareUltralightAppProcess+0x7fe>
            }
            break;

        case STATE_ACTIVE:
            /* Preserve incoming data length */
            ByteCount = (BitCount + 7) >> 3;
    6eec:	69 5f       	subi	r22, 0xF9	; 249
    6eee:	7f 4f       	sbci	r23, 0xFF	; 255
    6ef0:	83 e0       	ldi	r24, 0x03	; 3
    6ef2:	76 95       	lsr	r23
    6ef4:	67 95       	ror	r22
    6ef6:	8a 95       	dec	r24
    6ef8:	e1 f7       	brne	.-8      	; 0x6ef2 <MifareUltralightAppProcess+0x3e2>
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            }
            /* At the very least, there should be 3 bytes in the buffer. */
            if (ByteCount < (1 + ISO14443A_CRCA_SIZE)) {
    6efa:	63 30       	cpi	r22, 0x03	; 3
    6efc:	71 05       	cpc	r23, r1
    6efe:	08 f4       	brcc	.+2      	; 0x6f02 <MifareUltralightAppProcess+0x3f2>
    6f00:	77 ce       	rjmp	.-786    	; 0x6bf0 <MifareUltralightAppProcess+0xe0>
                State = STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            }
            /* All commands here have CRCA appended; verify it right away */
            ByteCount -= 2;
            if (!ISO14443ACheckCRCA(Buffer, ByteCount)) {
    6f02:	62 50       	subi	r22, 0x02	; 2
    6f04:	71 09       	sbc	r23, r1
    6f06:	c7 01       	movw	r24, r14
    6f08:	0e 94 8b 41 	call	0x8316	; 0x8316 <ISO14443ACheckCRCA>
    6f0c:	81 11       	cpse	r24, r1
    6f0e:	5b ce       	rjmp	.-842    	; 0x6bc6 <MifareUltralightAppProcess+0xb6>
                Buffer[0] = NAK_CRC_ERROR;
    6f10:	81 e0       	ldi	r24, 0x01	; 1
    6f12:	d9 c1       	rjmp	.+946    	; 0x72c6 <MifareUltralightAppProcess+0x7b6>
static uint16_t AppProcess(uint8_t *const Buffer, uint16_t ByteCount) {
    uint8_t Cmd = Buffer[0];

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
        ArmedForCompatWrite = false;
    6f14:	10 92 ed 2c 	sts	0x2CED, r1	; 0x802ced <ArmedForCompatWrite>

        //Handle MF ULC counter
        if (CompatWritePageAddress == MF_ULC_COUNTER_ADDRESS && Flavor == UL_C) {
    6f18:	60 91 ec 2c 	lds	r22, 0x2CEC	; 0x802cec <CompatWritePageAddress>
    6f1c:	69 32       	cpi	r22, 0x29	; 41
    6f1e:	e1 f4       	brne	.+56     	; 0x6f58 <MifareUltralightAppProcess+0x448>
    6f20:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <Flavor>
    6f24:	81 30       	cpi	r24, 0x01	; 1
    6f26:	c1 f4       	brne	.+48     	; 0x6f58 <MifareUltralightAppProcess+0x448>
            if (IncrementCounter(&Buffer[2])) {
    6f28:	c7 01       	movw	r24, r14
    6f2a:	02 96       	adiw	r24, 0x02	; 2
    6f2c:	12 dd       	rcall	.-1500   	; 0x6952 <IncrementCounter>
    6f2e:	88 23       	and	r24, r24
    6f30:	89 f0       	breq	.+34     	; 0x6f54 <MifareUltralightAppProcess+0x444>
                Buffer[0] = ACK_VALUE;
    6f32:	8a e0       	ldi	r24, 0x0A	; 10
    6f34:	e8 ce       	rjmp	.-560    	; 0x6d06 <MifareUltralightAppProcess+0x1f6>
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

    /* Handle EV0 commands */
    switch (Cmd) {
    6f36:	80 3a       	cpi	r24, 0xA0	; 160
    6f38:	09 f4       	brne	.+2      	; 0x6f3c <MifareUltralightAppProcess+0x42c>
    6f3a:	73 c0       	rjmp	.+230    	; 0x7022 <MifareUltralightAppProcess+0x512>
    6f3c:	82 3a       	cpi	r24, 0xA2	; 162
    6f3e:	09 f0       	breq	.+2      	; 0x6f42 <MifareUltralightAppProcess+0x432>
    6f40:	50 ce       	rjmp	.-864    	; 0x6be2 <MifareUltralightAppProcess+0xd2>
        }

        case CMD_WRITE: {
            /* This is a write command containing 4 bytes of data that
            * should be written to the given page address. */
            uint8_t PageAddress = Buffer[1];
    6f42:	d7 01       	movw	r26, r14
    6f44:	11 96       	adiw	r26, 0x01	; 1
    6f46:	1c 91       	ld	r17, X

            //Handle MF ULC counter
            if (PageAddress == MF_ULC_COUNTER_ADDRESS && Flavor == UL_C) {
    6f48:	19 32       	cpi	r17, 0x29	; 41
    6f4a:	09 f4       	brne	.+2      	; 0x6f4e <MifareUltralightAppProcess+0x43e>
    6f4c:	4b c0       	rjmp	.+150    	; 0x6fe4 <MifareUltralightAppProcess+0x4d4>
                    return NAK_FRAME_SIZE;
                }
            }

            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    6f4e:	12 30       	cpi	r17, 0x02	; 2
    6f50:	08 f0       	brcs	.+2      	; 0x6f54 <MifareUltralightAppProcess+0x444>
    6f52:	4d c0       	rjmp	.+154    	; 0x6fee <MifareUltralightAppProcess+0x4de>
        if (CompatWritePageAddress == MF_ULC_COUNTER_ADDRESS && Flavor == UL_C) {
            if (IncrementCounter(&Buffer[2])) {
                Buffer[0] = ACK_VALUE;
                return ACK_FRAME_SIZE;
            } else {
                Buffer[0] = NAK_INVALID_ARG;
    6f54:	f7 01       	movw	r30, r14
    6f56:	84 c1       	rjmp	.+776    	; 0x7260 <MifareUltralightAppProcess+0x750>
    /* Currently not implemented */
}

/* Perform access verification and commit data if passed */
static uint8_t AppWritePage(uint8_t PageAddress, uint8_t *const Buffer) {
    if (!ActiveConfiguration.ReadOnly) {
    6f58:	80 91 d4 2f 	lds	r24, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    6f5c:	81 11       	cpse	r24, r1
    6f5e:	e9 cf       	rjmp	.-46     	; 0x6f32 <MifareUltralightAppProcess+0x422>
        MemoryWriteBlock(Buffer, PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    6f60:	f4 e0       	ldi	r31, 0x04	; 4
    6f62:	6f 9f       	mul	r22, r31
    6f64:	b0 01       	movw	r22, r0
    6f66:	11 24       	eor	r1, r1
    6f68:	44 e0       	ldi	r20, 0x04	; 4
    6f6a:	50 e0       	ldi	r21, 0x00	; 0
    6f6c:	c7 01       	movw	r24, r14
    6f6e:	02 96       	adiw	r24, 0x02	; 2
    6f70:	55 c0       	rjmp	.+170    	; 0x701c <MifareUltralightAppProcess+0x50c>

    /* Handle EV0 commands */
    switch (Cmd) {

        case CMD_READ: {
            uint8_t PageAddress = Buffer[1];
    6f72:	f7 01       	movw	r30, r14
    6f74:	11 81       	ldd	r17, Z+1	; 0x01
            uint8_t PageLimit;
            uint8_t Offset;
            /* For EV1+ cards, ensure the wraparound is at the first protected page */
            if (Flavor >= UL_C && ReadAccessProtected && !Authenticated) {
    6f76:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <Flavor>
    6f7a:	88 23       	and	r24, r24
    6f7c:	69 f0       	breq	.+26     	; 0x6f98 <MifareUltralightAppProcess+0x488>
    6f7e:	90 91 e9 2c 	lds	r25, 0x2CE9	; 0x802ce9 <ReadAccessProtected>
    6f82:	99 23       	and	r25, r25
    6f84:	39 f0       	breq	.+14     	; 0x6f94 <MifareUltralightAppProcess+0x484>
    6f86:	90 91 eb 2c 	lds	r25, 0x2CEB	; 0x802ceb <Authenticated>
    6f8a:	91 11       	cpse	r25, r1
    6f8c:	03 c0       	rjmp	.+6      	; 0x6f94 <MifareUltralightAppProcess+0x484>
                PageLimit = FirstAuthenticatedPage;
    6f8e:	00 91 ea 2c 	lds	r16, 0x2CEA	; 0x802cea <FirstAuthenticatedPage>
    6f92:	06 c0       	rjmp	.+12     	; 0x6fa0 <MifareUltralightAppProcess+0x490>
            } else {
                if (Flavor == UL_C) PageLimit = MF_ULC_READ_MAX_PAGE; // For ULC make sure wraparound is at the first key page
    6f94:	81 30       	cpi	r24, 0x01	; 1
    6f96:	19 f0       	breq	.+6      	; 0x6f9e <MifareUltralightAppProcess+0x48e>
                else PageLimit = PageCount;
    6f98:	00 91 ee 2c 	lds	r16, 0x2CEE	; 0x802cee <PageCount>
    6f9c:	01 c0       	rjmp	.+2      	; 0x6fa0 <MifareUltralightAppProcess+0x490>
            uint8_t Offset;
            /* For EV1+ cards, ensure the wraparound is at the first protected page */
            if (Flavor >= UL_C && ReadAccessProtected && !Authenticated) {
                PageLimit = FirstAuthenticatedPage;
            } else {
                if (Flavor == UL_C) PageLimit = MF_ULC_READ_MAX_PAGE; // For ULC make sure wraparound is at the first key page
    6f9e:	0c e2       	ldi	r16, 0x2C	; 44
                else PageLimit = PageCount;
            }
            /* Validation */
            if (PageAddress >= PageLimit) {
    6fa0:	10 17       	cp	r17, r16
    6fa2:	c0 f6       	brcc	.-80     	; 0x6f54 <MifareUltralightAppProcess+0x444>
    6fa4:	c1 2c       	mov	r12, r1
    6fa6:	d1 2c       	mov	r13, r1
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            /* Read out, emulating the wraparound */
            for (Offset = 0; Offset < BYTES_PER_READ; Offset += 4) {
                MemoryReadBlock(&Buffer[Offset], PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    6fa8:	f4 e0       	ldi	r31, 0x04	; 4
    6faa:	1f 9f       	mul	r17, r31
    6fac:	b0 01       	movw	r22, r0
    6fae:	11 24       	eor	r1, r1
    6fb0:	44 e0       	ldi	r20, 0x04	; 4
    6fb2:	50 e0       	ldi	r21, 0x00	; 0
    6fb4:	c7 01       	movw	r24, r14
    6fb6:	8c 0d       	add	r24, r12
    6fb8:	9d 1d       	adc	r25, r13
    6fba:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                PageAddress++;
    6fbe:	1f 5f       	subi	r17, 0xFF	; 255
                if (PageAddress == PageLimit) {
    6fc0:	01 13       	cpse	r16, r17
    6fc2:	01 c0       	rjmp	.+2      	; 0x6fc6 <MifareUltralightAppProcess+0x4b6>
                    PageAddress = 0;
    6fc4:	10 e0       	ldi	r17, 0x00	; 0
    6fc6:	24 e0       	ldi	r18, 0x04	; 4
    6fc8:	c2 0e       	add	r12, r18
    6fca:	d1 1c       	adc	r13, r1
            if (PageAddress >= PageLimit) {
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            /* Read out, emulating the wraparound */
            for (Offset = 0; Offset < BYTES_PER_READ; Offset += 4) {
    6fcc:	80 e1       	ldi	r24, 0x10	; 16
    6fce:	c8 16       	cp	r12, r24
    6fd0:	d1 04       	cpc	r13, r1
    6fd2:	51 f7       	brne	.-44     	; 0x6fa8 <MifareUltralightAppProcess+0x498>
                PageAddress++;
                if (PageAddress == PageLimit) {
                    PageAddress = 0;
                }
            }
            ISO14443AAppendCRCA(Buffer, BYTES_PER_READ);
    6fd4:	60 e1       	ldi	r22, 0x10	; 16
    6fd6:	70 e0       	ldi	r23, 0x00	; 0
    6fd8:	c7 01       	movw	r24, r14
    6fda:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
            return (BYTES_PER_READ + ISO14443A_CRCA_SIZE) * 8;
    6fde:	80 e9       	ldi	r24, 0x90	; 144
    6fe0:	90 e0       	ldi	r25, 0x00	; 0
    6fe2:	95 c1       	rjmp	.+810    	; 0x730e <MifareUltralightAppProcess+0x7fe>
            /* This is a write command containing 4 bytes of data that
            * should be written to the given page address. */
            uint8_t PageAddress = Buffer[1];

            //Handle MF ULC counter
            if (PageAddress == MF_ULC_COUNTER_ADDRESS && Flavor == UL_C) {
    6fe4:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <Flavor>
    6fe8:	81 30       	cpi	r24, 0x01	; 1
    6fea:	09 f4       	brne	.+2      	; 0x6fee <MifareUltralightAppProcess+0x4de>
    6fec:	9d cf       	rjmp	.-198    	; 0x6f28 <MifareUltralightAppProcess+0x418>
                    return NAK_FRAME_SIZE;
                }
            }

            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    6fee:	80 91 ee 2c 	lds	r24, 0x2CEE	; 0x802cee <PageCount>
    6ff2:	18 17       	cp	r17, r24
    6ff4:	08 f0       	brcs	.+2      	; 0x6ff8 <MifareUltralightAppProcess+0x4e8>
    6ff6:	ae cf       	rjmp	.-164    	; 0x6f54 <MifareUltralightAppProcess+0x444>
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    6ff8:	81 2f       	mov	r24, r17
    6ffa:	62 dc       	rcall	.-1852   	; 0x68c0 <VerifyAuthentication>
    6ffc:	81 11       	cpse	r24, r1
    6ffe:	02 c0       	rjmp	.+4      	; 0x7004 <MifareUltralightAppProcess+0x4f4>
                Buffer[0] = NAK_AUTH_REQUIRED;
    7000:	86 e0       	ldi	r24, 0x06	; 6
    7002:	61 c1       	rjmp	.+706    	; 0x72c6 <MifareUltralightAppProcess+0x7b6>
                return NAK_FRAME_SIZE;
            }
            AppWritePage(PageAddress, &Buffer[2]);
    7004:	c7 01       	movw	r24, r14
    7006:	02 96       	adiw	r24, 0x02	; 2
    /* Currently not implemented */
}

/* Perform access verification and commit data if passed */
static uint8_t AppWritePage(uint8_t PageAddress, uint8_t *const Buffer) {
    if (!ActiveConfiguration.ReadOnly) {
    7008:	20 91 d4 2f 	lds	r18, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    700c:	21 11       	cpse	r18, r1
    700e:	91 cf       	rjmp	.-222    	; 0x6f32 <MifareUltralightAppProcess+0x422>
        MemoryWriteBlock(Buffer, PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    7010:	f4 e0       	ldi	r31, 0x04	; 4
    7012:	1f 9f       	mul	r17, r31
    7014:	b0 01       	movw	r22, r0
    7016:	11 24       	eor	r1, r1
    7018:	44 e0       	ldi	r20, 0x04	; 4
    701a:	50 e0       	ldi	r21, 0x00	; 0
    701c:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    7020:	88 cf       	rjmp	.-240    	; 0x6f32 <MifareUltralightAppProcess+0x422>
            Buffer[0] = ACK_VALUE;
            return ACK_FRAME_SIZE;
        }

        case CMD_COMPAT_WRITE: {
            uint8_t PageAddress = Buffer[1];
    7022:	d7 01       	movw	r26, r14
    7024:	11 96       	adiw	r26, 0x01	; 1
    7026:	1c 91       	ld	r17, X
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    7028:	12 30       	cpi	r17, 0x02	; 2
    702a:	08 f4       	brcc	.+2      	; 0x702e <MifareUltralightAppProcess+0x51e>
    702c:	93 cf       	rjmp	.-218    	; 0x6f54 <MifareUltralightAppProcess+0x444>
    702e:	80 91 ee 2c 	lds	r24, 0x2CEE	; 0x802cee <PageCount>
    7032:	18 17       	cp	r17, r24
    7034:	08 f0       	brcs	.+2      	; 0x7038 <MifareUltralightAppProcess+0x528>
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    7036:	8e cf       	rjmp	.-228    	; 0x6f54 <MifareUltralightAppProcess+0x444>
    7038:	81 2f       	mov	r24, r17
    703a:	42 dc       	rcall	.-1916   	; 0x68c0 <VerifyAuthentication>
    703c:	88 23       	and	r24, r24
    703e:	01 f3       	breq	.-64     	; 0x7000 <MifareUltralightAppProcess+0x4f0>
                Buffer[0] = NAK_AUTH_REQUIRED;
                return NAK_FRAME_SIZE;
            }
            /* CRC check passed and page-address is within bounds.
            * Store address and proceed to receiving the data. */
            CompatWritePageAddress = PageAddress;
    7040:	10 93 ec 2c 	sts	0x2CEC, r17	; 0x802cec <CompatWritePageAddress>
            ArmedForCompatWrite = true;
    7044:	81 e0       	ldi	r24, 0x01	; 1
    7046:	80 93 ed 2c 	sts	0x2CED, r24	; 0x802ced <ArmedForCompatWrite>
    704a:	3c c1       	rjmp	.+632    	; 0x72c4 <MifareUltralightAppProcess+0x7b4>
        }
        default:
            break;
    }
    if (Flavor == UL_C) {
        if (Cmd == CMD_ULC_AUTH) {
    704c:	8a 31       	cpi	r24, 0x1A	; 26
    704e:	09 f0       	breq	.+2      	; 0x7052 <MifareUltralightAppProcess+0x542>
    7050:	cf cd       	rjmp	.-1122   	; 0x6bf0 <MifareUltralightAppProcess+0xe0>
            State = STATE_AUTH;
    7052:	86 e0       	ldi	r24, 0x06	; 6
    7054:	80 93 f0 2c 	sts	0x2CF0, r24	; 0x802cf0 <State>

            RandomGetBuffer(RNDBBuff, 8); // Get Random Number
    7058:	68 e0       	ldi	r22, 0x08	; 8
    705a:	81 ee       	ldi	r24, 0xE1	; 225
    705c:	9c e2       	ldi	r25, 0x2C	; 44
    705e:	0e 94 18 11 	call	0x2230	; 0x2230 <RandomGetBuffer>
            memset(InitialVector, 0, 8);  // initialize InitialVector
    7062:	88 e0       	ldi	r24, 0x08	; 8
    7064:	e9 ed       	ldi	r30, 0xD9	; 217
    7066:	fc e2       	ldi	r31, 0x2C	; 44
    7068:	df 01       	movw	r26, r30
    706a:	1d 92       	st	X+, r1
    706c:	8a 95       	dec	r24
    706e:	e9 f7       	brne	.-6      	; 0x706a <MifareUltralightAppProcess+0x55a>
            CryptoEncrypt2KTDEA_CBCSend(1, RNDBBuff, &Buffer[1], InitialVector, TripleDesKey); // Crypt
    7070:	a7 01       	movw	r20, r14
    7072:	4f 5f       	subi	r20, 0xFF	; 255
    7074:	5f 4f       	sbci	r21, 0xFF	; 255
    7076:	09 ec       	ldi	r16, 0xC9	; 201
    7078:	1c e2       	ldi	r17, 0x2C	; 44
    707a:	9f 01       	movw	r18, r30
    707c:	61 ee       	ldi	r22, 0xE1	; 225
    707e:	7c e2       	ldi	r23, 0x2C	; 44
    7080:	81 e0       	ldi	r24, 0x01	; 1
    7082:	90 e0       	ldi	r25, 0x00	; 0
    7084:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <CryptoEncrypt2KTDEA_CBCSend>

            Buffer [0] = CMD_ULC_AUTH_2 ;
    7088:	8f ea       	ldi	r24, 0xAF	; 175
    708a:	f7 01       	movw	r30, r14
    708c:	80 83       	st	Z, r24
            ISO14443AAppendCRCA(Buffer, 9);
    708e:	69 e0       	ldi	r22, 0x09	; 9
    7090:	70 e0       	ldi	r23, 0x00	; 0
    7092:	c7 01       	movw	r24, r14
    7094:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
    7098:	2f ce       	rjmp	.-930    	; 0x6cf8 <MifareUltralightAppProcess+0x1e8>
            return (9 + ISO14443A_CRCA_SIZE) * 8;
        }
    }
    /* Handle EV1 commands */
    if (Flavor >= UL_EV1) {
        switch (Cmd) {
    709a:	8c 33       	cpi	r24, 0x3C	; 60
    709c:	09 f4       	brne	.+2      	; 0x70a0 <MifareUltralightAppProcess+0x590>
    709e:	16 c1       	rjmp	.+556    	; 0x72cc <MifareUltralightAppProcess+0x7bc>
    70a0:	48 f4       	brcc	.+18     	; 0x70b4 <MifareUltralightAppProcess+0x5a4>
    70a2:	89 33       	cpi	r24, 0x39	; 57
    70a4:	09 f4       	brne	.+2      	; 0x70a8 <MifareUltralightAppProcess+0x598>
    70a6:	ae c0       	rjmp	.+348    	; 0x7204 <MifareUltralightAppProcess+0x6f4>
    70a8:	8a 33       	cpi	r24, 0x3A	; 58
    70aa:	d9 f1       	breq	.+118    	; 0x7122 <MifareUltralightAppProcess+0x612>
    70ac:	8b 31       	cpi	r24, 0x1B	; 27
    70ae:	09 f0       	breq	.+2      	; 0x70b2 <MifareUltralightAppProcess+0x5a2>
    70b0:	9f cd       	rjmp	.-1218   	; 0x6bf0 <MifareUltralightAppProcess+0xe0>
    70b2:	75 c0       	rjmp	.+234    	; 0x719e <MifareUltralightAppProcess+0x68e>
    70b4:	8b 34       	cpi	r24, 0x4B	; 75
    70b6:	09 f4       	brne	.+2      	; 0x70ba <MifareUltralightAppProcess+0x5aa>
    70b8:	17 c1       	rjmp	.+558    	; 0x72e8 <MifareUltralightAppProcess+0x7d8>
    70ba:	38 f4       	brcc	.+14     	; 0x70ca <MifareUltralightAppProcess+0x5ba>
    70bc:	8e 33       	cpi	r24, 0x3E	; 62
    70be:	09 f0       	breq	.+2      	; 0x70c2 <MifareUltralightAppProcess+0x5b2>
    70c0:	97 cd       	rjmp	.-1234   	; 0x6bf0 <MifareUltralightAppProcess+0xe0>
                ISO14443AAppendCRCA(Buffer, SIGNATURE_LENGTH);
                return (SIGNATURE_LENGTH + ISO14443A_CRCA_SIZE) * 8;

            case CMD_CHECK_TEARING_EVENT:
                /* Hardcoded response */
                Buffer[0] = 0xBD;
    70c2:	8d eb       	ldi	r24, 0xBD	; 189
    70c4:	d7 01       	movw	r26, r14
    70c6:	8c 93       	st	X, r24
    70c8:	1c c1       	rjmp	.+568    	; 0x7302 <MifareUltralightAppProcess+0x7f2>
            return (9 + ISO14443A_CRCA_SIZE) * 8;
        }
    }
    /* Handle EV1 commands */
    if (Flavor >= UL_EV1) {
        switch (Cmd) {
    70ca:	80 36       	cpi	r24, 0x60	; 96
    70cc:	21 f0       	breq	.+8      	; 0x70d6 <MifareUltralightAppProcess+0x5c6>
    70ce:	85 3a       	cpi	r24, 0xA5	; 165
    70d0:	09 f4       	brne	.+2      	; 0x70d4 <MifareUltralightAppProcess+0x5c4>
    70d2:	b3 c0       	rjmp	.+358    	; 0x723a <MifareUltralightAppProcess+0x72a>
    70d4:	8d cd       	rjmp	.-1254   	; 0x6bf0 <MifareUltralightAppProcess+0xe0>

            case CMD_GET_VERSION: {
                /* Provide hardcoded version response */
                Buffer[0] = 0x00;
    70d6:	d7 01       	movw	r26, r14
    70d8:	1c 92       	st	X, r1
                Buffer[1] = 0x04;
    70da:	84 e0       	ldi	r24, 0x04	; 4
    70dc:	11 96       	adiw	r26, 0x01	; 1
    70de:	8c 93       	st	X, r24
    70e0:	11 97       	sbiw	r26, 0x01	; 1
                Buffer[2] = 0x03;
    70e2:	83 e0       	ldi	r24, 0x03	; 3
    70e4:	12 96       	adiw	r26, 0x02	; 2
    70e6:	8c 93       	st	X, r24
    70e8:	12 97       	sbiw	r26, 0x02	; 2
                Buffer[3] = 0x01; /**/
    70ea:	81 e0       	ldi	r24, 0x01	; 1
    70ec:	13 96       	adiw	r26, 0x03	; 3
    70ee:	8c 93       	st	X, r24
    70f0:	13 97       	sbiw	r26, 0x03	; 3
                Buffer[4] = 0x01;
    70f2:	14 96       	adiw	r26, 0x04	; 4
    70f4:	8c 93       	st	X, r24
    70f6:	14 97       	sbiw	r26, 0x04	; 4
                Buffer[5] = 0x00;
    70f8:	15 96       	adiw	r26, 0x05	; 5
    70fa:	1c 92       	st	X, r1
                Buffer[6] = PageCount == MIFARE_ULTRALIGHT_EV11_PAGES ? 0x0B : 0x0E;
    70fc:	80 91 ee 2c 	lds	r24, 0x2CEE	; 0x802cee <PageCount>
    7100:	84 31       	cpi	r24, 0x14	; 20
    7102:	11 f0       	breq	.+4      	; 0x7108 <MifareUltralightAppProcess+0x5f8>
    7104:	8e e0       	ldi	r24, 0x0E	; 14
    7106:	01 c0       	rjmp	.+2      	; 0x710a <MifareUltralightAppProcess+0x5fa>
    7108:	8b e0       	ldi	r24, 0x0B	; 11
    710a:	f7 01       	movw	r30, r14
    710c:	86 83       	std	Z+6, r24	; 0x06
                Buffer[7] = 0x03;
    710e:	83 e0       	ldi	r24, 0x03	; 3
    7110:	87 83       	std	Z+7, r24	; 0x07
                ISO14443AAppendCRCA(Buffer, VERSION_INFO_LENGTH);
    7112:	68 e0       	ldi	r22, 0x08	; 8
    7114:	70 e0       	ldi	r23, 0x00	; 0
    7116:	c7 01       	movw	r24, r14
    7118:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                return (VERSION_INFO_LENGTH + ISO14443A_CRCA_SIZE) * 8;
    711c:	80 e5       	ldi	r24, 0x50	; 80
    711e:	90 e0       	ldi	r25, 0x00	; 0
    7120:	f6 c0       	rjmp	.+492    	; 0x730e <MifareUltralightAppProcess+0x7fe>
            }

            case CMD_FAST_READ: {
                uint8_t StartPageAddress = Buffer[1];
    7122:	d7 01       	movw	r26, r14
    7124:	11 96       	adiw	r26, 0x01	; 1
    7126:	dc 90       	ld	r13, X
    7128:	11 97       	sbiw	r26, 0x01	; 1
                uint8_t EndPageAddress = Buffer[2];
    712a:	12 96       	adiw	r26, 0x02	; 2
    712c:	0c 91       	ld	r16, X
                /* Validation */
                if ((StartPageAddress > EndPageAddress) || (StartPageAddress >= PageCount) || (EndPageAddress >= PageCount)) {
    712e:	0d 15       	cp	r16, r13
    7130:	08 f4       	brcc	.+2      	; 0x7134 <MifareUltralightAppProcess+0x624>
    7132:	10 cf       	rjmp	.-480    	; 0x6f54 <MifareUltralightAppProcess+0x444>
    7134:	80 91 ee 2c 	lds	r24, 0x2CEE	; 0x802cee <PageCount>
    7138:	d8 16       	cp	r13, r24
    713a:	08 f0       	brcs	.+2      	; 0x713e <MifareUltralightAppProcess+0x62e>
    713c:	0b cf       	rjmp	.-490    	; 0x6f54 <MifareUltralightAppProcess+0x444>
    713e:	08 17       	cp	r16, r24
    7140:	08 f0       	brcs	.+2      	; 0x7144 <MifareUltralightAppProcess+0x634>
    7142:	08 cf       	rjmp	.-496    	; 0x6f54 <MifareUltralightAppProcess+0x444>
                    Buffer[0] = NAK_INVALID_ARG;
                    return NAK_FRAME_SIZE;
                }
                /* Check authentication only if protection is read&write */
                if (ReadAccessProtected) {
    7144:	80 91 e9 2c 	lds	r24, 0x2CE9	; 0x802ce9 <ReadAccessProtected>
    7148:	88 23       	and	r24, r24
                    if (!VerifyAuthentication(StartPageAddress) || !VerifyAuthentication(EndPageAddress)) {
    714a:	51 f0       	breq	.+20     	; 0x7160 <MifareUltralightAppProcess+0x650>
    714c:	8d 2d       	mov	r24, r13
    714e:	b8 db       	rcall	.-2192   	; 0x68c0 <VerifyAuthentication>
    7150:	88 23       	and	r24, r24
    7152:	09 f4       	brne	.+2      	; 0x7156 <MifareUltralightAppProcess+0x646>
    7154:	55 cf       	rjmp	.-342    	; 0x7000 <MifareUltralightAppProcess+0x4f0>
    7156:	80 2f       	mov	r24, r16
    7158:	b3 db       	rcall	.-2202   	; 0x68c0 <VerifyAuthentication>
    715a:	88 23       	and	r24, r24
    715c:	09 f4       	brne	.+2      	; 0x7160 <MifareUltralightAppProcess+0x650>
    715e:	50 cf       	rjmp	.-352    	; 0x7000 <MifareUltralightAppProcess+0x4f0>
                        Buffer[0] = NAK_AUTH_REQUIRED;
                        return NAK_FRAME_SIZE;
                    }
                }
                /* NOTE: With the current implementation, reading the password out is possible. */
                ByteCount = (EndPageAddress - StartPageAddress + 1) * MIFARE_ULTRALIGHT_PAGE_SIZE;
    7160:	10 e0       	ldi	r17, 0x00	; 0
    7162:	6d 2d       	mov	r22, r13
    7164:	70 e0       	ldi	r23, 0x00	; 0
    7166:	06 1b       	sub	r16, r22
    7168:	17 0b       	sbc	r17, r23
    716a:	0f 5f       	subi	r16, 0xFF	; 255
    716c:	1f 4f       	sbci	r17, 0xFF	; 255
    716e:	00 0f       	add	r16, r16
    7170:	11 1f       	adc	r17, r17
    7172:	00 0f       	add	r16, r16
    7174:	11 1f       	adc	r17, r17
                MemoryReadBlock(Buffer, StartPageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, ByteCount);
    7176:	66 0f       	add	r22, r22
    7178:	77 1f       	adc	r23, r23
    717a:	66 0f       	add	r22, r22
    717c:	77 1f       	adc	r23, r23
    717e:	a8 01       	movw	r20, r16
    7180:	c7 01       	movw	r24, r14
    7182:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, ByteCount);
    7186:	b8 01       	movw	r22, r16
    7188:	c7 01       	movw	r24, r14
    718a:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                return (ByteCount + ISO14443A_CRCA_SIZE) * 8;
    718e:	c8 01       	movw	r24, r16
    7190:	02 96       	adiw	r24, 0x02	; 2
    7192:	a3 e0       	ldi	r26, 0x03	; 3
    7194:	88 0f       	add	r24, r24
    7196:	99 1f       	adc	r25, r25
    7198:	aa 95       	dec	r26
    719a:	e1 f7       	brne	.-8      	; 0x7194 <MifareUltralightAppProcess+0x684>
    719c:	b8 c0       	rjmp	.+368    	; 0x730e <MifareUltralightAppProcess+0x7fe>
                    /* Too many failed attempts */
                    Buffer[0] = NAK_AUTH_FAILED;
                    return NAK_FRAME_SIZE;
                }
                /* Read and compare the password */
                MemoryReadBlock(Password, ConfigAreaAddress + CONF_PASSWORD_OFFSET, 4);
    719e:	00 91 ee 2c 	lds	r16, 0x2CEE	; 0x802cee <PageCount>
    71a2:	00 0f       	add	r16, r16
    71a4:	00 0f       	add	r16, r16
    71a6:	00 51       	subi	r16, 0x10	; 16
    71a8:	10 e0       	ldi	r17, 0x00	; 0
    71aa:	b8 01       	movw	r22, r16
    71ac:	68 5f       	subi	r22, 0xF8	; 248
    71ae:	7f 4f       	sbci	r23, 0xFF	; 255
    71b0:	44 e0       	ldi	r20, 0x04	; 4
    71b2:	50 e0       	ldi	r21, 0x00	; 0
    71b4:	ce 01       	movw	r24, r28
    71b6:	01 96       	adiw	r24, 0x01	; 1
    71b8:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                if (Password[0] != Buffer[1] || Password[1] != Buffer[2] || Password[2] != Buffer[3] || Password[3] != Buffer[4]) {
    71bc:	99 81       	ldd	r25, Y+1	; 0x01
    71be:	f7 01       	movw	r30, r14
    71c0:	81 81       	ldd	r24, Z+1	; 0x01
    71c2:	98 13       	cpse	r25, r24
    71c4:	9f cd       	rjmp	.-1218   	; 0x6d04 <MifareUltralightAppProcess+0x1f4>
    71c6:	9a 81       	ldd	r25, Y+2	; 0x02
    71c8:	82 81       	ldd	r24, Z+2	; 0x02
    71ca:	98 13       	cpse	r25, r24
    71cc:	9b cd       	rjmp	.-1226   	; 0x6d04 <MifareUltralightAppProcess+0x1f4>
    71ce:	9b 81       	ldd	r25, Y+3	; 0x03
    71d0:	83 81       	ldd	r24, Z+3	; 0x03
    71d2:	98 13       	cpse	r25, r24
    71d4:	97 cd       	rjmp	.-1234   	; 0x6d04 <MifareUltralightAppProcess+0x1f4>
    71d6:	9c 81       	ldd	r25, Y+4	; 0x04
    71d8:	84 81       	ldd	r24, Z+4	; 0x04
    71da:	98 13       	cpse	r25, r24
    71dc:	93 cd       	rjmp	.-1242   	; 0x6d04 <MifareUltralightAppProcess+0x1f4>
                    Buffer[0] = NAK_AUTH_FAILED;
                    return NAK_FRAME_SIZE;
                }
                /* Authenticate the user */
                AuthCounterReset();
                Authenticated = 1;
    71de:	81 e0       	ldi	r24, 0x01	; 1
    71e0:	80 93 eb 2c 	sts	0x2CEB, r24	; 0x802ceb <Authenticated>
                /* Send the PACK value back */
                MemoryReadBlock(Buffer, ConfigAreaAddress + CONF_PACK_OFFSET, 2);
    71e4:	b8 01       	movw	r22, r16
    71e6:	64 5f       	subi	r22, 0xF4	; 244
    71e8:	7f 4f       	sbci	r23, 0xFF	; 255
    71ea:	42 e0       	ldi	r20, 0x02	; 2
    71ec:	50 e0       	ldi	r21, 0x00	; 0
    71ee:	c7 01       	movw	r24, r14
    71f0:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, 2);
    71f4:	62 e0       	ldi	r22, 0x02	; 2
    71f6:	70 e0       	ldi	r23, 0x00	; 0
    71f8:	c7 01       	movw	r24, r14
    71fa:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                return (2 + ISO14443A_CRCA_SIZE) * 8;
    71fe:	80 e2       	ldi	r24, 0x20	; 32
    7200:	90 e0       	ldi	r25, 0x00	; 0
    7202:	85 c0       	rjmp	.+266    	; 0x730e <MifareUltralightAppProcess+0x7fe>
            }

            case CMD_READ_CNT: {
                uint8_t CounterId = Buffer[1];
    7204:	f7 01       	movw	r30, r14
    7206:	61 81       	ldd	r22, Z+1	; 0x01
                /* Validation */
                if (CounterId > CNT_MAX) {
    7208:	63 30       	cpi	r22, 0x03	; 3
    720a:	08 f0       	brcs	.+2      	; 0x720e <MifareUltralightAppProcess+0x6fe>
    720c:	a3 ce       	rjmp	.-698    	; 0x6f54 <MifareUltralightAppProcess+0x444>
                    Buffer[0] = NAK_INVALID_ARG;
                    return NAK_FRAME_SIZE;
                }
                /* Returned counter length is 3 bytes */
                MemoryReadBlock(Buffer, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, 3);
    720e:	80 91 ee 2c 	lds	r24, 0x2CEE	; 0x802cee <PageCount>
    7212:	70 e0       	ldi	r23, 0x00	; 0
    7214:	68 0f       	add	r22, r24
    7216:	71 1d       	adc	r23, r1
    7218:	66 0f       	add	r22, r22
    721a:	77 1f       	adc	r23, r23
    721c:	66 0f       	add	r22, r22
    721e:	77 1f       	adc	r23, r23
    7220:	43 e0       	ldi	r20, 0x03	; 3
    7222:	50 e0       	ldi	r21, 0x00	; 0
    7224:	c7 01       	movw	r24, r14
    7226:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, 3);
    722a:	63 e0       	ldi	r22, 0x03	; 3
    722c:	70 e0       	ldi	r23, 0x00	; 0
    722e:	c7 01       	movw	r24, r14
    7230:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                return (3 + ISO14443A_CRCA_SIZE) * 8;
    7234:	88 e2       	ldi	r24, 0x28	; 40
    7236:	90 e0       	ldi	r25, 0x00	; 0
    7238:	6a c0       	rjmp	.+212    	; 0x730e <MifareUltralightAppProcess+0x7fe>
            }

            case CMD_INCREMENT_CNT: {
                uint8_t CounterId = Buffer[1];
    723a:	d7 01       	movw	r26, r14
    723c:	11 96       	adiw	r26, 0x01	; 1
    723e:	2c 91       	ld	r18, X
                uint32_t Addend = (Buffer[0]) | (Buffer[1] << 8) | ((uint32_t)Buffer[2] << 16);
    7240:	02 2f       	mov	r16, r18
    7242:	10 e0       	ldi	r17, 0x00	; 0
    7244:	90 2f       	mov	r25, r16
    7246:	88 27       	eor	r24, r24
    7248:	85 6a       	ori	r24, 0xA5	; 165
    724a:	09 2e       	mov	r0, r25
    724c:	00 0c       	add	r0, r0
    724e:	aa 0b       	sbc	r26, r26
    7250:	bb 0b       	sbc	r27, r27
    7252:	f7 01       	movw	r30, r14
    7254:	32 81       	ldd	r19, Z+2	; 0x02
    7256:	4c 01       	movw	r8, r24
    7258:	5d 01       	movw	r10, r26
    725a:	a3 2a       	or	r10, r19
                uint32_t Counter;
                /* Validation */
                if (CounterId > CNT_MAX) {
    725c:	23 30       	cpi	r18, 0x03	; 3
    725e:	10 f0       	brcs	.+4      	; 0x7264 <MifareUltralightAppProcess+0x754>
                    Buffer[0] = NAK_INVALID_ARG;
    7260:	10 82       	st	Z, r1
    7262:	53 cd       	rjmp	.-1370   	; 0x6d0a <MifareUltralightAppProcess+0x1fa>
                    return NAK_FRAME_SIZE;
                }
                /* Read the value out */
                MemoryReadBlock(&Counter, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    7264:	80 91 ee 2c 	lds	r24, 0x2CEE	; 0x802cee <PageCount>
    7268:	b8 01       	movw	r22, r16
    726a:	68 0f       	add	r22, r24
    726c:	71 1d       	adc	r23, r1
    726e:	66 0f       	add	r22, r22
    7270:	77 1f       	adc	r23, r23
    7272:	66 0f       	add	r22, r22
    7274:	77 1f       	adc	r23, r23
    7276:	44 e0       	ldi	r20, 0x04	; 4
    7278:	50 e0       	ldi	r21, 0x00	; 0
    727a:	ce 01       	movw	r24, r28
    727c:	01 96       	adiw	r24, 0x01	; 1
    727e:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                /* Add and check for overflow */
                Counter += Addend;
    7282:	89 81       	ldd	r24, Y+1	; 0x01
    7284:	9a 81       	ldd	r25, Y+2	; 0x02
    7286:	ab 81       	ldd	r26, Y+3	; 0x03
    7288:	bc 81       	ldd	r27, Y+4	; 0x04
    728a:	88 0d       	add	r24, r8
    728c:	99 1d       	adc	r25, r9
    728e:	aa 1d       	adc	r26, r10
    7290:	bb 1d       	adc	r27, r11
    7292:	89 83       	std	Y+1, r24	; 0x01
    7294:	9a 83       	std	Y+2, r25	; 0x02
    7296:	ab 83       	std	Y+3, r26	; 0x03
    7298:	bc 83       	std	Y+4, r27	; 0x04
                if (Counter > CNT_MAX_VALUE) {
    729a:	00 97       	sbiw	r24, 0x00	; 0
    729c:	a1 05       	cpc	r26, r1
    729e:	b1 40       	sbci	r27, 0x01	; 1
    72a0:	10 f0       	brcs	.+4      	; 0x72a6 <MifareUltralightAppProcess+0x796>
                    Buffer[0] = NAK_CTR_ERROR;
    72a2:	84 e0       	ldi	r24, 0x04	; 4
    72a4:	30 cd       	rjmp	.-1440   	; 0x6d06 <MifareUltralightAppProcess+0x1f6>
                    return NAK_FRAME_SIZE;
                }
                /* Update memory */
                MemoryWriteBlock(&Counter, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    72a6:	80 91 ee 2c 	lds	r24, 0x2CEE	; 0x802cee <PageCount>
    72aa:	b8 01       	movw	r22, r16
    72ac:	68 0f       	add	r22, r24
    72ae:	71 1d       	adc	r23, r1
    72b0:	66 0f       	add	r22, r22
    72b2:	77 1f       	adc	r23, r23
    72b4:	66 0f       	add	r22, r22
    72b6:	77 1f       	adc	r23, r23
    72b8:	44 e0       	ldi	r20, 0x04	; 4
    72ba:	50 e0       	ldi	r21, 0x00	; 0
    72bc:	ce 01       	movw	r24, r28
    72be:	01 96       	adiw	r24, 0x01	; 1
    72c0:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
                Buffer[0] = ACK_VALUE;
    72c4:	8a e0       	ldi	r24, 0x0A	; 10
    72c6:	f7 01       	movw	r30, r14
    72c8:	80 83       	st	Z, r24
    72ca:	1f cd       	rjmp	.-1474   	; 0x6d0a <MifareUltralightAppProcess+0x1fa>
                return ACK_FRAME_SIZE;
            }

            case CMD_READ_SIG:
                /* Hardcoded response */
                memset(Buffer, 0xCA, SIGNATURE_LENGTH);
    72cc:	40 e2       	ldi	r20, 0x20	; 32
    72ce:	50 e0       	ldi	r21, 0x00	; 0
    72d0:	6a ec       	ldi	r22, 0xCA	; 202
    72d2:	70 e0       	ldi	r23, 0x00	; 0
    72d4:	c7 01       	movw	r24, r14
    72d6:	0e 94 ba 78 	call	0xf174	; 0xf174 <memset>
                ISO14443AAppendCRCA(Buffer, SIGNATURE_LENGTH);
    72da:	60 e2       	ldi	r22, 0x20	; 32
    72dc:	70 e0       	ldi	r23, 0x00	; 0
    72de:	c7 01       	movw	r24, r14
    72e0:	ef d7       	rcall	.+4062   	; 0x82c0 <ISO14443AAppendCRCA>
                return (SIGNATURE_LENGTH + ISO14443A_CRCA_SIZE) * 8;
    72e2:	80 e1       	ldi	r24, 0x10	; 16
    72e4:	91 e0       	ldi	r25, 0x01	; 1
    72e6:	13 c0       	rjmp	.+38     	; 0x730e <MifareUltralightAppProcess+0x7fe>

            case CMD_VCSL: {
                uint8_t ConfigAreaAddress = PageCount * MIFARE_ULTRALIGHT_PAGE_SIZE - CONFIG_AREA_SIZE;
                /* Input is ignored completely */
                /* Read out the value */
                MemoryReadBlock(Buffer, ConfigAreaAddress + CONF_VCTID_OFFSET, 1);
    72e8:	60 91 ee 2c 	lds	r22, 0x2CEE	; 0x802cee <PageCount>
    72ec:	66 0f       	add	r22, r22
    72ee:	66 0f       	add	r22, r22
    72f0:	60 51       	subi	r22, 0x10	; 16
    72f2:	70 e0       	ldi	r23, 0x00	; 0
    72f4:	6b 5f       	subi	r22, 0xFB	; 251
    72f6:	7f 4f       	sbci	r23, 0xFF	; 255
    72f8:	41 e0       	ldi	r20, 0x01	; 1
    72fa:	50 e0       	ldi	r21, 0x00	; 0
    72fc:	c7 01       	movw	r24, r14
    72fe:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, 1);
    7302:	61 e0       	ldi	r22, 0x01	; 1
    7304:	70 e0       	ldi	r23, 0x00	; 0
    7306:	c7 01       	movw	r24, r14
    7308:	db d7       	rcall	.+4022   	; 0x82c0 <ISO14443AAppendCRCA>
                return (1 + ISO14443A_CRCA_SIZE) * 8;
    730a:	88 e1       	ldi	r24, 0x18	; 24
    730c:	90 e0       	ldi	r25, 0x00	; 0
            break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
}
    730e:	60 96       	adiw	r28, 0x10	; 16
    7310:	cd bf       	out	0x3d, r28	; 61
    7312:	de bf       	out	0x3e, r29	; 62
    7314:	df 91       	pop	r29
    7316:	cf 91       	pop	r28
    7318:	1f 91       	pop	r17
    731a:	0f 91       	pop	r16
    731c:	ff 90       	pop	r15
    731e:	ef 90       	pop	r14
    7320:	df 90       	pop	r13
    7322:	cf 90       	pop	r12
    7324:	bf 90       	pop	r11
    7326:	af 90       	pop	r10
    7328:	9f 90       	pop	r9
    732a:	8f 90       	pop	r8
    732c:	08 95       	ret

0000732e <MifareUltralightGetUid>:

void MifareUltralightGetUid(ConfigurationUidType Uid) {
    732e:	cf 93       	push	r28
    7330:	df 93       	push	r29
    7332:	ec 01       	movw	r28, r24
    /* Read UID from memory */
    MemoryReadBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    7334:	43 e0       	ldi	r20, 0x03	; 3
    7336:	50 e0       	ldi	r21, 0x00	; 0
    7338:	60 e0       	ldi	r22, 0x00	; 0
    733a:	70 e0       	ldi	r23, 0x00	; 0
    733c:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    MemoryReadBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    7340:	44 e0       	ldi	r20, 0x04	; 4
    7342:	50 e0       	ldi	r21, 0x00	; 0
    7344:	64 e0       	ldi	r22, 0x04	; 4
    7346:	70 e0       	ldi	r23, 0x00	; 0
    7348:	ce 01       	movw	r24, r28
    734a:	03 96       	adiw	r24, 0x03	; 3
}
    734c:	df 91       	pop	r29
    734e:	cf 91       	pop	r28
}

void MifareUltralightGetUid(ConfigurationUidType Uid) {
    /* Read UID from memory */
    MemoryReadBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    MemoryReadBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    7350:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

00007354 <MifareUltralightSetUid>:
}

void MifareUltralightSetUid(ConfigurationUidType Uid) {
    7354:	0f 93       	push	r16
    7356:	1f 93       	push	r17
    7358:	cf 93       	push	r28
    735a:	df 93       	push	r29
    735c:	1f 92       	push	r1
    735e:	1f 92       	push	r1
    7360:	cd b7       	in	r28, 0x3d	; 61
    7362:	de b7       	in	r29, 0x3e	; 62
    7364:	8c 01       	movw	r16, r24
    /* Calculate check bytes and write everything into memory */
    uint8_t BCC1 = ISO14443A_UID0_CT ^ Uid[0] ^ Uid[1] ^ Uid[2];
    7366:	fc 01       	movw	r30, r24
    7368:	90 81       	ld	r25, Z
    736a:	81 81       	ldd	r24, Z+1	; 0x01
    736c:	89 27       	eor	r24, r25
    736e:	98 e8       	ldi	r25, 0x88	; 136
    7370:	89 27       	eor	r24, r25
    7372:	92 81       	ldd	r25, Z+2	; 0x02
    7374:	89 27       	eor	r24, r25
    7376:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t BCC2 = Uid[3] ^ Uid[4] ^ Uid[5] ^ Uid[6];
    7378:	93 81       	ldd	r25, Z+3	; 0x03
    737a:	84 81       	ldd	r24, Z+4	; 0x04
    737c:	89 27       	eor	r24, r25
    737e:	95 81       	ldd	r25, Z+5	; 0x05
    7380:	89 27       	eor	r24, r25
    7382:	96 81       	ldd	r25, Z+6	; 0x06
    7384:	89 27       	eor	r24, r25
    7386:	89 83       	std	Y+1, r24	; 0x01

    MemoryWriteBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    7388:	43 e0       	ldi	r20, 0x03	; 3
    738a:	50 e0       	ldi	r21, 0x00	; 0
    738c:	60 e0       	ldi	r22, 0x00	; 0
    738e:	70 e0       	ldi	r23, 0x00	; 0
    7390:	c8 01       	movw	r24, r16
    7392:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    MemoryWriteBlock(&BCC1, UID_BCC1_ADDRESS, ISO14443A_CL_BCC_SIZE);
    7396:	41 e0       	ldi	r20, 0x01	; 1
    7398:	50 e0       	ldi	r21, 0x00	; 0
    739a:	63 e0       	ldi	r22, 0x03	; 3
    739c:	70 e0       	ldi	r23, 0x00	; 0
    739e:	ce 01       	movw	r24, r28
    73a0:	02 96       	adiw	r24, 0x02	; 2
    73a2:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    MemoryWriteBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    73a6:	44 e0       	ldi	r20, 0x04	; 4
    73a8:	50 e0       	ldi	r21, 0x00	; 0
    73aa:	64 e0       	ldi	r22, 0x04	; 4
    73ac:	70 e0       	ldi	r23, 0x00	; 0
    73ae:	c8 01       	movw	r24, r16
    73b0:	03 96       	adiw	r24, 0x03	; 3
    73b2:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    MemoryWriteBlock(&BCC2, UID_BCC2_ADDRESS, ISO14443A_CL_BCC_SIZE);
    73b6:	41 e0       	ldi	r20, 0x01	; 1
    73b8:	50 e0       	ldi	r21, 0x00	; 0
    73ba:	68 e0       	ldi	r22, 0x08	; 8
    73bc:	70 e0       	ldi	r23, 0x00	; 0
    73be:	ce 01       	movw	r24, r28
    73c0:	01 96       	adiw	r24, 0x01	; 1
    73c2:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
}
    73c6:	0f 90       	pop	r0
    73c8:	0f 90       	pop	r0
    73ca:	df 91       	pop	r29
    73cc:	cf 91       	pop	r28
    73ce:	1f 91       	pop	r17
    73d0:	0f 91       	pop	r16
    73d2:	08 95       	ret

000073d4 <MifareClassicAppInitMini4B>:
    Block[10] = Block[2];
    Block[11] = Block[3];
}

void MifareClassicAppInitMini4B(void) {
    State = STATE_IDLE;
    73d4:	81 e0       	ldi	r24, 0x01	; 1
    73d6:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    CardATQAValue = MFCLASSIC_MINI_4B_ATQA_VALUE;
    73da:	84 e0       	ldi	r24, 0x04	; 4
    73dc:	90 e0       	ldi	r25, 0x00	; 0
    73de:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <CardATQAValue>
    73e2:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <CardATQAValue+0x1>
    CardSAKValue = MFCLASSIC_MINI_4B_SAK_VALUE;
    73e6:	89 e0       	ldi	r24, 0x09	; 9
    73e8:	80 93 f3 2c 	sts	0x2CF3, r24	; 0x802cf3 <CardSAKValue>
    FromHalt = false;
    73ec:	10 92 f2 2c 	sts	0x2CF2, r1	; 0x802cf2 <FromHalt>
    73f0:	08 95       	ret

000073f2 <MifareClassicAppInit1K>:
}

void MifareClassicAppInit1K(void) {
    State = STATE_IDLE;
    73f2:	81 e0       	ldi	r24, 0x01	; 1
    73f4:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    CardATQAValue = MFCLASSIC_1K_ATQA_VALUE;
    73f8:	84 e0       	ldi	r24, 0x04	; 4
    73fa:	90 e0       	ldi	r25, 0x00	; 0
    73fc:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <CardATQAValue>
    7400:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <CardATQAValue+0x1>
    CardSAKValue = MFCLASSIC_1K_SAK_VALUE;
    7404:	88 e0       	ldi	r24, 0x08	; 8
    7406:	80 93 f3 2c 	sts	0x2CF3, r24	; 0x802cf3 <CardSAKValue>
    FromHalt = false;
    740a:	10 92 f2 2c 	sts	0x2CF2, r1	; 0x802cf2 <FromHalt>
    740e:	08 95       	ret

00007410 <MifareClassicAppInit1K7B>:
}

void MifareClassicAppInit1K7B(void) {
    State = STATE_IDLE;
    7410:	81 e0       	ldi	r24, 0x01	; 1
    7412:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    CardATQAValue = MFCLASSIC_1K_7B_ATQA_VALUE;
    7416:	84 e4       	ldi	r24, 0x44	; 68
    7418:	90 e0       	ldi	r25, 0x00	; 0
    741a:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <CardATQAValue>
    741e:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <CardATQAValue+0x1>
    CardSAKValue = MFCLASSIC_1K_SAK_VALUE;
    7422:	88 e0       	ldi	r24, 0x08	; 8
    7424:	80 93 f3 2c 	sts	0x2CF3, r24	; 0x802cf3 <CardSAKValue>
    FromHalt = false;
    7428:	10 92 f2 2c 	sts	0x2CF2, r1	; 0x802cf2 <FromHalt>
    742c:	08 95       	ret

0000742e <MifareClassicAppInit4K>:
}


void MifareClassicAppInit4K(void) {
    State = STATE_IDLE;
    742e:	81 e0       	ldi	r24, 0x01	; 1
    7430:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    CardATQAValue = MFCLASSIC_4K_ATQA_VALUE;
    7434:	82 e0       	ldi	r24, 0x02	; 2
    7436:	90 e0       	ldi	r25, 0x00	; 0
    7438:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <CardATQAValue>
    743c:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <CardATQAValue+0x1>
    CardSAKValue = MFCLASSIC_4K_SAK_VALUE;
    7440:	88 e1       	ldi	r24, 0x18	; 24
    7442:	80 93 f3 2c 	sts	0x2CF3, r24	; 0x802cf3 <CardSAKValue>
    FromHalt = false;
    7446:	10 92 f2 2c 	sts	0x2CF2, r1	; 0x802cf2 <FromHalt>
    744a:	08 95       	ret

0000744c <MifareClassicAppInit4K7B>:
}

void MifareClassicAppInit4K7B(void) {
    State = STATE_IDLE;
    744c:	81 e0       	ldi	r24, 0x01	; 1
    744e:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    CardATQAValue = MFCLASSIC_4K_7B_ATQA_VALUE;
    7452:	82 e4       	ldi	r24, 0x42	; 66
    7454:	90 e0       	ldi	r25, 0x00	; 0
    7456:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <CardATQAValue>
    745a:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <CardATQAValue+0x1>
    CardSAKValue = MFCLASSIC_4K_SAK_VALUE;
    745e:	88 e1       	ldi	r24, 0x18	; 24
    7460:	80 93 f3 2c 	sts	0x2CF3, r24	; 0x802cf3 <CardSAKValue>
    FromHalt = false;
    7464:	10 92 f2 2c 	sts	0x2CF2, r1	; 0x802cf2 <FromHalt>
    7468:	08 95       	ret

0000746a <MifareClassicAppReset>:
}

void MifareClassicAppReset(void) {
    State = STATE_IDLE;
    746a:	81 e0       	ldi	r24, 0x01	; 1
    746c:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    7470:	08 95       	ret

00007472 <MifareClassicAppTask>:
}

void MifareClassicAppTask(void) {
    7472:	08 95       	ret

00007474 <MifareClassicAppProcess>:

}

uint16_t MifareClassicAppProcess(uint8_t *Buffer, uint16_t BitCount) {
    7474:	8f 92       	push	r8
    7476:	9f 92       	push	r9
    7478:	af 92       	push	r10
    747a:	bf 92       	push	r11
    747c:	cf 92       	push	r12
    747e:	df 92       	push	r13
    7480:	ef 92       	push	r14
    7482:	ff 92       	push	r15
    7484:	0f 93       	push	r16
    7486:	1f 93       	push	r17
    7488:	cf 93       	push	r28
    748a:	df 93       	push	r29
    748c:	cd b7       	in	r28, 0x3d	; 61
    748e:	de b7       	in	r29, 0x3e	; 62
    7490:	62 97       	sbiw	r28, 0x12	; 18
    7492:	cd bf       	out	0x3d, r28	; 61
    7494:	de bf       	out	0x3e, r29	; 62
    7496:	8c 01       	movw	r16, r24
    7498:	5b 01       	movw	r10, r22
    749a:	80 91 15 2d 	lds	r24, 0x2D15	; 0x802d15 <State>
    /* Wakeup and Request may occure in all states */
    if ((BitCount == 7) &&
    749e:	67 30       	cpi	r22, 0x07	; 7
    74a0:	71 05       	cpc	r23, r1
    74a2:	01 f5       	brne	.+64     	; 0x74e4 <MifareClassicAppProcess+0x70>
    74a4:	f8 01       	movw	r30, r16
    74a6:	90 81       	ld	r25, Z
    74a8:	88 23       	and	r24, r24
    74aa:	11 f0       	breq	.+4      	; 0x74b0 <MifareClassicAppProcess+0x3c>
            /* precheck of WUP/REQ because ISO14443AWakeUp destroys BitCount */
            (((State != STATE_HALT) && (Buffer[0] == ISO14443A_CMD_REQA)) ||
    74ac:	96 32       	cpi	r25, 0x26	; 38
    74ae:	11 f0       	breq	.+4      	; 0x74b4 <MifareClassicAppProcess+0x40>
    74b0:	92 35       	cpi	r25, 0x52	; 82
    74b2:	c1 f4       	brne	.+48     	; 0x74e4 <MifareClassicAppProcess+0x70>
             (Buffer[0] == ISO14443A_CMD_WUPA))) {
        FromHalt = State == STATE_HALT;
    74b4:	21 e0       	ldi	r18, 0x01	; 1
    74b6:	81 11       	cpse	r24, r1
    74b8:	20 e0       	ldi	r18, 0x00	; 0
    74ba:	20 93 f2 2c 	sts	0x2CF2, r18	; 0x802cf2 <FromHalt>

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    74be:	88 23       	and	r24, r24
    74c0:	11 f0       	breq	.+4      	; 0x74c6 <MifareClassicAppProcess+0x52>
    74c2:	96 32       	cpi	r25, 0x26	; 38
    74c4:	11 f0       	breq	.+4      	; 0x74ca <MifareClassicAppProcess+0x56>
    74c6:	92 35       	cpi	r25, 0x52	; 82
    74c8:	59 f4       	brne	.+22     	; 0x74e0 <MifareClassicAppProcess+0x6c>
        if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    74ca:	90 91 f4 2c 	lds	r25, 0x2CF4	; 0x802cf4 <CardATQAValue>
    74ce:	80 91 f5 2c 	lds	r24, 0x2CF5	; 0x802cf5 <CardATQAValue+0x1>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    74d2:	f8 01       	movw	r30, r16
    74d4:	90 83       	st	Z, r25
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    74d6:	81 83       	std	Z+1, r24	; 0x01
            AccessAddress = 0xff;
    74d8:	8f ef       	ldi	r24, 0xFF	; 255
    74da:	80 93 f6 2c 	sts	0x2CF6, r24	; 0x802cf6 <AccessAddress>
    74de:	37 c0       	rjmp	.+110    	; 0x754e <MifareClassicAppProcess+0xda>

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;

        return true;
    } else {
        *BitCount = 0;
    74e0:	a1 2c       	mov	r10, r1
    74e2:	b1 2c       	mov	r11, r1
            State = STATE_READY1;
            return BitCount;
        }
    }

    switch (State) {
    74e4:	85 30       	cpi	r24, 0x05	; 5
    74e6:	09 f4       	brne	.+2      	; 0x74ea <MifareClassicAppProcess+0x76>
    74e8:	97 c0       	rjmp	.+302    	; 0x7618 <MifareClassicAppProcess+0x1a4>
    74ea:	50 f4       	brcc	.+20     	; 0x7500 <MifareClassicAppProcess+0x8c>
    74ec:	82 30       	cpi	r24, 0x02	; 2
    74ee:	a1 f1       	breq	.+104    	; 0x7558 <MifareClassicAppProcess+0xe4>
    74f0:	c8 f0       	brcs	.+50     	; 0x7524 <MifareClassicAppProcess+0xb0>
    74f2:	83 30       	cpi	r24, 0x03	; 3
    74f4:	09 f4       	brne	.+2      	; 0x74f8 <MifareClassicAppProcess+0x84>
    74f6:	68 c0       	rjmp	.+208    	; 0x75c8 <MifareClassicAppProcess+0x154>
    74f8:	84 30       	cpi	r24, 0x04	; 4
    74fa:	09 f4       	brne	.+2      	; 0x74fe <MifareClassicAppProcess+0x8a>
    74fc:	81 c0       	rjmp	.+258    	; 0x7600 <MifareClassicAppProcess+0x18c>
    74fe:	ac c5       	rjmp	.+2904   	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7500:	88 30       	cpi	r24, 0x08	; 8
    7502:	09 f4       	brne	.+2      	; 0x7506 <MifareClassicAppProcess+0x92>
    7504:	1c c1       	rjmp	.+568    	; 0x773e <MifareClassicAppProcess+0x2ca>
    7506:	38 f4       	brcc	.+14     	; 0x7516 <MifareClassicAppProcess+0xa2>
    7508:	86 30       	cpi	r24, 0x06	; 6
    750a:	09 f4       	brne	.+2      	; 0x750e <MifareClassicAppProcess+0x9a>
    750c:	91 c0       	rjmp	.+290    	; 0x7630 <MifareClassicAppProcess+0x1bc>
    750e:	87 30       	cpi	r24, 0x07	; 7
    7510:	09 f4       	brne	.+2      	; 0x7514 <MifareClassicAppProcess+0xa0>
    7512:	ca c0       	rjmp	.+404    	; 0x76a8 <MifareClassicAppProcess+0x234>
    7514:	a1 c5       	rjmp	.+2882   	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7516:	89 30       	cpi	r24, 0x09	; 9
    7518:	09 f4       	brne	.+2      	; 0x751c <MifareClassicAppProcess+0xa8>
    751a:	41 c3       	rjmp	.+1666   	; 0x7b9e <MifareClassicAppProcess+0x72a>
    751c:	8d 30       	cpi	r24, 0x0D	; 13
    751e:	08 f4       	brcc	.+2      	; 0x7522 <MifareClassicAppProcess+0xae>
    7520:	63 c3       	rjmp	.+1734   	; 0x7be8 <MifareClassicAppProcess+0x774>
    7522:	9a c5       	rjmp	.+2868   	; 0x8058 <MifareClassicAppProcess+0xbe4>
        case STATE_IDLE:
        case STATE_HALT:
            FromHalt = State == STATE_HALT;
    7524:	98 2f       	mov	r25, r24
    7526:	90 95       	com	r25
    7528:	91 70       	andi	r25, 0x01	; 1
    752a:	90 93 f2 2c 	sts	0x2CF2, r25	; 0x802cf2 <FromHalt>
    752e:	f8 01       	movw	r30, r16
    7530:	90 81       	ld	r25, Z

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    7532:	88 23       	and	r24, r24
    7534:	11 f0       	breq	.+4      	; 0x753a <MifareClassicAppProcess+0xc6>
    7536:	96 32       	cpi	r25, 0x26	; 38
    7538:	19 f0       	breq	.+6      	; 0x7540 <MifareClassicAppProcess+0xcc>
    753a:	92 35       	cpi	r25, 0x52	; 82
    753c:	09 f0       	breq	.+2      	; 0x7540 <MifareClassicAppProcess+0xcc>
    753e:	06 c4       	rjmp	.+2060   	; 0x7d4c <MifareClassicAppProcess+0x8d8>
            if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    7540:	90 91 f4 2c 	lds	r25, 0x2CF4	; 0x802cf4 <CardATQAValue>
    7544:	80 91 f5 2c 	lds	r24, 0x2CF5	; 0x802cf5 <CardATQAValue+0x1>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    7548:	f8 01       	movw	r30, r16
    754a:	90 83       	st	Z, r25
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    754c:	81 83       	std	Z+1, r24	; 0x01
                State = STATE_READY1;
    754e:	84 e0       	ldi	r24, 0x04	; 4
    7550:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;
    7554:	80 e1       	ldi	r24, 0x10	; 16
    7556:	81 c5       	rjmp	.+2818   	; 0x805a <MifareClassicAppProcess+0xbe6>
            break;

#ifdef SUPPORT_MF_CLASSIC_MAGIC_MODE
        case STATE_CHINESE_IDLE:
            /* Support special china commands that dont require authentication. */
            if (Buffer[0] == CMD_CHINESE_UNLOCK_RW) {
    7558:	f8 01       	movw	r30, r16
    755a:	80 81       	ld	r24, Z
                /* Unlock read and write commands */
                Buffer[0] = ACK_VALUE;
                return ACK_NAK_FRAME_SIZE;
            } else if (Buffer[0] == CMD_CHINESE_WIPE) {
    755c:	98 2f       	mov	r25, r24
    755e:	9d 7f       	andi	r25, 0xFD	; 253
    7560:	91 34       	cpi	r25, 0x41	; 65
    7562:	19 f4       	brne	.+6      	; 0x756a <MifareClassicAppProcess+0xf6>
#ifdef SUPPORT_MF_CLASSIC_MAGIC_MODE
        case STATE_CHINESE_IDLE:
            /* Support special china commands that dont require authentication. */
            if (Buffer[0] == CMD_CHINESE_UNLOCK_RW) {
                /* Unlock read and write commands */
                Buffer[0] = ACK_VALUE;
    7564:	8a e0       	ldi	r24, 0x0A	; 10
    7566:	80 83       	st	Z, r24
    7568:	5a c3       	rjmp	.+1716   	; 0x7c1e <MifareClassicAppProcess+0x7aa>
                return ACK_NAK_FRAME_SIZE;
            } else if (Buffer[0] == CMD_CHINESE_WIPE) {
                /* Wipe memory */
                Buffer[0] = ACK_VALUE;
                return ACK_NAK_FRAME_SIZE;
            } else if (Buffer[0] == CMD_READ) {
    756a:	80 33       	cpi	r24, 0x30	; 48
    756c:	c1 f4       	brne	.+48     	; 0x759e <MifareClassicAppProcess+0x12a>
                if (ISO14443ACheckCRCA(Buffer, CMD_READ_FRAME_SIZE)) {
    756e:	62 e0       	ldi	r22, 0x02	; 2
    7570:	70 e0       	ldi	r23, 0x00	; 0
    7572:	c8 01       	movw	r24, r16
    7574:	d0 d6       	rcall	.+3488   	; 0x8316 <ISO14443ACheckCRCA>
    7576:	88 23       	and	r24, r24
    7578:	09 f4       	brne	.+2      	; 0x757c <MifareClassicAppProcess+0x108>
    757a:	94 c0       	rjmp	.+296    	; 0x76a4 <MifareClassicAppProcess+0x230>
                    /* Read command. Read data from memory and append CRCA. */
                    MemoryReadBlock(Buffer, (uint16_t)Buffer[1] * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    757c:	f8 01       	movw	r30, r16
    757e:	61 81       	ldd	r22, Z+1	; 0x01
    7580:	f0 e1       	ldi	r31, 0x10	; 16
    7582:	6f 9f       	mul	r22, r31
    7584:	b0 01       	movw	r22, r0
    7586:	11 24       	eor	r1, r1
    7588:	40 e1       	ldi	r20, 0x10	; 16
    758a:	50 e0       	ldi	r21, 0x00	; 0
    758c:	c8 01       	movw	r24, r16
    758e:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                    ISO14443AAppendCRCA(Buffer, MEM_BYTES_PER_BLOCK);
    7592:	60 e1       	ldi	r22, 0x10	; 16
    7594:	70 e0       	ldi	r23, 0x00	; 0
    7596:	c8 01       	movw	r24, r16
    7598:	93 d6       	rcall	.+3366   	; 0x82c0 <ISO14443AAppendCRCA>

                    return (CMD_READ_RESPONSE_FRAME_SIZE + ISO14443A_CRCA_SIZE)
    759a:	80 e9       	ldi	r24, 0x90	; 144
    759c:	5e c5       	rjmp	.+2748   	; 0x805a <MifareClassicAppProcess+0xbe6>
                           * BITS_PER_BYTE;
                } else {
                    Buffer[0] = NAK_CRC_ERROR;
                    return ACK_NAK_FRAME_SIZE;
                }
            } else if (Buffer[0] == CMD_WRITE) {
    759e:	80 3a       	cpi	r24, 0xA0	; 160
    75a0:	79 f4       	brne	.+30     	; 0x75c0 <MifareClassicAppProcess+0x14c>
                if (ISO14443ACheckCRCA(Buffer, CMD_WRITE_FRAME_SIZE)) {
    75a2:	62 e0       	ldi	r22, 0x02	; 2
    75a4:	70 e0       	ldi	r23, 0x00	; 0
    75a6:	c8 01       	movw	r24, r16
    75a8:	b6 d6       	rcall	.+3436   	; 0x8316 <ISO14443ACheckCRCA>
    75aa:	88 23       	and	r24, r24
    75ac:	09 f4       	brne	.+2      	; 0x75b0 <MifareClassicAppProcess+0x13c>
    75ae:	7a c0       	rjmp	.+244    	; 0x76a4 <MifareClassicAppProcess+0x230>
                    /* Write command. Store the address and prepare for the upcoming data.
                    * Respond with ACK. */
                    CurrentAddress = Buffer[1];
    75b0:	f8 01       	movw	r30, r16
    75b2:	81 81       	ldd	r24, Z+1	; 0x01
    75b4:	80 93 0c 2d 	sts	0x2D0C, r24	; 0x802d0c <CurrentAddress>
                    State = STATE_CHINESE_WRITE;
    75b8:	83 e0       	ldi	r24, 0x03	; 3
    75ba:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    75be:	d2 cf       	rjmp	.-92     	; 0x7564 <MifareClassicAppProcess+0xf0>
                    return ACK_NAK_FRAME_SIZE;
                } else {
                    Buffer[0] = NAK_CRC_ERROR;
                    return ACK_NAK_FRAME_SIZE;
                }
            } else if (Buffer[0] == CMD_HALT) {
    75c0:	80 35       	cpi	r24, 0x50	; 80
    75c2:	09 f0       	breq	.+2      	; 0x75c6 <MifareClassicAppProcess+0x152>
    75c4:	49 c5       	rjmp	.+2706   	; 0x8058 <MifareClassicAppProcess+0xbe4>
    75c6:	4a c0       	rjmp	.+148    	; 0x765c <MifareClassicAppProcess+0x1e8>
                }
            }
            break;

        case STATE_CHINESE_WRITE:
            if (ISO14443ACheckCRCA(Buffer, MEM_BYTES_PER_BLOCK)) {
    75c8:	60 e1       	ldi	r22, 0x10	; 16
    75ca:	70 e0       	ldi	r23, 0x00	; 0
    75cc:	c8 01       	movw	r24, r16
    75ce:	a3 d6       	rcall	.+3398   	; 0x8316 <ISO14443ACheckCRCA>
    75d0:	88 23       	and	r24, r24
    75d2:	89 f0       	breq	.+34     	; 0x75f6 <MifareClassicAppProcess+0x182>
                /* CRC check passed. Write data into memory and send ACK. */
                if (!ActiveConfiguration.ReadOnly) {
    75d4:	80 91 d4 2f 	lds	r24, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    75d8:	81 11       	cpse	r24, r1
    75da:	0b c0       	rjmp	.+22     	; 0x75f2 <MifareClassicAppProcess+0x17e>
                    MemoryWriteBlock(Buffer, CurrentAddress * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    75dc:	60 91 0c 2d 	lds	r22, 0x2D0C	; 0x802d0c <CurrentAddress>
    75e0:	f0 e1       	ldi	r31, 0x10	; 16
    75e2:	6f 9f       	mul	r22, r31
    75e4:	b0 01       	movw	r22, r0
    75e6:	11 24       	eor	r1, r1
    75e8:	40 e1       	ldi	r20, 0x10	; 16
    75ea:	50 e0       	ldi	r21, 0x00	; 0
    75ec:	c8 01       	movw	r24, r16
    75ee:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
                }

                Buffer[0] = ACK_VALUE;
    75f2:	8a e0       	ldi	r24, 0x0A	; 10
    75f4:	01 c0       	rjmp	.+2      	; 0x75f8 <MifareClassicAppProcess+0x184>
            } else {
                /* CRC Error. */
                Buffer[0] = NAK_CRC_ERROR;
    75f6:	81 e0       	ldi	r24, 0x01	; 1
    75f8:	f8 01       	movw	r30, r16
    75fa:	80 83       	st	Z, r24
            }

            State = STATE_CHINESE_IDLE;
    75fc:	82 e0       	ldi	r24, 0x02	; 2
    75fe:	0d c3       	rjmp	.+1562   	; 0x7c1a <MifareClassicAppProcess+0x7a6>

            return ACK_NAK_FRAME_SIZE;
#endif

        case STATE_READY1:
            if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    7600:	90 91 f2 2c 	lds	r25, 0x2CF2	; 0x802cf2 <FromHalt>
    7604:	f8 01       	movw	r30, r16
    7606:	80 81       	ld	r24, Z

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    7608:	91 11       	cpse	r25, r1
    760a:	02 c0       	rjmp	.+4      	; 0x7610 <MifareClassicAppProcess+0x19c>
    760c:	86 32       	cpi	r24, 0x26	; 38
    760e:	d1 f0       	breq	.+52     	; 0x7644 <MifareClassicAppProcess+0x1d0>
    7610:	82 35       	cpi	r24, 0x52	; 82
    7612:	09 f0       	breq	.+2      	; 0x7616 <MifareClassicAppProcess+0x1a2>
    7614:	a3 c3       	rjmp	.+1862   	; 0x7d5c <MifareClassicAppProcess+0x8e8>
    7616:	16 c0       	rjmp	.+44     	; 0x7644 <MifareClassicAppProcess+0x1d0>
                State = STATE_HALT;
            }
            break;

        case STATE_READY2:
            if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    7618:	90 91 f2 2c 	lds	r25, 0x2CF2	; 0x802cf2 <FromHalt>
    761c:	f8 01       	movw	r30, r16
    761e:	80 81       	ld	r24, Z
    7620:	91 11       	cpse	r25, r1
    7622:	02 c0       	rjmp	.+4      	; 0x7628 <MifareClassicAppProcess+0x1b4>
    7624:	86 32       	cpi	r24, 0x26	; 38
    7626:	71 f0       	breq	.+28     	; 0x7644 <MifareClassicAppProcess+0x1d0>
    7628:	82 35       	cpi	r24, 0x52	; 82
    762a:	09 f0       	breq	.+2      	; 0x762e <MifareClassicAppProcess+0x1ba>
    762c:	45 c4       	rjmp	.+2186   	; 0x7eb8 <MifareClassicAppProcess+0xa44>
    762e:	0a c0       	rjmp	.+20     	; 0x7644 <MifareClassicAppProcess+0x1d0>
                /* Unknown command. Enter HALT state. */
                State = STATE_HALT;
            }
            break;
        case STATE_ACTIVE:
            if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    7630:	90 91 f2 2c 	lds	r25, 0x2CF2	; 0x802cf2 <FromHalt>
    7634:	f8 01       	movw	r30, r16
    7636:	80 81       	ld	r24, Z
    7638:	91 11       	cpse	r25, r1
    763a:	02 c0       	rjmp	.+4      	; 0x7640 <MifareClassicAppProcess+0x1cc>
    763c:	86 32       	cpi	r24, 0x26	; 38
    763e:	11 f0       	breq	.+4      	; 0x7644 <MifareClassicAppProcess+0x1d0>
    7640:	82 35       	cpi	r24, 0x52	; 82
    7642:	51 f4       	brne	.+20     	; 0x7658 <MifareClassicAppProcess+0x1e4>
    7644:	20 91 f4 2c 	lds	r18, 0x2CF4	; 0x802cf4 <CardATQAValue>
    7648:	80 91 f5 2c 	lds	r24, 0x2CF5	; 0x802cf5 <CardATQAValue+0x1>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    764c:	f8 01       	movw	r30, r16
    764e:	20 83       	st	Z, r18
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    7650:	81 83       	std	Z+1, r24	; 0x01
                State = FromHalt ? STATE_HALT : STATE_IDLE;
    7652:	81 e0       	ldi	r24, 0x01	; 1
    7654:	89 27       	eor	r24, r25
    7656:	77 c3       	rjmp	.+1774   	; 0x7d46 <MifareClassicAppProcess+0x8d2>
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Buffer[0] == CMD_HALT) {
    7658:	80 35       	cpi	r24, 0x50	; 80
    765a:	c9 f4       	brne	.+50     	; 0x768e <MifareClassicAppProcess+0x21a>
                /* Halts the tag. According to the ISO14443, the second
                * byte is supposed to be 0. */
                if (Buffer[1] == 0) {
    765c:	f8 01       	movw	r30, r16
    765e:	81 81       	ldd	r24, Z+1	; 0x01
    7660:	88 23       	and	r24, r24
    7662:	19 f0       	breq	.+6      	; 0x766a <MifareClassicAppProcess+0x1f6>
                    } else {
                        Buffer[0] = NAK_CRC_ERROR;
                        return ACK_NAK_FRAME_SIZE;
                    }
                } else {
                    Buffer[0] = NAK_INVALID_ARG;
    7664:	f8 01       	movw	r30, r16
    7666:	10 82       	st	Z, r1
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Buffer[0] == CMD_HALT) {
                /* Halts the tag. According to the ISO14443, the second
                * byte is supposed to be 0. */
                if (Buffer[1] == 0) {
                    if (ISO14443ACheckCRCA(Buffer, CMD_HALT_FRAME_SIZE)) {
    7668:	da c2       	rjmp	.+1460   	; 0x7c1e <MifareClassicAppProcess+0x7aa>
    766a:	62 e0       	ldi	r22, 0x02	; 2
    766c:	70 e0       	ldi	r23, 0x00	; 0
    766e:	c8 01       	movw	r24, r16
    7670:	52 d6       	rcall	.+3236   	; 0x8316 <ISO14443ACheckCRCA>
    7672:	88 23       	and	r24, r24
    7674:	b9 f0       	breq	.+46     	; 0x76a4 <MifareClassicAppProcess+0x230>
void LogGetModeByName(char *Mode, uint16_t BufferSize);
void LogGetModeList(char *List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void *Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    7676:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    767a:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    767e:	40 e0       	ldi	r20, 0x00	; 0
    7680:	60 e0       	ldi	r22, 0x00	; 0
    7682:	70 e0       	ldi	r23, 0x00	; 0
    7684:	81 e9       	ldi	r24, 0x91	; 145
    7686:	19 95       	eicall
                        /* According to ISO14443, we must not send anything
                        * in order to acknowledge the HALT command. */
                        LogEntry(LOG_INFO_APP_CMD_HALT, NULL, 0);

                        State = STATE_HALT;
    7688:	10 92 15 2d 	sts	0x2D15, r1	; 0x802d15 <State>
    768c:	e5 c4       	rjmp	.+2506   	; 0x8058 <MifareClassicAppProcess+0xbe4>
                    }
                } else {
                    Buffer[0] = NAK_INVALID_ARG;
                    return ACK_NAK_FRAME_SIZE;
                }
            } else if ((Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
    768e:	90 ea       	ldi	r25, 0xA0	; 160
    7690:	98 0f       	add	r25, r24
    7692:	92 30       	cpi	r25, 0x02	; 2
    7694:	08 f0       	brcs	.+2      	; 0x7698 <MifareClassicAppProcess+0x224>
                if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {
    7696:	b4 c4       	rjmp	.+2408   	; 0x8000 <MifareClassicAppProcess+0xb8c>
    7698:	62 e0       	ldi	r22, 0x02	; 2
    769a:	70 e0       	ldi	r23, 0x00	; 0
    769c:	c8 01       	movw	r24, r16
    769e:	3b d6       	rcall	.+3190   	; 0x8316 <ISO14443ACheckCRCA>
    76a0:	81 11       	cpse	r24, r1
    76a2:	dd c4       	rjmp	.+2490   	; 0x805e <MifareClassicAppProcess+0xbea>
                        && (Key[3] == 0xea) && (Key[4] == 0x7b) && (Key[5] == 0xcc)) {
                    /* no response! */
                    /* Reader will send a HALT */
                    return ISO14443A_APP_NO_RESPONSE;
                } else {
                    Buffer[0] = NAK_CRC_ERROR;
    76a4:	81 e0       	ldi	r24, 0x01	; 1
    76a6:	4f c2       	rjmp	.+1182   	; 0x7b46 <MifareClassicAppProcess+0x6d2>

        case STATE_AUTHING:
            /* Reader delivers an encrypted nonce. We use it
            * to setup the crypto1 LFSR in nonlinear feedback mode.
            * Furthermore it delivers an encrypted answer. Decrypt and check it */
            Crypto1Auth(&Buffer[0]);
    76a8:	c8 01       	movw	r24, r16
    76aa:	0e 94 14 47 	call	0x8e28	; 0x8e28 <Crypto1Auth>

            Crypto1ByteArray(&Buffer[4], 4);
    76ae:	64 e0       	ldi	r22, 0x04	; 4
    76b0:	78 01       	movw	r14, r16
    76b2:	f4 e0       	ldi	r31, 0x04	; 4
    76b4:	ef 0e       	add	r14, r31
    76b6:	f1 1c       	adc	r15, r1
    76b8:	c7 01       	movw	r24, r14
    76ba:	0e 94 30 4a 	call	0x9460	; 0x9460 <Crypto1ByteArray>
    76be:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    76c2:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    76c6:	44 e0       	ldi	r20, 0x04	; 4
    76c8:	b7 01       	movw	r22, r14
    76ca:	80 ea       	ldi	r24, 0xA0	; 160
    76cc:	19 95       	eicall

            LogEntry(LOG_INFO_APP_AUTHING, &Buffer[4], 4);

            if ((Buffer[4] == ReaderResponse[0]) &&
    76ce:	f8 01       	movw	r30, r16
    76d0:	94 81       	ldd	r25, Z+4	; 0x04
    76d2:	80 91 0d 2d 	lds	r24, 0x2D0D	; 0x802d0d <ReaderResponse>
    76d6:	98 13       	cpse	r25, r24
    76d8:	29 c0       	rjmp	.+82     	; 0x772c <MifareClassicAppProcess+0x2b8>
    76da:	95 81       	ldd	r25, Z+5	; 0x05
    76dc:	80 91 0e 2d 	lds	r24, 0x2D0E	; 0x802d0e <ReaderResponse+0x1>
    76e0:	98 13       	cpse	r25, r24
    76e2:	24 c0       	rjmp	.+72     	; 0x772c <MifareClassicAppProcess+0x2b8>
                    (Buffer[5] == ReaderResponse[1]) &&
    76e4:	96 81       	ldd	r25, Z+6	; 0x06
    76e6:	80 91 0f 2d 	lds	r24, 0x2D0F	; 0x802d0f <ReaderResponse+0x2>
    76ea:	98 13       	cpse	r25, r24
    76ec:	1f c0       	rjmp	.+62     	; 0x772c <MifareClassicAppProcess+0x2b8>
                    (Buffer[6] == ReaderResponse[2]) &&
    76ee:	97 81       	ldd	r25, Z+7	; 0x07
    76f0:	80 91 10 2d 	lds	r24, 0x2D10	; 0x802d10 <ReaderResponse+0x3>
    76f4:	98 13       	cpse	r25, r24
    76f6:	1a c0       	rjmp	.+52     	; 0x772c <MifareClassicAppProcess+0x2b8>
                    (Buffer[7] == ReaderResponse[3])) {

                /* Reader is authenticated. Encrypt the precalculated card response
                * and generate the parity bits. */
                Buffer[0] = CardResponse[0];
    76f8:	80 91 11 2d 	lds	r24, 0x2D11	; 0x802d11 <CardResponse>
    76fc:	80 83       	st	Z, r24
                Buffer[1] = CardResponse[1];
    76fe:	80 91 12 2d 	lds	r24, 0x2D12	; 0x802d12 <CardResponse+0x1>
    7702:	81 83       	std	Z+1, r24	; 0x01
                Buffer[2] = CardResponse[2];
    7704:	80 91 13 2d 	lds	r24, 0x2D13	; 0x802d13 <CardResponse+0x2>
    7708:	82 83       	std	Z+2, r24	; 0x02
                Buffer[3] = CardResponse[3];
    770a:	80 91 14 2d 	lds	r24, 0x2D14	; 0x802d14 <CardResponse+0x3>
    770e:	83 83       	std	Z+3, r24	; 0x03
                Crypto1ByteArrayWithParity(Buffer, 4);
    7710:	64 e0       	ldi	r22, 0x04	; 4
    7712:	c8 01       	movw	r24, r16
    7714:	0e 94 49 4c 	call	0x9892	; 0x9892 <Crypto1ByteArrayWithParity>
    7718:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    771c:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7720:	44 e0       	ldi	r20, 0x04	; 4
    7722:	b8 01       	movw	r22, r16
    7724:	81 ea       	ldi	r24, 0xA1	; 161
    7726:	19 95       	eicall

                LogEntry(LOG_INFO_APP_AUTHED, Buffer, sizeof(CardResponse));

                State = STATE_AUTHED_IDLE;
    7728:	88 e0       	ldi	r24, 0x08	; 8
    772a:	04 c2       	rjmp	.+1032   	; 0x7b34 <MifareClassicAppProcess+0x6c0>
    772c:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7730:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7734:	44 e0       	ldi	r20, 0x04	; 4
    7736:	6d e0       	ldi	r22, 0x0D	; 13
    7738:	7d e2       	ldi	r23, 0x2D	; 45
    773a:	80 ec       	ldi	r24, 0xC0	; 192
    773c:	2d c2       	rjmp	.+1114   	; 0x7b98 <MifareClassicAppProcess+0x724>
            }
            break;

        case STATE_AUTHED_IDLE:
            /* If something went wrong the reader might send an unencrypted halt */
            if ((Buffer[0] == CMD_HALT) &&
    773e:	f8 01       	movw	r30, r16
    7740:	80 81       	ld	r24, Z
    7742:	80 35       	cpi	r24, 0x50	; 80
    7744:	51 f4       	brne	.+20     	; 0x775a <MifareClassicAppProcess+0x2e6>
    7746:	81 81       	ldd	r24, Z+1	; 0x01
    7748:	81 11       	cpse	r24, r1
    774a:	07 c0       	rjmp	.+14     	; 0x775a <MifareClassicAppProcess+0x2e6>
                    (Buffer[1] == 0) &&
    774c:	82 81       	ldd	r24, Z+2	; 0x02
    774e:	87 35       	cpi	r24, 0x57	; 87
    7750:	21 f4       	brne	.+8      	; 0x775a <MifareClassicAppProcess+0x2e6>
                    (Buffer[2] == 0x57) &&
    7752:	83 81       	ldd	r24, Z+3	; 0x03
    7754:	8d 3c       	cpi	r24, 0xCD	; 205
    7756:	09 f4       	brne	.+2      	; 0x775a <MifareClassicAppProcess+0x2e6>
    7758:	05 c2       	rjmp	.+1034   	; 0x7b64 <MifareClassicAppProcess+0x6f0>
                LogEntry(LOG_INFO_APP_CMD_HALT, NULL, 0);
                return ISO14443A_APP_NO_RESPONSE;
            }
            /* In this state, all communication is encrypted. Thus we first have to encrypt
             * the incoming data. */
            Crypto1ByteArray(Buffer, 4);
    775a:	64 e0       	ldi	r22, 0x04	; 4
    775c:	c8 01       	movw	r24, r16
    775e:	0e 94 30 4a 	call	0x9460	; 0x9460 <Crypto1ByteArray>

            if (Buffer[0] == CMD_READ) {
    7762:	f8 01       	movw	r30, r16
    7764:	80 81       	ld	r24, Z
    7766:	80 33       	cpi	r24, 0x30	; 48
    7768:	09 f0       	breq	.+2      	; 0x776c <MifareClassicAppProcess+0x2f8>
                if (ISO14443ACheckCRCA(Buffer, CMD_READ_FRAME_SIZE)) {
    776a:	bd c0       	rjmp	.+378    	; 0x78e6 <MifareClassicAppProcess+0x472>
    776c:	62 e0       	ldi	r22, 0x02	; 2
    776e:	70 e0       	ldi	r23, 0x00	; 0
    7770:	c8 01       	movw	r24, r16
    7772:	d1 d5       	rcall	.+2978   	; 0x8316 <ISO14443ACheckCRCA>
    7774:	88 23       	and	r24, r24
    7776:	09 f4       	brne	.+2      	; 0x777a <MifareClassicAppProcess+0x306>
    7778:	a7 c0       	rjmp	.+334    	; 0x78c8 <MifareClassicAppProcess+0x454>
                    /* Read command. Read data from memory and append CRCA. */
                    /* Sector trailor? Use access conditions! */

                    if ((Buffer[1] < 128 && (Buffer[1] & 3) == 3) || ((Buffer[1] & 15) == 15)) {
    777a:	f8 01       	movw	r30, r16
    777c:	61 81       	ldd	r22, Z+1	; 0x01
    777e:	67 fd       	sbrc	r22, 7
    7780:	04 c0       	rjmp	.+8      	; 0x778a <MifareClassicAppProcess+0x316>
    7782:	86 2f       	mov	r24, r22
    7784:	83 70       	andi	r24, 0x03	; 3
    7786:	83 30       	cpi	r24, 0x03	; 3
    7788:	29 f0       	breq	.+10     	; 0x7794 <MifareClassicAppProcess+0x320>
    778a:	86 2f       	mov	r24, r22
    778c:	8f 70       	andi	r24, 0x0F	; 15
    778e:	8f 30       	cpi	r24, 0x0F	; 15
    7790:	09 f0       	breq	.+2      	; 0x7794 <MifareClassicAppProcess+0x320>
    7792:	7f c0       	rjmp	.+254    	; 0x7892 <MifareClassicAppProcess+0x41e>
                        uint8_t Acc;
                        CurrentAddress = Buffer[1];
    7794:	60 93 0c 2d 	sts	0x2D0C, r22	; 0x802d0c <CurrentAddress>

/* decode Access conditions for a block */
INLINE uint8_t GetAccessCondition(uint8_t Block) {
    uint8_t  InvSAcc0;
    uint8_t  InvSAcc1;
    uint8_t  Acc0 = AccessConditions[0];
    7798:	80 91 f7 2c 	lds	r24, 0x2CF7	; 0x802cf7 <AccessConditions>
    uint8_t  Acc1 = AccessConditions[1];
    779c:	90 91 f8 2c 	lds	r25, 0x2CF8	; 0x802cf8 <AccessConditions+0x1>
    uint8_t  Acc2 = AccessConditions[2];
    77a0:	30 91 f9 2c 	lds	r19, 0x2CF9	; 0x802cf9 <AccessConditions+0x2>
    uint8_t  ResultForBlock = 0;

    InvSAcc0 = ~BYTE_SWAP(Acc0);
    77a4:	28 2f       	mov	r18, r24
    77a6:	22 95       	swap	r18
    77a8:	20 95       	com	r18
    InvSAcc1 = ~BYTE_SWAP(Acc1);

    /* Check */
    if (((InvSAcc0 ^ Acc1) & 0xf0) ||    /* C1x */
    77aa:	49 2f       	mov	r20, r25
    77ac:	42 27       	eor	r20, r18
    77ae:	40 7f       	andi	r20, 0xF0	; 240
    77b0:	09 f0       	breq	.+2      	; 0x77b4 <MifareClassicAppProcess+0x340>
    77b2:	3f c0       	rjmp	.+126    	; 0x7832 <MifareClassicAppProcess+0x3be>
    77b4:	23 27       	eor	r18, r19
    77b6:	2f 70       	andi	r18, 0x0F	; 15
    77b8:	e1 f5       	brne	.+120    	; 0x7832 <MifareClassicAppProcess+0x3be>
            ((InvSAcc0 ^ Acc2) & 0x0f) ||   /* C2x */
    77ba:	92 95       	swap	r25
    77bc:	90 95       	com	r25
    77be:	93 27       	eor	r25, r19
    77c0:	90 7f       	andi	r25, 0xF0	; 240
    77c2:	b9 f5       	brne	.+110    	; 0x7832 <MifareClassicAppProcess+0x3be>
            ((InvSAcc1 ^ Acc2) & 0xf0)) {   /* C3x */
        return (NO_ACCESS);
    }
    /* Fix for MFClassic 4K cards */
    if (Block < 128)
        Block &= 3;
    77c4:	26 2f       	mov	r18, r22
            ((InvSAcc0 ^ Acc2) & 0x0f) ||   /* C2x */
            ((InvSAcc1 ^ Acc2) & 0xf0)) {   /* C3x */
        return (NO_ACCESS);
    }
    /* Fix for MFClassic 4K cards */
    if (Block < 128)
    77c6:	67 fd       	sbrc	r22, 7
    77c8:	02 c0       	rjmp	.+4      	; 0x77ce <MifareClassicAppProcess+0x35a>
        Block &= 3;
    77ca:	23 70       	andi	r18, 0x03	; 3
    77cc:	03 c0       	rjmp	.+6      	; 0x77d4 <MifareClassicAppProcess+0x360>
    else {
        Block &= 15;
    77ce:	2f 70       	andi	r18, 0x0F	; 15
        if (Block & 15)
    77d0:	09 f0       	breq	.+2      	; 0x77d4 <MifareClassicAppProcess+0x360>
            Block = 3;
    77d2:	23 e0       	ldi	r18, 0x03	; 3
            Block = 1;
        else
            Block = 2;
    }

    Acc0 = ~Acc0;       /* C1x Bits to bit 0..3 */
    77d4:	80 95       	com	r24
    Acc1 =  Acc2;       /* C2x Bits to bit 0..3 */
    Acc2 =  Acc2 >> 4;  /* C3x Bits to bit 0..3 */
    77d6:	43 2f       	mov	r20, r19
    77d8:	42 95       	swap	r20
    77da:	4f 70       	andi	r20, 0x0F	; 15

    if (Block) {
    77dc:	22 23       	and	r18, r18
    77de:	b1 f0       	breq	.+44     	; 0x780c <MifareClassicAppProcess+0x398>
        Acc0 >>= Block;
    77e0:	90 e0       	ldi	r25, 0x00	; 0
    77e2:	02 2e       	mov	r0, r18
    77e4:	02 c0       	rjmp	.+4      	; 0x77ea <MifareClassicAppProcess+0x376>
    77e6:	95 95       	asr	r25
    77e8:	87 95       	ror	r24
    77ea:	0a 94       	dec	r0
    77ec:	e2 f7       	brpl	.-8      	; 0x77e6 <MifareClassicAppProcess+0x372>
        Acc1 >>= Block;
    77ee:	e3 2f       	mov	r30, r19
    77f0:	f0 e0       	ldi	r31, 0x00	; 0
    77f2:	02 2e       	mov	r0, r18
    77f4:	02 c0       	rjmp	.+4      	; 0x77fa <MifareClassicAppProcess+0x386>
    77f6:	f5 95       	asr	r31
    77f8:	e7 95       	ror	r30
    77fa:	0a 94       	dec	r0
    77fc:	e2 f7       	brpl	.-8      	; 0x77f6 <MifareClassicAppProcess+0x382>
    77fe:	3e 2f       	mov	r19, r30
        Acc2 >>= Block;
    7800:	50 e0       	ldi	r21, 0x00	; 0
    7802:	02 c0       	rjmp	.+4      	; 0x7808 <MifareClassicAppProcess+0x394>
    7804:	55 95       	asr	r21
    7806:	47 95       	ror	r20
    7808:	2a 95       	dec	r18
    780a:	e2 f7       	brpl	.-8      	; 0x7804 <MifareClassicAppProcess+0x390>
    }
    /* combine the bits */
    ResultForBlock = ((Acc2 & 1) << 2) |
    780c:	40 fb       	bst	r20, 0
    780e:	cc 24       	eor	r12, r12
    7810:	c0 f8       	bld	r12, 0
    7812:	d1 2c       	mov	r13, r1
    7814:	f6 01       	movw	r30, r12
    7816:	ee 0f       	add	r30, r30
    7818:	ff 1f       	adc	r31, r31
    781a:	ee 0f       	add	r30, r30
    781c:	ff 1f       	adc	r31, r31
    781e:	30 fb       	bst	r19, 0
    7820:	ee 24       	eor	r14, r14
    7822:	e0 f8       	bld	r14, 0
    7824:	f1 2c       	mov	r15, r1
    7826:	ee 0c       	add	r14, r14
    7828:	ff 1c       	adc	r15, r15
    782a:	ee 29       	or	r30, r14
    782c:	81 70       	andi	r24, 0x01	; 1
    782e:	e8 2b       	or	r30, r24
    7830:	01 c0       	rjmp	.+2      	; 0x7834 <MifareClassicAppProcess+0x3c0>

    /* Check */
    if (((InvSAcc0 ^ Acc1) & 0xf0) ||    /* C1x */
            ((InvSAcc0 ^ Acc2) & 0x0f) ||   /* C2x */
            ((InvSAcc1 ^ Acc2) & 0xf0)) {   /* C3x */
        return (NO_ACCESS);
    7832:	e7 e0       	ldi	r30, 0x07	; 7

                    if ((Buffer[1] < 128 && (Buffer[1] & 3) == 3) || ((Buffer[1] & 15) == 15)) {
                        uint8_t Acc;
                        CurrentAddress = Buffer[1];
                        /* Decode the access conditions */
                        Acc = abTrailorAccessConditions[ GetAccessCondition(CurrentAddress) ][ KeyInUse ];
    7834:	f0 e0       	ldi	r31, 0x00	; 0
    7836:	80 91 0b 2d 	lds	r24, 0x2D0B	; 0x802d0b <KeyInUse>
    783a:	ee 0f       	add	r30, r30
    783c:	ff 1f       	adc	r31, r31
    783e:	e0 5c       	subi	r30, 0xC0	; 192
    7840:	ff 4d       	sbci	r31, 0xDF	; 223
    7842:	e8 0f       	add	r30, r24
    7844:	f1 1d       	adc	r31, r1
    7846:	80 81       	ld	r24, Z
    7848:	f8 01       	movw	r30, r16
    784a:	98 01       	movw	r18, r16
    784c:	20 5f       	subi	r18, 0xF0	; 240
    784e:	3f 4f       	sbci	r19, 0xFF	; 255

                        /* Prepare empty Block */
                        for (uint8_t i = 0; i < MEM_BYTES_PER_BLOCK; i++)
                            Buffer[i] = 0;
    7850:	11 92       	st	Z+, r1
                        CurrentAddress = Buffer[1];
                        /* Decode the access conditions */
                        Acc = abTrailorAccessConditions[ GetAccessCondition(CurrentAddress) ][ KeyInUse ];

                        /* Prepare empty Block */
                        for (uint8_t i = 0; i < MEM_BYTES_PER_BLOCK; i++)
    7852:	2e 17       	cp	r18, r30
    7854:	3f 07       	cpc	r19, r31
    7856:	e1 f7       	brne	.-8      	; 0x7850 <MifareClassicAppProcess+0x3dc>
                            Buffer[i] = 0;

                        /* Allways copy the GPB */
                        /* Key A can never be read! */
                        /* Access conditions were already read during authentication! */
                        Buffer[MEM_KEY_SIZE + MEM_ACC_GPB_SIZE - 1] = AccessConditions[MEM_ACC_GPB_SIZE - 1];
    7858:	90 91 fa 2c 	lds	r25, 0x2CFA	; 0x802cfa <AccessConditions+0x3>
    785c:	f8 01       	movw	r30, r16
    785e:	91 87       	std	Z+9, r25	; 0x09

                        /* Access conditions are already known */
                        if (Acc & ACC_TRAILOR_READ_ACC) {
    7860:	82 ff       	sbrs	r24, 2
    7862:	09 c0       	rjmp	.+18     	; 0x7876 <MifareClassicAppProcess+0x402>
                            Buffer[MEM_KEY_SIZE]   = AccessConditions[0];
    7864:	90 91 f7 2c 	lds	r25, 0x2CF7	; 0x802cf7 <AccessConditions>
    7868:	96 83       	std	Z+6, r25	; 0x06
                            Buffer[MEM_KEY_SIZE + 1] = AccessConditions[1];
    786a:	90 91 f8 2c 	lds	r25, 0x2CF8	; 0x802cf8 <AccessConditions+0x1>
    786e:	97 83       	std	Z+7, r25	; 0x07
                            Buffer[MEM_KEY_SIZE + 2] = AccessConditions[2];
    7870:	90 91 f9 2c 	lds	r25, 0x2CF9	; 0x802cf9 <AccessConditions+0x2>
    7874:	90 87       	std	Z+8, r25	; 0x08
                        }
                        /* Key B is readable in some rare cases */
                        if (Acc & ACC_TRAILOR_READ_KEYB) {
    7876:	84 ff       	sbrs	r24, 4
    7878:	15 c0       	rjmp	.+42     	; 0x78a4 <MifareClassicAppProcess+0x430>
                            MemoryReadBlock(Buffer + MEM_BYTES_PER_BLOCK - MEM_KEY_SIZE,
    787a:	63 60       	ori	r22, 0x03	; 3
    787c:	f0 e1       	ldi	r31, 0x10	; 16
    787e:	6f 9f       	mul	r22, r31
    7880:	b0 01       	movw	r22, r0
    7882:	11 24       	eor	r1, r1
    7884:	66 5f       	subi	r22, 0xF6	; 246
    7886:	7f 4f       	sbci	r23, 0xFF	; 255
    7888:	46 e0       	ldi	r20, 0x06	; 6
    788a:	50 e0       	ldi	r21, 0x00	; 0
    788c:	c8 01       	movw	r24, r16
    788e:	0a 96       	adiw	r24, 0x0a	; 10
    7890:	07 c0       	rjmp	.+14     	; 0x78a0 <MifareClassicAppProcess+0x42c>
                                            (uint16_t)(CurrentAddress | 3) * MEM_BYTES_PER_BLOCK + MEM_BYTES_PER_BLOCK - MEM_KEY_SIZE,
                                            MEM_KEY_SIZE);
                        }
                    } else {
                        MemoryReadBlock(Buffer, (uint16_t) Buffer[1] * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    7892:	80 e1       	ldi	r24, 0x10	; 16
    7894:	68 9f       	mul	r22, r24
    7896:	b0 01       	movw	r22, r0
    7898:	11 24       	eor	r1, r1
    789a:	40 e1       	ldi	r20, 0x10	; 16
    789c:	50 e0       	ldi	r21, 0x00	; 0
    789e:	c8 01       	movw	r24, r16
    78a0:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                    }
                    ISO14443AAppendCRCA(Buffer, MEM_BYTES_PER_BLOCK);
    78a4:	60 e1       	ldi	r22, 0x10	; 16
    78a6:	70 e0       	ldi	r23, 0x00	; 0
    78a8:	c8 01       	movw	r24, r16
    78aa:	0a d5       	rcall	.+2580   	; 0x82c0 <ISO14443AAppendCRCA>
    78ac:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    78b0:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    78b4:	42 e1       	ldi	r20, 0x12	; 18
    78b6:	b8 01       	movw	r22, r16
    78b8:	80 e8       	ldi	r24, 0x80	; 128
    78ba:	19 95       	eicall

                    LogEntry(LOG_INFO_APP_CMD_READ, Buffer, MEM_BYTES_PER_BLOCK + ISO14443A_CRCA_SIZE);

                    /* Encrypt and calculate parity bits. */
                    Crypto1ByteArrayWithParity(Buffer, ISO14443A_CRCA_SIZE + MEM_BYTES_PER_BLOCK);
    78bc:	62 e1       	ldi	r22, 0x12	; 18
    78be:	c8 01       	movw	r24, r16
    78c0:	0e 94 49 4c 	call	0x9892	; 0x9892 <Crypto1ByteArrayWithParity>

                    return ((CMD_READ_RESPONSE_FRAME_SIZE + ISO14443A_CRCA_SIZE)
    78c4:	80 e9       	ldi	r24, 0x90	; 144
    78c6:	39 c1       	rjmp	.+626    	; 0x7b3a <MifareClassicAppProcess+0x6c6>
                            * BITS_PER_BYTE) | ISO14443A_APP_CUSTOM_PARITY;
                } else {
                    Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    78c8:	0e 94 3b 49 	call	0x9276	; 0x9276 <Crypto1Nibble>
    78cc:	91 e0       	ldi	r25, 0x01	; 1
    78ce:	89 27       	eor	r24, r25
    78d0:	f8 01       	movw	r30, r16
    78d2:	80 83       	st	Z, r24
    78d4:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    78d8:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    78dc:	44 e0       	ldi	r20, 0x04	; 4
    78de:	b8 01       	movw	r22, r16
    78e0:	81 ec       	ldi	r24, 0xC1	; 193
    78e2:	19 95       	eicall

                    LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);

                    return ACK_NAK_FRAME_SIZE;
                }
            } else if (Buffer[0] == CMD_WRITE) {
    78e4:	9c c1       	rjmp	.+824    	; 0x7c1e <MifareClassicAppProcess+0x7aa>
    78e6:	80 3a       	cpi	r24, 0xA0	; 160
                if (ISO14443ACheckCRCA(Buffer, CMD_WRITE_FRAME_SIZE)) {
    78e8:	61 f4       	brne	.+24     	; 0x7902 <MifareClassicAppProcess+0x48e>
    78ea:	62 e0       	ldi	r22, 0x02	; 2
    78ec:	70 e0       	ldi	r23, 0x00	; 0
    78ee:	c8 01       	movw	r24, r16
    78f0:	12 d5       	rcall	.+2596   	; 0x8316 <ISO14443ACheckCRCA>
    78f2:	88 23       	and	r24, r24
    78f4:	d9 f1       	breq	.+118    	; 0x796c <MifareClassicAppProcess+0x4f8>
                    /* Write command. Store the address and prepare for the upcoming data.
                     * Respond with ACK. */
                    CurrentAddress = Buffer[1];
    78f6:	f8 01       	movw	r30, r16
    78f8:	81 81       	ldd	r24, Z+1	; 0x01
    78fa:	80 93 0c 2d 	sts	0x2D0C, r24	; 0x802d0c <CurrentAddress>
                    State = STATE_WRITE;
    78fe:	89 e0       	ldi	r24, 0x09	; 9
                } else {
                    LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
                    Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
                }
                return ACK_NAK_FRAME_SIZE;
            } else if (Buffer[0] == CMD_DECREMENT) {
    7900:	0d c0       	rjmp	.+26     	; 0x791c <MifareClassicAppProcess+0x4a8>
    7902:	80 3c       	cpi	r24, 0xC0	; 192
                if (ISO14443ACheckCRCA(Buffer, CMD_DECREMENT_FRAME_SIZE)) {
    7904:	89 f4       	brne	.+34     	; 0x7928 <MifareClassicAppProcess+0x4b4>
    7906:	62 e0       	ldi	r22, 0x02	; 2
    7908:	70 e0       	ldi	r23, 0x00	; 0
    790a:	c8 01       	movw	r24, r16
    790c:	04 d5       	rcall	.+2568   	; 0x8316 <ISO14443ACheckCRCA>
    790e:	88 23       	and	r24, r24
    7910:	69 f1       	breq	.+90     	; 0x796c <MifareClassicAppProcess+0x4f8>
                    CurrentAddress = Buffer[1];
    7912:	f8 01       	movw	r30, r16
    7914:	81 81       	ldd	r24, Z+1	; 0x01
    7916:	80 93 0c 2d 	sts	0x2D0C, r24	; 0x802d0c <CurrentAddress>
                    State = STATE_DECREMENT;
    791a:	8b e0       	ldi	r24, 0x0B	; 11
    791c:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
                    Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
    7920:	0e 94 3b 49 	call	0x9276	; 0x9276 <Crypto1Nibble>
    7924:	9a e0       	ldi	r25, 0x0A	; 10
                } else {
                    LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
                    Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
                }
                return ACK_NAK_FRAME_SIZE;
            } else if (Buffer[0] == CMD_INCREMENT) {
    7926:	0e c1       	rjmp	.+540    	; 0x7b44 <MifareClassicAppProcess+0x6d0>
    7928:	81 3c       	cpi	r24, 0xC1	; 193
                if (ISO14443ACheckCRCA(Buffer, CMD_DECREMENT_FRAME_SIZE)) {
    792a:	91 f4       	brne	.+36     	; 0x7950 <MifareClassicAppProcess+0x4dc>
    792c:	62 e0       	ldi	r22, 0x02	; 2
    792e:	70 e0       	ldi	r23, 0x00	; 0
    7930:	c8 01       	movw	r24, r16
    7932:	f1 d4       	rcall	.+2530   	; 0x8316 <ISO14443ACheckCRCA>
    7934:	88 23       	and	r24, r24
    7936:	d1 f0       	breq	.+52     	; 0x796c <MifareClassicAppProcess+0x4f8>
                    CurrentAddress = Buffer[1];
    7938:	f8 01       	movw	r30, r16
    793a:	81 81       	ldd	r24, Z+1	; 0x01
    793c:	80 93 0c 2d 	sts	0x2D0C, r24	; 0x802d0c <CurrentAddress>
                    State = STATE_INCREMENT;
    7940:	fa e0       	ldi	r31, 0x0A	; 10
    7942:	ff 2e       	mov	r15, r31
    7944:	f0 92 15 2d 	sts	0x2D15, r15	; 0x802d15 <State>
                    Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
    7948:	0e 94 3b 49 	call	0x9276	; 0x9276 <Crypto1Nibble>
    794c:	8f 25       	eor	r24, r15
                } else {
                    LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
                    Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
                }
                return ACK_NAK_FRAME_SIZE;
            } else if (Buffer[0] == CMD_RESTORE) {
    794e:	fb c0       	rjmp	.+502    	; 0x7b46 <MifareClassicAppProcess+0x6d2>
    7950:	82 3c       	cpi	r24, 0xC2	; 194
                if (ISO14443ACheckCRCA(Buffer, CMD_DECREMENT_FRAME_SIZE)) {
    7952:	99 f4       	brne	.+38     	; 0x797a <MifareClassicAppProcess+0x506>
    7954:	62 e0       	ldi	r22, 0x02	; 2
    7956:	70 e0       	ldi	r23, 0x00	; 0
    7958:	c8 01       	movw	r24, r16
    795a:	dd d4       	rcall	.+2490   	; 0x8316 <ISO14443ACheckCRCA>
    795c:	88 23       	and	r24, r24
    795e:	31 f0       	breq	.+12     	; 0x796c <MifareClassicAppProcess+0x4f8>
                    CurrentAddress = Buffer[1];
    7960:	f8 01       	movw	r30, r16
    7962:	81 81       	ldd	r24, Z+1	; 0x01
    7964:	80 93 0c 2d 	sts	0x2D0C, r24	; 0x802d0c <CurrentAddress>
                    State = STATE_RESTORE;
    7968:	8c e0       	ldi	r24, 0x0C	; 12
    796a:	d8 cf       	rjmp	.-80     	; 0x791c <MifareClassicAppProcess+0x4a8>
    796c:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7970:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7974:	44 e0       	ldi	r20, 0x04	; 4
    7976:	b8 01       	movw	r22, r16
                } else {
                    LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
                    Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
                }
                return ACK_NAK_FRAME_SIZE;
            } else if (Buffer[0] == CMD_TRANSFER) {
    7978:	21 c0       	rjmp	.+66     	; 0x79bc <MifareClassicAppProcess+0x548>
    797a:	80 3b       	cpi	r24, 0xB0	; 176
                /* Write back the global block buffer to the desired block address */
                if (ISO14443ACheckCRCA(Buffer, CMD_TRANSFER_FRAME_SIZE)) {
    797c:	11 f5       	brne	.+68     	; 0x79c2 <MifareClassicAppProcess+0x54e>
    797e:	62 e0       	ldi	r22, 0x02	; 2
    7980:	70 e0       	ldi	r23, 0x00	; 0
    7982:	c8 01       	movw	r24, r16
    7984:	c8 d4       	rcall	.+2448   	; 0x8316 <ISO14443ACheckCRCA>
    7986:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    798a:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    798e:	44 e0       	ldi	r20, 0x04	; 4
    7990:	b8 01       	movw	r22, r16
    7992:	88 23       	and	r24, r24
    7994:	99 f0       	breq	.+38     	; 0x79bc <MifareClassicAppProcess+0x548>
    7996:	86 e8       	ldi	r24, 0x86	; 134
    7998:	19 95       	eicall
                    LogEntry(LOG_INFO_APP_CMD_TRANSFER, Buffer, 4);

                    if (!ActiveConfiguration.ReadOnly) {
    799a:	80 91 d4 2f 	lds	r24, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    799e:	81 11       	cpse	r24, r1
    79a0:	bf cf       	rjmp	.-130    	; 0x7920 <MifareClassicAppProcess+0x4ac>
                        MemoryWriteBlock(BlockBuffer, (uint16_t) Buffer[1] * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    79a2:	f8 01       	movw	r30, r16
    79a4:	61 81       	ldd	r22, Z+1	; 0x01
    79a6:	f0 e1       	ldi	r31, 0x10	; 16
    79a8:	6f 9f       	mul	r22, r31
    79aa:	b0 01       	movw	r22, r0
    79ac:	11 24       	eor	r1, r1
    79ae:	40 e1       	ldi	r20, 0x10	; 16
    79b0:	50 e0       	ldi	r21, 0x00	; 0
    79b2:	8b ef       	ldi	r24, 0xFB	; 251
    79b4:	9c e2       	ldi	r25, 0x2C	; 44
    79b6:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    79ba:	b2 cf       	rjmp	.-156    	; 0x7920 <MifareClassicAppProcess+0x4ac>
    79bc:	81 ec       	ldi	r24, 0xC1	; 193
    79be:	19 95       	eicall
                    LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
                    Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
                }

                return ACK_NAK_FRAME_SIZE;
            } else if ((Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
    79c0:	be c0       	rjmp	.+380    	; 0x7b3e <MifareClassicAppProcess+0x6ca>
    79c2:	90 ea       	ldi	r25, 0xA0	; 160
    79c4:	98 0f       	add	r25, r24
    79c6:	92 30       	cpi	r25, 0x02	; 2
    79c8:	08 f0       	brcs	.+2      	; 0x79cc <MifareClassicAppProcess+0x558>
                if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {
    79ca:	bf c0       	rjmp	.+382    	; 0x7b4a <MifareClassicAppProcess+0x6d6>
    79cc:	62 e0       	ldi	r22, 0x02	; 2
    79ce:	70 e0       	ldi	r23, 0x00	; 0
    79d0:	c8 01       	movw	r24, r16
    79d2:	a1 d4       	rcall	.+2370   	; 0x8316 <ISO14443ACheckCRCA>
    79d4:	88 23       	and	r24, r24
    79d6:	09 f4       	brne	.+2      	; 0x79da <MifareClassicAppProcess+0x566>
    79d8:	b2 c0       	rjmp	.+356    	; 0x7b3e <MifareClassicAppProcess+0x6ca>
                    /* Nested authentication. */
                    //uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
                    uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
    79da:	f8 01       	movw	r30, r16
    79dc:	80 81       	ld	r24, Z
    79de:	80 36       	cpi	r24, 0x60	; 96
    79e0:	21 f0       	breq	.+8      	; 0x79ea <MifareClassicAppProcess+0x576>
    79e2:	ea e3       	ldi	r30, 0x3A	; 58
    79e4:	ce 2e       	mov	r12, r30
    79e6:	d1 2c       	mov	r13, r1
    79e8:	03 c0       	rjmp	.+6      	; 0x79f0 <MifareClassicAppProcess+0x57c>
    79ea:	70 e3       	ldi	r23, 0x30	; 48
    79ec:	c7 2e       	mov	r12, r23
    79ee:	d1 2c       	mov	r13, r1
                    uint8_t Key[6];
                    uint8_t Uid[4];
                    uint8_t CardNonce[8];

                    /* Fix for MFClassic 4k cards */
                    if (Buffer[1] >= 128) {
    79f0:	f8 01       	movw	r30, r16
    79f2:	81 81       	ldd	r24, Z+1	; 0x01
    79f4:	87 ff       	sbrs	r24, 7
    79f6:	0c c0       	rjmp	.+24     	; 0x7a10 <MifareClassicAppProcess+0x59c>
    79f8:	80 7f       	andi	r24, 0xF0	; 240
                        SectorStartAddress = (Buffer[1] & MEM_BIGSECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    79fa:	f0 e1       	ldi	r31, 0x10	; 16
    79fc:	8f 9f       	mul	r24, r31
    79fe:	70 01       	movw	r14, r0
    7a00:	11 24       	eor	r1, r1
                        KeyOffset += MEM_KEY_BIGSECTOR_OFFSET;
    7a02:	80 ec       	ldi	r24, 0xC0	; 192
    7a04:	c8 0e       	add	r12, r24
    7a06:	d1 1c       	adc	r13, r1
                        AccOffset += MEM_KEY_BIGSECTOR_OFFSET;
    7a08:	66 ef       	ldi	r22, 0xF6	; 246
    7a0a:	a6 2e       	mov	r10, r22
    7a0c:	b1 2c       	mov	r11, r1
    7a0e:	08 c0       	rjmp	.+16     	; 0x7a20 <MifareClassicAppProcess+0x5ac>
    7a10:	8c 7f       	andi	r24, 0xFC	; 252
                    } else {
                        SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    7a12:	90 e1       	ldi	r25, 0x10	; 16
    7a14:	89 9f       	mul	r24, r25
    7a16:	70 01       	movw	r14, r0
    7a18:	11 24       	eor	r1, r1
            } else if ((Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
                if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {
                    /* Nested authentication. */
                    //uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
                    uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
                    uint16_t AccOffset = MEM_KEY_A_OFFSET + MEM_KEY_SIZE;
    7a1a:	56 e3       	ldi	r21, 0x36	; 54
    7a1c:	a5 2e       	mov	r10, r21
    7a1e:	b1 2c       	mov	r11, r1
    7a20:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7a24:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7a28:	42 e0       	ldi	r20, 0x02	; 2
    7a2a:	b8 01       	movw	r22, r16
    7a2c:	80 e9       	ldi	r24, 0x90	; 144
    7a2e:	19 95       	eicall
                        SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
                    }

                    LogEntry(LOG_INFO_APP_CMD_AUTH, Buffer, 2);
                    /* set KeyInUse for global use to keep info about authentication */
                    KeyInUse = Buffer[0] & 1;
    7a30:	f8 01       	movw	r30, r16
    7a32:	80 81       	ld	r24, Z
    7a34:	81 70       	andi	r24, 0x01	; 1
    7a36:	80 93 0b 2d 	sts	0x2D0B, r24	; 0x802d0b <KeyInUse>
                    CurrentAddress = SectorStartAddress / MEM_BYTES_PER_BLOCK;
    7a3a:	c7 01       	movw	r24, r14
    7a3c:	44 e0       	ldi	r20, 0x04	; 4
    7a3e:	96 95       	lsr	r25
    7a40:	87 95       	ror	r24
    7a42:	4a 95       	dec	r20
    7a44:	e1 f7       	brne	.-8      	; 0x7a3e <MifareClassicAppProcess+0x5ca>
    7a46:	80 93 0c 2d 	sts	0x2D0C, r24	; 0x802d0c <CurrentAddress>
                    if (CurrentAddress != AccessAddress) {
    7a4a:	90 91 f6 2c 	lds	r25, 0x2CF6	; 0x802cf6 <AccessAddress>
    7a4e:	98 17       	cp	r25, r24
    7a50:	69 f0       	breq	.+26     	; 0x7a6c <MifareClassicAppProcess+0x5f8>
                        /* Get access conditions from the sector trailor */
                        MemoryReadBlock(AccessConditions, SectorStartAddress + AccOffset, MEM_ACC_GPB_SIZE);
    7a52:	b5 01       	movw	r22, r10
    7a54:	6e 0d       	add	r22, r14
    7a56:	7f 1d       	adc	r23, r15
    7a58:	44 e0       	ldi	r20, 0x04	; 4
    7a5a:	50 e0       	ldi	r21, 0x00	; 0
    7a5c:	87 ef       	ldi	r24, 0xF7	; 247
    7a5e:	9c e2       	ldi	r25, 0x2C	; 44
    7a60:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                        AccessAddress = CurrentAddress;
    7a64:	80 91 0c 2d 	lds	r24, 0x2D0C	; 0x802d0c <CurrentAddress>
    7a68:	80 93 f6 2c 	sts	0x2CF6, r24	; 0x802cf6 <AccessAddress>
                    }

                    /* Generate a random nonce and read UID and key from memory */
                    RandomGetBuffer(CardNonce, sizeof(CardNonce));
    7a6c:	68 e0       	ldi	r22, 0x08	; 8
    7a6e:	ce 01       	movw	r24, r28
    7a70:	01 96       	adiw	r24, 0x01	; 1
    7a72:	0e 94 18 11 	call	0x2230	; 0x2230 <RandomGetBuffer>
                    if (ActiveConfiguration.UidSize == 7)
    7a76:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
                        MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    7a7a:	44 e0       	ldi	r20, 0x04	; 4
    7a7c:	50 e0       	ldi	r21, 0x00	; 0
                        AccessAddress = CurrentAddress;
                    }

                    /* Generate a random nonce and read UID and key from memory */
                    RandomGetBuffer(CardNonce, sizeof(CardNonce));
                    if (ActiveConfiguration.UidSize == 7)
    7a7e:	87 30       	cpi	r24, 0x07	; 7
    7a80:	19 f4       	brne	.+6      	; 0x7a88 <MifareClassicAppProcess+0x614>
                        MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    7a82:	63 e0       	ldi	r22, 0x03	; 3
    7a84:	70 e0       	ldi	r23, 0x00	; 0
    7a86:	02 c0       	rjmp	.+4      	; 0x7a8c <MifareClassicAppProcess+0x618>
                    else
                        MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    7a88:	60 e0       	ldi	r22, 0x00	; 0
    7a8a:	70 e0       	ldi	r23, 0x00	; 0
    7a8c:	ce 01       	movw	r24, r28
    7a8e:	0f 96       	adiw	r24, 0x0f	; 15
    7a90:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                    MemoryReadBlock(Key, SectorStartAddress + KeyOffset, MEM_KEY_SIZE);
    7a94:	b6 01       	movw	r22, r12
    7a96:	6e 0d       	add	r22, r14
    7a98:	7f 1d       	adc	r23, r15
    7a9a:	46 e0       	ldi	r20, 0x06	; 6
    7a9c:	50 e0       	ldi	r21, 0x00	; 0
    7a9e:	ce 01       	movw	r24, r28
    7aa0:	09 96       	adiw	r24, 0x09	; 9
    7aa2:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

                    /* Precalculate the reader response from card-nonce */
                    for (uint8_t i = 0; i < sizeof(ReaderResponse); i++)
                        ReaderResponse[i] = CardNonce[i];
    7aa6:	89 81       	ldd	r24, Y+1	; 0x01
    7aa8:	80 93 0d 2d 	sts	0x2D0D, r24	; 0x802d0d <ReaderResponse>
    7aac:	8a 81       	ldd	r24, Y+2	; 0x02
    7aae:	80 93 0e 2d 	sts	0x2D0E, r24	; 0x802d0e <ReaderResponse+0x1>
    7ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    7ab4:	80 93 0f 2d 	sts	0x2D0F, r24	; 0x802d0f <ReaderResponse+0x2>
    7ab8:	8c 81       	ldd	r24, Y+4	; 0x04
    7aba:	80 93 10 2d 	sts	0x2D10, r24	; 0x802d10 <ReaderResponse+0x3>

                    Crypto1PRNG(ReaderResponse, 64);
    7abe:	60 e4       	ldi	r22, 0x40	; 64
    7ac0:	8d e0       	ldi	r24, 0x0D	; 13
    7ac2:	9d e2       	ldi	r25, 0x2D	; 45
    7ac4:	0e 94 63 4e 	call	0x9cc6	; 0x9cc6 <Crypto1PRNG>

                    /* Precalculate our response from the reader response */
                    for (uint8_t i = 0; i < sizeof(CardResponse); i++)
                        CardResponse[i] = ReaderResponse[i];
    7ac8:	80 91 0d 2d 	lds	r24, 0x2D0D	; 0x802d0d <ReaderResponse>
    7acc:	80 93 11 2d 	sts	0x2D11, r24	; 0x802d11 <CardResponse>
    7ad0:	80 91 0e 2d 	lds	r24, 0x2D0E	; 0x802d0e <ReaderResponse+0x1>
    7ad4:	80 93 12 2d 	sts	0x2D12, r24	; 0x802d12 <CardResponse+0x1>
    7ad8:	80 91 0f 2d 	lds	r24, 0x2D0F	; 0x802d0f <ReaderResponse+0x2>
    7adc:	80 93 13 2d 	sts	0x2D13, r24	; 0x802d13 <CardResponse+0x2>
    7ae0:	80 91 10 2d 	lds	r24, 0x2D10	; 0x802d10 <ReaderResponse+0x3>
    7ae4:	80 93 14 2d 	sts	0x2D14, r24	; 0x802d14 <CardResponse+0x3>

                    Crypto1PRNG(CardResponse, 32);
    7ae8:	60 e2       	ldi	r22, 0x20	; 32
    7aea:	81 e1       	ldi	r24, 0x11	; 17
    7aec:	9d e2       	ldi	r25, 0x2D	; 45
    7aee:	0e 94 63 4e 	call	0x9cc6	; 0x9cc6 <Crypto1PRNG>

                    /* Setup crypto1 cipher. */
                    Crypto1SetupNested(Key, Uid, CardNonce, false);
    7af2:	20 e0       	ldi	r18, 0x00	; 0
    7af4:	ae 01       	movw	r20, r28
    7af6:	4f 5f       	subi	r20, 0xFF	; 255
    7af8:	5f 4f       	sbci	r21, 0xFF	; 255
    7afa:	be 01       	movw	r22, r28
    7afc:	61 5f       	subi	r22, 0xF1	; 241
    7afe:	7f 4f       	sbci	r23, 0xFF	; 255
    7b00:	ce 01       	movw	r24, r28
    7b02:	09 96       	adiw	r24, 0x09	; 9
    7b04:	e6 d6       	rcall	.+3532   	; 0x88d2 <Crypto1SetupNested>

                    /* Respond with the encrypted random card nonce and expect further authentication
                     * form the reader in the next frame. */
                    Buffer[0] = CardNonce[0];
    7b06:	89 81       	ldd	r24, Y+1	; 0x01
    7b08:	f8 01       	movw	r30, r16
    7b0a:	80 83       	st	Z, r24
                    Buffer[1] = CardNonce[1];
    7b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    7b0e:	81 83       	std	Z+1, r24	; 0x01
                    Buffer[2] = CardNonce[2];
    7b10:	8b 81       	ldd	r24, Y+3	; 0x03
    7b12:	82 83       	std	Z+2, r24	; 0x02
                    Buffer[3] = CardNonce[3];
    7b14:	8c 81       	ldd	r24, Y+4	; 0x04
    7b16:	83 83       	std	Z+3, r24	; 0x03
                    /* Encryption is on, so we have also to encrypt the pariy */
                    Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 0] =  CardNonce[4];
    7b18:	e0 58       	subi	r30, 0x80	; 128
    7b1a:	ff 4f       	sbci	r31, 0xFF	; 255
    7b1c:	8d 81       	ldd	r24, Y+5	; 0x05
    7b1e:	80 83       	st	Z, r24
                    Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 1] =  CardNonce[5];
    7b20:	31 96       	adiw	r30, 0x01	; 1
    7b22:	8e 81       	ldd	r24, Y+6	; 0x06
    7b24:	80 83       	st	Z, r24
                    Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 2] =  CardNonce[6];
    7b26:	31 96       	adiw	r30, 0x01	; 1
    7b28:	8f 81       	ldd	r24, Y+7	; 0x07
    7b2a:	80 83       	st	Z, r24
                    Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 3] =  CardNonce[7];
    7b2c:	31 96       	adiw	r30, 0x01	; 1
    7b2e:	88 85       	ldd	r24, Y+8	; 0x08
    7b30:	80 83       	st	Z, r24
                    State = STATE_AUTHING;
    7b32:	87 e0       	ldi	r24, 0x07	; 7
    7b34:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>

                    return CMD_AUTH_RB_FRAME_SIZE * BITS_PER_BYTE | ISO14443A_APP_CUSTOM_PARITY;
    7b38:	80 e2       	ldi	r24, 0x20	; 32
    7b3a:	90 e1       	ldi	r25, 0x10	; 16
    7b3c:	6c c3       	rjmp	.+1752   	; 0x8216 <MifareClassicAppProcess+0xda2>
                } else {
                    Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    7b3e:	0e 94 3b 49 	call	0x9276	; 0x9276 <Crypto1Nibble>
    7b42:	91 e0       	ldi	r25, 0x01	; 1
    7b44:	89 27       	eor	r24, r25
    7b46:	f8 01       	movw	r30, r16
                    return ACK_NAK_FRAME_SIZE;
                }
            } else if (Buffer[0] == CMD_HALT) {
    7b48:	0e cd       	rjmp	.-1508   	; 0x7566 <MifareClassicAppProcess+0xf2>
    7b4a:	80 35       	cpi	r24, 0x50	; 80
                /* Halts the tag. According to the ISO14443, the second
                 * byte is supposed to be 0. */
                if (Buffer[1] == 0) {
    7b4c:	b9 f4       	brne	.+46     	; 0x7b7c <MifareClassicAppProcess+0x708>
    7b4e:	f8 01       	movw	r30, r16
    7b50:	81 81       	ldd	r24, Z+1	; 0x01
    7b52:	81 11       	cpse	r24, r1
                    if (ISO14443ACheckCRCA(Buffer, CMD_HALT_FRAME_SIZE)) {
    7b54:	87 cd       	rjmp	.-1266   	; 0x7664 <MifareClassicAppProcess+0x1f0>
    7b56:	62 e0       	ldi	r22, 0x02	; 2
    7b58:	70 e0       	ldi	r23, 0x00	; 0
    7b5a:	c8 01       	movw	r24, r16
    7b5c:	dc d3       	rcall	.+1976   	; 0x8316 <ISO14443ACheckCRCA>
    7b5e:	88 23       	and	r24, r24
    7b60:	09 f4       	brne	.+2      	; 0x7b64 <MifareClassicAppProcess+0x6f0>
    7b62:	a0 cd       	rjmp	.-1216   	; 0x76a4 <MifareClassicAppProcess+0x230>
                        /* According to ISO14443, we must not send anything
                         * in order to acknowledge the HALT command. */
                        State = STATE_HALT;
    7b64:	10 92 15 2d 	sts	0x2D15, r1	; 0x802d15 <State>
    7b68:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7b6c:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7b70:	40 e0       	ldi	r20, 0x00	; 0
    7b72:	60 e0       	ldi	r22, 0x00	; 0
    7b74:	70 e0       	ldi	r23, 0x00	; 0
    7b76:	81 e9       	ldi	r24, 0x91	; 145
    7b78:	19 95       	eicall
    7b7a:	6e c2       	rjmp	.+1244   	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7b7c:	a5 01       	movw	r20, r10
    7b7e:	49 5f       	subi	r20, 0xF9	; 249
    7b80:	5f 4f       	sbci	r21, 0xFF	; 255
    7b82:	33 e0       	ldi	r19, 0x03	; 3
    7b84:	56 95       	lsr	r21
    7b86:	47 95       	ror	r20
    7b88:	3a 95       	dec	r19
    7b8a:	e1 f7       	brne	.-8      	; 0x7b84 <MifareClassicAppProcess+0x710>
    7b8c:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7b90:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7b94:	b8 01       	movw	r22, r16
    7b96:	82 e9       	ldi	r24, 0x92	; 146
                    return ACK_NAK_FRAME_SIZE;
                }
            } else {
                /* Unknown command. Enter HALT state */
                LogEntry(LOG_INFO_APP_CMD_UNKNOWN, Buffer, (BitCount + 7) / 8);
                State = STATE_IDLE;
    7b98:	19 95       	eicall
    7b9a:	81 e0       	ldi	r24, 0x01	; 1
             * sending the data to be written. Decrypt the data first and
             * check for CRC. Then write the data when ReadOnly mode is not
             * activated. */

            /* We receive 16 bytes of data to be written and 2 bytes CRCA. Decrypt */
            Crypto1ByteArray(Buffer, MEM_BYTES_PER_BLOCK + ISO14443A_CRCA_SIZE);
    7b9c:	d4 c0       	rjmp	.+424    	; 0x7d46 <MifareClassicAppProcess+0x8d2>
    7b9e:	62 e1       	ldi	r22, 0x12	; 18
    7ba0:	c8 01       	movw	r24, r16
    7ba2:	0e 94 30 4a 	call	0x9460	; 0x9460 <Crypto1ByteArray>

            if (ISO14443ACheckCRCA(Buffer, MEM_BYTES_PER_BLOCK)) {
    7ba6:	60 e1       	ldi	r22, 0x10	; 16
    7ba8:	70 e0       	ldi	r23, 0x00	; 0
    7baa:	c8 01       	movw	r24, r16
    7bac:	b4 d3       	rcall	.+1896   	; 0x8316 <ISO14443ACheckCRCA>
    7bae:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7bb2:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7bb6:	88 23       	and	r24, r24
    7bb8:	29 f1       	breq	.+74     	; 0x7c04 <MifareClassicAppProcess+0x790>
    7bba:	42 e1       	ldi	r20, 0x12	; 18
    7bbc:	b8 01       	movw	r22, r16
    7bbe:	81 e8       	ldi	r24, 0x81	; 129
    7bc0:	19 95       	eicall
                LogEntry(LOG_INFO_APP_CMD_WRITE, Buffer, MEM_BYTES_PER_BLOCK + ISO14443A_CRCA_SIZE);

                if (!ActiveConfiguration.ReadOnly) {
    7bc2:	80 91 d4 2f 	lds	r24, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    7bc6:	81 11       	cpse	r24, r1
    7bc8:	0b c0       	rjmp	.+22     	; 0x7be0 <MifareClassicAppProcess+0x76c>
                    MemoryWriteBlock(Buffer, CurrentAddress * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    7bca:	60 91 0c 2d 	lds	r22, 0x2D0C	; 0x802d0c <CurrentAddress>
    7bce:	f0 e1       	ldi	r31, 0x10	; 16
    7bd0:	6f 9f       	mul	r22, r31
    7bd2:	b0 01       	movw	r22, r0
    7bd4:	11 24       	eor	r1, r1
    7bd6:	40 e1       	ldi	r20, 0x10	; 16
    7bd8:	50 e0       	ldi	r21, 0x00	; 0
    7bda:	c8 01       	movw	r24, r16
    7bdc:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
                } else {
                    /* Silently ignore in ReadOnly mode */
                }

                Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
    7be0:	0e 94 3b 49 	call	0x9276	; 0x9276 <Crypto1Nibble>
    7be4:	9a e0       	ldi	r25, 0x0A	; 10
             * been issued earlier and the reader is now sending the data. First,
             * decrypt the data and check CRC. Read data from the requested block
             * address into the global block buffer and check for integrity. Then
             * add or subtract according to issued command if necessary and store
             * the block back into the global block buffer. */
            Crypto1ByteArray(Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
    7be6:	15 c0       	rjmp	.+42     	; 0x7c12 <MifareClassicAppProcess+0x79e>
    7be8:	66 e0       	ldi	r22, 0x06	; 6
    7bea:	c8 01       	movw	r24, r16
    7bec:	0e 94 30 4a 	call	0x9460	; 0x9460 <Crypto1ByteArray>

            if (ISO14443ACheckCRCA(Buffer, MEM_VALUE_SIZE)) {
    7bf0:	64 e0       	ldi	r22, 0x04	; 4
    7bf2:	70 e0       	ldi	r23, 0x00	; 0
    7bf4:	c8 01       	movw	r24, r16
    7bf6:	8f d3       	rcall	.+1822   	; 0x8316 <ISO14443ACheckCRCA>
    7bf8:	81 11       	cpse	r24, r1
    7bfa:	13 c0       	rjmp	.+38     	; 0x7c22 <MifareClassicAppProcess+0x7ae>
    7bfc:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7c00:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7c04:	44 e0       	ldi	r20, 0x04	; 4
    7c06:	b8 01       	movw	r22, r16
    7c08:	81 ec       	ldi	r24, 0xC1	; 193
    7c0a:	19 95       	eicall
                }

                Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
            } else {
                LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
                Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    7c0c:	0e 94 3b 49 	call	0x9276	; 0x9276 <Crypto1Nibble>
    7c10:	91 e0       	ldi	r25, 0x01	; 1
    7c12:	89 27       	eor	r24, r25
    7c14:	f8 01       	movw	r30, r16
    7c16:	80 83       	st	Z, r24
            }

            State = STATE_AUTHED_IDLE;
    7c18:	88 e0       	ldi	r24, 0x08	; 8
    7c1a:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
            return ACK_NAK_FRAME_SIZE;
    7c1e:	84 e0       	ldi	r24, 0x04	; 4
    7c20:	1c c2       	rjmp	.+1080   	; 0x805a <MifareClassicAppProcess+0xbe6>
             * add or subtract according to issued command if necessary and store
             * the block back into the global block buffer. */
            Crypto1ByteArray(Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);

            if (ISO14443ACheckCRCA(Buffer, MEM_VALUE_SIZE)) {
                MemoryReadBlock(BlockBuffer, (uint16_t) CurrentAddress * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    7c22:	60 91 0c 2d 	lds	r22, 0x2D0C	; 0x802d0c <CurrentAddress>
    7c26:	f0 e1       	ldi	r31, 0x10	; 16
    7c28:	6f 9f       	mul	r22, r31
    7c2a:	b0 01       	movw	r22, r0
    7c2c:	11 24       	eor	r1, r1
    7c2e:	40 e1       	ldi	r20, 0x10	; 16
    7c30:	50 e0       	ldi	r21, 0x00	; 0
    7c32:	8b ef       	ldi	r24, 0xFB	; 251
    7c34:	9c e2       	ldi	r25, 0x2C	; 44
    7c36:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
}

INLINE bool CheckValueIntegrity(uint8_t *Block) {
    /* Value Blocks contain a value stored three times, with
     * the middle portion inverted. */
    if ((Block[0] == (uint8_t) ~Block[4]) && (Block[0] == Block[8])
    7c3a:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <BlockBuffer>
    7c3e:	80 91 ff 2c 	lds	r24, 0x2CFF	; 0x802cff <BlockBuffer+0x4>
    7c42:	80 95       	com	r24
    7c44:	98 13       	cpse	r25, r24
    7c46:	e3 c2       	rjmp	.+1478   	; 0x820e <MifareClassicAppProcess+0xd9a>
    7c48:	80 91 03 2d 	lds	r24, 0x2D03	; 0x802d03 <BlockBuffer+0x8>
    7c4c:	98 13       	cpse	r25, r24
    7c4e:	df c2       	rjmp	.+1470   	; 0x820e <MifareClassicAppProcess+0xd9a>
            && (Block[1] == (uint8_t) ~Block[5]) && (Block[1] == Block[9])
    7c50:	90 91 fc 2c 	lds	r25, 0x2CFC	; 0x802cfc <BlockBuffer+0x1>
    7c54:	80 91 00 2d 	lds	r24, 0x2D00	; 0x802d00 <BlockBuffer+0x5>
    7c58:	80 95       	com	r24
    7c5a:	98 13       	cpse	r25, r24
    7c5c:	d8 c2       	rjmp	.+1456   	; 0x820e <MifareClassicAppProcess+0xd9a>
    7c5e:	80 91 04 2d 	lds	r24, 0x2D04	; 0x802d04 <BlockBuffer+0x9>
    7c62:	98 13       	cpse	r25, r24
    7c64:	d4 c2       	rjmp	.+1448   	; 0x820e <MifareClassicAppProcess+0xd9a>
            && (Block[2] == (uint8_t) ~Block[6]) && (Block[2] == Block[10])
    7c66:	90 91 fd 2c 	lds	r25, 0x2CFD	; 0x802cfd <BlockBuffer+0x2>
    7c6a:	80 91 01 2d 	lds	r24, 0x2D01	; 0x802d01 <BlockBuffer+0x6>
    7c6e:	80 95       	com	r24
    7c70:	98 13       	cpse	r25, r24
    7c72:	cd c2       	rjmp	.+1434   	; 0x820e <MifareClassicAppProcess+0xd9a>
    7c74:	80 91 05 2d 	lds	r24, 0x2D05	; 0x802d05 <BlockBuffer+0xa>
    7c78:	98 13       	cpse	r25, r24
    7c7a:	c9 c2       	rjmp	.+1426   	; 0x820e <MifareClassicAppProcess+0xd9a>
            && (Block[3] == (uint8_t) ~Block[7]) && (Block[3] == Block[11])
    7c7c:	90 91 fe 2c 	lds	r25, 0x2CFE	; 0x802cfe <BlockBuffer+0x3>
    7c80:	80 91 02 2d 	lds	r24, 0x2D02	; 0x802d02 <BlockBuffer+0x7>
    7c84:	80 95       	com	r24
    7c86:	98 13       	cpse	r25, r24
    7c88:	c2 c2       	rjmp	.+1412   	; 0x820e <MifareClassicAppProcess+0xd9a>
    7c8a:	80 91 06 2d 	lds	r24, 0x2D06	; 0x802d06 <BlockBuffer+0xb>
    7c8e:	98 13       	cpse	r25, r24
    7c90:	be c2       	rjmp	.+1404   	; 0x820e <MifareClassicAppProcess+0xd9a>
            && (Block[12] == (uint8_t) ~Block[13])
    7c92:	90 91 07 2d 	lds	r25, 0x2D07	; 0x802d07 <BlockBuffer+0xc>
    7c96:	80 91 08 2d 	lds	r24, 0x2D08	; 0x802d08 <BlockBuffer+0xd>
    7c9a:	80 95       	com	r24
    7c9c:	98 13       	cpse	r25, r24
    7c9e:	b7 c2       	rjmp	.+1390   	; 0x820e <MifareClassicAppProcess+0xd9a>
            && (Block[12] == Block[14])
    7ca0:	80 91 09 2d 	lds	r24, 0x2D09	; 0x802d09 <BlockBuffer+0xe>
    7ca4:	98 13       	cpse	r25, r24
    7ca6:	b3 c2       	rjmp	.+1382   	; 0x820e <MifareClassicAppProcess+0xd9a>
            && (Block[14] == (uint8_t) ~Block[15])) {
    7ca8:	80 91 0a 2d 	lds	r24, 0x2D0A	; 0x802d0a <BlockBuffer+0xf>
    7cac:	80 95       	com	r24
    7cae:	98 13       	cpse	r25, r24
    7cb0:	ae c2       	rjmp	.+1372   	; 0x820e <MifareClassicAppProcess+0xd9a>
INLINE void ValueFromBlock(uint32_t *Value, uint8_t *Block) {
    *Value = 0;
    *Value |= ((uint32_t) Block[0] << 0);
    *Value |= ((uint32_t) Block[1] << 8);
    *Value |= ((uint32_t) Block[2] << 16);
    *Value |= ((uint32_t) Block[3] << 24);
    7cb2:	c0 90 fb 2c 	lds	r12, 0x2CFB	; 0x802cfb <BlockBuffer>
    7cb6:	d0 90 fc 2c 	lds	r13, 0x2CFC	; 0x802cfc <BlockBuffer+0x1>
    7cba:	e0 90 fd 2c 	lds	r14, 0x2CFD	; 0x802cfd <BlockBuffer+0x2>
    7cbe:	f0 90 fe 2c 	lds	r15, 0x2CFE	; 0x802cfe <BlockBuffer+0x3>
    7cc2:	f8 01       	movw	r30, r16
    7cc4:	80 80       	ld	r8, Z
    7cc6:	91 80       	ldd	r9, Z+1	; 0x01
    7cc8:	a2 80       	ldd	r10, Z+2	; 0x02
    7cca:	b3 80       	ldd	r11, Z+3	; 0x03
                    uint32_t BlockValue;

                    ValueFromBlock(&ParamValue, Buffer);
                    ValueFromBlock(&BlockValue, BlockBuffer);

                    if (State == STATE_DECREMENT) {
    7ccc:	80 91 15 2d 	lds	r24, 0x2D15	; 0x802d15 <State>
    7cd0:	8b 30       	cpi	r24, 0x0B	; 11
    7cd2:	09 f0       	breq	.+2      	; 0x7cd6 <MifareClassicAppProcess+0x862>
    7cd4:	81 c2       	rjmp	.+1282   	; 0x81d8 <MifareClassicAppProcess+0xd64>
    7cd6:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    7cda:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    7cde:	46 e0       	ldi	r20, 0x06	; 6
    7ce0:	b8 01       	movw	r22, r16
    7ce2:	85 e8       	ldi	r24, 0x85	; 133
    7ce4:	19 95       	eicall
                        LogEntry(LOG_INFO_APP_CMD_DEC, Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
                        BlockValue -= ParamValue;
    7ce6:	c8 18       	sub	r12, r8
    7ce8:	d9 08       	sbc	r13, r9
    7cea:	ea 08       	sbc	r14, r10
    7cec:	fb 08       	sbc	r15, r11
    *Value |= ((uint32_t) Block[2] << 16);
    *Value |= ((uint32_t) Block[3] << 24);
}

INLINE void ValueToBlock(uint8_t *Block, uint32_t Value) {
    Block[0] = (uint8_t)(Value >> 0);
    7cee:	c0 92 fb 2c 	sts	0x2CFB, r12	; 0x802cfb <BlockBuffer>
    Block[1] = (uint8_t)(Value >> 8);
    7cf2:	33 27       	eor	r19, r19
    7cf4:	2f 2d       	mov	r18, r15
    7cf6:	1e 2d       	mov	r17, r14
    7cf8:	0d 2d       	mov	r16, r13
    7cfa:	00 93 fc 2c 	sts	0x2CFC, r16	; 0x802cfc <BlockBuffer+0x1>
    Block[2] = (uint8_t)(Value >> 16);
    7cfe:	a7 01       	movw	r20, r14
    7d00:	66 27       	eor	r22, r22
    7d02:	77 27       	eor	r23, r23
    7d04:	40 93 fd 2c 	sts	0x2CFD, r20	; 0x802cfd <BlockBuffer+0x2>
    Block[3] = (uint8_t)(Value >> 24);
    7d08:	8f 2d       	mov	r24, r15
    7d0a:	99 27       	eor	r25, r25
    7d0c:	aa 27       	eor	r26, r26
    7d0e:	bb 27       	eor	r27, r27
    7d10:	80 93 fe 2c 	sts	0x2CFE, r24	; 0x802cfe <BlockBuffer+0x3>
    Block[4] = ~Block[0];
    7d14:	ec 2d       	mov	r30, r12
    7d16:	e0 95       	com	r30
    7d18:	e0 93 ff 2c 	sts	0x2CFF, r30	; 0x802cff <BlockBuffer+0x4>
    Block[5] = ~Block[1];
    7d1c:	e0 2f       	mov	r30, r16
    7d1e:	e0 95       	com	r30
    7d20:	e0 93 00 2d 	sts	0x2D00, r30	; 0x802d00 <BlockBuffer+0x5>
    Block[6] = ~Block[2];
    7d24:	e4 2f       	mov	r30, r20
    7d26:	e0 95       	com	r30
    7d28:	e0 93 01 2d 	sts	0x2D01, r30	; 0x802d01 <BlockBuffer+0x6>
    Block[7] = ~Block[3];
    7d2c:	e8 2f       	mov	r30, r24
    7d2e:	e0 95       	com	r30
    7d30:	e0 93 02 2d 	sts	0x2D02, r30	; 0x802d02 <BlockBuffer+0x7>
    Block[8] = Block[0];
    7d34:	c0 92 03 2d 	sts	0x2D03, r12	; 0x802d03 <BlockBuffer+0x8>
    Block[9] = Block[1];
    7d38:	00 93 04 2d 	sts	0x2D04, r16	; 0x802d04 <BlockBuffer+0x9>
    Block[10] = Block[2];
    7d3c:	40 93 05 2d 	sts	0x2D05, r20	; 0x802d05 <BlockBuffer+0xa>
    Block[11] = Block[3];
    7d40:	80 93 06 2d 	sts	0x2D06, r24	; 0x802d06 <BlockBuffer+0xb>
                        /* Do nothing */
                    }

                    ValueToBlock(BlockBuffer, BlockValue);

                    State = STATE_AUTHED_IDLE;
    7d44:	88 e0       	ldi	r24, 0x08	; 8
    7d46:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    7d4a:	86 c1       	rjmp	.+780    	; 0x8058 <MifareClassicAppProcess+0xbe4>
            if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
                State = STATE_READY1;
                return BitCount;
            }
#ifdef SUPPORT_MF_CLASSIC_MAGIC_MODE
            else if (Buffer[0] == CMD_CHINESE_UNLOCK) {
    7d4c:	90 34       	cpi	r25, 0x40	; 64
    7d4e:	09 f0       	breq	.+2      	; 0x7d52 <MifareClassicAppProcess+0x8de>
    7d50:	83 c1       	rjmp	.+774    	; 0x8058 <MifareClassicAppProcess+0xbe4>
                State = STATE_CHINESE_IDLE;
    7d52:	82 e0       	ldi	r24, 0x02	; 2
    7d54:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
                Buffer[0] = ACK_VALUE;
    7d58:	8a e0       	ldi	r24, 0x0A	; 10
    7d5a:	f5 ce       	rjmp	.-534    	; 0x7b46 <MifareClassicAppProcess+0x6d2>

        case STATE_READY1:
            if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Buffer[0] == ISO14443A_CMD_SELECT_CL1) {
    7d5c:	83 39       	cpi	r24, 0x93	; 147
    7d5e:	09 f0       	breq	.+2      	; 0x7d62 <MifareClassicAppProcess+0x8ee>
    7d60:	93 cc       	rjmp	.-1754   	; 0x7688 <MifareClassicAppProcess+0x214>
                /* Load UID CL1 and perform anticollision */
                uint8_t UidCL1[ISO14443A_CL_UID_SIZE];
                /* For Longer UIDs indicate that more UID-Bytes follow (-> CL2) */
                if (ActiveConfiguration.UidSize == 7) {
    7d62:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    7d66:	87 30       	cpi	r24, 0x07	; 7
    7d68:	09 f0       	breq	.+2      	; 0x7d6c <MifareClassicAppProcess+0x8f8>
    7d6a:	a1 c0       	rjmp	.+322    	; 0x7eae <MifareClassicAppProcess+0xa3a>
                    MemoryReadBlock(&UidCL1[1], MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE - 1);
    7d6c:	43 e0       	ldi	r20, 0x03	; 3
    7d6e:	50 e0       	ldi	r21, 0x00	; 0
    7d70:	60 e0       	ldi	r22, 0x00	; 0
    7d72:	70 e0       	ldi	r23, 0x00	; 0
    7d74:	ce 01       	movw	r24, r28
    7d76:	02 96       	adiw	r24, 0x02	; 2
    7d78:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                    UidCL1[0] = ISO14443A_UID0_CT;
    7d7c:	88 e8       	ldi	r24, 0x88	; 136
    7d7e:	89 83       	std	Y+1, r24	; 0x01
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    7d80:	f8 01       	movw	r30, r16
    7d82:	91 81       	ldd	r25, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    7d84:	90 32       	cpi	r25, 0x20	; 32
    7d86:	19 f0       	breq	.+6      	; 0x7d8e <MifareClassicAppProcess+0x91a>
    7d88:	90 37       	cpi	r25, 0x70	; 112
    7d8a:	61 f0       	breq	.+24     	; 0x7da4 <MifareClassicAppProcess+0x930>
    7d8c:	24 c0       	rjmp	.+72     	; 0x7dd6 <MifareClassicAppProcess+0x962>
        case ISO14443A_NVB_AC_START:
            /* Start of anticollision procedure.
            * Send whole UID CLn + BCC */
            DataPtr[0] = UidCL[0];
    7d8e:	f8 01       	movw	r30, r16
    7d90:	80 83       	st	Z, r24
            DataPtr[1] = UidCL[1];
    7d92:	3a 81       	ldd	r19, Y+2	; 0x02
    7d94:	31 83       	std	Z+1, r19	; 0x01
            DataPtr[2] = UidCL[2];
    7d96:	2b 81       	ldd	r18, Y+3	; 0x03
    7d98:	22 83       	std	Z+2, r18	; 0x02
            DataPtr[3] = UidCL[3];
    7d9a:	9c 81       	ldd	r25, Y+4	; 0x04
    7d9c:	93 83       	std	Z+3, r25	; 0x03
            DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    7d9e:	23 27       	eor	r18, r19
    7da0:	82 27       	eor	r24, r18
    7da2:	2a c1       	rjmp	.+596    	; 0x7ff8 <MifareClassicAppProcess+0xb84>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    7da4:	f8 01       	movw	r30, r16
    7da6:	82 81       	ldd	r24, Z+2	; 0x02
    7da8:	88 38       	cpi	r24, 0x88	; 136
    7daa:	09 f0       	breq	.+2      	; 0x7dae <MifareClassicAppProcess+0x93a>
    7dac:	55 c1       	rjmp	.+682    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7dae:	93 81       	ldd	r25, Z+3	; 0x03
    7db0:	8a 81       	ldd	r24, Y+2	; 0x02
    7db2:	98 13       	cpse	r25, r24
                    (DataPtr[3] == UidCL[1]) &&
    7db4:	51 c1       	rjmp	.+674    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7db6:	94 81       	ldd	r25, Z+4	; 0x04
    7db8:	8b 81       	ldd	r24, Y+3	; 0x03
    7dba:	98 13       	cpse	r25, r24
                    (DataPtr[4] == UidCL[2]) &&
    7dbc:	4d c1       	rjmp	.+666    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7dbe:	95 81       	ldd	r25, Z+5	; 0x05
    7dc0:	8c 81       	ldd	r24, Y+4	; 0x04
    7dc2:	98 13       	cpse	r25, r24
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    7dc4:	49 c1       	rjmp	.+658    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7dc6:	84 e0       	ldi	r24, 0x04	; 4
                ISO14443AAppendCRCA(Buffer, 1);
    7dc8:	80 83       	st	Z, r24
    7dca:	61 e0       	ldi	r22, 0x01	; 1
    7dcc:	70 e0       	ldi	r23, 0x00	; 0
    7dce:	c8 01       	movw	r24, r16
    7dd0:	77 d2       	rcall	.+1262   	; 0x82c0 <ISO14443AAppendCRCA>
                    if (ISO14443ASelect(Buffer, &BitCount, UidCL1, SAK_UID_NOT_FINISHED))
                        State = STATE_READY2;
    7dd2:	85 e0       	ldi	r24, 0x05	; 5
    7dd4:	9f c0       	rjmp	.+318    	; 0x7f14 <MifareClassicAppProcess+0xaa0>
                /* We have not been selected. Don't send anything. */
                *BitCount = 0;
                return false;
            }
        default: {
            uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    7dd6:	e9 2e       	mov	r14, r25
    7dd8:	e2 94       	swap	r14
    7dda:	ef e0       	ldi	r30, 0x0F	; 15
    7ddc:	ee 22       	and	r14, r30
    7dde:	ea 94       	dec	r14
    7de0:	ea 94       	dec	r14
            uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    7de2:	9f 70       	andi	r25, 0x0F	; 15
    7de4:	f9 2e       	mov	r15, r25
            uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    7de6:	88 e0       	ldi	r24, 0x08	; 8
    7de8:	90 e0       	ldi	r25, 0x00	; 0
    7dea:	8f 19       	sub	r24, r15
    7dec:	91 09       	sbc	r25, r1
    7dee:	2f ef       	ldi	r18, 0xFF	; 255
    7df0:	30 e0       	ldi	r19, 0x00	; 0
    7df2:	69 01       	movw	r12, r18
    7df4:	02 c0       	rjmp	.+4      	; 0x7dfa <MifareClassicAppProcess+0x986>
    7df6:	d5 94       	asr	r13
    7df8:	c7 94       	ror	r12
    7dfa:	8a 95       	dec	r24
    7dfc:	e2 f7       	brpl	.-8      	; 0x7df6 <MifareClassicAppProcess+0x982>
            // Since the UidCL does not contain the BCC, we have to distinguish here
            if (
    7dfe:	f5 e0       	ldi	r31, 0x05	; 5
    7e00:	ef 16       	cp	r14, r31
    7e02:	29 f0       	breq	.+10     	; 0x7e0e <MifareClassicAppProcess+0x99a>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    7e04:	84 e0       	ldi	r24, 0x04	; 4
    7e06:	e8 12       	cpse	r14, r24
    7e08:	2a c0       	rjmp	.+84     	; 0x7e5e <MifareClassicAppProcess+0x9ea>
    7e0a:	ff 20       	and	r15, r15
    7e0c:	e1 f0       	breq	.+56     	; 0x7e46 <MifareClassicAppProcess+0x9d2>
    7e0e:	44 e0       	ldi	r20, 0x04	; 4
    7e10:	50 e0       	ldi	r21, 0x00	; 0
    7e12:	b8 01       	movw	r22, r16
    7e14:	6e 5f       	subi	r22, 0xFE	; 254
    7e16:	7f 4f       	sbci	r23, 0xFF	; 255
    7e18:	ce 01       	movw	r24, r28
    7e1a:	01 96       	adiw	r24, 0x01	; 1
    7e1c:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    7e20:	89 2b       	or	r24, r25
    7e22:	61 f4       	brne	.+24     	; 0x7e3c <MifareClassicAppProcess+0x9c8>
    7e24:	9a 81       	ldd	r25, Y+2	; 0x02
    7e26:	8b 81       	ldd	r24, Y+3	; 0x03
    7e28:	89 27       	eor	r24, r25
    7e2a:	98 e8       	ldi	r25, 0x88	; 136
    7e2c:	89 27       	eor	r24, r25
    7e2e:	9c 81       	ldd	r25, Y+4	; 0x04
    7e30:	89 27       	eor	r24, r25
    7e32:	f8 01       	movw	r30, r16
    7e34:	96 81       	ldd	r25, Z+6	; 0x06
    7e36:	89 27       	eor	r24, r25
    7e38:	8c 21       	and	r24, r12
    7e3a:	89 f1       	breq	.+98     	; 0x7e9e <MifareClassicAppProcess+0xa2a>
                ||
    7e3c:	f4 e0       	ldi	r31, 0x04	; 4
    7e3e:	ef 12       	cpse	r14, r31
    7e40:	0e c0       	rjmp	.+28     	; 0x7e5e <MifareClassicAppProcess+0x9ea>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    7e42:	f1 10       	cpse	r15, r1
    7e44:	09 c1       	rjmp	.+530    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7e46:	44 e0       	ldi	r20, 0x04	; 4
    7e48:	50 e0       	ldi	r21, 0x00	; 0
    7e4a:	b8 01       	movw	r22, r16
    7e4c:	6e 5f       	subi	r22, 0xFE	; 254
    7e4e:	7f 4f       	sbci	r23, 0xFF	; 255
    7e50:	ce 01       	movw	r24, r28
    7e52:	01 96       	adiw	r24, 0x01	; 1
    7e54:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    7e58:	89 2b       	or	r24, r25
    7e5a:	09 f1       	breq	.+66     	; 0x7e9e <MifareClassicAppProcess+0xa2a>
    7e5c:	fd c0       	rjmp	.+506    	; 0x8058 <MifareClassicAppProcess+0xbe4>
                ||
    7e5e:	83 e0       	ldi	r24, 0x03	; 3
    7e60:	8e 15       	cp	r24, r14
    7e62:	08 f4       	brcc	.+2      	; 0x7e66 <MifareClassicAppProcess+0x9f2>
    7e64:	f9 c0       	rjmp	.+498    	; 0x8058 <MifareClassicAppProcess+0xbe4>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    7e66:	f1 2c       	mov	r15, r1
    7e68:	a7 01       	movw	r20, r14
    7e6a:	b8 01       	movw	r22, r16
    7e6c:	6e 5f       	subi	r22, 0xFE	; 254
    7e6e:	7f 4f       	sbci	r23, 0xFF	; 255
    7e70:	ce 01       	movw	r24, r28
    7e72:	01 96       	adiw	r24, 0x01	; 1
    7e74:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    7e78:	89 2b       	or	r24, r25
    7e7a:	09 f0       	breq	.+2      	; 0x7e7e <MifareClassicAppProcess+0xa0a>
    7e7c:	ed c0       	rjmp	.+474    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7e7e:	d8 01       	movw	r26, r16
    7e80:	ae 0d       	add	r26, r14
    7e82:	bf 1d       	adc	r27, r15
    7e84:	e1 e0       	ldi	r30, 0x01	; 1
    7e86:	f0 e0       	ldi	r31, 0x00	; 0
    7e88:	ec 0f       	add	r30, r28
    7e8a:	fd 1f       	adc	r31, r29
    7e8c:	ee 0d       	add	r30, r14
    7e8e:	ff 1d       	adc	r31, r15
    7e90:	12 96       	adiw	r26, 0x02	; 2
    7e92:	9c 91       	ld	r25, X
    7e94:	80 81       	ld	r24, Z
    7e96:	89 27       	eor	r24, r25
    7e98:	c8 22       	and	r12, r24
    7e9a:	09 f0       	breq	.+2      	; 0x7e9e <MifareClassicAppProcess+0xa2a>
    7e9c:	dd c0       	rjmp	.+442    	; 0x8058 <MifareClassicAppProcess+0xbe4>
            ) {
                DataPtr[0] = UidCL[0];
    7e9e:	98 e8       	ldi	r25, 0x88	; 136
    7ea0:	f8 01       	movw	r30, r16
    7ea2:	90 83       	st	Z, r25
                DataPtr[1] = UidCL[1];
    7ea4:	3a 81       	ldd	r19, Y+2	; 0x02
    7ea6:	31 83       	std	Z+1, r19	; 0x01
                DataPtr[2] = UidCL[2];
    7ea8:	2b 81       	ldd	r18, Y+3	; 0x03
    7eaa:	22 83       	std	Z+2, r18	; 0x02
    7eac:	a1 c0       	rjmp	.+322    	; 0x7ff0 <MifareClassicAppProcess+0xb7c>
                } else {
                    MemoryReadBlock(UidCL1, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    7eae:	44 e0       	ldi	r20, 0x04	; 4
    7eb0:	50 e0       	ldi	r21, 0x00	; 0
    7eb2:	60 e0       	ldi	r22, 0x00	; 0
    7eb4:	70 e0       	ldi	r23, 0x00	; 0
    7eb6:	07 c0       	rjmp	.+14     	; 0x7ec6 <MifareClassicAppProcess+0xa52>

        case STATE_READY2:
            if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Buffer[0] == ISO14443A_CMD_SELECT_CL2) {
    7eb8:	85 39       	cpi	r24, 0x95	; 149
    7eba:	09 f0       	breq	.+2      	; 0x7ebe <MifareClassicAppProcess+0xa4a>
    7ebc:	e5 cb       	rjmp	.-2102   	; 0x7688 <MifareClassicAppProcess+0x214>
                /* Load UID CL2 and perform anticollision */
                uint8_t UidCL2[ISO14443A_CL_UID_SIZE];
                MemoryReadBlock(UidCL2, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    7ebe:	44 e0       	ldi	r20, 0x04	; 4
    7ec0:	50 e0       	ldi	r21, 0x00	; 0
    7ec2:	63 e0       	ldi	r22, 0x03	; 3
    7ec4:	70 e0       	ldi	r23, 0x00	; 0
    7ec6:	ce 01       	movw	r24, r28
    7ec8:	01 96       	adiw	r24, 0x01	; 1
    7eca:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    7ece:	f8 01       	movw	r30, r16
    7ed0:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    7ed2:	80 32       	cpi	r24, 0x20	; 32
    7ed4:	09 f4       	brne	.+2      	; 0x7ed8 <MifareClassicAppProcess+0xa64>
    7ed6:	85 c0       	rjmp	.+266    	; 0x7fe2 <MifareClassicAppProcess+0xb6e>
    7ed8:	80 37       	cpi	r24, 0x70	; 112
    7eda:	01 f5       	brne	.+64     	; 0x7f1c <MifareClassicAppProcess+0xaa8>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    7edc:	f8 01       	movw	r30, r16
    7ede:	92 81       	ldd	r25, Z+2	; 0x02
    7ee0:	89 81       	ldd	r24, Y+1	; 0x01
    7ee2:	98 13       	cpse	r25, r24
    7ee4:	b9 c0       	rjmp	.+370    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7ee6:	93 81       	ldd	r25, Z+3	; 0x03
    7ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    7eea:	98 13       	cpse	r25, r24
                    (DataPtr[3] == UidCL[1]) &&
    7eec:	b5 c0       	rjmp	.+362    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7eee:	94 81       	ldd	r25, Z+4	; 0x04
    7ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    7ef2:	98 13       	cpse	r25, r24
                    (DataPtr[4] == UidCL[2]) &&
    7ef4:	b1 c0       	rjmp	.+354    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7ef6:	95 81       	ldd	r25, Z+5	; 0x05
    7ef8:	8c 81       	ldd	r24, Y+4	; 0x04
    7efa:	98 13       	cpse	r25, r24
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    7efc:	ad c0       	rjmp	.+346    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7efe:	80 91 f3 2c 	lds	r24, 0x2CF3	; 0x802cf3 <CardSAKValue>
                ISO14443AAppendCRCA(Buffer, 1);
    7f02:	80 83       	st	Z, r24
    7f04:	61 e0       	ldi	r22, 0x01	; 1
    7f06:	70 e0       	ldi	r23, 0x00	; 0
    7f08:	c8 01       	movw	r24, r16
    7f0a:	da d1       	rcall	.+948    	; 0x82c0 <ISO14443AAppendCRCA>

                if (ISO14443ASelect(Buffer, &BitCount, UidCL2, CardSAKValue)) {
                    AccessAddress = 0xff; /* invalid, force reload */
    7f0c:	8f ef       	ldi	r24, 0xFF	; 255
    7f0e:	80 93 f6 2c 	sts	0x2CF6, r24	; 0x802cf6 <AccessAddress>
                    State = STATE_ACTIVE;
    7f12:	86 e0       	ldi	r24, 0x06	; 6
    7f14:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
    7f18:	88 e1       	ldi	r24, 0x18	; 24
    7f1a:	9f c0       	rjmp	.+318    	; 0x805a <MifareClassicAppProcess+0xbe6>
                /* We have not been selected. Don't send anything. */
                *BitCount = 0;
                return false;
            }
        default: {
            uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    7f1c:	e8 2e       	mov	r14, r24
    7f1e:	e2 94       	swap	r14
    7f20:	7f e0       	ldi	r23, 0x0F	; 15
    7f22:	e7 22       	and	r14, r23
    7f24:	ea 94       	dec	r14
    7f26:	ea 94       	dec	r14
            uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    7f28:	8f 70       	andi	r24, 0x0F	; 15
    7f2a:	f8 2e       	mov	r15, r24
            uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    7f2c:	88 e0       	ldi	r24, 0x08	; 8
    7f2e:	90 e0       	ldi	r25, 0x00	; 0
    7f30:	8f 19       	sub	r24, r15
    7f32:	91 09       	sbc	r25, r1
    7f34:	2f ef       	ldi	r18, 0xFF	; 255
    7f36:	30 e0       	ldi	r19, 0x00	; 0
    7f38:	69 01       	movw	r12, r18
    7f3a:	02 c0       	rjmp	.+4      	; 0x7f40 <MifareClassicAppProcess+0xacc>
    7f3c:	d5 94       	asr	r13
    7f3e:	c7 94       	ror	r12
    7f40:	8a 95       	dec	r24
    7f42:	e2 f7       	brpl	.-8      	; 0x7f3c <MifareClassicAppProcess+0xac8>
            // Since the UidCL does not contain the BCC, we have to distinguish here
            if (
    7f44:	f5 e0       	ldi	r31, 0x05	; 5
    7f46:	ef 16       	cp	r14, r31
    7f48:	29 f0       	breq	.+10     	; 0x7f54 <MifareClassicAppProcess+0xae0>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    7f4a:	84 e0       	ldi	r24, 0x04	; 4
    7f4c:	e8 12       	cpse	r14, r24
    7f4e:	2a c0       	rjmp	.+84     	; 0x7fa4 <MifareClassicAppProcess+0xb30>
    7f50:	ff 20       	and	r15, r15
    7f52:	e1 f0       	breq	.+56     	; 0x7f8c <MifareClassicAppProcess+0xb18>
    7f54:	44 e0       	ldi	r20, 0x04	; 4
    7f56:	50 e0       	ldi	r21, 0x00	; 0
    7f58:	b8 01       	movw	r22, r16
    7f5a:	6e 5f       	subi	r22, 0xFE	; 254
    7f5c:	7f 4f       	sbci	r23, 0xFF	; 255
    7f5e:	ce 01       	movw	r24, r28
    7f60:	01 96       	adiw	r24, 0x01	; 1
    7f62:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    7f66:	89 2b       	or	r24, r25
    7f68:	61 f4       	brne	.+24     	; 0x7f82 <MifareClassicAppProcess+0xb0e>
    7f6a:	99 81       	ldd	r25, Y+1	; 0x01
    7f6c:	8a 81       	ldd	r24, Y+2	; 0x02
    7f6e:	89 27       	eor	r24, r25
    7f70:	9b 81       	ldd	r25, Y+3	; 0x03
    7f72:	89 27       	eor	r24, r25
    7f74:	9c 81       	ldd	r25, Y+4	; 0x04
    7f76:	89 27       	eor	r24, r25
    7f78:	f8 01       	movw	r30, r16
    7f7a:	96 81       	ldd	r25, Z+6	; 0x06
    7f7c:	89 27       	eor	r24, r25
    7f7e:	8c 21       	and	r24, r12
    7f80:	81 f1       	breq	.+96     	; 0x7fe2 <MifareClassicAppProcess+0xb6e>
                ||
    7f82:	f4 e0       	ldi	r31, 0x04	; 4
    7f84:	ef 12       	cpse	r14, r31
    7f86:	0e c0       	rjmp	.+28     	; 0x7fa4 <MifareClassicAppProcess+0xb30>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    7f88:	f1 10       	cpse	r15, r1
    7f8a:	66 c0       	rjmp	.+204    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7f8c:	44 e0       	ldi	r20, 0x04	; 4
    7f8e:	50 e0       	ldi	r21, 0x00	; 0
    7f90:	b8 01       	movw	r22, r16
    7f92:	6e 5f       	subi	r22, 0xFE	; 254
    7f94:	7f 4f       	sbci	r23, 0xFF	; 255
    7f96:	ce 01       	movw	r24, r28
    7f98:	01 96       	adiw	r24, 0x01	; 1
    7f9a:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    7f9e:	89 2b       	or	r24, r25
    7fa0:	01 f1       	breq	.+64     	; 0x7fe2 <MifareClassicAppProcess+0xb6e>
    7fa2:	5a c0       	rjmp	.+180    	; 0x8058 <MifareClassicAppProcess+0xbe4>
                ||
    7fa4:	83 e0       	ldi	r24, 0x03	; 3
    7fa6:	8e 15       	cp	r24, r14
    7fa8:	08 f4       	brcc	.+2      	; 0x7fac <MifareClassicAppProcess+0xb38>
    7faa:	56 c0       	rjmp	.+172    	; 0x8058 <MifareClassicAppProcess+0xbe4>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    7fac:	f1 2c       	mov	r15, r1
    7fae:	a7 01       	movw	r20, r14
    7fb0:	b8 01       	movw	r22, r16
    7fb2:	6e 5f       	subi	r22, 0xFE	; 254
    7fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    7fb6:	ce 01       	movw	r24, r28
    7fb8:	01 96       	adiw	r24, 0x01	; 1
    7fba:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    7fbe:	89 2b       	or	r24, r25
    7fc0:	09 f0       	breq	.+2      	; 0x7fc4 <MifareClassicAppProcess+0xb50>
    7fc2:	4a c0       	rjmp	.+148    	; 0x8058 <MifareClassicAppProcess+0xbe4>
    7fc4:	d8 01       	movw	r26, r16
    7fc6:	ae 0d       	add	r26, r14
    7fc8:	bf 1d       	adc	r27, r15
    7fca:	e1 e0       	ldi	r30, 0x01	; 1
    7fcc:	f0 e0       	ldi	r31, 0x00	; 0
    7fce:	ec 0f       	add	r30, r28
    7fd0:	fd 1f       	adc	r31, r29
    7fd2:	ee 0d       	add	r30, r14
    7fd4:	ff 1d       	adc	r31, r15
    7fd6:	12 96       	adiw	r26, 0x02	; 2
    7fd8:	9c 91       	ld	r25, X
    7fda:	80 81       	ld	r24, Z
    7fdc:	89 27       	eor	r24, r25
    7fde:	c8 22       	and	r12, r24
    7fe0:	d9 f5       	brne	.+118    	; 0x8058 <MifareClassicAppProcess+0xbe4>
            ) {
                DataPtr[0] = UidCL[0];
    7fe2:	39 81       	ldd	r19, Y+1	; 0x01
    7fe4:	f8 01       	movw	r30, r16
    7fe6:	30 83       	st	Z, r19
                DataPtr[1] = UidCL[1];
    7fe8:	2a 81       	ldd	r18, Y+2	; 0x02
    7fea:	21 83       	std	Z+1, r18	; 0x01
                DataPtr[2] = UidCL[2];
    7fec:	9b 81       	ldd	r25, Y+3	; 0x03
    7fee:	92 83       	std	Z+2, r25	; 0x02
                DataPtr[3] = UidCL[3];
    7ff0:	8c 81       	ldd	r24, Y+4	; 0x04
    7ff2:	83 83       	std	Z+3, r24	; 0x03
                DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    7ff4:	23 27       	eor	r18, r19
    7ff6:	92 27       	eor	r25, r18
    7ff8:	89 27       	eor	r24, r25
    7ffa:	84 83       	std	Z+4, r24	; 0x04

                *BitCount = ISO14443A_CL_FRAME_SIZE;
    7ffc:	88 e2       	ldi	r24, 0x28	; 40
    7ffe:	2d c0       	rjmp	.+90     	; 0x805a <MifareClassicAppProcess+0xbe6>
                    return ACK_NAK_FRAME_SIZE;
                }

                /* EV1 READ_SIG command is */
                /* same as CMD_RESTORE but has no operand, rely on CRC here! */
            } else if ((Buffer[0] == CMD_SIG_READ) &&
    8000:	82 3c       	cpi	r24, 0xC2	; 194
    8002:	09 f0       	breq	.+2      	; 0x8006 <MifareClassicAppProcess+0xb92>
    8004:	cb c0       	rjmp	.+406    	; 0x819c <MifareClassicAppProcess+0xd28>
    8006:	f8 01       	movw	r30, r16
    8008:	81 81       	ldd	r24, Z+1	; 0x01
    800a:	80 3e       	cpi	r24, 0xE0	; 224
    800c:	09 f0       	breq	.+2      	; 0x8010 <MifareClassicAppProcess+0xb9c>
    800e:	cf c0       	rjmp	.+414    	; 0x81ae <MifareClassicAppProcess+0xd3a>
                       (Buffer[1] == 0xe0) &&
    8010:	82 81       	ldd	r24, Z+2	; 0x02
    8012:	84 3b       	cpi	r24, 0xB4	; 180
    8014:	09 f0       	breq	.+2      	; 0x8018 <MifareClassicAppProcess+0xba4>
    8016:	cb c0       	rjmp	.+406    	; 0x81ae <MifareClassicAppProcess+0xd3a>
                       (Buffer[2] == 0xb4)) {
                uint8_t Key[6];
                /* check if Originality check signature data available */
                /* Signature data is stored in (hidden) blocks 68..71 (0x44..0x47) */
                /* Signature data is read with key B, check if present */
                MemoryReadBlock(Key,
    8018:	46 e0       	ldi	r20, 0x06	; 6
    801a:	50 e0       	ldi	r21, 0x00	; 0
    801c:	6a ea       	ldi	r22, 0xAA	; 170
    801e:	74 e0       	ldi	r23, 0x04	; 4
    8020:	ce 01       	movw	r24, r28
    8022:	01 96       	adiw	r24, 0x01	; 1
    8024:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                                MEM_EV1_SIGNATURE_TRAILOR + MEM_KEY_B_OFFSET,
                                MEM_KEY_SIZE);
                /* Key B = 4b791bea7bcc is used to read the data, check if correct key */
                if ((Key[0] == 0x4b) && (Key[1] == 0x79) && (Key[2] == 0x1b)
    8028:	89 81       	ldd	r24, Y+1	; 0x01
    802a:	8b 34       	cpi	r24, 0x4B	; 75
    802c:	09 f0       	breq	.+2      	; 0x8030 <MifareClassicAppProcess+0xbbc>
    802e:	3a cb       	rjmp	.-2444   	; 0x76a4 <MifareClassicAppProcess+0x230>
    8030:	8a 81       	ldd	r24, Y+2	; 0x02
    8032:	89 37       	cpi	r24, 0x79	; 121
    8034:	09 f0       	breq	.+2      	; 0x8038 <MifareClassicAppProcess+0xbc4>
    8036:	36 cb       	rjmp	.-2452   	; 0x76a4 <MifareClassicAppProcess+0x230>
    8038:	8b 81       	ldd	r24, Y+3	; 0x03
    803a:	8b 31       	cpi	r24, 0x1B	; 27
    803c:	09 f0       	breq	.+2      	; 0x8040 <MifareClassicAppProcess+0xbcc>
    803e:	32 cb       	rjmp	.-2460   	; 0x76a4 <MifareClassicAppProcess+0x230>
                        && (Key[3] == 0xea) && (Key[4] == 0x7b) && (Key[5] == 0xcc)) {
    8040:	8c 81       	ldd	r24, Y+4	; 0x04
    8042:	8a 3e       	cpi	r24, 0xEA	; 234
    8044:	09 f0       	breq	.+2      	; 0x8048 <MifareClassicAppProcess+0xbd4>
    8046:	2e cb       	rjmp	.-2468   	; 0x76a4 <MifareClassicAppProcess+0x230>
    8048:	8d 81       	ldd	r24, Y+5	; 0x05
    804a:	8b 37       	cpi	r24, 0x7B	; 123
    804c:	09 f0       	breq	.+2      	; 0x8050 <MifareClassicAppProcess+0xbdc>
    804e:	2a cb       	rjmp	.-2476   	; 0x76a4 <MifareClassicAppProcess+0x230>
    8050:	8e 81       	ldd	r24, Y+6	; 0x06
    8052:	8c 3c       	cpi	r24, 0xCC	; 204
    8054:	09 f0       	breq	.+2      	; 0x8058 <MifareClassicAppProcess+0xbe4>
    8056:	26 cb       	rjmp	.-2484   	; 0x76a4 <MifareClassicAppProcess+0x230>

                *BitCount = ISO14443A_SAK_FRAME_SIZE;
                return true;
            } else {
                /* We have not been selected. Don't send anything. */
                *BitCount = 0;
    8058:	80 e0       	ldi	r24, 0x00	; 0
    805a:	90 e0       	ldi	r25, 0x00	; 0
    805c:	dc c0       	rjmp	.+440    	; 0x8216 <MifareClassicAppProcess+0xda2>
                }
            } else if ((Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
                if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {

                    //uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
                    uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
    805e:	f8 01       	movw	r30, r16
    8060:	80 81       	ld	r24, Z
    8062:	80 36       	cpi	r24, 0x60	; 96
    8064:	21 f0       	breq	.+8      	; 0x806e <MifareClassicAppProcess+0xbfa>
    8066:	6a e3       	ldi	r22, 0x3A	; 58
    8068:	c6 2e       	mov	r12, r22
    806a:	d1 2c       	mov	r13, r1
    806c:	03 c0       	rjmp	.+6      	; 0x8074 <MifareClassicAppProcess+0xc00>
    806e:	50 e3       	ldi	r21, 0x30	; 48
    8070:	c5 2e       	mov	r12, r21
    8072:	d1 2c       	mov	r13, r1
                    uint8_t Key[6];
                    uint8_t Uid[4];
                    uint8_t CardNonce[8];

                    /* Fix for MFClassic 4k cards */
                    if (Buffer[1] >= 128) {
    8074:	f8 01       	movw	r30, r16
    8076:	81 81       	ldd	r24, Z+1	; 0x01
    8078:	87 ff       	sbrs	r24, 7
    807a:	0c c0       	rjmp	.+24     	; 0x8094 <MifareClassicAppProcess+0xc20>
    807c:	80 7f       	andi	r24, 0xF0	; 240
                        SectorStartAddress = (Buffer[1] & MEM_BIGSECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    807e:	f0 e1       	ldi	r31, 0x10	; 16
    8080:	8f 9f       	mul	r24, r31
    8082:	70 01       	movw	r14, r0
    8084:	11 24       	eor	r1, r1
                        KeyOffset += MEM_KEY_BIGSECTOR_OFFSET;
    8086:	80 ec       	ldi	r24, 0xC0	; 192
    8088:	c8 0e       	add	r12, r24
    808a:	d1 1c       	adc	r13, r1
                        AccessOffset += MEM_KEY_BIGSECTOR_OFFSET;
    808c:	46 ef       	ldi	r20, 0xF6	; 246
    808e:	a4 2e       	mov	r10, r20
    8090:	b1 2c       	mov	r11, r1
    8092:	08 c0       	rjmp	.+16     	; 0x80a4 <MifareClassicAppProcess+0xc30>
    8094:	8c 7f       	andi	r24, 0xFC	; 252
                    } else {
                        SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    8096:	90 e1       	ldi	r25, 0x10	; 16
    8098:	89 9f       	mul	r24, r25
    809a:	70 01       	movw	r14, r0
    809c:	11 24       	eor	r1, r1
            } else if ((Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
                if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {

                    //uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
                    uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
                    uint16_t AccessOffset = MEM_KEY_A_OFFSET + MEM_KEY_SIZE;
    809e:	36 e3       	ldi	r19, 0x36	; 54
    80a0:	a3 2e       	mov	r10, r19
    80a2:	b1 2c       	mov	r11, r1
    80a4:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    80a8:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    80ac:	42 e0       	ldi	r20, 0x02	; 2
    80ae:	b8 01       	movw	r22, r16
    80b0:	80 e9       	ldi	r24, 0x90	; 144
    80b2:	19 95       	eicall
                        SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
                    }

                    LogEntry(LOG_INFO_APP_CMD_AUTH, Buffer, 2);
                    /* set KeyInUse for global use to keep info about authentication */
                    KeyInUse = Buffer[0] & 1;
    80b4:	f8 01       	movw	r30, r16
    80b6:	80 81       	ld	r24, Z
    80b8:	81 70       	andi	r24, 0x01	; 1
    80ba:	80 93 0b 2d 	sts	0x2D0B, r24	; 0x802d0b <KeyInUse>
                    CurrentAddress = SectorStartAddress / MEM_BYTES_PER_BLOCK;
    80be:	c7 01       	movw	r24, r14
    80c0:	24 e0       	ldi	r18, 0x04	; 4
    80c2:	96 95       	lsr	r25
    80c4:	87 95       	ror	r24
    80c6:	2a 95       	dec	r18
    80c8:	e1 f7       	brne	.-8      	; 0x80c2 <MifareClassicAppProcess+0xc4e>
    80ca:	80 93 0c 2d 	sts	0x2D0C, r24	; 0x802d0c <CurrentAddress>
                    //if (!AccessConditions[MEM_ACC_GPB_SIZE-1] ||(CurrentAddress != AccessAddress)) {
                    /* Get access conditions from the sector trailor */
                    MemoryReadBlock(AccessConditions, SectorStartAddress + AccessOffset, MEM_ACC_GPB_SIZE);
    80ce:	b5 01       	movw	r22, r10
    80d0:	6e 0d       	add	r22, r14
    80d2:	7f 1d       	adc	r23, r15
    80d4:	44 e0       	ldi	r20, 0x04	; 4
    80d6:	50 e0       	ldi	r21, 0x00	; 0
    80d8:	87 ef       	ldi	r24, 0xF7	; 247
    80da:	9c e2       	ldi	r25, 0x2C	; 44
    80dc:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                    AccessAddress = CurrentAddress;
    80e0:	80 91 0c 2d 	lds	r24, 0x2D0C	; 0x802d0c <CurrentAddress>
    80e4:	80 93 f6 2c 	sts	0x2CF6, r24	; 0x802cf6 <AccessAddress>
                    //}


                    /* Generate a random nonce and read UID and key from memory */
                    RandomGetBuffer(CardNonce, sizeof(CardNonce));
    80e8:	68 e0       	ldi	r22, 0x08	; 8
    80ea:	ce 01       	movw	r24, r28
    80ec:	01 96       	adiw	r24, 0x01	; 1
    80ee:	0e 94 18 11 	call	0x2230	; 0x2230 <RandomGetBuffer>
                    if (ActiveConfiguration.UidSize == 7)
    80f2:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
                        MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    80f6:	44 e0       	ldi	r20, 0x04	; 4
    80f8:	50 e0       	ldi	r21, 0x00	; 0
                    //}


                    /* Generate a random nonce and read UID and key from memory */
                    RandomGetBuffer(CardNonce, sizeof(CardNonce));
                    if (ActiveConfiguration.UidSize == 7)
    80fa:	87 30       	cpi	r24, 0x07	; 7
    80fc:	19 f4       	brne	.+6      	; 0x8104 <MifareClassicAppProcess+0xc90>
                        MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    80fe:	63 e0       	ldi	r22, 0x03	; 3
    8100:	70 e0       	ldi	r23, 0x00	; 0
    8102:	02 c0       	rjmp	.+4      	; 0x8108 <MifareClassicAppProcess+0xc94>
                    else
                        MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    8104:	60 e0       	ldi	r22, 0x00	; 0
    8106:	70 e0       	ldi	r23, 0x00	; 0
    8108:	ce 01       	movw	r24, r28
    810a:	0f 96       	adiw	r24, 0x0f	; 15
    810c:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                    MemoryReadBlock(Key, SectorStartAddress + KeyOffset, MEM_KEY_SIZE);
    8110:	b6 01       	movw	r22, r12
    8112:	6e 0d       	add	r22, r14
    8114:	7f 1d       	adc	r23, r15
    8116:	46 e0       	ldi	r20, 0x06	; 6
    8118:	50 e0       	ldi	r21, 0x00	; 0
    811a:	ce 01       	movw	r24, r28
    811c:	09 96       	adiw	r24, 0x09	; 9
    811e:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

                    /* Precalculate the reader response from card-nonce */
                    for (uint8_t i = 0; i < sizeof(ReaderResponse); i++)
                        ReaderResponse[i] = CardNonce[i];
    8122:	89 81       	ldd	r24, Y+1	; 0x01
    8124:	80 93 0d 2d 	sts	0x2D0D, r24	; 0x802d0d <ReaderResponse>
    8128:	8a 81       	ldd	r24, Y+2	; 0x02
    812a:	80 93 0e 2d 	sts	0x2D0E, r24	; 0x802d0e <ReaderResponse+0x1>
    812e:	8b 81       	ldd	r24, Y+3	; 0x03
    8130:	80 93 0f 2d 	sts	0x2D0F, r24	; 0x802d0f <ReaderResponse+0x2>
    8134:	8c 81       	ldd	r24, Y+4	; 0x04
    8136:	80 93 10 2d 	sts	0x2D10, r24	; 0x802d10 <ReaderResponse+0x3>

                    Crypto1PRNG(ReaderResponse, 64);
    813a:	60 e4       	ldi	r22, 0x40	; 64
    813c:	8d e0       	ldi	r24, 0x0D	; 13
    813e:	9d e2       	ldi	r25, 0x2D	; 45
    8140:	0e 94 63 4e 	call	0x9cc6	; 0x9cc6 <Crypto1PRNG>

                    /* Precalculate our response from the reader response */
                    for (uint8_t i = 0; i < sizeof(CardResponse); i++)
                        CardResponse[i] = ReaderResponse[i];
    8144:	80 91 0d 2d 	lds	r24, 0x2D0D	; 0x802d0d <ReaderResponse>
    8148:	80 93 11 2d 	sts	0x2D11, r24	; 0x802d11 <CardResponse>
    814c:	80 91 0e 2d 	lds	r24, 0x2D0E	; 0x802d0e <ReaderResponse+0x1>
    8150:	80 93 12 2d 	sts	0x2D12, r24	; 0x802d12 <CardResponse+0x1>
    8154:	80 91 0f 2d 	lds	r24, 0x2D0F	; 0x802d0f <ReaderResponse+0x2>
    8158:	80 93 13 2d 	sts	0x2D13, r24	; 0x802d13 <CardResponse+0x2>
    815c:	80 91 10 2d 	lds	r24, 0x2D10	; 0x802d10 <ReaderResponse+0x3>
    8160:	80 93 14 2d 	sts	0x2D14, r24	; 0x802d14 <CardResponse+0x3>

                    Crypto1PRNG(CardResponse, 32);
    8164:	60 e2       	ldi	r22, 0x20	; 32
    8166:	81 e1       	ldi	r24, 0x11	; 17
    8168:	9d e2       	ldi	r25, 0x2D	; 45
    816a:	0e 94 63 4e 	call	0x9cc6	; 0x9cc6 <Crypto1PRNG>

                    /* Respond with the random card nonce and expect further authentication
                     * form the reader in the next frame. */
                    State = STATE_AUTHING;
    816e:	87 e0       	ldi	r24, 0x07	; 7
    8170:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>

                    /* use unencrypted card nonce */
                    Buffer[0] = CardNonce[0];
    8174:	89 81       	ldd	r24, Y+1	; 0x01
    8176:	f8 01       	movw	r30, r16
                    Buffer[1] = CardNonce[1];
    8178:	80 83       	st	Z, r24
    817a:	8a 81       	ldd	r24, Y+2	; 0x02
                    Buffer[2] = CardNonce[2];
    817c:	81 83       	std	Z+1, r24	; 0x01
    817e:	8b 81       	ldd	r24, Y+3	; 0x03
                    Buffer[3] = CardNonce[3];
    8180:	82 83       	std	Z+2, r24	; 0x02
    8182:	8c 81       	ldd	r24, Y+4	; 0x04

                    /* Setup crypto1 cipher. Discard in-place encrypted CardNonce. */
                    Crypto1Setup(Key, Uid, CardNonce);
    8184:	83 83       	std	Z+3, r24	; 0x03
    8186:	ae 01       	movw	r20, r28
    8188:	4f 5f       	subi	r20, 0xFF	; 255
    818a:	5f 4f       	sbci	r21, 0xFF	; 255
    818c:	be 01       	movw	r22, r28
    818e:	61 5f       	subi	r22, 0xF1	; 241
    8190:	7f 4f       	sbci	r23, 0xFF	; 255
    8192:	ce 01       	movw	r24, r28
    8194:	09 96       	adiw	r24, 0x09	; 9
    8196:	f0 d0       	rcall	.+480    	; 0x8378 <Crypto1Setup>

                    return CMD_AUTH_RB_FRAME_SIZE * BITS_PER_BYTE;
    8198:	80 e2       	ldi	r24, 0x20	; 32
    819a:	5f cf       	rjmp	.-322    	; 0x805a <MifareClassicAppProcess+0xbe6>
                    return ISO14443A_APP_NO_RESPONSE;
                } else {
                    Buffer[0] = NAK_CRC_ERROR;
                    return ACK_NAK_FRAME_SIZE;
                }
            } else if ((Buffer[0] == CMD_READ) || (Buffer[0] == CMD_WRITE) || (Buffer[0] == CMD_DECREMENT)
    819c:	98 2f       	mov	r25, r24
    819e:	9f 77       	andi	r25, 0x7F	; 127
    81a0:	90 33       	cpi	r25, 0x30	; 48
    81a2:	29 f0       	breq	.+10     	; 0x81ae <MifareClassicAppProcess+0xd3a>
    81a4:	80 3a       	cpi	r24, 0xA0	; 160
    81a6:	19 f0       	breq	.+6      	; 0x81ae <MifareClassicAppProcess+0xd3a>
    81a8:	80 5c       	subi	r24, 0xC0	; 192
    81aa:	83 30       	cpi	r24, 0x03	; 3
    81ac:	78 f4       	brcc	.+30     	; 0x81cc <MifareClassicAppProcess+0xd58>
                       || (Buffer[0] == CMD_INCREMENT) || (Buffer[0] == CMD_RESTORE) || (Buffer[0] == CMD_TRANSFER)) {
                State = STATE_IDLE;
    81ae:	81 e0       	ldi	r24, 0x01	; 1
    81b0:	80 93 15 2d 	sts	0x2D15, r24	; 0x802d15 <State>
                Buffer[0] = NAK_NOT_AUTHED;
    81b4:	84 e0       	ldi	r24, 0x04	; 4
    81b6:	f8 01       	movw	r30, r16
    81b8:	80 83       	st	Z, r24
    81ba:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    81be:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    81c2:	40 e0       	ldi	r20, 0x00	; 0
    81c4:	60 e0       	ldi	r22, 0x00	; 0
    81c6:	70 e0       	ldi	r23, 0x00	; 0
    81c8:	82 ec       	ldi	r24, 0xC2	; 194
    81ca:	8b cb       	rjmp	.-2282   	; 0x78e2 <MifareClassicAppProcess+0x46e>
    81cc:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    81d0:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    81d4:	40 e0       	ldi	r20, 0x00	; 0
    81d6:	de cc       	rjmp	.-1604   	; 0x7b94 <MifareClassicAppProcess+0x720>
                    ValueFromBlock(&BlockValue, BlockBuffer);

                    if (State == STATE_DECREMENT) {
                        LogEntry(LOG_INFO_APP_CMD_DEC, Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
                        BlockValue -= ParamValue;
                    } else if (State == STATE_INCREMENT) {
    81d8:	8a 30       	cpi	r24, 0x0A	; 10
    81da:	69 f4       	brne	.+26     	; 0x81f6 <MifareClassicAppProcess+0xd82>
    81dc:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    81e0:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    81e4:	46 e0       	ldi	r20, 0x06	; 6
    81e6:	b8 01       	movw	r22, r16
    81e8:	84 e8       	ldi	r24, 0x84	; 132
    81ea:	19 95       	eicall
                        LogEntry(LOG_INFO_APP_CMD_INC, Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
                        BlockValue += ParamValue;
    81ec:	c8 0c       	add	r12, r8
    81ee:	d9 1c       	adc	r13, r9
    81f0:	ea 1c       	adc	r14, r10
    81f2:	fb 1c       	adc	r15, r11
    81f4:	7c cd       	rjmp	.-1288   	; 0x7cee <MifareClassicAppProcess+0x87a>
                    } else if (State == STATE_RESTORE) {
    81f6:	8c 30       	cpi	r24, 0x0C	; 12
    81f8:	09 f0       	breq	.+2      	; 0x81fc <MifareClassicAppProcess+0xd88>
    81fa:	79 cd       	rjmp	.-1294   	; 0x7cee <MifareClassicAppProcess+0x87a>
    81fc:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    8200:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    8204:	46 e0       	ldi	r20, 0x06	; 6
    8206:	b8 01       	movw	r22, r16
    8208:	87 e8       	ldi	r24, 0x87	; 135
    820a:	19 95       	eicall
    820c:	70 cd       	rjmp	.-1312   	; 0x7cee <MifareClassicAppProcess+0x87a>
                    State = STATE_AUTHED_IDLE;
                    /* No ACK response on value commands part 2 */
                    return ISO14443A_APP_NO_RESPONSE;
                } else {
                    /* Not sure if this is the correct error code.. */
                    Buffer[0] = NAK_OTHER_ERROR ^ Crypto1Nibble();
    820e:	0e 94 3b 49 	call	0x9276	; 0x9276 <Crypto1Nibble>
    8212:	96 e0       	ldi	r25, 0x06	; 6
    8214:	fe cc       	rjmp	.-1540   	; 0x7c12 <MifareClassicAppProcess+0x79e>
            break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
}
    8216:	62 96       	adiw	r28, 0x12	; 18
    8218:	cd bf       	out	0x3d, r28	; 61
    821a:	de bf       	out	0x3e, r29	; 62
    821c:	df 91       	pop	r29
    821e:	cf 91       	pop	r28
    8220:	1f 91       	pop	r17
    8222:	0f 91       	pop	r16
    8224:	ff 90       	pop	r15
    8226:	ef 90       	pop	r14
    8228:	df 90       	pop	r13
    822a:	cf 90       	pop	r12
    822c:	bf 90       	pop	r11
    822e:	af 90       	pop	r10
    8230:	9f 90       	pop	r9
    8232:	8f 90       	pop	r8
    8234:	08 95       	ret

00008236 <MifareClassicGetUid>:

void MifareClassicGetUid(ConfigurationUidType Uid) {
    8236:	cf 93       	push	r28
    8238:	df 93       	push	r29
    if (ActiveConfiguration.UidSize == 7) {
    823a:	20 91 d3 2f 	lds	r18, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    823e:	27 30       	cpi	r18, 0x07	; 7
    8240:	71 f4       	brne	.+28     	; 0x825e <MifareClassicGetUid+0x28>
    8242:	ec 01       	movw	r28, r24
        //Uid[0]=0x88;
        MemoryReadBlock(&Uid[0], MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE - 1);
    8244:	43 e0       	ldi	r20, 0x03	; 3
    8246:	50 e0       	ldi	r21, 0x00	; 0
    8248:	60 e0       	ldi	r22, 0x00	; 0
    824a:	70 e0       	ldi	r23, 0x00	; 0
    824c:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
        MemoryReadBlock(&Uid[3], MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    8250:	44 e0       	ldi	r20, 0x04	; 4
    8252:	50 e0       	ldi	r21, 0x00	; 0
    8254:	63 e0       	ldi	r22, 0x03	; 3
    8256:	70 e0       	ldi	r23, 0x00	; 0
    8258:	ce 01       	movw	r24, r28
    825a:	03 96       	adiw	r24, 0x03	; 3
    825c:	04 c0       	rjmp	.+8      	; 0x8266 <MifareClassicGetUid+0x30>
    } else
        MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    825e:	44 e0       	ldi	r20, 0x04	; 4
    8260:	50 e0       	ldi	r21, 0x00	; 0
    8262:	60 e0       	ldi	r22, 0x00	; 0
    8264:	70 e0       	ldi	r23, 0x00	; 0
}
    8266:	df 91       	pop	r29
    8268:	cf 91       	pop	r28
    if (ActiveConfiguration.UidSize == 7) {
        //Uid[0]=0x88;
        MemoryReadBlock(&Uid[0], MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE - 1);
        MemoryReadBlock(&Uid[3], MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    } else
        MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    826a:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

0000826e <MifareClassicSetUid>:
}

void MifareClassicSetUid(ConfigurationUidType Uid) {
    826e:	cf 93       	push	r28
    8270:	df 93       	push	r29
    8272:	1f 92       	push	r1
    8274:	cd b7       	in	r28, 0x3d	; 61
    8276:	de b7       	in	r29, 0x3e	; 62
    if (ActiveConfiguration.UidSize == 7) {
    8278:	20 91 d3 2f 	lds	r18, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    827c:	27 30       	cpi	r18, 0x07	; 7
    827e:	29 f4       	brne	.+10     	; 0x828a <MifareClassicSetUid+0x1c>
        //Uid[0]=0x88;
        MemoryWriteBlock(Uid, MEM_UID_CL1_ADDRESS, ActiveConfiguration.UidSize);
    8280:	47 e0       	ldi	r20, 0x07	; 7
    8282:	50 e0       	ldi	r21, 0x00	; 0
    8284:	60 e0       	ldi	r22, 0x00	; 0
    8286:	70 e0       	ldi	r23, 0x00	; 0
    8288:	15 c0       	rjmp	.+42     	; 0x82b4 <MifareClassicSetUid+0x46>
    } else {
        uint8_t BCC =  Uid[0] ^ Uid[1] ^ Uid[2] ^ Uid[3];
    828a:	fc 01       	movw	r30, r24
    828c:	30 81       	ld	r19, Z
    828e:	21 81       	ldd	r18, Z+1	; 0x01
    8290:	23 27       	eor	r18, r19
    8292:	32 81       	ldd	r19, Z+2	; 0x02
    8294:	23 27       	eor	r18, r19
    8296:	33 81       	ldd	r19, Z+3	; 0x03
    8298:	23 27       	eor	r18, r19
    829a:	29 83       	std	Y+1, r18	; 0x01

        MemoryWriteBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    829c:	44 e0       	ldi	r20, 0x04	; 4
    829e:	50 e0       	ldi	r21, 0x00	; 0
    82a0:	60 e0       	ldi	r22, 0x00	; 0
    82a2:	70 e0       	ldi	r23, 0x00	; 0
    82a4:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
        MemoryWriteBlock(&BCC, MEM_UID_BCC1_ADDRESS, ISO14443A_CL_BCC_SIZE);
    82a8:	41 e0       	ldi	r20, 0x01	; 1
    82aa:	50 e0       	ldi	r21, 0x00	; 0
    82ac:	64 e0       	ldi	r22, 0x04	; 4
    82ae:	70 e0       	ldi	r23, 0x00	; 0
    82b0:	ce 01       	movw	r24, r28
    82b2:	01 96       	adiw	r24, 0x01	; 1
    82b4:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    }
}
    82b8:	0f 90       	pop	r0
    82ba:	df 91       	pop	r29
    82bc:	cf 91       	pop	r28
    82be:	08 95       	ret

000082c0 <ISO14443AAppendCRCA>:

#ifdef USE_HW_CRC
void ISO14443AAppendCRCA(void *Buffer, uint16_t ByteCount) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    CRC.CTRL = CRC_RESET0_bm;
    82c0:	20 e4       	ldi	r18, 0x40	; 64
    82c2:	20 93 d0 00 	sts	0x00D0, r18	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    CRC.CHECKSUM1 = (CRC_INIT_R >> 8) & 0xFF;
    82c6:	26 ec       	ldi	r18, 0xC6	; 198
    82c8:	20 93 d5 00 	sts	0x00D5, r18	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    CRC.CHECKSUM0 = (CRC_INIT_R >> 0) & 0xFF;
    82cc:	20 93 d4 00 	sts	0x00D4, r18	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    CRC.CTRL = CRC_SOURCE_IO_gc;
    82d0:	21 e0       	ldi	r18, 0x01	; 1
    82d2:	20 93 d0 00 	sts	0x00D0, r18	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    82d6:	dc 01       	movw	r26, r24
    82d8:	68 0f       	add	r22, r24
    82da:	79 1f       	adc	r23, r25

    while (ByteCount--) {
    82dc:	a6 17       	cp	r26, r22
    82de:	b7 07       	cpc	r27, r23
    82e0:	41 f0       	breq	.+16     	; 0x82f2 <ISO14443AAppendCRCA+0x32>
        uint8_t Byte = *DataPtr++;
    82e2:	ed 91       	ld	r30, X+
uint16_t HexStringToBuffer(void *Buffer, uint16_t MaxBytes, const char *HexIn);

INLINE uint8_t BitReverseByte(uint8_t Byte) {
    extern const uint8_t PROGMEM BitReverseByteTable[];

    return pgm_read_byte(&BitReverseByteTable[Byte]);
    82e4:	f0 e0       	ldi	r31, 0x00	; 0
    82e6:	ea 50       	subi	r30, 0x0A	; 10
    82e8:	f8 4f       	sbci	r31, 0xF8	; 248
    82ea:	e4 91       	lpm	r30, Z
        Byte = BitReverseByte(Byte);

        CRC.DATAIN = Byte;
    82ec:	e0 93 d3 00 	sts	0x00D3, r30	; 0x8000d3 <__TEXT_REGION_LENGTH__+0x7000d3>
    82f0:	f5 cf       	rjmp	.-22     	; 0x82dc <ISO14443AAppendCRCA+0x1c>
    }

    DataPtr[0] = BitReverseByte(CRC.CHECKSUM1);
    82f2:	e0 91 d5 00 	lds	r30, 0x00D5	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    82f6:	f0 e0       	ldi	r31, 0x00	; 0
    82f8:	ea 50       	subi	r30, 0x0A	; 10
    82fa:	f8 4f       	sbci	r31, 0xF8	; 248
    82fc:	e4 91       	lpm	r30, Z
    82fe:	ec 93       	st	X, r30
    DataPtr[1] = BitReverseByte(CRC.CHECKSUM0);
    8300:	e0 91 d4 00 	lds	r30, 0x00D4	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    8304:	f0 e0       	ldi	r31, 0x00	; 0
    8306:	ea 50       	subi	r30, 0x0A	; 10
    8308:	f8 4f       	sbci	r31, 0xF8	; 248
    830a:	e4 91       	lpm	r30, Z
    830c:	11 96       	adiw	r26, 0x01	; 1
    830e:	ec 93       	st	X, r30

    CRC.CTRL = CRC_SOURCE_DISABLE_gc;
    8310:	10 92 d0 00 	sts	0x00D0, r1	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    8314:	08 95       	ret

00008316 <ISO14443ACheckCRCA>:

#ifdef USE_HW_CRC
bool ISO14443ACheckCRCA(const void *Buffer, uint16_t ByteCount) {
    const uint8_t *DataPtr = (const uint8_t *) Buffer;

    CRC.CTRL = CRC_RESET0_bm;
    8316:	20 e4       	ldi	r18, 0x40	; 64
    8318:	20 93 d0 00 	sts	0x00D0, r18	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    CRC.CHECKSUM1 = (CRC_INIT_R >> 8) & 0xFF;
    831c:	26 ec       	ldi	r18, 0xC6	; 198
    831e:	20 93 d5 00 	sts	0x00D5, r18	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    CRC.CHECKSUM0 = (CRC_INIT_R >> 0) & 0xFF;
    8322:	20 93 d4 00 	sts	0x00D4, r18	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    CRC.CTRL = CRC_SOURCE_IO_gc;
    8326:	21 e0       	ldi	r18, 0x01	; 1
    8328:	20 93 d0 00 	sts	0x00D0, r18	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    832c:	dc 01       	movw	r26, r24
    832e:	68 0f       	add	r22, r24
    8330:	79 1f       	adc	r23, r25

    while (ByteCount--) {
    8332:	a6 17       	cp	r26, r22
    8334:	b7 07       	cpc	r27, r23
    8336:	41 f0       	breq	.+16     	; 0x8348 <ISO14443ACheckCRCA+0x32>
        uint8_t Byte = *DataPtr++;
    8338:	ed 91       	ld	r30, X+
    833a:	f0 e0       	ldi	r31, 0x00	; 0
    833c:	ea 50       	subi	r30, 0x0A	; 10
    833e:	f8 4f       	sbci	r31, 0xF8	; 248
    8340:	e4 91       	lpm	r30, Z
        Byte = BitReverseByte(Byte);

        CRC.DATAIN = Byte;
    8342:	e0 93 d3 00 	sts	0x00D3, r30	; 0x8000d3 <__TEXT_REGION_LENGTH__+0x7000d3>
    8346:	f5 cf       	rjmp	.-22     	; 0x8332 <ISO14443ACheckCRCA+0x1c>
    }

    bool Result = (DataPtr[0] == BitReverseByte(CRC.CHECKSUM1)) && (DataPtr[1] == BitReverseByte(CRC.CHECKSUM0));
    8348:	e0 91 d5 00 	lds	r30, 0x00D5	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    834c:	f0 e0       	ldi	r31, 0x00	; 0
    834e:	ea 50       	subi	r30, 0x0A	; 10
    8350:	f8 4f       	sbci	r31, 0xF8	; 248
    8352:	e4 91       	lpm	r30, Z
    8354:	8c 91       	ld	r24, X
    8356:	8e 13       	cpse	r24, r30
    8358:	0a c0       	rjmp	.+20     	; 0x836e <ISO14443ACheckCRCA+0x58>
    835a:	e0 91 d4 00 	lds	r30, 0x00D4	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    835e:	f0 e0       	ldi	r31, 0x00	; 0
    8360:	ea 50       	subi	r30, 0x0A	; 10
    8362:	f8 4f       	sbci	r31, 0xF8	; 248
    8364:	e4 91       	lpm	r30, Z
    8366:	81 e0       	ldi	r24, 0x01	; 1
    8368:	11 96       	adiw	r26, 0x01	; 1
    836a:	9c 91       	ld	r25, X
    836c:	9e 13       	cpse	r25, r30
    836e:	80 e0       	ldi	r24, 0x00	; 0

    CRC.CTRL = CRC_SOURCE_DISABLE_gc;
    8370:	10 92 d0 00 	sts	0x00D0, r1	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    return Result;
}
    8374:	81 70       	andi	r24, 0x01	; 1
    8376:	08 95       	ret

00008378 <Crypto1Setup>:

/* Setup LFSR split into odd and even states, feed in uid ^nonce */
/* Version for first (not nested) authentication.                 */
void Crypto1Setup(uint8_t Key[6],
                  uint8_t Uid[4],
                  uint8_t CardNonce[4]) {
    8378:	8f 92       	push	r8
    837a:	9f 92       	push	r9
    837c:	bf 92       	push	r11
    837e:	cf 92       	push	r12
    8380:	df 92       	push	r13
    8382:	ef 92       	push	r14
    8384:	ff 92       	push	r15
    8386:	0f 93       	push	r16
    8388:	1f 93       	push	r17
    838a:	cf 93       	push	r28
    838c:	df 93       	push	r29
    838e:	dc 01       	movw	r26, r24
    uint8_t Feedback;
    uint8_t Out;
    uint8_t In;
    uint8_t ByteCount;

    KeyStream = *Key++;
    8390:	8c 91       	ld	r24, X
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    8392:	d1 2c       	mov	r13, r1
    8394:	30 e0       	ldi	r19, 0x00	; 0
    8396:	86 95       	lsr	r24
    8398:	d7 94       	ror	r13
    839a:	86 95       	lsr	r24
    839c:	37 95       	ror	r19
    839e:	86 95       	lsr	r24
    83a0:	d7 94       	ror	r13
    83a2:	86 95       	lsr	r24
    83a4:	37 95       	ror	r19
    83a6:	86 95       	lsr	r24
    83a8:	d7 94       	ror	r13
    83aa:	86 95       	lsr	r24
    83ac:	37 95       	ror	r19
    83ae:	86 95       	lsr	r24
    83b0:	d7 94       	ror	r13
    83b2:	86 95       	lsr	r24
    83b4:	37 95       	ror	r19
    KeyStream = *Key++;
    83b6:	11 96       	adiw	r26, 0x01	; 1
    83b8:	8c 91       	ld	r24, X
    83ba:	11 97       	sbiw	r26, 0x01	; 1
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    83bc:	86 95       	lsr	r24
    83be:	d7 94       	ror	r13
    83c0:	86 95       	lsr	r24
    83c2:	37 95       	ror	r19
    83c4:	86 95       	lsr	r24
    83c6:	d7 94       	ror	r13
    83c8:	86 95       	lsr	r24
    83ca:	37 95       	ror	r19
    83cc:	86 95       	lsr	r24
    83ce:	d7 94       	ror	r13
    83d0:	86 95       	lsr	r24
    83d2:	37 95       	ror	r19
    83d4:	86 95       	lsr	r24
    83d6:	d7 94       	ror	r13
    83d8:	86 95       	lsr	r24
    83da:	37 95       	ror	r19
    KeyStream = *Key++;
    83dc:	12 96       	adiw	r26, 0x02	; 2
    83de:	8c 91       	ld	r24, X
    83e0:	12 97       	sbiw	r26, 0x02	; 2
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    83e2:	f0 e0       	ldi	r31, 0x00	; 0
    83e4:	10 e0       	ldi	r17, 0x00	; 0
    83e6:	86 95       	lsr	r24
    83e8:	f7 95       	ror	r31
    83ea:	86 95       	lsr	r24
    83ec:	17 95       	ror	r17
    83ee:	86 95       	lsr	r24
    83f0:	f7 95       	ror	r31
    83f2:	86 95       	lsr	r24
    83f4:	17 95       	ror	r17
    83f6:	86 95       	lsr	r24
    83f8:	f7 95       	ror	r31
    83fa:	86 95       	lsr	r24
    83fc:	17 95       	ror	r17
    83fe:	86 95       	lsr	r24
    8400:	f7 95       	ror	r31
    8402:	86 95       	lsr	r24
    8404:	17 95       	ror	r17
    KeyStream = *Key++;
    8406:	13 96       	adiw	r26, 0x03	; 3
    8408:	8c 91       	ld	r24, X
    840a:	13 97       	sbiw	r26, 0x03	; 3
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    840c:	86 95       	lsr	r24
    840e:	f7 95       	ror	r31
    8410:	86 95       	lsr	r24
    8412:	17 95       	ror	r17
    8414:	86 95       	lsr	r24
    8416:	f7 95       	ror	r31
    8418:	86 95       	lsr	r24
    841a:	17 95       	ror	r17
    841c:	86 95       	lsr	r24
    841e:	f7 95       	ror	r31
    8420:	86 95       	lsr	r24
    8422:	17 95       	ror	r17
    8424:	86 95       	lsr	r24
    8426:	f7 95       	ror	r31
    8428:	86 95       	lsr	r24
    842a:	17 95       	ror	r17
    KeyStream = *Key++;
    842c:	14 96       	adiw	r26, 0x04	; 4
    842e:	8c 91       	ld	r24, X
    8430:	14 97       	sbiw	r26, 0x04	; 4
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    8432:	90 e0       	ldi	r25, 0x00	; 0
    8434:	20 e0       	ldi	r18, 0x00	; 0
    8436:	86 95       	lsr	r24
    8438:	97 95       	ror	r25
    843a:	86 95       	lsr	r24
    843c:	27 95       	ror	r18
    843e:	86 95       	lsr	r24
    8440:	97 95       	ror	r25
    8442:	86 95       	lsr	r24
    8444:	27 95       	ror	r18
    8446:	86 95       	lsr	r24
    8448:	97 95       	ror	r25
    844a:	86 95       	lsr	r24
    844c:	27 95       	ror	r18
    844e:	86 95       	lsr	r24
    8450:	97 95       	ror	r25
    8452:	86 95       	lsr	r24
    8454:	27 95       	ror	r18
    KeyStream = *Key++;
    8456:	15 96       	adiw	r26, 0x05	; 5
    8458:	ec 91       	ld	r30, X
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    845a:	e6 95       	lsr	r30
    845c:	97 95       	ror	r25
    845e:	e6 95       	lsr	r30
    8460:	27 95       	ror	r18
    8462:	e6 95       	lsr	r30
    8464:	97 95       	ror	r25
    8466:	e6 95       	lsr	r30
    8468:	27 95       	ror	r18
    846a:	e6 95       	lsr	r30
    846c:	97 95       	ror	r25
    846e:	e6 95       	lsr	r30
    8470:	27 95       	ror	r18
    8472:	e6 95       	lsr	r30
    8474:	97 95       	ror	r25
    8476:	e6 95       	lsr	r30
    8478:	27 95       	ror	r18
    847a:	4b 01       	movw	r8, r22
    847c:	da 01       	movw	r26, r20
    847e:	4c 5f       	subi	r20, 0xFC	; 252
    8480:	5f 4f       	sbci	r21, 0xFF	; 255

    for (ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++) {
        In = *CardNonce ^ *Uid++;
    8482:	0c 91       	ld	r16, X
    8484:	e4 01       	movw	r28, r8
    8486:	b9 90       	ld	r11, Y+
    8488:	4e 01       	movw	r8, r28
    848a:	b0 26       	eor	r11, r16

        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    848c:	c3 2f       	mov	r28, r19
    848e:	d0 e0       	ldi	r29, 0x00	; 0
    8490:	be 01       	movw	r22, r28
    8492:	60 55       	subi	r22, 0x50	; 80
    8494:	7f 4d       	sbci	r23, 0xDF	; 223
    8496:	7b 01       	movw	r14, r22
    8498:	61 2f       	mov	r22, r17
    849a:	70 e0       	ldi	r23, 0x00	; 0
    849c:	60 55       	subi	r22, 0x50	; 80
    849e:	7e 4d       	sbci	r23, 0xDE	; 222
    84a0:	e7 01       	movw	r28, r14
    84a2:	f8 80       	ld	r15, Y
    84a4:	eb 01       	movw	r28, r22
    84a6:	88 81       	ld	r24, Y
    84a8:	6f 2d       	mov	r22, r15
    84aa:	68 2b       	or	r22, r24
    84ac:	e2 2e       	mov	r14, r18
    84ae:	f1 2c       	mov	r15, r1
    84b0:	e7 01       	movw	r28, r14
    84b2:	c0 55       	subi	r28, 0x50	; 80
    84b4:	dd 4d       	sbci	r29, 0xDD	; 221
    84b6:	88 81       	ld	r24, Y
    84b8:	68 2b       	or	r22, r24
    84ba:	70 e0       	ldi	r23, 0x00	; 0
    84bc:	60 57       	subi	r22, 0x70	; 112
    84be:	7f 4d       	sbci	r23, 0xDF	; 223
    84c0:	eb 01       	movw	r28, r22
    84c2:	88 81       	ld	r24, Y
        SHIFT8(KeyStream, Out);
    84c4:	86 95       	lsr	r24
    84c6:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    84c8:	6f 2f       	mov	r22, r31
    84ca:	60 71       	andi	r22, 0x10	; 16
    84cc:	8d 2d       	mov	r24, r13
    84ce:	81 7e       	andi	r24, 0xE1	; 225
    84d0:	68 27       	eor	r22, r24
    84d2:	89 2f       	mov	r24, r25
    84d4:	80 72       	andi	r24, 0x20	; 32
    84d6:	68 27       	eor	r22, r24
    84d8:	83 2f       	mov	r24, r19
    84da:	84 79       	andi	r24, 0x94	; 148
    84dc:	68 27       	eor	r22, r24
    84de:	81 2f       	mov	r24, r17
    84e0:	83 77       	andi	r24, 0x73	; 115
    84e2:	68 27       	eor	r22, r24
    84e4:	82 2f       	mov	r24, r18
    84e6:	8a 73       	andi	r24, 0x3A	; 58
    84e8:	68 27       	eor	r22, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    84ea:	f6 2e       	mov	r15, r22
    84ec:	f2 94       	swap	r15
    84ee:	6f 25       	eor	r22, r15
    Feedback ^= Feedback >> 2;
    84f0:	76 2f       	mov	r23, r22
    84f2:	76 95       	lsr	r23
    84f4:	76 95       	lsr	r23
    84f6:	67 27       	eor	r22, r23
        In = *CardNonce ^ *Uid++;

        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    84f8:	fb 2c       	mov	r15, r11
    84fa:	f6 26       	eor	r15, r22
    84fc:	66 95       	lsr	r22
    84fe:	f6 26       	eor	r15, r22
        SHIFT24(Even0, Even1, Even2, Feedback);
    8500:	7d 2d       	mov	r23, r13
    8502:	6f 2f       	mov	r22, r31
    8504:	89 2f       	mov	r24, r25
    8506:	f6 94       	lsr	r15
    8508:	87 95       	ror	r24
    850a:	67 95       	ror	r22
    850c:	77 95       	ror	r23

        /* Bit 1 */
        In >>= 1;
    850e:	b6 94       	lsr	r11
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    8510:	c7 2e       	mov	r12, r23
    8512:	d1 2c       	mov	r13, r1
    8514:	e6 01       	movw	r28, r12
    8516:	c0 55       	subi	r28, 0x50	; 80
    8518:	df 4d       	sbci	r29, 0xDF	; 223
    851a:	6e 01       	movw	r12, r28
    851c:	e6 2e       	mov	r14, r22
    851e:	f1 2c       	mov	r15, r1
    8520:	e7 01       	movw	r28, r14
    8522:	c0 55       	subi	r28, 0x50	; 80
    8524:	de 4d       	sbci	r29, 0xDE	; 222
    8526:	7e 01       	movw	r14, r28
    8528:	e6 01       	movw	r28, r12
    852a:	f8 81       	ld	r31, Y
    852c:	e7 01       	movw	r28, r14
    852e:	98 81       	ld	r25, Y
    8530:	ef 2e       	mov	r14, r31
    8532:	e9 2a       	or	r14, r25
    8534:	c8 2e       	mov	r12, r24
    8536:	d1 2c       	mov	r13, r1
    8538:	e6 01       	movw	r28, r12
    853a:	c0 55       	subi	r28, 0x50	; 80
    853c:	dd 4d       	sbci	r29, 0xDD	; 221
    853e:	98 81       	ld	r25, Y
    8540:	e9 2a       	or	r14, r25
    8542:	f1 2c       	mov	r15, r1
    8544:	e7 01       	movw	r28, r14
    8546:	c0 57       	subi	r28, 0x70	; 112
    8548:	df 4d       	sbci	r29, 0xDF	; 223
    854a:	98 81       	ld	r25, Y
        SHIFT8(KeyStream, Out);
    854c:	96 95       	lsr	r25
    854e:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8550:	f1 2f       	mov	r31, r17
    8552:	f0 71       	andi	r31, 0x10	; 16
    8554:	93 2f       	mov	r25, r19
    8556:	91 7e       	andi	r25, 0xE1	; 225
    8558:	ef 2e       	mov	r14, r31
    855a:	e9 26       	eor	r14, r25
    855c:	92 2f       	mov	r25, r18
    855e:	90 72       	andi	r25, 0x20	; 32
    8560:	e9 26       	eor	r14, r25
    8562:	97 2f       	mov	r25, r23
    8564:	94 79       	andi	r25, 0x94	; 148
    8566:	e9 26       	eor	r14, r25
    8568:	96 2f       	mov	r25, r22
    856a:	93 77       	andi	r25, 0x73	; 115
    856c:	e9 26       	eor	r14, r25
    856e:	98 2f       	mov	r25, r24
    8570:	9a 73       	andi	r25, 0x3A	; 58
    8572:	e9 26       	eor	r14, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8574:	fe 2c       	mov	r15, r14
    8576:	f2 94       	swap	r15
    8578:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    857a:	ce 2c       	mov	r12, r14
    857c:	c6 94       	lsr	r12
    857e:	c6 94       	lsr	r12
    8580:	ec 24       	eor	r14, r12
        In >>= 1;
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8582:	fb 2c       	mov	r15, r11
    8584:	fe 24       	eor	r15, r14
    8586:	e6 94       	lsr	r14
    8588:	fe 24       	eor	r15, r14
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    858a:	f6 94       	lsr	r15
    858c:	27 95       	ror	r18
    858e:	17 95       	ror	r17
    8590:	37 95       	ror	r19

        /* Bit 2 */
        In >>= 1;
    8592:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8594:	c3 2e       	mov	r12, r19
    8596:	d1 2c       	mov	r13, r1
    8598:	e6 01       	movw	r28, r12
    859a:	c0 55       	subi	r28, 0x50	; 80
    859c:	df 4d       	sbci	r29, 0xDF	; 223
    859e:	6e 01       	movw	r12, r28
    85a0:	e1 2e       	mov	r14, r17
    85a2:	f1 2c       	mov	r15, r1
    85a4:	e7 01       	movw	r28, r14
    85a6:	c0 55       	subi	r28, 0x50	; 80
    85a8:	de 4d       	sbci	r29, 0xDE	; 222
    85aa:	7e 01       	movw	r14, r28
    85ac:	e6 01       	movw	r28, r12
    85ae:	f8 81       	ld	r31, Y
    85b0:	e7 01       	movw	r28, r14
    85b2:	98 81       	ld	r25, Y
    85b4:	ef 2e       	mov	r14, r31
    85b6:	e9 2a       	or	r14, r25
    85b8:	c2 2e       	mov	r12, r18
    85ba:	d1 2c       	mov	r13, r1
    85bc:	e6 01       	movw	r28, r12
    85be:	c0 55       	subi	r28, 0x50	; 80
    85c0:	dd 4d       	sbci	r29, 0xDD	; 221
    85c2:	98 81       	ld	r25, Y
    85c4:	e9 2a       	or	r14, r25
    85c6:	f1 2c       	mov	r15, r1
    85c8:	e7 01       	movw	r28, r14
    85ca:	c0 57       	subi	r28, 0x70	; 112
    85cc:	df 4d       	sbci	r29, 0xDF	; 223
    85ce:	98 81       	ld	r25, Y
        SHIFT8(KeyStream, Out);
    85d0:	96 95       	lsr	r25
    85d2:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    85d4:	f6 2f       	mov	r31, r22
    85d6:	f0 71       	andi	r31, 0x10	; 16
    85d8:	97 2f       	mov	r25, r23
    85da:	91 7e       	andi	r25, 0xE1	; 225
    85dc:	ef 2e       	mov	r14, r31
    85de:	e9 26       	eor	r14, r25
    85e0:	98 2f       	mov	r25, r24
    85e2:	90 72       	andi	r25, 0x20	; 32
    85e4:	e9 26       	eor	r14, r25
    85e6:	93 2f       	mov	r25, r19
    85e8:	94 79       	andi	r25, 0x94	; 148
    85ea:	e9 26       	eor	r14, r25
    85ec:	91 2f       	mov	r25, r17
    85ee:	93 77       	andi	r25, 0x73	; 115
    85f0:	e9 26       	eor	r14, r25
    85f2:	92 2f       	mov	r25, r18
    85f4:	9a 73       	andi	r25, 0x3A	; 58
    85f6:	e9 26       	eor	r14, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    85f8:	fe 2c       	mov	r15, r14
    85fa:	f2 94       	swap	r15
    85fc:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    85fe:	ce 2c       	mov	r12, r14
    8600:	c6 94       	lsr	r12
    8602:	c6 94       	lsr	r12
    8604:	ec 24       	eor	r14, r12
        /* Bit 2 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    8606:	fb 2c       	mov	r15, r11
    8608:	fe 24       	eor	r15, r14
    860a:	e6 94       	lsr	r14
    860c:	fe 24       	eor	r15, r14
        SHIFT24(Even0, Even1, Even2, Feedback);
    860e:	f8 2f       	mov	r31, r24
    8610:	f6 94       	lsr	r15
    8612:	f7 95       	ror	r31
    8614:	67 95       	ror	r22
    8616:	77 95       	ror	r23

        /* Bit 3 */
        In >>= 1;
    8618:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    861a:	87 2f       	mov	r24, r23
    861c:	90 e0       	ldi	r25, 0x00	; 0
    861e:	ec 01       	movw	r28, r24
    8620:	c0 55       	subi	r28, 0x50	; 80
    8622:	df 4d       	sbci	r29, 0xDF	; 223
    8624:	86 2f       	mov	r24, r22
    8626:	90 e0       	ldi	r25, 0x00	; 0
    8628:	80 55       	subi	r24, 0x50	; 80
    862a:	9e 4d       	sbci	r25, 0xDE	; 222
    862c:	f8 80       	ld	r15, Y
    862e:	ec 01       	movw	r28, r24
    8630:	88 81       	ld	r24, Y
    8632:	8f 29       	or	r24, r15
    8634:	ef 2e       	mov	r14, r31
    8636:	f1 2c       	mov	r15, r1
    8638:	e7 01       	movw	r28, r14
    863a:	c0 55       	subi	r28, 0x50	; 80
    863c:	dd 4d       	sbci	r29, 0xDD	; 221
    863e:	98 81       	ld	r25, Y
    8640:	89 2b       	or	r24, r25
    8642:	90 e0       	ldi	r25, 0x00	; 0
    8644:	80 57       	subi	r24, 0x70	; 112
    8646:	9f 4d       	sbci	r25, 0xDF	; 223
    8648:	ec 01       	movw	r28, r24
    864a:	88 81       	ld	r24, Y
        SHIFT8(KeyStream, Out);
    864c:	86 95       	lsr	r24
    864e:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8650:	91 2f       	mov	r25, r17
    8652:	90 71       	andi	r25, 0x10	; 16
    8654:	83 2f       	mov	r24, r19
    8656:	81 7e       	andi	r24, 0xE1	; 225
    8658:	e9 2e       	mov	r14, r25
    865a:	e8 26       	eor	r14, r24
    865c:	82 2f       	mov	r24, r18
    865e:	80 72       	andi	r24, 0x20	; 32
    8660:	e8 26       	eor	r14, r24
    8662:	87 2f       	mov	r24, r23
    8664:	84 79       	andi	r24, 0x94	; 148
    8666:	e8 26       	eor	r14, r24
    8668:	86 2f       	mov	r24, r22
    866a:	83 77       	andi	r24, 0x73	; 115
    866c:	e8 26       	eor	r14, r24
    866e:	8f 2f       	mov	r24, r31
    8670:	8a 73       	andi	r24, 0x3A	; 58
    8672:	e8 26       	eor	r14, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8674:	fe 2c       	mov	r15, r14
    8676:	f2 94       	swap	r15
    8678:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    867a:	ce 2c       	mov	r12, r14
    867c:	c6 94       	lsr	r12
    867e:	c6 94       	lsr	r12
    8680:	ec 24       	eor	r14, r12
        /* Bit 3 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8682:	fb 2c       	mov	r15, r11
    8684:	fe 24       	eor	r15, r14
    8686:	e6 94       	lsr	r14
    8688:	fe 24       	eor	r15, r14
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    868a:	f6 94       	lsr	r15
    868c:	27 95       	ror	r18
    868e:	17 95       	ror	r17
    8690:	37 95       	ror	r19

        /* Bit 4 */
        In >>= 1;
    8692:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8694:	83 2f       	mov	r24, r19
    8696:	90 e0       	ldi	r25, 0x00	; 0
    8698:	ec 01       	movw	r28, r24
    869a:	c0 55       	subi	r28, 0x50	; 80
    869c:	df 4d       	sbci	r29, 0xDF	; 223
    869e:	81 2f       	mov	r24, r17
    86a0:	90 e0       	ldi	r25, 0x00	; 0
    86a2:	80 55       	subi	r24, 0x50	; 80
    86a4:	9e 4d       	sbci	r25, 0xDE	; 222
    86a6:	f8 80       	ld	r15, Y
    86a8:	ec 01       	movw	r28, r24
    86aa:	88 81       	ld	r24, Y
    86ac:	8f 29       	or	r24, r15
    86ae:	e2 2e       	mov	r14, r18
    86b0:	f1 2c       	mov	r15, r1
    86b2:	e7 01       	movw	r28, r14
    86b4:	c0 55       	subi	r28, 0x50	; 80
    86b6:	dd 4d       	sbci	r29, 0xDD	; 221
    86b8:	98 81       	ld	r25, Y
    86ba:	89 2b       	or	r24, r25
    86bc:	90 e0       	ldi	r25, 0x00	; 0
    86be:	80 57       	subi	r24, 0x70	; 112
    86c0:	9f 4d       	sbci	r25, 0xDF	; 223
    86c2:	ec 01       	movw	r28, r24
    86c4:	88 81       	ld	r24, Y
        SHIFT8(KeyStream, Out);
    86c6:	86 95       	lsr	r24
    86c8:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    86ca:	96 2f       	mov	r25, r22
    86cc:	90 71       	andi	r25, 0x10	; 16
    86ce:	87 2f       	mov	r24, r23
    86d0:	81 7e       	andi	r24, 0xE1	; 225
    86d2:	f9 2e       	mov	r15, r25
    86d4:	f8 26       	eor	r15, r24
    86d6:	8f 2f       	mov	r24, r31
    86d8:	80 72       	andi	r24, 0x20	; 32
    86da:	f8 26       	eor	r15, r24
    86dc:	83 2f       	mov	r24, r19
    86de:	84 79       	andi	r24, 0x94	; 148
    86e0:	f8 26       	eor	r15, r24
    86e2:	81 2f       	mov	r24, r17
    86e4:	83 77       	andi	r24, 0x73	; 115
    86e6:	f8 26       	eor	r15, r24
    86e8:	82 2f       	mov	r24, r18
    86ea:	8a 73       	andi	r24, 0x3A	; 58
    86ec:	f8 26       	eor	r15, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    86ee:	9f 2d       	mov	r25, r15
    86f0:	92 95       	swap	r25
    86f2:	f9 26       	eor	r15, r25
    Feedback ^= Feedback >> 2;
    86f4:	ef 2c       	mov	r14, r15
    86f6:	e6 94       	lsr	r14
    86f8:	e6 94       	lsr	r14
    86fa:	fe 24       	eor	r15, r14
        /* Bit 4 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    86fc:	9b 2d       	mov	r25, r11
    86fe:	9f 25       	eor	r25, r15
    8700:	f6 94       	lsr	r15
    8702:	9f 25       	eor	r25, r15
        SHIFT24(Even0, Even1, Even2, Feedback);
    8704:	8f 2f       	mov	r24, r31
    8706:	96 95       	lsr	r25
    8708:	87 95       	ror	r24
    870a:	67 95       	ror	r22
    870c:	77 95       	ror	r23

        /* Bit 5 */
        In >>= 1;
    870e:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    8710:	c7 2e       	mov	r12, r23
    8712:	d1 2c       	mov	r13, r1
    8714:	e6 01       	movw	r28, r12
    8716:	c0 55       	subi	r28, 0x50	; 80
    8718:	df 4d       	sbci	r29, 0xDF	; 223
    871a:	6e 01       	movw	r12, r28
    871c:	e6 2e       	mov	r14, r22
    871e:	f1 2c       	mov	r15, r1
    8720:	e7 01       	movw	r28, r14
    8722:	c0 55       	subi	r28, 0x50	; 80
    8724:	de 4d       	sbci	r29, 0xDE	; 222
    8726:	7e 01       	movw	r14, r28
    8728:	e6 01       	movw	r28, r12
    872a:	f8 81       	ld	r31, Y
    872c:	e7 01       	movw	r28, r14
    872e:	98 81       	ld	r25, Y
    8730:	ef 2e       	mov	r14, r31
    8732:	e9 2a       	or	r14, r25
    8734:	c8 2e       	mov	r12, r24
    8736:	d1 2c       	mov	r13, r1
    8738:	e6 01       	movw	r28, r12
    873a:	c0 55       	subi	r28, 0x50	; 80
    873c:	dd 4d       	sbci	r29, 0xDD	; 221
    873e:	98 81       	ld	r25, Y
    8740:	e9 2a       	or	r14, r25
    8742:	f1 2c       	mov	r15, r1
    8744:	e7 01       	movw	r28, r14
    8746:	c0 57       	subi	r28, 0x70	; 112
    8748:	df 4d       	sbci	r29, 0xDF	; 223
    874a:	98 81       	ld	r25, Y
        SHIFT8(KeyStream, Out);
    874c:	96 95       	lsr	r25
    874e:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8750:	f1 2f       	mov	r31, r17
    8752:	f0 71       	andi	r31, 0x10	; 16
    8754:	93 2f       	mov	r25, r19
    8756:	91 7e       	andi	r25, 0xE1	; 225
    8758:	f9 27       	eor	r31, r25
    875a:	92 2f       	mov	r25, r18
    875c:	90 72       	andi	r25, 0x20	; 32
    875e:	f9 27       	eor	r31, r25
    8760:	97 2f       	mov	r25, r23
    8762:	94 79       	andi	r25, 0x94	; 148
    8764:	f9 27       	eor	r31, r25
    8766:	96 2f       	mov	r25, r22
    8768:	93 77       	andi	r25, 0x73	; 115
    876a:	f9 27       	eor	r31, r25
    876c:	98 2f       	mov	r25, r24
    876e:	9a 73       	andi	r25, 0x3A	; 58
    8770:	f9 27       	eor	r31, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8772:	9f 2f       	mov	r25, r31
    8774:	92 95       	swap	r25
    8776:	f9 27       	eor	r31, r25
    Feedback ^= Feedback >> 2;
    8778:	ff 2e       	mov	r15, r31
    877a:	f6 94       	lsr	r15
    877c:	f6 94       	lsr	r15
    877e:	ff 25       	eor	r31, r15
        /* Bit 5 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8780:	9b 2d       	mov	r25, r11
    8782:	9f 27       	eor	r25, r31
    8784:	f6 95       	lsr	r31
    8786:	9f 27       	eor	r25, r31
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    8788:	96 95       	lsr	r25
    878a:	27 95       	ror	r18
    878c:	17 95       	ror	r17
    878e:	37 95       	ror	r19

        /* Bit 6 */
        In >>= 1;
    8790:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8792:	c3 2e       	mov	r12, r19
    8794:	d1 2c       	mov	r13, r1
    8796:	e6 01       	movw	r28, r12
    8798:	c0 55       	subi	r28, 0x50	; 80
    879a:	df 4d       	sbci	r29, 0xDF	; 223
    879c:	6e 01       	movw	r12, r28
    879e:	e1 2e       	mov	r14, r17
    87a0:	f1 2c       	mov	r15, r1
    87a2:	e7 01       	movw	r28, r14
    87a4:	c0 55       	subi	r28, 0x50	; 80
    87a6:	de 4d       	sbci	r29, 0xDE	; 222
    87a8:	7e 01       	movw	r14, r28
    87aa:	e6 01       	movw	r28, r12
    87ac:	f8 81       	ld	r31, Y
    87ae:	e7 01       	movw	r28, r14
    87b0:	98 81       	ld	r25, Y
    87b2:	ef 2e       	mov	r14, r31
    87b4:	e9 2a       	or	r14, r25
    87b6:	c2 2e       	mov	r12, r18
    87b8:	d1 2c       	mov	r13, r1
    87ba:	e6 01       	movw	r28, r12
    87bc:	c0 55       	subi	r28, 0x50	; 80
    87be:	dd 4d       	sbci	r29, 0xDD	; 221
    87c0:	98 81       	ld	r25, Y
    87c2:	e9 2a       	or	r14, r25
    87c4:	f1 2c       	mov	r15, r1
    87c6:	e7 01       	movw	r28, r14
    87c8:	c0 57       	subi	r28, 0x70	; 112
    87ca:	df 4d       	sbci	r29, 0xDF	; 223
    87cc:	98 81       	ld	r25, Y
        SHIFT8(KeyStream, Out);
    87ce:	96 95       	lsr	r25
    87d0:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    87d2:	f6 2f       	mov	r31, r22
    87d4:	f0 71       	andi	r31, 0x10	; 16
    87d6:	97 2f       	mov	r25, r23
    87d8:	91 7e       	andi	r25, 0xE1	; 225
    87da:	9f 27       	eor	r25, r31
    87dc:	f8 2f       	mov	r31, r24
    87de:	f0 72       	andi	r31, 0x20	; 32
    87e0:	9f 27       	eor	r25, r31
    87e2:	f3 2f       	mov	r31, r19
    87e4:	f4 79       	andi	r31, 0x94	; 148
    87e6:	9f 27       	eor	r25, r31
    87e8:	f1 2f       	mov	r31, r17
    87ea:	f3 77       	andi	r31, 0x73	; 115
    87ec:	9f 27       	eor	r25, r31
    87ee:	f2 2f       	mov	r31, r18
    87f0:	fa 73       	andi	r31, 0x3A	; 58
    87f2:	9f 27       	eor	r25, r31

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    87f4:	f9 2f       	mov	r31, r25
    87f6:	f2 95       	swap	r31
    87f8:	9f 27       	eor	r25, r31
    Feedback ^= Feedback >> 2;
    87fa:	f9 2f       	mov	r31, r25
    87fc:	f6 95       	lsr	r31
    87fe:	f6 95       	lsr	r31
    8800:	9f 27       	eor	r25, r31
        /* Bit 6 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    8802:	fb 2d       	mov	r31, r11
    8804:	f9 27       	eor	r31, r25
    8806:	96 95       	lsr	r25
    8808:	f9 27       	eor	r31, r25
        SHIFT24(Even0, Even1, Even2, Feedback);
    880a:	98 2f       	mov	r25, r24
    880c:	8f 2f       	mov	r24, r31
    880e:	86 95       	lsr	r24
    8810:	97 95       	ror	r25
    8812:	67 95       	ror	r22
    8814:	77 95       	ror	r23
    8816:	d7 2e       	mov	r13, r23
    8818:	f6 2f       	mov	r31, r22

        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    881a:	67 2f       	mov	r22, r23
    881c:	70 e0       	ldi	r23, 0x00	; 0
    881e:	eb 01       	movw	r28, r22
    8820:	c0 55       	subi	r28, 0x50	; 80
    8822:	df 4d       	sbci	r29, 0xDF	; 223
    8824:	6f 2f       	mov	r22, r31
    8826:	70 e0       	ldi	r23, 0x00	; 0
    8828:	60 55       	subi	r22, 0x50	; 80
    882a:	7e 4d       	sbci	r23, 0xDE	; 222
    882c:	f8 80       	ld	r15, Y
    882e:	eb 01       	movw	r28, r22
    8830:	88 81       	ld	r24, Y
    8832:	6f 2d       	mov	r22, r15
    8834:	68 2b       	or	r22, r24
    8836:	e9 2e       	mov	r14, r25
    8838:	f1 2c       	mov	r15, r1
    883a:	e7 01       	movw	r28, r14
    883c:	c0 55       	subi	r28, 0x50	; 80
    883e:	dd 4d       	sbci	r29, 0xDD	; 221
    8840:	88 81       	ld	r24, Y
    8842:	68 2b       	or	r22, r24
    8844:	70 e0       	ldi	r23, 0x00	; 0
    8846:	60 57       	subi	r22, 0x70	; 112
    8848:	7f 4d       	sbci	r23, 0xDF	; 223
    884a:	eb 01       	movw	r28, r22
    884c:	88 81       	ld	r24, Y
        SHIFT8(KeyStream, Out);
    884e:	86 95       	lsr	r24
    8850:	e7 95       	ror	r30
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8852:	63 2f       	mov	r22, r19
    8854:	61 7e       	andi	r22, 0xE1	; 225
    8856:	81 2f       	mov	r24, r17
    8858:	80 71       	andi	r24, 0x10	; 16
    885a:	86 27       	eor	r24, r22
    885c:	62 2f       	mov	r22, r18
    885e:	60 72       	andi	r22, 0x20	; 32
    8860:	86 27       	eor	r24, r22
    8862:	6d 2d       	mov	r22, r13
    8864:	64 79       	andi	r22, 0x94	; 148
    8866:	86 27       	eor	r24, r22
    8868:	6f 2f       	mov	r22, r31
    886a:	63 77       	andi	r22, 0x73	; 115
    886c:	86 27       	eor	r24, r22
    886e:	69 2f       	mov	r22, r25
    8870:	6a 73       	andi	r22, 0x3A	; 58
    8872:	86 27       	eor	r24, r22

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8874:	68 2f       	mov	r22, r24
    8876:	62 95       	swap	r22
    8878:	86 27       	eor	r24, r22
    Feedback ^= Feedback >> 2;
    887a:	68 2f       	mov	r22, r24
    887c:	66 95       	lsr	r22
    887e:	66 95       	lsr	r22
    8880:	86 27       	eor	r24, r22
        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8882:	b6 94       	lsr	r11
    8884:	b8 26       	eor	r11, r24
    8886:	86 95       	lsr	r24
    8888:	b8 26       	eor	r11, r24
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    888a:	81 2f       	mov	r24, r17
    888c:	b6 94       	lsr	r11
    888e:	27 95       	ror	r18
    8890:	87 95       	ror	r24
    8892:	37 95       	ror	r19
    8894:	18 2f       	mov	r17, r24

        /* Encrypt Nonce */
        *CardNonce++ ^= KeyStream; /* Encrypt byte   */
    8896:	0e 27       	eor	r16, r30
    8898:	0d 93       	st	X+, r16
    KeyStream = *Key++;
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    KeyStream = *Key++;
    SPLIT_BYTE(Even2, Odd2, KeyStream);

    for (ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++) {
    889a:	4a 17       	cp	r20, r26
    889c:	5b 07       	cpc	r21, r27
    889e:	09 f0       	breq	.+2      	; 0x88a2 <Crypto1Setup+0x52a>
    88a0:	f0 cd       	rjmp	.-1056   	; 0x8482 <Crypto1Setup+0x10a>

        /* Encrypt Nonce */
        *CardNonce++ ^= KeyStream; /* Encrypt byte   */
    }
    /* save state */
    State.Even[0] = Even0;
    88a2:	d0 92 16 2d 	sts	0x2D16, r13	; 0x802d16 <State>
    State.Even[1] = Even1;
    88a6:	f0 93 17 2d 	sts	0x2D17, r31	; 0x802d17 <State+0x1>
    State.Even[2] = Even2;
    88aa:	90 93 18 2d 	sts	0x2D18, r25	; 0x802d18 <State+0x2>
    State.Odd[0]  = Odd0;
    88ae:	30 93 19 2d 	sts	0x2D19, r19	; 0x802d19 <State+0x3>
    State.Odd[1]  = Odd1;
    88b2:	80 93 1a 2d 	sts	0x2D1A, r24	; 0x802d1a <State+0x4>
    State.Odd[2]  = Odd2;
    88b6:	20 93 1b 2d 	sts	0x2D1B, r18	; 0x802d1b <State+0x5>
}
    88ba:	df 91       	pop	r29
    88bc:	cf 91       	pop	r28
    88be:	1f 91       	pop	r17
    88c0:	0f 91       	pop	r16
    88c2:	ff 90       	pop	r15
    88c4:	ef 90       	pop	r14
    88c6:	df 90       	pop	r13
    88c8:	cf 90       	pop	r12
    88ca:	bf 90       	pop	r11
    88cc:	9f 90       	pop	r9
    88ce:	8f 90       	pop	r8
    88d0:	08 95       	ret

000088d2 <Crypto1SetupNested>:

/* Setup LFSR split into odd and even states, feed in uid ^nonce    */
/* Vesion for nested authentication.                                */
/* Also generates encrypted parity bits at CardNonce[4]..[7]        */
/* Use: Decrypt = false for the tag, Decrypt = true for the reader  */
void Crypto1SetupNested(uint8_t Key[6], uint8_t Uid[4], uint8_t CardNonce[8], bool Decrypt) {
    88d2:	8f 92       	push	r8
    88d4:	9f 92       	push	r9
    88d6:	af 92       	push	r10
    88d8:	bf 92       	push	r11
    88da:	cf 92       	push	r12
    88dc:	df 92       	push	r13
    88de:	ef 92       	push	r14
    88e0:	ff 92       	push	r15
    88e2:	0f 93       	push	r16
    88e4:	1f 93       	push	r17
    88e6:	cf 93       	push	r28
    88e8:	df 93       	push	r29
    88ea:	fc 01       	movw	r30, r24
    88ec:	c6 2f       	mov	r28, r22
    88ee:	f4 2e       	mov	r15, r20
    88f0:	b5 2f       	mov	r27, r21
    uint8_t Feedback;
    uint8_t Out;
    uint8_t In;
    uint8_t ByteCount;

    KeyStream = *Key++;
    88f2:	80 81       	ld	r24, Z
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    88f4:	a0 e0       	ldi	r26, 0x00	; 0
    88f6:	50 e0       	ldi	r21, 0x00	; 0
    88f8:	86 95       	lsr	r24
    88fa:	57 95       	ror	r21
    88fc:	86 95       	lsr	r24
    88fe:	a7 95       	ror	r26
    8900:	86 95       	lsr	r24
    8902:	57 95       	ror	r21
    8904:	86 95       	lsr	r24
    8906:	a7 95       	ror	r26
    8908:	86 95       	lsr	r24
    890a:	57 95       	ror	r21
    890c:	86 95       	lsr	r24
    890e:	a7 95       	ror	r26
    8910:	86 95       	lsr	r24
    8912:	57 95       	ror	r21
    8914:	86 95       	lsr	r24
    8916:	a7 95       	ror	r26
    KeyStream = *Key++;
    8918:	81 81       	ldd	r24, Z+1	; 0x01
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    891a:	86 95       	lsr	r24
    891c:	57 95       	ror	r21
    891e:	86 95       	lsr	r24
    8920:	a7 95       	ror	r26
    8922:	86 95       	lsr	r24
    8924:	57 95       	ror	r21
    8926:	86 95       	lsr	r24
    8928:	a7 95       	ror	r26
    892a:	86 95       	lsr	r24
    892c:	57 95       	ror	r21
    892e:	86 95       	lsr	r24
    8930:	a7 95       	ror	r26
    8932:	86 95       	lsr	r24
    8934:	57 95       	ror	r21
    8936:	86 95       	lsr	r24
    8938:	a7 95       	ror	r26
    KeyStream = *Key++;
    893a:	82 81       	ldd	r24, Z+2	; 0x02
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    893c:	30 e0       	ldi	r19, 0x00	; 0
    893e:	40 e0       	ldi	r20, 0x00	; 0
    8940:	86 95       	lsr	r24
    8942:	47 95       	ror	r20
    8944:	86 95       	lsr	r24
    8946:	37 95       	ror	r19
    8948:	86 95       	lsr	r24
    894a:	47 95       	ror	r20
    894c:	86 95       	lsr	r24
    894e:	37 95       	ror	r19
    8950:	86 95       	lsr	r24
    8952:	47 95       	ror	r20
    8954:	86 95       	lsr	r24
    8956:	37 95       	ror	r19
    8958:	86 95       	lsr	r24
    895a:	47 95       	ror	r20
    895c:	86 95       	lsr	r24
    895e:	37 95       	ror	r19
    KeyStream = *Key++;
    8960:	83 81       	ldd	r24, Z+3	; 0x03
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    8962:	86 95       	lsr	r24
    8964:	47 95       	ror	r20
    8966:	86 95       	lsr	r24
    8968:	37 95       	ror	r19
    896a:	86 95       	lsr	r24
    896c:	47 95       	ror	r20
    896e:	86 95       	lsr	r24
    8970:	37 95       	ror	r19
    8972:	86 95       	lsr	r24
    8974:	47 95       	ror	r20
    8976:	86 95       	lsr	r24
    8978:	37 95       	ror	r19
    897a:	86 95       	lsr	r24
    897c:	47 95       	ror	r20
    897e:	86 95       	lsr	r24
    8980:	37 95       	ror	r19
    KeyStream = *Key++;
    8982:	64 81       	ldd	r22, Z+4	; 0x04
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    8984:	90 e0       	ldi	r25, 0x00	; 0
    8986:	80 e0       	ldi	r24, 0x00	; 0
    8988:	66 95       	lsr	r22
    898a:	87 95       	ror	r24
    898c:	66 95       	lsr	r22
    898e:	97 95       	ror	r25
    8990:	66 95       	lsr	r22
    8992:	87 95       	ror	r24
    8994:	66 95       	lsr	r22
    8996:	97 95       	ror	r25
    8998:	66 95       	lsr	r22
    899a:	87 95       	ror	r24
    899c:	66 95       	lsr	r22
    899e:	97 95       	ror	r25
    89a0:	66 95       	lsr	r22
    89a2:	87 95       	ror	r24
    89a4:	66 95       	lsr	r22
    89a6:	97 95       	ror	r25
    KeyStream = *Key++;
    89a8:	b5 80       	ldd	r11, Z+5	; 0x05
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    89aa:	6b 2d       	mov	r22, r11
    89ac:	66 95       	lsr	r22
    89ae:	87 95       	ror	r24
    89b0:	66 95       	lsr	r22
    89b2:	97 95       	ror	r25
    89b4:	66 95       	lsr	r22
    89b6:	87 95       	ror	r24
    89b8:	66 95       	lsr	r22
    89ba:	97 95       	ror	r25
    89bc:	66 95       	lsr	r22
    89be:	87 95       	ror	r24
    89c0:	66 95       	lsr	r22
    89c2:	97 95       	ror	r25
    89c4:	66 95       	lsr	r22
    89c6:	87 95       	ror	r24
    89c8:	66 95       	lsr	r22
    89ca:	97 95       	ror	r25
    89cc:	b6 2e       	mov	r11, r22

    /* Get first filter output */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    89ce:	ea 2f       	mov	r30, r26
    89d0:	f0 e0       	ldi	r31, 0x00	; 0
    89d2:	e0 55       	subi	r30, 0x50	; 80
    89d4:	ff 4d       	sbci	r31, 0xDF	; 223
    89d6:	03 2f       	mov	r16, r19
    89d8:	10 e0       	ldi	r17, 0x00	; 0
    89da:	00 55       	subi	r16, 0x50	; 80
    89dc:	1e 4d       	sbci	r17, 0xDE	; 222
    89de:	d0 81       	ld	r29, Z
    89e0:	f8 01       	movw	r30, r16
    89e2:	60 81       	ld	r22, Z
    89e4:	d6 2b       	or	r29, r22
    89e6:	09 2f       	mov	r16, r25
    89e8:	10 e0       	ldi	r17, 0x00	; 0
    89ea:	00 55       	subi	r16, 0x50	; 80
    89ec:	1d 4d       	sbci	r17, 0xDD	; 221
    89ee:	f8 01       	movw	r30, r16
    89f0:	60 81       	ld	r22, Z
    89f2:	ed 2f       	mov	r30, r29
    89f4:	e6 2b       	or	r30, r22
    89f6:	f0 e0       	ldi	r31, 0x00	; 0
    89f8:	e0 57       	subi	r30, 0x70	; 112
    89fa:	ff 4d       	sbci	r31, 0xDF	; 223
    89fc:	c0 80       	ld	r12, Z
    89fe:	0c 2f       	mov	r16, r28
    8a00:	17 2f       	mov	r17, r23
    8a02:	cf 2d       	mov	r28, r15
    8a04:	db 2f       	mov	r29, r27
    8a06:	7e 01       	movw	r14, r28
    8a08:	f4 e0       	ldi	r31, 0x04	; 4
    8a0a:	ef 0e       	add	r14, r31
    8a0c:	f1 1c       	adc	r15, r1

    for (ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++) {
        In = *CardNonce ^ *Uid++;
    8a0e:	78 81       	ld	r23, Y
    8a10:	f8 01       	movw	r30, r16
    8a12:	b1 91       	ld	r27, Z+
    8a14:	8f 01       	movw	r16, r30
    8a16:	b7 27       	eor	r27, r23

        /* we can reuse the filter output used to decrypt the parity bit! */
        SHIFT8(KeyStream, Out);
    8a18:	6b 2d       	mov	r22, r11
    8a1a:	c6 94       	lsr	r12
    8a1c:	67 95       	ror	r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8a1e:	f4 2f       	mov	r31, r20
    8a20:	f0 71       	andi	r31, 0x10	; 16
    8a22:	e5 2f       	mov	r30, r21
    8a24:	e1 7e       	andi	r30, 0xE1	; 225
    8a26:	fe 27       	eor	r31, r30
    8a28:	e8 2f       	mov	r30, r24
    8a2a:	e0 72       	andi	r30, 0x20	; 32
    8a2c:	fe 27       	eor	r31, r30
    8a2e:	ea 2f       	mov	r30, r26
    8a30:	e4 79       	andi	r30, 0x94	; 148
    8a32:	fe 27       	eor	r31, r30
    8a34:	e3 2f       	mov	r30, r19
    8a36:	e3 77       	andi	r30, 0x73	; 115
    8a38:	fe 27       	eor	r31, r30
    8a3a:	e9 2f       	mov	r30, r25
    8a3c:	ea 73       	andi	r30, 0x3A	; 58
    8a3e:	fe 27       	eor	r31, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8a40:	ef 2f       	mov	r30, r31
    8a42:	e2 95       	swap	r30
    8a44:	fe 27       	eor	r31, r30
    Feedback ^= Feedback >> 2;
    8a46:	df 2e       	mov	r13, r31
    8a48:	d6 94       	lsr	r13
    8a4a:	d6 94       	lsr	r13
    8a4c:	fd 25       	eor	r31, r13
        In = *CardNonce ^ *Uid++;

        /* we can reuse the filter output used to decrypt the parity bit! */
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    8a4e:	eb 2f       	mov	r30, r27
    8a50:	ef 27       	eor	r30, r31
    8a52:	f6 95       	lsr	r31
    8a54:	ef 27       	eor	r30, r31
        SHIFT24_COND_DECRYPT(Even0, Even1, Even2, Feedback, Out, Decrypt);
    8a56:	20 fd       	sbrc	r18, 0
    8a58:	ec 25       	eor	r30, r12
    8a5a:	e6 95       	lsr	r30
    8a5c:	87 95       	ror	r24
    8a5e:	47 95       	ror	r20
    8a60:	57 95       	ror	r21

        /* Bit 1 */
        In >>= 1;
    8a62:	b6 95       	lsr	r27
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    8a64:	c5 2e       	mov	r12, r21
    8a66:	d1 2c       	mov	r13, r1
    8a68:	f6 01       	movw	r30, r12
    8a6a:	e0 55       	subi	r30, 0x50	; 80
    8a6c:	ff 4d       	sbci	r31, 0xDF	; 223
    8a6e:	6f 01       	movw	r12, r30
    8a70:	a4 2e       	mov	r10, r20
    8a72:	b1 2c       	mov	r11, r1
    8a74:	f5 01       	movw	r30, r10
    8a76:	e0 55       	subi	r30, 0x50	; 80
    8a78:	fe 4d       	sbci	r31, 0xDE	; 222
    8a7a:	5f 01       	movw	r10, r30
    8a7c:	f6 01       	movw	r30, r12
    8a7e:	d0 80       	ld	r13, Z
    8a80:	f5 01       	movw	r30, r10
    8a82:	c0 80       	ld	r12, Z
    8a84:	dc 28       	or	r13, r12
    8a86:	e8 2f       	mov	r30, r24
    8a88:	f0 e0       	ldi	r31, 0x00	; 0
    8a8a:	e0 55       	subi	r30, 0x50	; 80
    8a8c:	fd 4d       	sbci	r31, 0xDD	; 221
    8a8e:	f0 81       	ld	r31, Z
    8a90:	ed 2d       	mov	r30, r13
    8a92:	ef 2b       	or	r30, r31
    8a94:	f0 e0       	ldi	r31, 0x00	; 0
    8a96:	e0 57       	subi	r30, 0x70	; 112
    8a98:	ff 4d       	sbci	r31, 0xDF	; 223
    8a9a:	c0 80       	ld	r12, Z
        SHIFT8(KeyStream, Out);
    8a9c:	c6 94       	lsr	r12
    8a9e:	67 95       	ror	r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8aa0:	f3 2f       	mov	r31, r19
    8aa2:	f0 71       	andi	r31, 0x10	; 16
    8aa4:	ea 2f       	mov	r30, r26
    8aa6:	e1 7e       	andi	r30, 0xE1	; 225
    8aa8:	fe 27       	eor	r31, r30
    8aaa:	e9 2f       	mov	r30, r25
    8aac:	e0 72       	andi	r30, 0x20	; 32
    8aae:	fe 27       	eor	r31, r30
    8ab0:	e5 2f       	mov	r30, r21
    8ab2:	e4 79       	andi	r30, 0x94	; 148
    8ab4:	fe 27       	eor	r31, r30
    8ab6:	e4 2f       	mov	r30, r20
    8ab8:	e3 77       	andi	r30, 0x73	; 115
    8aba:	fe 27       	eor	r31, r30
    8abc:	e8 2f       	mov	r30, r24
    8abe:	ea 73       	andi	r30, 0x3A	; 58
    8ac0:	fe 27       	eor	r31, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8ac2:	ef 2f       	mov	r30, r31
    8ac4:	e2 95       	swap	r30
    8ac6:	fe 27       	eor	r31, r30
    Feedback ^= Feedback >> 2;
    8ac8:	df 2e       	mov	r13, r31
    8aca:	d6 94       	lsr	r13
    8acc:	d6 94       	lsr	r13
    8ace:	fd 25       	eor	r31, r13
        In >>= 1;
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8ad0:	eb 2f       	mov	r30, r27
    8ad2:	ef 27       	eor	r30, r31
    8ad4:	f6 95       	lsr	r31
    8ad6:	ef 27       	eor	r30, r31
        SHIFT24_COND_DECRYPT(Odd0, Odd1, Odd2, Feedback, Out, Decrypt);
    8ad8:	da 2e       	mov	r13, r26
    8ada:	20 fd       	sbrc	r18, 0
    8adc:	ec 25       	eor	r30, r12
    8ade:	e6 95       	lsr	r30
    8ae0:	97 95       	ror	r25
    8ae2:	37 95       	ror	r19
    8ae4:	d7 94       	ror	r13

        /* Bit 2 */
        In >>= 1;
    8ae6:	cb 2e       	mov	r12, r27
    8ae8:	c6 94       	lsr	r12
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8aea:	ad 2d       	mov	r26, r13
    8aec:	b0 e0       	ldi	r27, 0x00	; 0
    8aee:	a0 55       	subi	r26, 0x50	; 80
    8af0:	bf 4d       	sbci	r27, 0xDF	; 223
    8af2:	e3 2f       	mov	r30, r19
    8af4:	f0 e0       	ldi	r31, 0x00	; 0
    8af6:	e0 55       	subi	r30, 0x50	; 80
    8af8:	fe 4d       	sbci	r31, 0xDE	; 222
    8afa:	ac 91       	ld	r26, X
    8afc:	e0 81       	ld	r30, Z
    8afe:	ea 2b       	or	r30, r26
    8b00:	a9 2f       	mov	r26, r25
    8b02:	b0 e0       	ldi	r27, 0x00	; 0
    8b04:	a0 55       	subi	r26, 0x50	; 80
    8b06:	bd 4d       	sbci	r27, 0xDD	; 221
    8b08:	fc 91       	ld	r31, X
    8b0a:	ef 2b       	or	r30, r31
    8b0c:	f0 e0       	ldi	r31, 0x00	; 0
    8b0e:	e0 57       	subi	r30, 0x70	; 112
    8b10:	ff 4d       	sbci	r31, 0xDF	; 223
    8b12:	b0 81       	ld	r27, Z
        SHIFT8(KeyStream, Out);
    8b14:	b6 95       	lsr	r27
    8b16:	67 95       	ror	r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8b18:	f4 2f       	mov	r31, r20
    8b1a:	f0 71       	andi	r31, 0x10	; 16
    8b1c:	e5 2f       	mov	r30, r21
    8b1e:	e1 7e       	andi	r30, 0xE1	; 225
    8b20:	fe 27       	eor	r31, r30
    8b22:	e8 2f       	mov	r30, r24
    8b24:	e0 72       	andi	r30, 0x20	; 32
    8b26:	fe 27       	eor	r31, r30
    8b28:	ed 2d       	mov	r30, r13
    8b2a:	e4 79       	andi	r30, 0x94	; 148
    8b2c:	fe 27       	eor	r31, r30
    8b2e:	e3 2f       	mov	r30, r19
    8b30:	e3 77       	andi	r30, 0x73	; 115
    8b32:	fe 27       	eor	r31, r30
    8b34:	e9 2f       	mov	r30, r25
    8b36:	ea 73       	andi	r30, 0x3A	; 58
    8b38:	fe 27       	eor	r31, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8b3a:	ef 2f       	mov	r30, r31
    8b3c:	e2 95       	swap	r30
    8b3e:	fe 27       	eor	r31, r30
    Feedback ^= Feedback >> 2;
    8b40:	af 2f       	mov	r26, r31
    8b42:	a6 95       	lsr	r26
    8b44:	a6 95       	lsr	r26
    8b46:	fa 27       	eor	r31, r26
        /* Bit 2 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    8b48:	ec 2d       	mov	r30, r12
    8b4a:	ef 27       	eor	r30, r31
    8b4c:	f6 95       	lsr	r31
    8b4e:	ef 27       	eor	r30, r31
        SHIFT24_COND_DECRYPT(Even0, Even1, Even2, Feedback, Out, Decrypt);
    8b50:	20 fd       	sbrc	r18, 0
    8b52:	eb 27       	eor	r30, r27
    8b54:	e6 95       	lsr	r30
    8b56:	87 95       	ror	r24
    8b58:	47 95       	ror	r20
    8b5a:	57 95       	ror	r21

        /* Bit 3 */
        In >>= 1;
    8b5c:	c6 94       	lsr	r12
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    8b5e:	a5 2f       	mov	r26, r21
    8b60:	b0 e0       	ldi	r27, 0x00	; 0
    8b62:	a0 55       	subi	r26, 0x50	; 80
    8b64:	bf 4d       	sbci	r27, 0xDF	; 223
    8b66:	e4 2f       	mov	r30, r20
    8b68:	f0 e0       	ldi	r31, 0x00	; 0
    8b6a:	e0 55       	subi	r30, 0x50	; 80
    8b6c:	fe 4d       	sbci	r31, 0xDE	; 222
    8b6e:	ac 91       	ld	r26, X
    8b70:	e0 81       	ld	r30, Z
    8b72:	ea 2b       	or	r30, r26
    8b74:	a8 2f       	mov	r26, r24
    8b76:	b0 e0       	ldi	r27, 0x00	; 0
    8b78:	a0 55       	subi	r26, 0x50	; 80
    8b7a:	bd 4d       	sbci	r27, 0xDD	; 221
    8b7c:	fc 91       	ld	r31, X
    8b7e:	ef 2b       	or	r30, r31
    8b80:	f0 e0       	ldi	r31, 0x00	; 0
    8b82:	e0 57       	subi	r30, 0x70	; 112
    8b84:	ff 4d       	sbci	r31, 0xDF	; 223
    8b86:	b0 81       	ld	r27, Z
        SHIFT8(KeyStream, Out);
    8b88:	b6 95       	lsr	r27
    8b8a:	67 95       	ror	r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8b8c:	f3 2f       	mov	r31, r19
    8b8e:	f0 71       	andi	r31, 0x10	; 16
    8b90:	ed 2d       	mov	r30, r13
    8b92:	e1 7e       	andi	r30, 0xE1	; 225
    8b94:	fe 27       	eor	r31, r30
    8b96:	e9 2f       	mov	r30, r25
    8b98:	e0 72       	andi	r30, 0x20	; 32
    8b9a:	fe 27       	eor	r31, r30
    8b9c:	e5 2f       	mov	r30, r21
    8b9e:	e4 79       	andi	r30, 0x94	; 148
    8ba0:	fe 27       	eor	r31, r30
    8ba2:	e4 2f       	mov	r30, r20
    8ba4:	e3 77       	andi	r30, 0x73	; 115
    8ba6:	fe 27       	eor	r31, r30
    8ba8:	e8 2f       	mov	r30, r24
    8baa:	ea 73       	andi	r30, 0x3A	; 58
    8bac:	fe 27       	eor	r31, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8bae:	ef 2f       	mov	r30, r31
    8bb0:	e2 95       	swap	r30
    8bb2:	fe 27       	eor	r31, r30
    Feedback ^= Feedback >> 2;
    8bb4:	af 2f       	mov	r26, r31
    8bb6:	a6 95       	lsr	r26
    8bb8:	a6 95       	lsr	r26
    8bba:	fa 27       	eor	r31, r26
        /* Bit 3 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8bbc:	ec 2d       	mov	r30, r12
    8bbe:	ef 27       	eor	r30, r31
    8bc0:	f6 95       	lsr	r31
    8bc2:	ef 27       	eor	r30, r31
        SHIFT24_COND_DECRYPT(Odd0, Odd1, Odd2, Feedback, Out, Decrypt);
    8bc4:	20 fd       	sbrc	r18, 0
    8bc6:	eb 27       	eor	r30, r27
    8bc8:	e6 95       	lsr	r30
    8bca:	97 95       	ror	r25
    8bcc:	37 95       	ror	r19
    8bce:	d7 94       	ror	r13

        /* Bit 4 */
        In >>= 1;
    8bd0:	c6 94       	lsr	r12
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8bd2:	ad 2d       	mov	r26, r13
    8bd4:	b0 e0       	ldi	r27, 0x00	; 0
    8bd6:	a0 55       	subi	r26, 0x50	; 80
    8bd8:	bf 4d       	sbci	r27, 0xDF	; 223
    8bda:	e3 2f       	mov	r30, r19
    8bdc:	f0 e0       	ldi	r31, 0x00	; 0
    8bde:	e0 55       	subi	r30, 0x50	; 80
    8be0:	fe 4d       	sbci	r31, 0xDE	; 222
    8be2:	ac 91       	ld	r26, X
    8be4:	e0 81       	ld	r30, Z
    8be6:	ea 2b       	or	r30, r26
    8be8:	a9 2f       	mov	r26, r25
    8bea:	b0 e0       	ldi	r27, 0x00	; 0
    8bec:	a0 55       	subi	r26, 0x50	; 80
    8bee:	bd 4d       	sbci	r27, 0xDD	; 221
    8bf0:	fc 91       	ld	r31, X
    8bf2:	ef 2b       	or	r30, r31
    8bf4:	f0 e0       	ldi	r31, 0x00	; 0
    8bf6:	e0 57       	subi	r30, 0x70	; 112
    8bf8:	ff 4d       	sbci	r31, 0xDF	; 223
    8bfa:	b0 81       	ld	r27, Z
        SHIFT8(KeyStream, Out);
    8bfc:	b6 95       	lsr	r27
    8bfe:	67 95       	ror	r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8c00:	f4 2f       	mov	r31, r20
    8c02:	f0 71       	andi	r31, 0x10	; 16
    8c04:	e5 2f       	mov	r30, r21
    8c06:	e1 7e       	andi	r30, 0xE1	; 225
    8c08:	fe 27       	eor	r31, r30
    8c0a:	e8 2f       	mov	r30, r24
    8c0c:	e0 72       	andi	r30, 0x20	; 32
    8c0e:	fe 27       	eor	r31, r30
    8c10:	ed 2d       	mov	r30, r13
    8c12:	e4 79       	andi	r30, 0x94	; 148
    8c14:	fe 27       	eor	r31, r30
    8c16:	e3 2f       	mov	r30, r19
    8c18:	e3 77       	andi	r30, 0x73	; 115
    8c1a:	fe 27       	eor	r31, r30
    8c1c:	e9 2f       	mov	r30, r25
    8c1e:	ea 73       	andi	r30, 0x3A	; 58
    8c20:	fe 27       	eor	r31, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8c22:	ef 2f       	mov	r30, r31
    8c24:	e2 95       	swap	r30
    8c26:	fe 27       	eor	r31, r30
    Feedback ^= Feedback >> 2;
    8c28:	af 2f       	mov	r26, r31
    8c2a:	a6 95       	lsr	r26
    8c2c:	a6 95       	lsr	r26
    8c2e:	fa 27       	eor	r31, r26
        /* Bit 4 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    8c30:	ec 2d       	mov	r30, r12
    8c32:	ef 27       	eor	r30, r31
    8c34:	f6 95       	lsr	r31
    8c36:	ef 27       	eor	r30, r31
        SHIFT24_COND_DECRYPT(Even0, Even1, Even2, Feedback, Out, Decrypt);
    8c38:	20 fd       	sbrc	r18, 0
    8c3a:	eb 27       	eor	r30, r27
    8c3c:	e6 95       	lsr	r30
    8c3e:	87 95       	ror	r24
    8c40:	47 95       	ror	r20
    8c42:	57 95       	ror	r21

        /* Bit 5 */
        In >>= 1;
    8c44:	c6 94       	lsr	r12
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    8c46:	a5 2f       	mov	r26, r21
    8c48:	b0 e0       	ldi	r27, 0x00	; 0
    8c4a:	a0 55       	subi	r26, 0x50	; 80
    8c4c:	bf 4d       	sbci	r27, 0xDF	; 223
    8c4e:	e4 2f       	mov	r30, r20
    8c50:	f0 e0       	ldi	r31, 0x00	; 0
    8c52:	e0 55       	subi	r30, 0x50	; 80
    8c54:	fe 4d       	sbci	r31, 0xDE	; 222
    8c56:	ac 91       	ld	r26, X
    8c58:	e0 81       	ld	r30, Z
    8c5a:	ea 2b       	or	r30, r26
    8c5c:	a8 2f       	mov	r26, r24
    8c5e:	b0 e0       	ldi	r27, 0x00	; 0
    8c60:	a0 55       	subi	r26, 0x50	; 80
    8c62:	bd 4d       	sbci	r27, 0xDD	; 221
    8c64:	fc 91       	ld	r31, X
    8c66:	ef 2b       	or	r30, r31
    8c68:	f0 e0       	ldi	r31, 0x00	; 0
    8c6a:	e0 57       	subi	r30, 0x70	; 112
    8c6c:	ff 4d       	sbci	r31, 0xDF	; 223
    8c6e:	b0 81       	ld	r27, Z
        SHIFT8(KeyStream, Out);
    8c70:	b6 95       	lsr	r27
    8c72:	67 95       	ror	r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8c74:	f3 2f       	mov	r31, r19
    8c76:	f0 71       	andi	r31, 0x10	; 16
    8c78:	ed 2d       	mov	r30, r13
    8c7a:	e1 7e       	andi	r30, 0xE1	; 225
    8c7c:	fe 27       	eor	r31, r30
    8c7e:	e9 2f       	mov	r30, r25
    8c80:	e0 72       	andi	r30, 0x20	; 32
    8c82:	fe 27       	eor	r31, r30
    8c84:	e5 2f       	mov	r30, r21
    8c86:	e4 79       	andi	r30, 0x94	; 148
    8c88:	fe 27       	eor	r31, r30
    8c8a:	e4 2f       	mov	r30, r20
    8c8c:	e3 77       	andi	r30, 0x73	; 115
    8c8e:	fe 27       	eor	r31, r30
    8c90:	e8 2f       	mov	r30, r24
    8c92:	ea 73       	andi	r30, 0x3A	; 58
    8c94:	fe 27       	eor	r31, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8c96:	ef 2f       	mov	r30, r31
    8c98:	e2 95       	swap	r30
    8c9a:	fe 27       	eor	r31, r30
    Feedback ^= Feedback >> 2;
    8c9c:	af 2f       	mov	r26, r31
    8c9e:	a6 95       	lsr	r26
    8ca0:	a6 95       	lsr	r26
    8ca2:	fa 27       	eor	r31, r26
        /* Bit 5 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8ca4:	ec 2d       	mov	r30, r12
    8ca6:	ef 27       	eor	r30, r31
    8ca8:	f6 95       	lsr	r31
    8caa:	ef 27       	eor	r30, r31
        SHIFT24_COND_DECRYPT(Odd0, Odd1, Odd2, Feedback, Out, Decrypt);
    8cac:	20 fd       	sbrc	r18, 0
    8cae:	eb 27       	eor	r30, r27
    8cb0:	e6 95       	lsr	r30
    8cb2:	97 95       	ror	r25
    8cb4:	37 95       	ror	r19
    8cb6:	d7 94       	ror	r13

        /* Bit 6 */
        In >>= 1;
    8cb8:	c6 94       	lsr	r12
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8cba:	ed 2d       	mov	r30, r13
    8cbc:	f0 e0       	ldi	r31, 0x00	; 0
    8cbe:	e0 55       	subi	r30, 0x50	; 80
    8cc0:	ff 4d       	sbci	r31, 0xDF	; 223
    8cc2:	a3 2f       	mov	r26, r19
    8cc4:	b0 e0       	ldi	r27, 0x00	; 0
    8cc6:	a0 55       	subi	r26, 0x50	; 80
    8cc8:	be 4d       	sbci	r27, 0xDE	; 222
    8cca:	f0 81       	ld	r31, Z
    8ccc:	ec 91       	ld	r30, X
    8cce:	ef 2b       	or	r30, r31
    8cd0:	a9 2f       	mov	r26, r25
    8cd2:	b0 e0       	ldi	r27, 0x00	; 0
    8cd4:	a0 55       	subi	r26, 0x50	; 80
    8cd6:	bd 4d       	sbci	r27, 0xDD	; 221
    8cd8:	fc 91       	ld	r31, X
    8cda:	ef 2b       	or	r30, r31
    8cdc:	f0 e0       	ldi	r31, 0x00	; 0
    8cde:	e0 57       	subi	r30, 0x70	; 112
    8ce0:	ff 4d       	sbci	r31, 0xDF	; 223
    8ce2:	b0 81       	ld	r27, Z
        SHIFT8(KeyStream, Out);
    8ce4:	b6 95       	lsr	r27
    8ce6:	67 95       	ror	r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8ce8:	f4 2f       	mov	r31, r20
    8cea:	f0 71       	andi	r31, 0x10	; 16
    8cec:	e5 2f       	mov	r30, r21
    8cee:	e1 7e       	andi	r30, 0xE1	; 225
    8cf0:	fe 27       	eor	r31, r30
    8cf2:	e8 2f       	mov	r30, r24
    8cf4:	e0 72       	andi	r30, 0x20	; 32
    8cf6:	fe 27       	eor	r31, r30
    8cf8:	ed 2d       	mov	r30, r13
    8cfa:	e4 79       	andi	r30, 0x94	; 148
    8cfc:	fe 27       	eor	r31, r30
    8cfe:	e3 2f       	mov	r30, r19
    8d00:	e3 77       	andi	r30, 0x73	; 115
    8d02:	fe 27       	eor	r31, r30
    8d04:	e9 2f       	mov	r30, r25
    8d06:	ea 73       	andi	r30, 0x3A	; 58
    8d08:	fe 27       	eor	r31, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8d0a:	ef 2f       	mov	r30, r31
    8d0c:	e2 95       	swap	r30
    8d0e:	fe 27       	eor	r31, r30
    Feedback ^= Feedback >> 2;
    8d10:	af 2f       	mov	r26, r31
    8d12:	a6 95       	lsr	r26
    8d14:	a6 95       	lsr	r26
    8d16:	fa 27       	eor	r31, r26
        /* Bit 6 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        Feedback ^= In;
    8d18:	ec 2d       	mov	r30, r12
    8d1a:	ef 27       	eor	r30, r31
    8d1c:	f6 95       	lsr	r31
    8d1e:	ef 27       	eor	r30, r31
        SHIFT24_COND_DECRYPT(Even0, Even1, Even2, Feedback, Out, Decrypt);
    8d20:	20 fd       	sbrc	r18, 0
    8d22:	eb 27       	eor	r30, r27
    8d24:	e6 95       	lsr	r30
    8d26:	87 95       	ror	r24
    8d28:	47 95       	ror	r20
    8d2a:	57 95       	ror	r21

        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    8d2c:	a5 2f       	mov	r26, r21
    8d2e:	b0 e0       	ldi	r27, 0x00	; 0
    8d30:	a0 55       	subi	r26, 0x50	; 80
    8d32:	bf 4d       	sbci	r27, 0xDF	; 223
    8d34:	e4 2f       	mov	r30, r20
    8d36:	f0 e0       	ldi	r31, 0x00	; 0
    8d38:	e0 55       	subi	r30, 0x50	; 80
    8d3a:	fe 4d       	sbci	r31, 0xDE	; 222
    8d3c:	ac 91       	ld	r26, X
    8d3e:	e0 81       	ld	r30, Z
    8d40:	ea 2b       	or	r30, r26
    8d42:	a8 2f       	mov	r26, r24
    8d44:	b0 e0       	ldi	r27, 0x00	; 0
    8d46:	a0 55       	subi	r26, 0x50	; 80
    8d48:	bd 4d       	sbci	r27, 0xDD	; 221
    8d4a:	fc 91       	ld	r31, X
    8d4c:	ef 2b       	or	r30, r31
    8d4e:	f0 e0       	ldi	r31, 0x00	; 0
    8d50:	e0 57       	subi	r30, 0x70	; 112
    8d52:	ff 4d       	sbci	r31, 0xDF	; 223
    8d54:	f0 81       	ld	r31, Z
        SHIFT8(KeyStream, Out);
    8d56:	f6 95       	lsr	r31
    8d58:	67 95       	ror	r22
    8d5a:	b6 2e       	mov	r11, r22
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8d5c:	ed 2d       	mov	r30, r13
    8d5e:	e1 7e       	andi	r30, 0xE1	; 225
    8d60:	63 2f       	mov	r22, r19
    8d62:	60 71       	andi	r22, 0x10	; 16
    8d64:	6e 27       	eor	r22, r30
    8d66:	e9 2f       	mov	r30, r25
    8d68:	e0 72       	andi	r30, 0x20	; 32
    8d6a:	6e 27       	eor	r22, r30
    8d6c:	e5 2f       	mov	r30, r21
    8d6e:	e4 79       	andi	r30, 0x94	; 148
    8d70:	6e 27       	eor	r22, r30
    8d72:	e4 2f       	mov	r30, r20
    8d74:	e3 77       	andi	r30, 0x73	; 115
    8d76:	6e 27       	eor	r22, r30
    8d78:	e8 2f       	mov	r30, r24
    8d7a:	ea 73       	andi	r30, 0x3A	; 58
    8d7c:	6e 27       	eor	r22, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8d7e:	e6 2f       	mov	r30, r22
    8d80:	e2 95       	swap	r30
    8d82:	6e 27       	eor	r22, r30
    Feedback ^= Feedback >> 2;
    8d84:	e6 2f       	mov	r30, r22
    8d86:	e6 95       	lsr	r30
    8d88:	e6 95       	lsr	r30
    8d8a:	6e 27       	eor	r22, r30
        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        Feedback ^= In;
    8d8c:	c6 94       	lsr	r12
    8d8e:	c6 26       	eor	r12, r22
    8d90:	66 95       	lsr	r22
    8d92:	c6 26       	eor	r12, r22
        SHIFT24_COND_DECRYPT(Odd0, Odd1, Odd2, Feedback, Out, Decrypt);
    8d94:	20 fd       	sbrc	r18, 0
    8d96:	cf 26       	eor	r12, r31
    8d98:	c6 94       	lsr	r12
    8d9a:	97 95       	ror	r25
    8d9c:	37 95       	ror	r19
    8d9e:	d7 94       	ror	r13
    8da0:	ad 2d       	mov	r26, r13

        /* Generate parity bit */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8da2:	cd 2c       	mov	r12, r13
    8da4:	d1 2c       	mov	r13, r1
    8da6:	f6 01       	movw	r30, r12
    8da8:	e0 55       	subi	r30, 0x50	; 80
    8daa:	ff 4d       	sbci	r31, 0xDF	; 223
    8dac:	6f 01       	movw	r12, r30
    8dae:	83 2e       	mov	r8, r19
    8db0:	91 2c       	mov	r9, r1
    8db2:	f4 01       	movw	r30, r8
    8db4:	e0 55       	subi	r30, 0x50	; 80
    8db6:	fe 4d       	sbci	r31, 0xDE	; 222
    8db8:	4f 01       	movw	r8, r30
    8dba:	f6 01       	movw	r30, r12
    8dbc:	b0 81       	ld	r27, Z
    8dbe:	f4 01       	movw	r30, r8
    8dc0:	60 81       	ld	r22, Z
    8dc2:	b6 2b       	or	r27, r22
    8dc4:	c9 2e       	mov	r12, r25
    8dc6:	d1 2c       	mov	r13, r1
    8dc8:	f6 01       	movw	r30, r12
    8dca:	e0 55       	subi	r30, 0x50	; 80
    8dcc:	fd 4d       	sbci	r31, 0xDD	; 221
    8dce:	60 81       	ld	r22, Z
    8dd0:	eb 2f       	mov	r30, r27
    8dd2:	e6 2b       	or	r30, r22
    8dd4:	f0 e0       	ldi	r31, 0x00	; 0
    8dd6:	e0 57       	subi	r30, 0x70	; 112
    8dd8:	ff 4d       	sbci	r31, 0xDF	; 223
    8dda:	c0 80       	ld	r12, Z
}

INLINE uint8_t OddParityBit(uint8_t Byte) {
    extern const uint8_t PROGMEM OddParityByteTable[];

    return pgm_read_byte(&OddParityByteTable[Byte]);
    8ddc:	e7 2f       	mov	r30, r23
    8dde:	f0 e0       	ldi	r31, 0x00	; 0
    8de0:	ea 50       	subi	r30, 0x0A	; 10
    8de2:	f9 4f       	sbci	r31, 0xF9	; 249
    8de4:	e4 91       	lpm	r30, Z
        In = *CardNonce;
        Feedback = ODD_PARITY(In);
        CardNonce[NONCE_SIZE] = Out ^ Feedback;  /* Encrypted parity at Offset 4*/
    8de6:	ec 25       	eor	r30, r12
    8de8:	ec 83       	std	Y+4, r30	; 0x04

        /* Encrypt byte   */
        *CardNonce++ = In ^ KeyStream;
    8dea:	7b 25       	eor	r23, r11
    8dec:	79 93       	st	Y+, r23
    SPLIT_BYTE(Even2, Odd2, KeyStream);

    /* Get first filter output */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);

    for (ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++) {
    8dee:	ec 16       	cp	r14, r28
    8df0:	fd 06       	cpc	r15, r29
    8df2:	09 f0       	breq	.+2      	; 0x8df6 <Crypto1SetupNested+0x524>
    8df4:	0c ce       	rjmp	.-1000   	; 0x8a0e <Crypto1SetupNested+0x13c>

        /* Encrypt byte   */
        *CardNonce++ = In ^ KeyStream;
    }
    /* save state */
    State.Even[0] = Even0;
    8df6:	50 93 16 2d 	sts	0x2D16, r21	; 0x802d16 <State>
    State.Even[1] = Even1;
    8dfa:	40 93 17 2d 	sts	0x2D17, r20	; 0x802d17 <State+0x1>
    State.Even[2] = Even2;
    8dfe:	80 93 18 2d 	sts	0x2D18, r24	; 0x802d18 <State+0x2>
    State.Odd[0]  = Odd0;
    8e02:	a0 93 19 2d 	sts	0x2D19, r26	; 0x802d19 <State+0x3>
    State.Odd[1]  = Odd1;
    8e06:	30 93 1a 2d 	sts	0x2D1A, r19	; 0x802d1a <State+0x4>
    State.Odd[2]  = Odd2;
    8e0a:	90 93 1b 2d 	sts	0x2D1B, r25	; 0x802d1b <State+0x5>
}
    8e0e:	df 91       	pop	r29
    8e10:	cf 91       	pop	r28
    8e12:	1f 91       	pop	r17
    8e14:	0f 91       	pop	r16
    8e16:	ff 90       	pop	r15
    8e18:	ef 90       	pop	r14
    8e1a:	df 90       	pop	r13
    8e1c:	cf 90       	pop	r12
    8e1e:	bf 90       	pop	r11
    8e20:	af 90       	pop	r10
    8e22:	9f 90       	pop	r9
    8e24:	8f 90       	pop	r8
    8e26:	08 95       	ret

00008e28 <Crypto1Auth>:

/* Crypto1Auth is similar to Crypto1Byte but */
/* EncryptedReaderNonce is decrypted and fed back */
void Crypto1Auth(uint8_t EncryptedReaderNonce[NONCE_SIZE]) {
    8e28:	bf 92       	push	r11
    8e2a:	cf 92       	push	r12
    8e2c:	df 92       	push	r13
    8e2e:	ef 92       	push	r14
    8e30:	ff 92       	push	r15
    8e32:	0f 93       	push	r16
    8e34:	1f 93       	push	r17
    8e36:	cf 93       	push	r28
    8e38:	df 93       	push	r29
    uint8_t In;
    uint8_t Feedback;
    uint8_t i;

    /* read state */
    Even0 = State.Even[0];
    8e3a:	a0 91 16 2d 	lds	r26, 0x2D16	; 0x802d16 <State>
    Even1 = State.Even[1];
    8e3e:	50 91 17 2d 	lds	r21, 0x2D17	; 0x802d17 <State+0x1>
    Even2 = State.Even[2];
    8e42:	10 91 18 2d 	lds	r17, 0x2D18	; 0x802d18 <State+0x2>
    Odd0 = State.Odd[0];
    8e46:	40 91 19 2d 	lds	r20, 0x2D19	; 0x802d19 <State+0x3>
    Odd1 = State.Odd[1];
    8e4a:	30 91 1a 2d 	lds	r19, 0x2D1A	; 0x802d1a <State+0x4>
    Odd2 = State.Odd[2];
    8e4e:	20 91 1b 2d 	lds	r18, 0x2D1B	; 0x802d1b <State+0x5>
    8e52:	fc 01       	movw	r30, r24
    8e54:	bc 01       	movw	r22, r24
    8e56:	6c 5f       	subi	r22, 0xFC	; 252
    8e58:	7f 4f       	sbci	r23, 0xFF	; 255

    /* 4 Bytes */
    for (i = 0; i < NONCE_SIZE; i++) {
        In = EncryptedReaderNonce[i];
    8e5a:	01 91       	ld	r16, Z+
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8e5c:	95 2f       	mov	r25, r21
    8e5e:	90 71       	andi	r25, 0x10	; 16
    8e60:	8a 2f       	mov	r24, r26
    8e62:	81 7e       	andi	r24, 0xE1	; 225
    8e64:	98 27       	eor	r25, r24
    8e66:	81 2f       	mov	r24, r17
    8e68:	80 72       	andi	r24, 0x20	; 32
    8e6a:	98 27       	eor	r25, r24
    8e6c:	84 2f       	mov	r24, r20
    8e6e:	84 79       	andi	r24, 0x94	; 148
    8e70:	98 27       	eor	r25, r24
    8e72:	83 2f       	mov	r24, r19
    8e74:	83 77       	andi	r24, 0x73	; 115
    8e76:	98 27       	eor	r25, r24
    8e78:	82 2f       	mov	r24, r18
    8e7a:	8a 73       	andi	r24, 0x3A	; 58
    8e7c:	98 27       	eor	r25, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8e7e:	89 2f       	mov	r24, r25
    8e80:	82 95       	swap	r24
    8e82:	98 27       	eor	r25, r24
    Feedback ^= Feedback >> 2;
    8e84:	89 2f       	mov	r24, r25
    8e86:	86 95       	lsr	r24
    8e88:	86 95       	lsr	r24
    8e8a:	98 27       	eor	r25, r24
    /* 4 Bytes */
    for (i = 0; i < NONCE_SIZE; i++) {
        In = EncryptedReaderNonce[i];

        /* Bit 0 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8e8c:	c4 2e       	mov	r12, r20
    8e8e:	d1 2c       	mov	r13, r1
    8e90:	e6 01       	movw	r28, r12
    8e92:	c0 55       	subi	r28, 0x50	; 80
    8e94:	df 4d       	sbci	r29, 0xDF	; 223
    8e96:	6e 01       	movw	r12, r28
    8e98:	e3 2e       	mov	r14, r19
    8e9a:	f1 2c       	mov	r15, r1
    8e9c:	e7 01       	movw	r28, r14
    8e9e:	c0 55       	subi	r28, 0x50	; 80
    8ea0:	de 4d       	sbci	r29, 0xDE	; 222
    8ea2:	7e 01       	movw	r14, r28
    8ea4:	e6 01       	movw	r28, r12
    8ea6:	b8 81       	ld	r27, Y
    8ea8:	e7 01       	movw	r28, r14
    8eaa:	88 81       	ld	r24, Y
    8eac:	b8 2b       	or	r27, r24
    8eae:	e2 2e       	mov	r14, r18
    8eb0:	f1 2c       	mov	r15, r1
    8eb2:	e7 01       	movw	r28, r14
    8eb4:	c0 55       	subi	r28, 0x50	; 80
    8eb6:	dd 4d       	sbci	r29, 0xDD	; 221
    8eb8:	88 81       	ld	r24, Y
    8eba:	cb 2f       	mov	r28, r27
    8ebc:	c8 2b       	or	r28, r24
    8ebe:	d0 e0       	ldi	r29, 0x00	; 0
    8ec0:	c0 57       	subi	r28, 0x70	; 112
    8ec2:	df 4d       	sbci	r29, 0xDF	; 223
    8ec4:	b8 81       	ld	r27, Y
    8ec6:	b0 27       	eor	r27, r16
    8ec8:	b9 27       	eor	r27, r25
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2)
    8eca:	96 95       	lsr	r25
    8ecc:	9b 27       	eor	r25, r27
                    ^ Feedback
                    ^ In;
        In >>= 1;
    8ece:	06 95       	lsr	r16
        SHIFT24(Even0, Even1, Even2, Feedback);
    8ed0:	81 2f       	mov	r24, r17
    8ed2:	96 95       	lsr	r25
    8ed4:	87 95       	ror	r24
    8ed6:	57 95       	ror	r21
    8ed8:	a7 95       	ror	r26
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8eda:	b3 2f       	mov	r27, r19
    8edc:	b0 71       	andi	r27, 0x10	; 16
    8ede:	94 2f       	mov	r25, r20
    8ee0:	91 7e       	andi	r25, 0xE1	; 225
    8ee2:	b9 27       	eor	r27, r25
    8ee4:	92 2f       	mov	r25, r18
    8ee6:	90 72       	andi	r25, 0x20	; 32
    8ee8:	b9 27       	eor	r27, r25
    8eea:	9a 2f       	mov	r25, r26
    8eec:	94 79       	andi	r25, 0x94	; 148
    8eee:	b9 27       	eor	r27, r25
    8ef0:	95 2f       	mov	r25, r21
    8ef2:	93 77       	andi	r25, 0x73	; 115
    8ef4:	b9 27       	eor	r27, r25
    8ef6:	98 2f       	mov	r25, r24
    8ef8:	9a 73       	andi	r25, 0x3A	; 58
    8efa:	b9 27       	eor	r27, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8efc:	9b 2f       	mov	r25, r27
    8efe:	92 95       	swap	r25
    8f00:	b9 27       	eor	r27, r25
    Feedback ^= Feedback >> 2;
    8f02:	9b 2f       	mov	r25, r27
    8f04:	96 95       	lsr	r25
    8f06:	96 95       	lsr	r25
    8f08:	b9 27       	eor	r27, r25
        In >>= 1;
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    8f0a:	ca 2e       	mov	r12, r26
    8f0c:	d1 2c       	mov	r13, r1
    8f0e:	e6 01       	movw	r28, r12
    8f10:	c0 55       	subi	r28, 0x50	; 80
    8f12:	df 4d       	sbci	r29, 0xDF	; 223
    8f14:	6e 01       	movw	r12, r28
    8f16:	e5 2e       	mov	r14, r21
    8f18:	f1 2c       	mov	r15, r1
    8f1a:	e7 01       	movw	r28, r14
    8f1c:	c0 55       	subi	r28, 0x50	; 80
    8f1e:	de 4d       	sbci	r29, 0xDE	; 222
    8f20:	7e 01       	movw	r14, r28
    8f22:	e6 01       	movw	r28, r12
    8f24:	18 81       	ld	r17, Y
    8f26:	e7 01       	movw	r28, r14
    8f28:	98 81       	ld	r25, Y
    8f2a:	19 2b       	or	r17, r25
    8f2c:	e8 2e       	mov	r14, r24
    8f2e:	f1 2c       	mov	r15, r1
    8f30:	e7 01       	movw	r28, r14
    8f32:	c0 55       	subi	r28, 0x50	; 80
    8f34:	dd 4d       	sbci	r29, 0xDD	; 221
    8f36:	98 81       	ld	r25, Y
    8f38:	c1 2f       	mov	r28, r17
    8f3a:	c9 2b       	or	r28, r25
    8f3c:	d0 e0       	ldi	r29, 0x00	; 0
    8f3e:	c0 57       	subi	r28, 0x70	; 112
    8f40:	df 4d       	sbci	r29, 0xDF	; 223
    8f42:	98 81       	ld	r25, Y
    8f44:	90 27       	eor	r25, r16
    8f46:	9b 27       	eor	r25, r27
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2)
    8f48:	b6 95       	lsr	r27
    8f4a:	b9 27       	eor	r27, r25
                   ^ Feedback
                   ^ In;
        In >>= 1;
    8f4c:	b0 2e       	mov	r11, r16
    8f4e:	b6 94       	lsr	r11
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    8f50:	92 2f       	mov	r25, r18
    8f52:	b6 95       	lsr	r27
    8f54:	97 95       	ror	r25
    8f56:	37 95       	ror	r19
    8f58:	47 95       	ror	r20
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8f5a:	b5 2f       	mov	r27, r21
    8f5c:	b0 71       	andi	r27, 0x10	; 16
    8f5e:	2a 2f       	mov	r18, r26
    8f60:	21 7e       	andi	r18, 0xE1	; 225
    8f62:	b2 27       	eor	r27, r18
    8f64:	28 2f       	mov	r18, r24
    8f66:	20 72       	andi	r18, 0x20	; 32
    8f68:	b2 27       	eor	r27, r18
    8f6a:	24 2f       	mov	r18, r20
    8f6c:	24 79       	andi	r18, 0x94	; 148
    8f6e:	b2 27       	eor	r27, r18
    8f70:	23 2f       	mov	r18, r19
    8f72:	23 77       	andi	r18, 0x73	; 115
    8f74:	b2 27       	eor	r27, r18
    8f76:	29 2f       	mov	r18, r25
    8f78:	2a 73       	andi	r18, 0x3A	; 58
    8f7a:	b2 27       	eor	r27, r18

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8f7c:	2b 2f       	mov	r18, r27
    8f7e:	22 95       	swap	r18
    8f80:	b2 27       	eor	r27, r18
    Feedback ^= Feedback >> 2;
    8f82:	2b 2f       	mov	r18, r27
    8f84:	26 95       	lsr	r18
    8f86:	26 95       	lsr	r18
    8f88:	b2 27       	eor	r27, r18
                   ^ In;
        In >>= 1;
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 2 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8f8a:	c4 2f       	mov	r28, r20
    8f8c:	d0 e0       	ldi	r29, 0x00	; 0
    8f8e:	8e 01       	movw	r16, r28
    8f90:	00 55       	subi	r16, 0x50	; 80
    8f92:	1f 4d       	sbci	r17, 0xDF	; 223
    8f94:	68 01       	movw	r12, r16
    8f96:	c3 2f       	mov	r28, r19
    8f98:	d0 e0       	ldi	r29, 0x00	; 0
    8f9a:	8e 01       	movw	r16, r28
    8f9c:	00 55       	subi	r16, 0x50	; 80
    8f9e:	1e 4d       	sbci	r17, 0xDE	; 222
    8fa0:	78 01       	movw	r14, r16
    8fa2:	e6 01       	movw	r28, r12
    8fa4:	08 81       	ld	r16, Y
    8fa6:	e7 01       	movw	r28, r14
    8fa8:	28 81       	ld	r18, Y
    8faa:	02 2b       	or	r16, r18
    8fac:	e9 2e       	mov	r14, r25
    8fae:	f1 2c       	mov	r15, r1
    8fb0:	e7 01       	movw	r28, r14
    8fb2:	c0 55       	subi	r28, 0x50	; 80
    8fb4:	dd 4d       	sbci	r29, 0xDD	; 221
    8fb6:	28 81       	ld	r18, Y
    8fb8:	02 2b       	or	r16, r18
    8fba:	10 e0       	ldi	r17, 0x00	; 0
    8fbc:	00 57       	subi	r16, 0x70	; 112
    8fbe:	1f 4d       	sbci	r17, 0xDF	; 223
    8fc0:	e8 01       	movw	r28, r16
    8fc2:	28 81       	ld	r18, Y
    8fc4:	c2 2f       	mov	r28, r18
    8fc6:	cb 25       	eor	r28, r11
    8fc8:	cb 27       	eor	r28, r27
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2)
    8fca:	b6 95       	lsr	r27
    8fcc:	bc 27       	eor	r27, r28
                    ^ Feedback
                    ^ In;
        In >>= 1;
    8fce:	2b 2d       	mov	r18, r11
    8fd0:	26 95       	lsr	r18
        SHIFT24(Even0, Even1, Even2, Feedback);
    8fd2:	b6 95       	lsr	r27
    8fd4:	87 95       	ror	r24
    8fd6:	57 95       	ror	r21
    8fd8:	a7 95       	ror	r26
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    8fda:	c3 2f       	mov	r28, r19
    8fdc:	c0 71       	andi	r28, 0x10	; 16
    8fde:	b4 2f       	mov	r27, r20
    8fe0:	b1 7e       	andi	r27, 0xE1	; 225
    8fe2:	bc 27       	eor	r27, r28
    8fe4:	c9 2f       	mov	r28, r25
    8fe6:	c0 72       	andi	r28, 0x20	; 32
    8fe8:	bc 27       	eor	r27, r28
    8fea:	ca 2f       	mov	r28, r26
    8fec:	c4 79       	andi	r28, 0x94	; 148
    8fee:	bc 27       	eor	r27, r28
    8ff0:	c5 2f       	mov	r28, r21
    8ff2:	c3 77       	andi	r28, 0x73	; 115
    8ff4:	bc 27       	eor	r27, r28
    8ff6:	c8 2f       	mov	r28, r24
    8ff8:	ca 73       	andi	r28, 0x3A	; 58
    8ffa:	bc 27       	eor	r27, r28

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8ffc:	cb 2f       	mov	r28, r27
    8ffe:	c2 95       	swap	r28
    9000:	bc 27       	eor	r27, r28
    Feedback ^= Feedback >> 2;
    9002:	cb 2f       	mov	r28, r27
    9004:	c6 95       	lsr	r28
    9006:	c6 95       	lsr	r28
    9008:	bc 27       	eor	r27, r28
                    ^ In;
        In >>= 1;
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 3 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    900a:	ca 2f       	mov	r28, r26
    900c:	d0 e0       	ldi	r29, 0x00	; 0
    900e:	c0 55       	subi	r28, 0x50	; 80
    9010:	df 4d       	sbci	r29, 0xDF	; 223
    9012:	05 2f       	mov	r16, r21
    9014:	10 e0       	ldi	r17, 0x00	; 0
    9016:	00 55       	subi	r16, 0x50	; 80
    9018:	1e 4d       	sbci	r17, 0xDE	; 222
    901a:	f8 80       	ld	r15, Y
    901c:	e8 01       	movw	r28, r16
    901e:	18 81       	ld	r17, Y
    9020:	f1 2a       	or	r15, r17
    9022:	08 2f       	mov	r16, r24
    9024:	10 e0       	ldi	r17, 0x00	; 0
    9026:	00 55       	subi	r16, 0x50	; 80
    9028:	1d 4d       	sbci	r17, 0xDD	; 221
    902a:	e8 01       	movw	r28, r16
    902c:	18 81       	ld	r17, Y
    902e:	cf 2d       	mov	r28, r15
    9030:	c1 2b       	or	r28, r17
    9032:	d0 e0       	ldi	r29, 0x00	; 0
    9034:	c0 57       	subi	r28, 0x70	; 112
    9036:	df 4d       	sbci	r29, 0xDF	; 223
    9038:	c8 81       	ld	r28, Y
    903a:	c2 27       	eor	r28, r18
    903c:	cb 27       	eor	r28, r27
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2)
    903e:	b6 95       	lsr	r27
    9040:	bc 27       	eor	r27, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
    9042:	26 95       	lsr	r18
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9044:	b6 95       	lsr	r27
    9046:	97 95       	ror	r25
    9048:	37 95       	ror	r19
    904a:	47 95       	ror	r20
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    904c:	c5 2f       	mov	r28, r21
    904e:	c0 71       	andi	r28, 0x10	; 16
    9050:	ba 2f       	mov	r27, r26
    9052:	b1 7e       	andi	r27, 0xE1	; 225
    9054:	bc 27       	eor	r27, r28
    9056:	c8 2f       	mov	r28, r24
    9058:	c0 72       	andi	r28, 0x20	; 32
    905a:	bc 27       	eor	r27, r28
    905c:	c4 2f       	mov	r28, r20
    905e:	c4 79       	andi	r28, 0x94	; 148
    9060:	bc 27       	eor	r27, r28
    9062:	c3 2f       	mov	r28, r19
    9064:	c3 77       	andi	r28, 0x73	; 115
    9066:	bc 27       	eor	r27, r28
    9068:	c9 2f       	mov	r28, r25
    906a:	ca 73       	andi	r28, 0x3A	; 58
    906c:	bc 27       	eor	r27, r28

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    906e:	cb 2f       	mov	r28, r27
    9070:	c2 95       	swap	r28
    9072:	bc 27       	eor	r27, r28
    Feedback ^= Feedback >> 2;
    9074:	cb 2f       	mov	r28, r27
    9076:	c6 95       	lsr	r28
    9078:	c6 95       	lsr	r28
    907a:	bc 27       	eor	r27, r28
                   ^ In;
        In >>= 1;
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 4 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    907c:	c4 2f       	mov	r28, r20
    907e:	d0 e0       	ldi	r29, 0x00	; 0
    9080:	c0 55       	subi	r28, 0x50	; 80
    9082:	df 4d       	sbci	r29, 0xDF	; 223
    9084:	03 2f       	mov	r16, r19
    9086:	10 e0       	ldi	r17, 0x00	; 0
    9088:	00 55       	subi	r16, 0x50	; 80
    908a:	1e 4d       	sbci	r17, 0xDE	; 222
    908c:	f8 80       	ld	r15, Y
    908e:	e8 01       	movw	r28, r16
    9090:	18 81       	ld	r17, Y
    9092:	f1 2a       	or	r15, r17
    9094:	09 2f       	mov	r16, r25
    9096:	10 e0       	ldi	r17, 0x00	; 0
    9098:	00 55       	subi	r16, 0x50	; 80
    909a:	1d 4d       	sbci	r17, 0xDD	; 221
    909c:	e8 01       	movw	r28, r16
    909e:	18 81       	ld	r17, Y
    90a0:	cf 2d       	mov	r28, r15
    90a2:	c1 2b       	or	r28, r17
    90a4:	d0 e0       	ldi	r29, 0x00	; 0
    90a6:	c0 57       	subi	r28, 0x70	; 112
    90a8:	df 4d       	sbci	r29, 0xDF	; 223
    90aa:	c8 81       	ld	r28, Y
    90ac:	c2 27       	eor	r28, r18
    90ae:	cb 27       	eor	r28, r27
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2)
    90b0:	b6 95       	lsr	r27
    90b2:	bc 27       	eor	r27, r28
                    ^ Feedback
                    ^ In;
        In >>= 1;
    90b4:	26 95       	lsr	r18
        SHIFT24(Even0, Even1, Even2, Feedback);
    90b6:	b6 95       	lsr	r27
    90b8:	87 95       	ror	r24
    90ba:	57 95       	ror	r21
    90bc:	a7 95       	ror	r26
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    90be:	d3 2f       	mov	r29, r19
    90c0:	d0 71       	andi	r29, 0x10	; 16
    90c2:	b4 2f       	mov	r27, r20
    90c4:	b1 7e       	andi	r27, 0xE1	; 225
    90c6:	db 27       	eor	r29, r27
    90c8:	b9 2f       	mov	r27, r25
    90ca:	b0 72       	andi	r27, 0x20	; 32
    90cc:	db 27       	eor	r29, r27
    90ce:	ba 2f       	mov	r27, r26
    90d0:	b4 79       	andi	r27, 0x94	; 148
    90d2:	db 27       	eor	r29, r27
    90d4:	b5 2f       	mov	r27, r21
    90d6:	b3 77       	andi	r27, 0x73	; 115
    90d8:	db 27       	eor	r29, r27
    90da:	b8 2f       	mov	r27, r24
    90dc:	ba 73       	andi	r27, 0x3A	; 58
    90de:	db 27       	eor	r29, r27

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    90e0:	bd 2f       	mov	r27, r29
    90e2:	b2 95       	swap	r27
    90e4:	db 27       	eor	r29, r27
    Feedback ^= Feedback >> 2;
    90e6:	1d 2f       	mov	r17, r29
    90e8:	16 95       	lsr	r17
    90ea:	16 95       	lsr	r17
    90ec:	1d 27       	eor	r17, r29
                    ^ In;
        In >>= 1;
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 5 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    90ee:	ca 2e       	mov	r12, r26
    90f0:	d1 2c       	mov	r13, r1
    90f2:	e6 01       	movw	r28, r12
    90f4:	c0 55       	subi	r28, 0x50	; 80
    90f6:	df 4d       	sbci	r29, 0xDF	; 223
    90f8:	6e 01       	movw	r12, r28
    90fa:	e5 2e       	mov	r14, r21
    90fc:	f1 2c       	mov	r15, r1
    90fe:	e7 01       	movw	r28, r14
    9100:	c0 55       	subi	r28, 0x50	; 80
    9102:	de 4d       	sbci	r29, 0xDE	; 222
    9104:	7e 01       	movw	r14, r28
    9106:	e6 01       	movw	r28, r12
    9108:	08 81       	ld	r16, Y
    910a:	e7 01       	movw	r28, r14
    910c:	b8 81       	ld	r27, Y
    910e:	0b 2b       	or	r16, r27
    9110:	e8 2e       	mov	r14, r24
    9112:	f1 2c       	mov	r15, r1
    9114:	e7 01       	movw	r28, r14
    9116:	c0 55       	subi	r28, 0x50	; 80
    9118:	dd 4d       	sbci	r29, 0xDD	; 221
    911a:	b8 81       	ld	r27, Y
    911c:	c0 2f       	mov	r28, r16
    911e:	cb 2b       	or	r28, r27
    9120:	d0 e0       	ldi	r29, 0x00	; 0
    9122:	c0 57       	subi	r28, 0x70	; 112
    9124:	df 4d       	sbci	r29, 0xDF	; 223
    9126:	b8 81       	ld	r27, Y
    9128:	b2 27       	eor	r27, r18
    912a:	b1 27       	eor	r27, r17
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2)
    912c:	d1 2f       	mov	r29, r17
    912e:	d6 95       	lsr	r29
    9130:	db 27       	eor	r29, r27
                   ^ Feedback
                   ^ In;
        In >>= 1;
    9132:	b2 2e       	mov	r11, r18
    9134:	b6 94       	lsr	r11
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9136:	d6 95       	lsr	r29
    9138:	97 95       	ror	r25
    913a:	37 95       	ror	r19
    913c:	47 95       	ror	r20
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    913e:	d5 2f       	mov	r29, r21
    9140:	d0 71       	andi	r29, 0x10	; 16
    9142:	2a 2f       	mov	r18, r26
    9144:	21 7e       	andi	r18, 0xE1	; 225
    9146:	d2 27       	eor	r29, r18
    9148:	28 2f       	mov	r18, r24
    914a:	20 72       	andi	r18, 0x20	; 32
    914c:	d2 27       	eor	r29, r18
    914e:	24 2f       	mov	r18, r20
    9150:	24 79       	andi	r18, 0x94	; 148
    9152:	d2 27       	eor	r29, r18
    9154:	23 2f       	mov	r18, r19
    9156:	23 77       	andi	r18, 0x73	; 115
    9158:	d2 27       	eor	r29, r18
    915a:	29 2f       	mov	r18, r25
    915c:	2a 73       	andi	r18, 0x3A	; 58
    915e:	d2 27       	eor	r29, r18

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9160:	2d 2f       	mov	r18, r29
    9162:	22 95       	swap	r18
    9164:	d2 27       	eor	r29, r18
    Feedback ^= Feedback >> 2;
    9166:	2d 2f       	mov	r18, r29
    9168:	26 95       	lsr	r18
    916a:	26 95       	lsr	r18
    916c:	bd 2f       	mov	r27, r29
    916e:	b2 27       	eor	r27, r18
                   ^ In;
        In >>= 1;
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 6 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    9170:	c4 2f       	mov	r28, r20
    9172:	d0 e0       	ldi	r29, 0x00	; 0
    9174:	8e 01       	movw	r16, r28
    9176:	00 55       	subi	r16, 0x50	; 80
    9178:	1f 4d       	sbci	r17, 0xDF	; 223
    917a:	68 01       	movw	r12, r16
    917c:	c3 2f       	mov	r28, r19
    917e:	d0 e0       	ldi	r29, 0x00	; 0
    9180:	8e 01       	movw	r16, r28
    9182:	00 55       	subi	r16, 0x50	; 80
    9184:	1e 4d       	sbci	r17, 0xDE	; 222
    9186:	78 01       	movw	r14, r16
    9188:	e6 01       	movw	r28, r12
    918a:	08 81       	ld	r16, Y
    918c:	e7 01       	movw	r28, r14
    918e:	28 81       	ld	r18, Y
    9190:	02 2b       	or	r16, r18
    9192:	e9 2e       	mov	r14, r25
    9194:	f1 2c       	mov	r15, r1
    9196:	e7 01       	movw	r28, r14
    9198:	c0 55       	subi	r28, 0x50	; 80
    919a:	dd 4d       	sbci	r29, 0xDD	; 221
    919c:	28 81       	ld	r18, Y
    919e:	02 2b       	or	r16, r18
    91a0:	10 e0       	ldi	r17, 0x00	; 0
    91a2:	00 57       	subi	r16, 0x70	; 112
    91a4:	1f 4d       	sbci	r17, 0xDF	; 223
    91a6:	e8 01       	movw	r28, r16
    91a8:	18 81       	ld	r17, Y
    91aa:	1b 25       	eor	r17, r11
    91ac:	1b 27       	eor	r17, r27
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2)
    91ae:	db 2f       	mov	r29, r27
    91b0:	d6 95       	lsr	r29
    91b2:	d1 27       	eor	r29, r17
                    ^ Feedback
                    ^ In;
        In >>= 1;
        SHIFT24(Even0, Even1, Even2, Feedback);
    91b4:	d6 95       	lsr	r29
    91b6:	87 95       	ror	r24
    91b8:	57 95       	ror	r21
    91ba:	a7 95       	ror	r26
    91bc:	18 2f       	mov	r17, r24
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    91be:	24 2f       	mov	r18, r20
    91c0:	21 7e       	andi	r18, 0xE1	; 225
    91c2:	83 2f       	mov	r24, r19
    91c4:	80 71       	andi	r24, 0x10	; 16
    91c6:	28 27       	eor	r18, r24
    91c8:	89 2f       	mov	r24, r25
    91ca:	80 72       	andi	r24, 0x20	; 32
    91cc:	28 27       	eor	r18, r24
    91ce:	8a 2f       	mov	r24, r26
    91d0:	84 79       	andi	r24, 0x94	; 148
    91d2:	28 27       	eor	r18, r24
    91d4:	85 2f       	mov	r24, r21
    91d6:	83 77       	andi	r24, 0x73	; 115
    91d8:	28 27       	eor	r18, r24
    91da:	81 2f       	mov	r24, r17
    91dc:	8a 73       	andi	r24, 0x3A	; 58
    91de:	28 27       	eor	r18, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    91e0:	b2 2f       	mov	r27, r18
    91e2:	b2 95       	swap	r27
    91e4:	2b 27       	eor	r18, r27
    Feedback ^= Feedback >> 2;
    91e6:	b2 2f       	mov	r27, r18
    91e8:	b6 95       	lsr	r27
    91ea:	b6 95       	lsr	r27
    91ec:	2b 27       	eor	r18, r27
                    ^ In;
        In >>= 1;
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 7 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0, Even1, Even2);
    91ee:	ea 2e       	mov	r14, r26
    91f0:	f1 2c       	mov	r15, r1
    91f2:	e7 01       	movw	r28, r14
    91f4:	c0 55       	subi	r28, 0x50	; 80
    91f6:	df 4d       	sbci	r29, 0xDF	; 223
    91f8:	7e 01       	movw	r14, r28
    91fa:	c5 2e       	mov	r12, r21
    91fc:	d1 2c       	mov	r13, r1
    91fe:	e6 01       	movw	r28, r12
    9200:	c0 55       	subi	r28, 0x50	; 80
    9202:	de 4d       	sbci	r29, 0xDE	; 222
    9204:	6e 01       	movw	r12, r28
    9206:	e7 01       	movw	r28, r14
    9208:	e8 80       	ld	r14, Y
    920a:	e6 01       	movw	r28, r12
    920c:	88 81       	ld	r24, Y
    920e:	e8 2a       	or	r14, r24
    9210:	c1 2e       	mov	r12, r17
    9212:	d1 2c       	mov	r13, r1
    9214:	e6 01       	movw	r28, r12
    9216:	c0 55       	subi	r28, 0x50	; 80
    9218:	dd 4d       	sbci	r29, 0xDD	; 221
    921a:	88 81       	ld	r24, Y
    921c:	e8 2a       	or	r14, r24
    921e:	f1 2c       	mov	r15, r1
    9220:	e7 01       	movw	r28, r14
    9222:	c0 57       	subi	r28, 0x70	; 112
    9224:	df 4d       	sbci	r29, 0xDF	; 223
    9226:	b6 94       	lsr	r11
    9228:	88 81       	ld	r24, Y
    922a:	cb 2d       	mov	r28, r11
    922c:	c8 27       	eor	r28, r24
    922e:	c2 27       	eor	r28, r18
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2)
    9230:	26 95       	lsr	r18
    9232:	b2 2f       	mov	r27, r18
    9234:	bc 27       	eor	r27, r28
                   ^ Feedback
                   ^ In;
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9236:	2b 2f       	mov	r18, r27
    9238:	26 95       	lsr	r18
    923a:	97 95       	ror	r25
    923c:	37 95       	ror	r19
    923e:	47 95       	ror	r20
    9240:	29 2f       	mov	r18, r25
    Odd0 = State.Odd[0];
    Odd1 = State.Odd[1];
    Odd2 = State.Odd[2];

    /* 4 Bytes */
    for (i = 0; i < NONCE_SIZE; i++) {
    9242:	6e 17       	cp	r22, r30
    9244:	7f 07       	cpc	r23, r31
    9246:	09 f0       	breq	.+2      	; 0x924a <Crypto1Auth+0x422>
    9248:	08 ce       	rjmp	.-1008   	; 0x8e5a <Crypto1Auth+0x32>
                   ^ Feedback
                   ^ In;
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    }
    /* save state */
    State.Even[0] = Even0;
    924a:	a0 93 16 2d 	sts	0x2D16, r26	; 0x802d16 <State>
    State.Even[1] = Even1;
    924e:	50 93 17 2d 	sts	0x2D17, r21	; 0x802d17 <State+0x1>
    State.Even[2] = Even2;
    9252:	10 93 18 2d 	sts	0x2D18, r17	; 0x802d18 <State+0x2>
    State.Odd[0]  = Odd0;
    9256:	40 93 19 2d 	sts	0x2D19, r20	; 0x802d19 <State+0x3>
    State.Odd[1]  = Odd1;
    925a:	30 93 1a 2d 	sts	0x2D1A, r19	; 0x802d1a <State+0x4>
    State.Odd[2]  = Odd2;
    925e:	90 93 1b 2d 	sts	0x2D1B, r25	; 0x802d1b <State+0x5>
}
    9262:	df 91       	pop	r29
    9264:	cf 91       	pop	r28
    9266:	1f 91       	pop	r17
    9268:	0f 91       	pop	r16
    926a:	ff 90       	pop	r15
    926c:	ef 90       	pop	r14
    926e:	df 90       	pop	r13
    9270:	cf 90       	pop	r12
    9272:	bf 90       	pop	r11
    9274:	08 95       	ret

00009276 <Crypto1Nibble>:

/* Crypto1Nibble generates keystrem for a nibble (4 bit) */
/* no input to the LFSR  */
uint8_t Crypto1Nibble(void) {
    9276:	cf 93       	push	r28
    9278:	df 93       	push	r29
    uint8_t KeyStream;
    uint8_t Feedback;
    uint8_t Out;

    /* read state */
    Even0 = State.Even[0];
    927a:	e6 e1       	ldi	r30, 0x16	; 22
    927c:	fd e2       	ldi	r31, 0x2D	; 45
    927e:	a0 81       	ld	r26, Z
    Even1 = State.Even[1];
    9280:	71 81       	ldd	r23, Z+1	; 0x01
    Even2 = State.Even[2];
    9282:	62 81       	ldd	r22, Z+2	; 0x02
    Odd0 = State.Odd[0];
    9284:	33 81       	ldd	r19, Z+3	; 0x03
    Odd1 = State.Odd[1];
    9286:	24 81       	ldd	r18, Z+4	; 0x04
    Odd2 = State.Odd[2];
    9288:	95 81       	ldd	r25, Z+5	; 0x05
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    928a:	47 2f       	mov	r20, r23
    928c:	40 71       	andi	r20, 0x10	; 16
    928e:	8a 2f       	mov	r24, r26
    9290:	81 7e       	andi	r24, 0xE1	; 225
    9292:	84 27       	eor	r24, r20
    9294:	46 2f       	mov	r20, r22
    9296:	40 72       	andi	r20, 0x20	; 32
    9298:	84 27       	eor	r24, r20
    929a:	43 2f       	mov	r20, r19
    929c:	44 79       	andi	r20, 0x94	; 148
    929e:	84 27       	eor	r24, r20
    92a0:	42 2f       	mov	r20, r18
    92a2:	43 77       	andi	r20, 0x73	; 115
    92a4:	84 27       	eor	r24, r20
    92a6:	49 2f       	mov	r20, r25
    92a8:	4a 73       	andi	r20, 0x3A	; 58
    92aa:	84 27       	eor	r24, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    92ac:	48 2f       	mov	r20, r24
    92ae:	42 95       	swap	r20
    92b0:	84 27       	eor	r24, r20
    Feedback ^= Feedback >> 2;
    92b2:	48 2f       	mov	r20, r24
    92b4:	46 95       	lsr	r20
    92b6:	46 95       	lsr	r20
    92b8:	84 27       	eor	r24, r20
    Feedback ^= Feedback >> 1;
    92ba:	48 2f       	mov	r20, r24
    92bc:	46 95       	lsr	r20
    92be:	84 27       	eor	r24, r20
    Odd2 = State.Odd[2];

    /* Bit 0, initialise keystream */
    KeyStream = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
    SHIFT24(Even0, Even1, Even2, Feedback);
    92c0:	86 95       	lsr	r24
    92c2:	67 95       	ror	r22
    92c4:	77 95       	ror	r23
    92c6:	a7 95       	ror	r26
    Odd0 = State.Odd[0];
    Odd1 = State.Odd[1];
    Odd2 = State.Odd[2];

    /* Bit 0, initialise keystream */
    KeyStream = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    92c8:	c3 2f       	mov	r28, r19
    92ca:	d0 e0       	ldi	r29, 0x00	; 0
    92cc:	c0 55       	subi	r28, 0x50	; 80
    92ce:	df 4d       	sbci	r29, 0xDF	; 223
    92d0:	42 2f       	mov	r20, r18
    92d2:	50 e0       	ldi	r21, 0x00	; 0
    92d4:	40 55       	subi	r20, 0x50	; 80
    92d6:	5e 4d       	sbci	r21, 0xDE	; 222
    92d8:	b8 81       	ld	r27, Y
    92da:	ea 01       	movw	r28, r20
    92dc:	88 81       	ld	r24, Y
    92de:	b8 2b       	or	r27, r24
    92e0:	49 2f       	mov	r20, r25
    92e2:	50 e0       	ldi	r21, 0x00	; 0
    92e4:	40 55       	subi	r20, 0x50	; 80
    92e6:	5d 4d       	sbci	r21, 0xDD	; 221
    92e8:	ea 01       	movw	r28, r20
    92ea:	88 81       	ld	r24, Y
    92ec:	cb 2f       	mov	r28, r27
    92ee:	c8 2b       	or	r28, r24
    92f0:	d0 e0       	ldi	r29, 0x00	; 0
    92f2:	c0 5b       	subi	r28, 0xB0	; 176
    92f4:	df 4d       	sbci	r29, 0xDF	; 223
    Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
    SHIFT24(Even0, Even1, Even2, Feedback);

    /* Bit 1 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0, Even1, Even2);
    KeyStream = (KeyStream >> 1) | Out;
    92f6:	88 81       	ld	r24, Y
    92f8:	86 95       	lsr	r24
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    92fa:	52 2f       	mov	r21, r18
    92fc:	50 71       	andi	r21, 0x10	; 16
    92fe:	43 2f       	mov	r20, r19
    9300:	41 7e       	andi	r20, 0xE1	; 225
    9302:	45 27       	eor	r20, r21
    9304:	59 2f       	mov	r21, r25
    9306:	50 72       	andi	r21, 0x20	; 32
    9308:	45 27       	eor	r20, r21
    930a:	5a 2f       	mov	r21, r26
    930c:	54 79       	andi	r21, 0x94	; 148
    930e:	45 27       	eor	r20, r21
    9310:	57 2f       	mov	r21, r23
    9312:	53 77       	andi	r21, 0x73	; 115
    9314:	45 27       	eor	r20, r21
    9316:	56 2f       	mov	r21, r22
    9318:	5a 73       	andi	r21, 0x3A	; 58
    931a:	45 27       	eor	r20, r21

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    931c:	54 2f       	mov	r21, r20
    931e:	52 95       	swap	r21
    9320:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 2;
    9322:	54 2f       	mov	r21, r20
    9324:	56 95       	lsr	r21
    9326:	56 95       	lsr	r21
    9328:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 1;
    932a:	54 2f       	mov	r21, r20
    932c:	56 95       	lsr	r21
    932e:	45 27       	eor	r20, r21

    /* Bit 1 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0, Even1, Even2);
    KeyStream = (KeyStream >> 1) | Out;
    Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
    SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9330:	46 95       	lsr	r20
    9332:	97 95       	ror	r25
    9334:	27 95       	ror	r18
    9336:	37 95       	ror	r19
    KeyStream = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
    SHIFT24(Even0, Even1, Even2, Feedback);

    /* Bit 1 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0, Even1, Even2);
    9338:	ca 2f       	mov	r28, r26
    933a:	d0 e0       	ldi	r29, 0x00	; 0
    933c:	c0 55       	subi	r28, 0x50	; 80
    933e:	df 4d       	sbci	r29, 0xDF	; 223
    9340:	47 2f       	mov	r20, r23
    9342:	50 e0       	ldi	r21, 0x00	; 0
    9344:	40 55       	subi	r20, 0x50	; 80
    9346:	5e 4d       	sbci	r21, 0xDE	; 222
    9348:	b8 81       	ld	r27, Y
    934a:	ea 01       	movw	r28, r20
    934c:	48 81       	ld	r20, Y
    934e:	b4 2b       	or	r27, r20
    9350:	46 2f       	mov	r20, r22
    9352:	50 e0       	ldi	r21, 0x00	; 0
    9354:	40 55       	subi	r20, 0x50	; 80
    9356:	5d 4d       	sbci	r21, 0xDD	; 221
    9358:	ea 01       	movw	r28, r20
    935a:	48 81       	ld	r20, Y
    935c:	cb 2f       	mov	r28, r27
    935e:	c4 2b       	or	r28, r20
    9360:	d0 e0       	ldi	r29, 0x00	; 0
    9362:	c0 5b       	subi	r28, 0xB0	; 176
    9364:	df 4d       	sbci	r29, 0xDF	; 223
    Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
    SHIFT24(Odd0, Odd1, Odd2, Feedback);

    /* Bit 2 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    KeyStream = (KeyStream >> 1) | Out;
    9366:	48 81       	ld	r20, Y
    9368:	84 2b       	or	r24, r20
    936a:	86 95       	lsr	r24
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    936c:	57 2f       	mov	r21, r23
    936e:	50 71       	andi	r21, 0x10	; 16
    9370:	4a 2f       	mov	r20, r26
    9372:	41 7e       	andi	r20, 0xE1	; 225
    9374:	45 27       	eor	r20, r21
    9376:	56 2f       	mov	r21, r22
    9378:	50 72       	andi	r21, 0x20	; 32
    937a:	45 27       	eor	r20, r21
    937c:	53 2f       	mov	r21, r19
    937e:	54 79       	andi	r21, 0x94	; 148
    9380:	45 27       	eor	r20, r21
    9382:	52 2f       	mov	r21, r18
    9384:	53 77       	andi	r21, 0x73	; 115
    9386:	45 27       	eor	r20, r21
    9388:	59 2f       	mov	r21, r25
    938a:	5a 73       	andi	r21, 0x3A	; 58
    938c:	45 27       	eor	r20, r21

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    938e:	54 2f       	mov	r21, r20
    9390:	52 95       	swap	r21
    9392:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 2;
    9394:	54 2f       	mov	r21, r20
    9396:	56 95       	lsr	r21
    9398:	56 95       	lsr	r21
    939a:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 1;
    939c:	54 2f       	mov	r21, r20
    939e:	56 95       	lsr	r21
    93a0:	45 27       	eor	r20, r21

    /* Bit 2 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    KeyStream = (KeyStream >> 1) | Out;
    Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
    SHIFT24(Even0, Even1, Even2, Feedback);
    93a2:	46 95       	lsr	r20
    93a4:	67 95       	ror	r22
    93a6:	77 95       	ror	r23
    93a8:	a7 95       	ror	r26
    KeyStream = (KeyStream >> 1) | Out;
    Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
    SHIFT24(Odd0, Odd1, Odd2, Feedback);

    /* Bit 2 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    93aa:	c3 2f       	mov	r28, r19
    93ac:	d0 e0       	ldi	r29, 0x00	; 0
    93ae:	c0 55       	subi	r28, 0x50	; 80
    93b0:	df 4d       	sbci	r29, 0xDF	; 223
    93b2:	42 2f       	mov	r20, r18
    93b4:	50 e0       	ldi	r21, 0x00	; 0
    93b6:	40 55       	subi	r20, 0x50	; 80
    93b8:	5e 4d       	sbci	r21, 0xDE	; 222
    93ba:	b8 81       	ld	r27, Y
    93bc:	ea 01       	movw	r28, r20
    93be:	48 81       	ld	r20, Y
    93c0:	b4 2b       	or	r27, r20
    93c2:	49 2f       	mov	r20, r25
    93c4:	50 e0       	ldi	r21, 0x00	; 0
    93c6:	40 55       	subi	r20, 0x50	; 80
    93c8:	5d 4d       	sbci	r21, 0xDD	; 221
    93ca:	ea 01       	movw	r28, r20
    93cc:	48 81       	ld	r20, Y
    93ce:	cb 2f       	mov	r28, r27
    93d0:	c4 2b       	or	r28, r20
    93d2:	d0 e0       	ldi	r29, 0x00	; 0
    93d4:	c0 5b       	subi	r28, 0xB0	; 176
    93d6:	df 4d       	sbci	r29, 0xDF	; 223
    Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
    SHIFT24(Even0, Even1, Even2, Feedback);

    /* Bit 3 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0, Even1, Even2);
    KeyStream = (KeyStream >> 1) | Out;
    93d8:	48 81       	ld	r20, Y
    93da:	84 2b       	or	r24, r20
    93dc:	86 95       	lsr	r24
    KeyStream = (KeyStream >> 1) | Out;
    Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
    SHIFT24(Even0, Even1, Even2, Feedback);

    /* Bit 3 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0, Even1, Even2);
    93de:	ca 2f       	mov	r28, r26
    93e0:	d0 e0       	ldi	r29, 0x00	; 0
    93e2:	c0 55       	subi	r28, 0x50	; 80
    93e4:	df 4d       	sbci	r29, 0xDF	; 223
    93e6:	47 2f       	mov	r20, r23
    93e8:	50 e0       	ldi	r21, 0x00	; 0
    93ea:	40 55       	subi	r20, 0x50	; 80
    93ec:	5e 4d       	sbci	r21, 0xDE	; 222
    93ee:	b8 81       	ld	r27, Y
    93f0:	ea 01       	movw	r28, r20
    93f2:	48 81       	ld	r20, Y
    93f4:	b4 2b       	or	r27, r20
    93f6:	46 2f       	mov	r20, r22
    93f8:	50 e0       	ldi	r21, 0x00	; 0
    93fa:	40 55       	subi	r20, 0x50	; 80
    93fc:	5d 4d       	sbci	r21, 0xDD	; 221
    93fe:	ea 01       	movw	r28, r20
    9400:	48 81       	ld	r20, Y
    9402:	cb 2f       	mov	r28, r27
    9404:	c4 2b       	or	r28, r20
    9406:	d0 e0       	ldi	r29, 0x00	; 0
    9408:	c0 5b       	subi	r28, 0xB0	; 176
    940a:	df 4d       	sbci	r29, 0xDF	; 223
    KeyStream = (KeyStream >> 1) | Out;
    940c:	48 81       	ld	r20, Y
    940e:	84 2b       	or	r24, r20
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9410:	53 2f       	mov	r21, r19
    9412:	51 7e       	andi	r21, 0xE1	; 225
    9414:	42 2f       	mov	r20, r18
    9416:	40 71       	andi	r20, 0x10	; 16
    9418:	45 27       	eor	r20, r21
    941a:	59 2f       	mov	r21, r25
    941c:	50 72       	andi	r21, 0x20	; 32
    941e:	45 27       	eor	r20, r21
    9420:	5a 2f       	mov	r21, r26
    9422:	54 79       	andi	r21, 0x94	; 148
    9424:	45 27       	eor	r20, r21
    9426:	57 2f       	mov	r21, r23
    9428:	53 77       	andi	r21, 0x73	; 115
    942a:	45 27       	eor	r20, r21
    942c:	56 2f       	mov	r21, r22
    942e:	5a 73       	andi	r21, 0x3A	; 58
    9430:	45 27       	eor	r20, r21

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9432:	54 2f       	mov	r21, r20
    9434:	52 95       	swap	r21
    9436:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 2;
    9438:	54 2f       	mov	r21, r20
    943a:	56 95       	lsr	r21
    943c:	56 95       	lsr	r21
    943e:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 1;
    9440:	54 2f       	mov	r21, r20
    9442:	56 95       	lsr	r21
    9444:	45 27       	eor	r20, r21

    /* Bit 3 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0, Even1, Even2);
    KeyStream = (KeyStream >> 1) | Out;
    Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
    SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9446:	46 95       	lsr	r20
    9448:	97 95       	ror	r25
    944a:	27 95       	ror	r18
    944c:	37 95       	ror	r19

    /* save state */
    State.Even[0] = Even0;
    944e:	a0 83       	st	Z, r26
    State.Even[1] = Even1;
    9450:	71 83       	std	Z+1, r23	; 0x01
    State.Even[2] = Even2;
    9452:	62 83       	std	Z+2, r22	; 0x02
    State.Odd[0]  = Odd0;
    9454:	33 83       	std	Z+3, r19	; 0x03
    State.Odd[1]  = Odd1;
    9456:	24 83       	std	Z+4, r18	; 0x04
    State.Odd[2]  = Odd2;
    9458:	95 83       	std	Z+5, r25	; 0x05

    return (KeyStream);
}
    945a:	df 91       	pop	r29
    945c:	cf 91       	pop	r28
    945e:	08 95       	ret

00009460 <Crypto1ByteArray>:

/* Crypto1ByteArray transcrypts array of bytes        */
/* No input to the LFSR                               */
/* Avoids load/store of the LFSR-state for each byte! */
/* Enhacement for the original function Crypto1Byte() */
void Crypto1ByteArray(uint8_t *Buffer, uint8_t Count) {
    9460:	bf 92       	push	r11
    9462:	cf 92       	push	r12
    9464:	df 92       	push	r13
    9466:	ef 92       	push	r14
    9468:	ff 92       	push	r15
    946a:	0f 93       	push	r16
    946c:	1f 93       	push	r17
    946e:	cf 93       	push	r28
    9470:	df 93       	push	r29
    uint8_t KeyStream = 0;
    uint8_t Feedback;
    uint8_t Out;

    /* read state */
    Even0 = State.Even[0];
    9472:	50 91 16 2d 	lds	r21, 0x2D16	; 0x802d16 <State>
    Even1 = State.Even[1];
    9476:	c0 91 17 2d 	lds	r28, 0x2D17	; 0x802d17 <State+0x1>
    Even2 = State.Even[2];
    947a:	b0 90 18 2d 	lds	r11, 0x2D18	; 0x802d18 <State+0x2>
    Odd0 = State.Odd[0];
    947e:	40 91 19 2d 	lds	r20, 0x2D19	; 0x802d19 <State+0x3>
    Odd1 = State.Odd[1];
    9482:	30 91 1a 2d 	lds	r19, 0x2D1A	; 0x802d1a <State+0x4>
    Odd2 = State.Odd[2];
    9486:	20 91 1b 2d 	lds	r18, 0x2D1B	; 0x802d1b <State+0x5>
    948a:	fc 01       	movw	r30, r24

    while (Count--) {
    948c:	61 50       	subi	r22, 0x01	; 1
    948e:	08 f4       	brcc	.+2      	; 0x9492 <Crypto1ByteArray+0x32>
    9490:	ea c1       	rjmp	.+980    	; 0x9866 <Crypto1ByteArray+0x406>
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9492:	9c 2f       	mov	r25, r28
    9494:	90 71       	andi	r25, 0x10	; 16
    9496:	85 2f       	mov	r24, r21
    9498:	81 7e       	andi	r24, 0xE1	; 225
    949a:	98 27       	eor	r25, r24
    949c:	8b 2d       	mov	r24, r11
    949e:	80 72       	andi	r24, 0x20	; 32
    94a0:	98 27       	eor	r25, r24
    94a2:	84 2f       	mov	r24, r20
    94a4:	84 79       	andi	r24, 0x94	; 148
    94a6:	98 27       	eor	r25, r24
    94a8:	83 2f       	mov	r24, r19
    94aa:	83 77       	andi	r24, 0x73	; 115
    94ac:	98 27       	eor	r25, r24
    94ae:	82 2f       	mov	r24, r18
    94b0:	8a 73       	andi	r24, 0x3A	; 58
    94b2:	98 27       	eor	r25, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    94b4:	89 2f       	mov	r24, r25
    94b6:	82 95       	swap	r24
    94b8:	98 27       	eor	r25, r24
    Feedback ^= Feedback >> 2;
    94ba:	79 2f       	mov	r23, r25
    94bc:	76 95       	lsr	r23
    94be:	76 95       	lsr	r23
    94c0:	97 27       	eor	r25, r23
    Feedback ^= Feedback >> 1;
    94c2:	89 2f       	mov	r24, r25
    94c4:	86 95       	lsr	r24
    94c6:	98 27       	eor	r25, r24

    while (Count--) {
        /* Bit 0, initialise keystream */
        KeyStream = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    94c8:	ac 2f       	mov	r26, r28
    94ca:	8b 2d       	mov	r24, r11
    94cc:	96 95       	lsr	r25
    94ce:	87 95       	ror	r24
    94d0:	a7 95       	ror	r26
    94d2:	57 95       	ror	r21
    Odd1 = State.Odd[1];
    Odd2 = State.Odd[2];

    while (Count--) {
        /* Bit 0, initialise keystream */
        KeyStream = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    94d4:	c4 2f       	mov	r28, r20
    94d6:	d0 e0       	ldi	r29, 0x00	; 0
    94d8:	c0 55       	subi	r28, 0x50	; 80
    94da:	df 4d       	sbci	r29, 0xDF	; 223
    94dc:	03 2f       	mov	r16, r19
    94de:	10 e0       	ldi	r17, 0x00	; 0
    94e0:	00 55       	subi	r16, 0x50	; 80
    94e2:	1e 4d       	sbci	r17, 0xDE	; 222
    94e4:	78 81       	ld	r23, Y
    94e6:	e8 01       	movw	r28, r16
    94e8:	98 81       	ld	r25, Y
    94ea:	79 2b       	or	r23, r25
    94ec:	02 2f       	mov	r16, r18
    94ee:	10 e0       	ldi	r17, 0x00	; 0
    94f0:	00 55       	subi	r16, 0x50	; 80
    94f2:	1d 4d       	sbci	r17, 0xDD	; 221
    94f4:	e8 01       	movw	r28, r16
    94f6:	98 81       	ld	r25, Y
    94f8:	c7 2f       	mov	r28, r23
    94fa:	c9 2b       	or	r28, r25
    94fc:	d0 e0       	ldi	r29, 0x00	; 0
    94fe:	c0 59       	subi	r28, 0x90	; 144
    9500:	df 4d       	sbci	r29, 0xDF	; 223
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    9502:	18 81       	ld	r17, Y
    9504:	16 95       	lsr	r17
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9506:	73 2f       	mov	r23, r19
    9508:	70 71       	andi	r23, 0x10	; 16
    950a:	94 2f       	mov	r25, r20
    950c:	91 7e       	andi	r25, 0xE1	; 225
    950e:	97 27       	eor	r25, r23
    9510:	72 2f       	mov	r23, r18
    9512:	70 72       	andi	r23, 0x20	; 32
    9514:	97 27       	eor	r25, r23
    9516:	75 2f       	mov	r23, r21
    9518:	74 79       	andi	r23, 0x94	; 148
    951a:	97 27       	eor	r25, r23
    951c:	7a 2f       	mov	r23, r26
    951e:	73 77       	andi	r23, 0x73	; 115
    9520:	97 27       	eor	r25, r23
    9522:	78 2f       	mov	r23, r24
    9524:	7a 73       	andi	r23, 0x3A	; 58
    9526:	97 27       	eor	r25, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9528:	79 2f       	mov	r23, r25
    952a:	72 95       	swap	r23
    952c:	97 27       	eor	r25, r23
    Feedback ^= Feedback >> 2;
    952e:	79 2f       	mov	r23, r25
    9530:	76 95       	lsr	r23
    9532:	76 95       	lsr	r23
    9534:	97 27       	eor	r25, r23
    Feedback ^= Feedback >> 1;
    9536:	79 2f       	mov	r23, r25
    9538:	76 95       	lsr	r23
    953a:	79 27       	eor	r23, r25
        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    953c:	92 2f       	mov	r25, r18
    953e:	27 2f       	mov	r18, r23
    9540:	26 95       	lsr	r18
    9542:	97 95       	ror	r25
    9544:	37 95       	ror	r19
    9546:	47 95       	ror	r20
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    9548:	c5 2e       	mov	r12, r21
    954a:	d1 2c       	mov	r13, r1
    954c:	e6 01       	movw	r28, r12
    954e:	c0 55       	subi	r28, 0x50	; 80
    9550:	df 4d       	sbci	r29, 0xDF	; 223
    9552:	6e 01       	movw	r12, r28
    9554:	ea 2e       	mov	r14, r26
    9556:	f1 2c       	mov	r15, r1
    9558:	e7 01       	movw	r28, r14
    955a:	c0 55       	subi	r28, 0x50	; 80
    955c:	de 4d       	sbci	r29, 0xDE	; 222
    955e:	7e 01       	movw	r14, r28
    9560:	e6 01       	movw	r28, r12
    9562:	78 81       	ld	r23, Y
    9564:	e7 01       	movw	r28, r14
    9566:	28 81       	ld	r18, Y
    9568:	72 2b       	or	r23, r18
    956a:	e8 2e       	mov	r14, r24
    956c:	f1 2c       	mov	r15, r1
    956e:	e7 01       	movw	r28, r14
    9570:	c0 55       	subi	r28, 0x50	; 80
    9572:	dd 4d       	sbci	r29, 0xDD	; 221
    9574:	28 81       	ld	r18, Y
    9576:	c7 2f       	mov	r28, r23
    9578:	c2 2b       	or	r28, r18
    957a:	d0 e0       	ldi	r29, 0x00	; 0
    957c:	c0 59       	subi	r28, 0x90	; 144
    957e:	df 4d       	sbci	r29, 0xDF	; 223
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
    9580:	28 81       	ld	r18, Y
    9582:	12 2b       	or	r17, r18
    9584:	16 95       	lsr	r17
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9586:	7a 2f       	mov	r23, r26
    9588:	70 71       	andi	r23, 0x10	; 16
    958a:	25 2f       	mov	r18, r21
    958c:	21 7e       	andi	r18, 0xE1	; 225
    958e:	27 27       	eor	r18, r23
    9590:	78 2f       	mov	r23, r24
    9592:	70 72       	andi	r23, 0x20	; 32
    9594:	27 27       	eor	r18, r23
    9596:	74 2f       	mov	r23, r20
    9598:	74 79       	andi	r23, 0x94	; 148
    959a:	27 27       	eor	r18, r23
    959c:	73 2f       	mov	r23, r19
    959e:	73 77       	andi	r23, 0x73	; 115
    95a0:	27 27       	eor	r18, r23
    95a2:	79 2f       	mov	r23, r25
    95a4:	7a 73       	andi	r23, 0x3A	; 58
    95a6:	27 27       	eor	r18, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    95a8:	72 2f       	mov	r23, r18
    95aa:	72 95       	swap	r23
    95ac:	27 27       	eor	r18, r23
    Feedback ^= Feedback >> 2;
    95ae:	72 2f       	mov	r23, r18
    95b0:	76 95       	lsr	r23
    95b2:	76 95       	lsr	r23
    95b4:	27 27       	eor	r18, r23
    Feedback ^= Feedback >> 1;
    95b6:	72 2f       	mov	r23, r18
    95b8:	76 95       	lsr	r23
    95ba:	27 27       	eor	r18, r23

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    95bc:	ba 2f       	mov	r27, r26
    95be:	26 95       	lsr	r18
    95c0:	87 95       	ror	r24
    95c2:	b7 95       	ror	r27
    95c4:	57 95       	ror	r21
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    95c6:	c4 2e       	mov	r12, r20
    95c8:	d1 2c       	mov	r13, r1
    95ca:	e6 01       	movw	r28, r12
    95cc:	c0 55       	subi	r28, 0x50	; 80
    95ce:	df 4d       	sbci	r29, 0xDF	; 223
    95d0:	6e 01       	movw	r12, r28
    95d2:	e3 2e       	mov	r14, r19
    95d4:	f1 2c       	mov	r15, r1
    95d6:	e7 01       	movw	r28, r14
    95d8:	c0 55       	subi	r28, 0x50	; 80
    95da:	de 4d       	sbci	r29, 0xDE	; 222
    95dc:	7e 01       	movw	r14, r28
    95de:	e6 01       	movw	r28, r12
    95e0:	78 81       	ld	r23, Y
    95e2:	e7 01       	movw	r28, r14
    95e4:	28 81       	ld	r18, Y
    95e6:	72 2b       	or	r23, r18
    95e8:	e9 2e       	mov	r14, r25
    95ea:	f1 2c       	mov	r15, r1
    95ec:	e7 01       	movw	r28, r14
    95ee:	c0 55       	subi	r28, 0x50	; 80
    95f0:	dd 4d       	sbci	r29, 0xDD	; 221
    95f2:	28 81       	ld	r18, Y
    95f4:	c7 2f       	mov	r28, r23
    95f6:	c2 2b       	or	r28, r18
    95f8:	d0 e0       	ldi	r29, 0x00	; 0
    95fa:	c0 59       	subi	r28, 0x90	; 144
    95fc:	df 4d       	sbci	r29, 0xDF	; 223
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    95fe:	a8 81       	ld	r26, Y
    9600:	a1 2b       	or	r26, r17
    9602:	a6 95       	lsr	r26
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9604:	73 2f       	mov	r23, r19
    9606:	70 71       	andi	r23, 0x10	; 16
    9608:	24 2f       	mov	r18, r20
    960a:	21 7e       	andi	r18, 0xE1	; 225
    960c:	27 27       	eor	r18, r23
    960e:	79 2f       	mov	r23, r25
    9610:	70 72       	andi	r23, 0x20	; 32
    9612:	27 27       	eor	r18, r23
    9614:	75 2f       	mov	r23, r21
    9616:	74 79       	andi	r23, 0x94	; 148
    9618:	27 27       	eor	r18, r23
    961a:	7b 2f       	mov	r23, r27
    961c:	73 77       	andi	r23, 0x73	; 115
    961e:	27 27       	eor	r18, r23
    9620:	78 2f       	mov	r23, r24
    9622:	7a 73       	andi	r23, 0x3A	; 58
    9624:	27 27       	eor	r18, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9626:	72 2f       	mov	r23, r18
    9628:	72 95       	swap	r23
    962a:	27 27       	eor	r18, r23
    Feedback ^= Feedback >> 2;
    962c:	72 2f       	mov	r23, r18
    962e:	76 95       	lsr	r23
    9630:	76 95       	lsr	r23
    9632:	27 27       	eor	r18, r23
    Feedback ^= Feedback >> 1;
    9634:	72 2f       	mov	r23, r18
    9636:	76 95       	lsr	r23
    9638:	72 27       	eor	r23, r18
        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    963a:	23 2f       	mov	r18, r19
    963c:	37 2f       	mov	r19, r23
    963e:	36 95       	lsr	r19
    9640:	97 95       	ror	r25
    9642:	27 95       	ror	r18
    9644:	47 95       	ror	r20
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    9646:	c5 2f       	mov	r28, r21
    9648:	d0 e0       	ldi	r29, 0x00	; 0
    964a:	c0 55       	subi	r28, 0x50	; 80
    964c:	df 4d       	sbci	r29, 0xDF	; 223
    964e:	0b 2f       	mov	r16, r27
    9650:	10 e0       	ldi	r17, 0x00	; 0
    9652:	00 55       	subi	r16, 0x50	; 80
    9654:	1e 4d       	sbci	r17, 0xDE	; 222
    9656:	78 81       	ld	r23, Y
    9658:	e8 01       	movw	r28, r16
    965a:	38 81       	ld	r19, Y
    965c:	73 2b       	or	r23, r19
    965e:	08 2f       	mov	r16, r24
    9660:	10 e0       	ldi	r17, 0x00	; 0
    9662:	00 55       	subi	r16, 0x50	; 80
    9664:	1d 4d       	sbci	r17, 0xDD	; 221
    9666:	e8 01       	movw	r28, r16
    9668:	38 81       	ld	r19, Y
    966a:	c7 2f       	mov	r28, r23
    966c:	c3 2b       	or	r28, r19
    966e:	d0 e0       	ldi	r29, 0x00	; 0
    9670:	c0 59       	subi	r28, 0x90	; 144
    9672:	df 4d       	sbci	r29, 0xDF	; 223
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
    9674:	d8 81       	ld	r29, Y
    9676:	ad 2b       	or	r26, r29
    9678:	a6 95       	lsr	r26
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    967a:	7b 2f       	mov	r23, r27
    967c:	70 71       	andi	r23, 0x10	; 16
    967e:	35 2f       	mov	r19, r21
    9680:	31 7e       	andi	r19, 0xE1	; 225
    9682:	37 27       	eor	r19, r23
    9684:	78 2f       	mov	r23, r24
    9686:	70 72       	andi	r23, 0x20	; 32
    9688:	37 27       	eor	r19, r23
    968a:	74 2f       	mov	r23, r20
    968c:	74 79       	andi	r23, 0x94	; 148
    968e:	37 27       	eor	r19, r23
    9690:	72 2f       	mov	r23, r18
    9692:	73 77       	andi	r23, 0x73	; 115
    9694:	37 27       	eor	r19, r23
    9696:	79 2f       	mov	r23, r25
    9698:	7a 73       	andi	r23, 0x3A	; 58
    969a:	37 27       	eor	r19, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    969c:	73 2f       	mov	r23, r19
    969e:	72 95       	swap	r23
    96a0:	37 27       	eor	r19, r23
    Feedback ^= Feedback >> 2;
    96a2:	73 2f       	mov	r23, r19
    96a4:	76 95       	lsr	r23
    96a6:	76 95       	lsr	r23
    96a8:	37 27       	eor	r19, r23
    Feedback ^= Feedback >> 1;
    96aa:	73 2f       	mov	r23, r19
    96ac:	76 95       	lsr	r23
    96ae:	37 27       	eor	r19, r23

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    96b0:	36 95       	lsr	r19
    96b2:	87 95       	ror	r24
    96b4:	b7 95       	ror	r27
    96b6:	57 95       	ror	r21
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    96b8:	c4 2f       	mov	r28, r20
    96ba:	d0 e0       	ldi	r29, 0x00	; 0
    96bc:	c0 55       	subi	r28, 0x50	; 80
    96be:	df 4d       	sbci	r29, 0xDF	; 223
    96c0:	02 2f       	mov	r16, r18
    96c2:	10 e0       	ldi	r17, 0x00	; 0
    96c4:	00 55       	subi	r16, 0x50	; 80
    96c6:	1e 4d       	sbci	r17, 0xDE	; 222
    96c8:	78 81       	ld	r23, Y
    96ca:	e8 01       	movw	r28, r16
    96cc:	38 81       	ld	r19, Y
    96ce:	73 2b       	or	r23, r19
    96d0:	09 2f       	mov	r16, r25
    96d2:	10 e0       	ldi	r17, 0x00	; 0
    96d4:	00 55       	subi	r16, 0x50	; 80
    96d6:	1d 4d       	sbci	r17, 0xDD	; 221
    96d8:	e8 01       	movw	r28, r16
    96da:	38 81       	ld	r19, Y
    96dc:	c7 2f       	mov	r28, r23
    96de:	c3 2b       	or	r28, r19
    96e0:	d0 e0       	ldi	r29, 0x00	; 0
    96e2:	c0 59       	subi	r28, 0x90	; 144
    96e4:	df 4d       	sbci	r29, 0xDF	; 223
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    96e6:	d8 81       	ld	r29, Y
    96e8:	ad 2b       	or	r26, r29
    96ea:	a6 95       	lsr	r26
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    96ec:	72 2f       	mov	r23, r18
    96ee:	70 71       	andi	r23, 0x10	; 16
    96f0:	34 2f       	mov	r19, r20
    96f2:	31 7e       	andi	r19, 0xE1	; 225
    96f4:	73 27       	eor	r23, r19
    96f6:	39 2f       	mov	r19, r25
    96f8:	30 72       	andi	r19, 0x20	; 32
    96fa:	73 27       	eor	r23, r19
    96fc:	35 2f       	mov	r19, r21
    96fe:	34 79       	andi	r19, 0x94	; 148
    9700:	73 27       	eor	r23, r19
    9702:	3b 2f       	mov	r19, r27
    9704:	33 77       	andi	r19, 0x73	; 115
    9706:	73 27       	eor	r23, r19
    9708:	38 2f       	mov	r19, r24
    970a:	3a 73       	andi	r19, 0x3A	; 58
    970c:	73 27       	eor	r23, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    970e:	37 2f       	mov	r19, r23
    9710:	32 95       	swap	r19
    9712:	73 27       	eor	r23, r19
    Feedback ^= Feedback >> 2;
    9714:	37 2f       	mov	r19, r23
    9716:	36 95       	lsr	r19
    9718:	36 95       	lsr	r19
    971a:	73 27       	eor	r23, r19
    Feedback ^= Feedback >> 1;
    971c:	37 2f       	mov	r19, r23
    971e:	36 95       	lsr	r19
    9720:	73 27       	eor	r23, r19
        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9722:	34 2f       	mov	r19, r20
    9724:	76 95       	lsr	r23
    9726:	97 95       	ror	r25
    9728:	27 95       	ror	r18
    972a:	37 95       	ror	r19
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    972c:	c5 2f       	mov	r28, r21
    972e:	d0 e0       	ldi	r29, 0x00	; 0
    9730:	c0 55       	subi	r28, 0x50	; 80
    9732:	df 4d       	sbci	r29, 0xDF	; 223
    9734:	0b 2f       	mov	r16, r27
    9736:	10 e0       	ldi	r17, 0x00	; 0
    9738:	00 55       	subi	r16, 0x50	; 80
    973a:	1e 4d       	sbci	r17, 0xDE	; 222
    973c:	78 81       	ld	r23, Y
    973e:	e8 01       	movw	r28, r16
    9740:	48 81       	ld	r20, Y
    9742:	74 2b       	or	r23, r20
    9744:	08 2f       	mov	r16, r24
    9746:	10 e0       	ldi	r17, 0x00	; 0
    9748:	00 55       	subi	r16, 0x50	; 80
    974a:	1d 4d       	sbci	r17, 0xDD	; 221
    974c:	e8 01       	movw	r28, r16
    974e:	48 81       	ld	r20, Y
    9750:	c7 2f       	mov	r28, r23
    9752:	c4 2b       	or	r28, r20
    9754:	d0 e0       	ldi	r29, 0x00	; 0
    9756:	c0 59       	subi	r28, 0x90	; 144
    9758:	df 4d       	sbci	r29, 0xDF	; 223
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
    975a:	d8 81       	ld	r29, Y
    975c:	da 2b       	or	r29, r26
    975e:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9760:	7b 2f       	mov	r23, r27
    9762:	70 71       	andi	r23, 0x10	; 16
    9764:	45 2f       	mov	r20, r21
    9766:	41 7e       	andi	r20, 0xE1	; 225
    9768:	74 27       	eor	r23, r20
    976a:	48 2f       	mov	r20, r24
    976c:	40 72       	andi	r20, 0x20	; 32
    976e:	74 27       	eor	r23, r20
    9770:	43 2f       	mov	r20, r19
    9772:	44 79       	andi	r20, 0x94	; 148
    9774:	74 27       	eor	r23, r20
    9776:	42 2f       	mov	r20, r18
    9778:	43 77       	andi	r20, 0x73	; 115
    977a:	74 27       	eor	r23, r20
    977c:	49 2f       	mov	r20, r25
    977e:	4a 73       	andi	r20, 0x3A	; 58
    9780:	74 27       	eor	r23, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9782:	47 2f       	mov	r20, r23
    9784:	42 95       	swap	r20
    9786:	74 27       	eor	r23, r20
    Feedback ^= Feedback >> 2;
    9788:	a7 2f       	mov	r26, r23
    978a:	a6 95       	lsr	r26
    978c:	a6 95       	lsr	r26
    978e:	7a 27       	eor	r23, r26
    Feedback ^= Feedback >> 1;
    9790:	47 2f       	mov	r20, r23
    9792:	46 95       	lsr	r20
    9794:	74 27       	eor	r23, r20

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    9796:	4b 2f       	mov	r20, r27
    9798:	76 95       	lsr	r23
    979a:	87 95       	ror	r24
    979c:	47 95       	ror	r20
    979e:	57 95       	ror	r21
    97a0:	c4 2f       	mov	r28, r20
    97a2:	b8 2e       	mov	r11, r24
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    97a4:	a3 2f       	mov	r26, r19
    97a6:	b0 e0       	ldi	r27, 0x00	; 0
    97a8:	8d 01       	movw	r16, r26
    97aa:	00 55       	subi	r16, 0x50	; 80
    97ac:	1f 4d       	sbci	r17, 0xDF	; 223
    97ae:	68 01       	movw	r12, r16
    97b0:	a2 2f       	mov	r26, r18
    97b2:	b0 e0       	ldi	r27, 0x00	; 0
    97b4:	8d 01       	movw	r16, r26
    97b6:	00 55       	subi	r16, 0x50	; 80
    97b8:	1e 4d       	sbci	r17, 0xDE	; 222
    97ba:	78 01       	movw	r14, r16
    97bc:	d6 01       	movw	r26, r12
    97be:	0c 91       	ld	r16, X
    97c0:	d7 01       	movw	r26, r14
    97c2:	8c 91       	ld	r24, X
    97c4:	08 2b       	or	r16, r24
    97c6:	e9 2e       	mov	r14, r25
    97c8:	f1 2c       	mov	r15, r1
    97ca:	d7 01       	movw	r26, r14
    97cc:	a0 55       	subi	r26, 0x50	; 80
    97ce:	bd 4d       	sbci	r27, 0xDD	; 221
    97d0:	8c 91       	ld	r24, X
    97d2:	08 2b       	or	r16, r24
    97d4:	10 e0       	ldi	r17, 0x00	; 0
    97d6:	00 59       	subi	r16, 0x90	; 144
    97d8:	1f 4d       	sbci	r17, 0xDF	; 223
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    97da:	d8 01       	movw	r26, r16
    97dc:	8c 91       	ld	r24, X
    97de:	d8 2b       	or	r29, r24
    97e0:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    97e2:	73 2f       	mov	r23, r19
    97e4:	71 7e       	andi	r23, 0xE1	; 225
    97e6:	82 2f       	mov	r24, r18
    97e8:	80 71       	andi	r24, 0x10	; 16
    97ea:	78 27       	eor	r23, r24
    97ec:	89 2f       	mov	r24, r25
    97ee:	80 72       	andi	r24, 0x20	; 32
    97f0:	78 27       	eor	r23, r24
    97f2:	85 2f       	mov	r24, r21
    97f4:	84 79       	andi	r24, 0x94	; 148
    97f6:	78 27       	eor	r23, r24
    97f8:	84 2f       	mov	r24, r20
    97fa:	83 77       	andi	r24, 0x73	; 115
    97fc:	78 27       	eor	r23, r24
    97fe:	8b 2d       	mov	r24, r11
    9800:	8a 73       	andi	r24, 0x3A	; 58
    9802:	78 27       	eor	r23, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9804:	87 2f       	mov	r24, r23
    9806:	82 95       	swap	r24
    9808:	78 27       	eor	r23, r24
    Feedback ^= Feedback >> 2;
    980a:	a7 2f       	mov	r26, r23
    980c:	a6 95       	lsr	r26
    980e:	a6 95       	lsr	r26
    9810:	7a 27       	eor	r23, r26
    Feedback ^= Feedback >> 1;
    9812:	87 2f       	mov	r24, r23
    9814:	86 95       	lsr	r24
    9816:	78 27       	eor	r23, r24
        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9818:	43 2f       	mov	r20, r19
    981a:	32 2f       	mov	r19, r18
    981c:	27 2f       	mov	r18, r23
    981e:	26 95       	lsr	r18
    9820:	97 95       	ror	r25
    9822:	37 95       	ror	r19
    9824:	47 95       	ror	r20
    9826:	29 2f       	mov	r18, r25
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    9828:	85 2f       	mov	r24, r21
    982a:	90 e0       	ldi	r25, 0x00	; 0
    982c:	80 55       	subi	r24, 0x50	; 80
    982e:	9f 4d       	sbci	r25, 0xDF	; 223
    9830:	0c 2f       	mov	r16, r28
    9832:	10 e0       	ldi	r17, 0x00	; 0
    9834:	00 55       	subi	r16, 0x50	; 80
    9836:	1e 4d       	sbci	r17, 0xDE	; 222
    9838:	dc 01       	movw	r26, r24
    983a:	9c 91       	ld	r25, X
    983c:	d8 01       	movw	r26, r16
    983e:	8c 91       	ld	r24, X
    9840:	89 2b       	or	r24, r25
    9842:	0b 2d       	mov	r16, r11
    9844:	10 e0       	ldi	r17, 0x00	; 0
    9846:	00 55       	subi	r16, 0x50	; 80
    9848:	1d 4d       	sbci	r17, 0xDD	; 221
    984a:	d8 01       	movw	r26, r16
    984c:	9c 91       	ld	r25, X
    984e:	89 2b       	or	r24, r25
    9850:	90 e0       	ldi	r25, 0x00	; 0
    9852:	80 59       	subi	r24, 0x90	; 144
    9854:	9f 4d       	sbci	r25, 0xDF	; 223
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Transcrypt and increment buffer address */
        *Buffer++ ^= KeyStream;
    9856:	dc 01       	movw	r26, r24
    9858:	9c 91       	ld	r25, X
    985a:	8d 2f       	mov	r24, r29
    985c:	89 2b       	or	r24, r25
    985e:	90 81       	ld	r25, Z
    9860:	89 27       	eor	r24, r25
    9862:	81 93       	st	Z+, r24
    9864:	13 ce       	rjmp	.-986    	; 0x948c <Crypto1ByteArray+0x2c>
    }

    /* save state */
    State.Even[0] = Even0;
    9866:	50 93 16 2d 	sts	0x2D16, r21	; 0x802d16 <State>
    State.Even[1] = Even1;
    986a:	c0 93 17 2d 	sts	0x2D17, r28	; 0x802d17 <State+0x1>
    State.Even[2] = Even2;
    986e:	b0 92 18 2d 	sts	0x2D18, r11	; 0x802d18 <State+0x2>
    State.Odd[0]  = Odd0;
    9872:	40 93 19 2d 	sts	0x2D19, r20	; 0x802d19 <State+0x3>
    State.Odd[1]  = Odd1;
    9876:	30 93 1a 2d 	sts	0x2D1A, r19	; 0x802d1a <State+0x4>
    State.Odd[2]  = Odd2;
    987a:	20 93 1b 2d 	sts	0x2D1B, r18	; 0x802d1b <State+0x5>
}
    987e:	df 91       	pop	r29
    9880:	cf 91       	pop	r28
    9882:	1f 91       	pop	r17
    9884:	0f 91       	pop	r16
    9886:	ff 90       	pop	r15
    9888:	ef 90       	pop	r14
    988a:	df 90       	pop	r13
    988c:	cf 90       	pop	r12
    988e:	bf 90       	pop	r11
    9890:	08 95       	ret

00009892 <Crypto1ByteArrayWithParity>:
/* and generates the parity bits                           */
/* No input to the LFSR                                    */
/* Avoids load/store of the LFSR-state for each byte!      */
/* The filter output used to encrypt the parity is         */
/* reused to encrypt bit 0 in the next byte.               */
void Crypto1ByteArrayWithParity(uint8_t *Buffer, uint8_t Count) {
    9892:	ef 92       	push	r14
    9894:	ff 92       	push	r15
    9896:	0f 93       	push	r16
    9898:	1f 93       	push	r17
    989a:	cf 93       	push	r28
    989c:	df 93       	push	r29
    uint8_t KeyStream = 0;
    uint8_t Feedback;
    uint8_t Out;

    /* read state */
    Even0 = State.Even[0];
    989e:	70 91 16 2d 	lds	r23, 0x2D16	; 0x802d16 <State>
    Even1 = State.Even[1];
    98a2:	50 91 17 2d 	lds	r21, 0x2D17	; 0x802d17 <State+0x1>
    Even2 = State.Even[2];
    98a6:	20 91 18 2d 	lds	r18, 0x2D18	; 0x802d18 <State+0x2>
    Odd0 = State.Odd[0];
    98aa:	40 91 19 2d 	lds	r20, 0x2D19	; 0x802d19 <State+0x3>
    Odd1 = State.Odd[1];
    98ae:	30 91 1a 2d 	lds	r19, 0x2D1A	; 0x802d1a <State+0x4>
    Odd2 = State.Odd[2];
    98b2:	c0 91 1b 2d 	lds	r28, 0x2D1B	; 0x802d1b <State+0x5>

    /* First pass needs output, next pass uses parity bit! */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    98b6:	e4 2f       	mov	r30, r20
    98b8:	f0 e0       	ldi	r31, 0x00	; 0
    98ba:	e0 55       	subi	r30, 0x50	; 80
    98bc:	ff 4d       	sbci	r31, 0xDF	; 223
    98be:	a3 2f       	mov	r26, r19
    98c0:	b0 e0       	ldi	r27, 0x00	; 0
    98c2:	a0 55       	subi	r26, 0x50	; 80
    98c4:	be 4d       	sbci	r27, 0xDE	; 222
    98c6:	f0 81       	ld	r31, Z
    98c8:	ec 91       	ld	r30, X
    98ca:	ef 2b       	or	r30, r31
    98cc:	ac 2f       	mov	r26, r28
    98ce:	b0 e0       	ldi	r27, 0x00	; 0
    98d0:	a0 55       	subi	r26, 0x50	; 80
    98d2:	bd 4d       	sbci	r27, 0xDD	; 221
    98d4:	fc 91       	ld	r31, X
    98d6:	ef 2b       	or	r30, r31
    98d8:	f0 e0       	ldi	r31, 0x00	; 0
    98da:	e0 57       	subi	r30, 0x70	; 112
    98dc:	ff 4d       	sbci	r31, 0xDF	; 223
    98de:	10 81       	ld	r17, Z
    98e0:	dc 01       	movw	r26, r24
/* reused to encrypt bit 0 in the next byte.               */
void Crypto1ByteArrayWithParity(uint8_t *Buffer, uint8_t Count) {
    /* state registers */
    register uint8_t Even0, Even1, Even2;
    register uint8_t Odd0,  Odd1,  Odd2;
    uint8_t KeyStream = 0;
    98e2:	d0 e0       	ldi	r29, 0x00	; 0
    Odd2 = State.Odd[2];

    /* First pass needs output, next pass uses parity bit! */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);

    while (Count--) {
    98e4:	61 50       	subi	r22, 0x01	; 1
    98e6:	08 f4       	brcc	.+2      	; 0x98ea <Crypto1ByteArrayWithParity+0x58>
    98e8:	db c1       	rjmp	.+950    	; 0x9ca0 <Crypto1ByteArrayWithParity+0x40e>
        /* Bit 0, initialise keystream from parity */
        SHIFT8(KeyStream, Out);
    98ea:	16 95       	lsr	r17
    98ec:	d7 95       	ror	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    98ee:	95 2f       	mov	r25, r21
    98f0:	90 71       	andi	r25, 0x10	; 16
    98f2:	87 2f       	mov	r24, r23
    98f4:	81 7e       	andi	r24, 0xE1	; 225
    98f6:	89 27       	eor	r24, r25
    98f8:	92 2f       	mov	r25, r18
    98fa:	90 72       	andi	r25, 0x20	; 32
    98fc:	89 27       	eor	r24, r25
    98fe:	94 2f       	mov	r25, r20
    9900:	94 79       	andi	r25, 0x94	; 148
    9902:	89 27       	eor	r24, r25
    9904:	93 2f       	mov	r25, r19
    9906:	93 77       	andi	r25, 0x73	; 115
    9908:	89 27       	eor	r24, r25
    990a:	9c 2f       	mov	r25, r28
    990c:	9a 73       	andi	r25, 0x3A	; 58
    990e:	89 27       	eor	r24, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9910:	98 2f       	mov	r25, r24
    9912:	92 95       	swap	r25
    9914:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    9916:	e8 2f       	mov	r30, r24
    9918:	e6 95       	lsr	r30
    991a:	e6 95       	lsr	r30
    991c:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 1;
    991e:	98 2f       	mov	r25, r24
    9920:	96 95       	lsr	r25
    9922:	89 27       	eor	r24, r25

    while (Count--) {
        /* Bit 0, initialise keystream from parity */
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    9924:	86 95       	lsr	r24
    9926:	27 95       	ror	r18
    9928:	57 95       	ror	r21
    992a:	77 95       	ror	r23

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    992c:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    992e:	93 2f       	mov	r25, r19
    9930:	90 71       	andi	r25, 0x10	; 16
    9932:	84 2f       	mov	r24, r20
    9934:	81 7e       	andi	r24, 0xE1	; 225
    9936:	89 27       	eor	r24, r25
    9938:	9c 2f       	mov	r25, r28
    993a:	90 72       	andi	r25, 0x20	; 32
    993c:	89 27       	eor	r24, r25
    993e:	97 2f       	mov	r25, r23
    9940:	94 79       	andi	r25, 0x94	; 148
    9942:	89 27       	eor	r24, r25
    9944:	95 2f       	mov	r25, r21
    9946:	93 77       	andi	r25, 0x73	; 115
    9948:	89 27       	eor	r24, r25
    994a:	92 2f       	mov	r25, r18
    994c:	9a 73       	andi	r25, 0x3A	; 58
    994e:	89 27       	eor	r24, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9950:	98 2f       	mov	r25, r24
    9952:	92 95       	swap	r25
    9954:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    9956:	e8 2f       	mov	r30, r24
    9958:	e6 95       	lsr	r30
    995a:	e6 95       	lsr	r30
    995c:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 1;
    995e:	98 2f       	mov	r25, r24
    9960:	96 95       	lsr	r25
    9962:	89 27       	eor	r24, r25
        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9964:	9c 2f       	mov	r25, r28
    9966:	86 95       	lsr	r24
    9968:	97 95       	ror	r25
    996a:	37 95       	ror	r19
    996c:	47 95       	ror	r20
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    996e:	e7 2f       	mov	r30, r23
    9970:	f0 e0       	ldi	r31, 0x00	; 0
    9972:	e0 55       	subi	r30, 0x50	; 80
    9974:	ff 4d       	sbci	r31, 0xDF	; 223
    9976:	05 2f       	mov	r16, r21
    9978:	10 e0       	ldi	r17, 0x00	; 0
    997a:	00 55       	subi	r16, 0x50	; 80
    997c:	1e 4d       	sbci	r17, 0xDE	; 222
    997e:	c0 81       	ld	r28, Z
    9980:	f8 01       	movw	r30, r16
    9982:	80 81       	ld	r24, Z
    9984:	c8 2b       	or	r28, r24
    9986:	02 2f       	mov	r16, r18
    9988:	10 e0       	ldi	r17, 0x00	; 0
    998a:	00 55       	subi	r16, 0x50	; 80
    998c:	1d 4d       	sbci	r17, 0xDD	; 221
    998e:	f8 01       	movw	r30, r16
    9990:	80 81       	ld	r24, Z
    9992:	ec 2f       	mov	r30, r28
    9994:	e8 2b       	or	r30, r24
    9996:	f0 e0       	ldi	r31, 0x00	; 0
    9998:	e0 59       	subi	r30, 0x90	; 144
    999a:	ff 4d       	sbci	r31, 0xDF	; 223
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
    999c:	80 81       	ld	r24, Z
    999e:	d8 2b       	or	r29, r24
    99a0:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    99a2:	e5 2f       	mov	r30, r21
    99a4:	e0 71       	andi	r30, 0x10	; 16
    99a6:	87 2f       	mov	r24, r23
    99a8:	81 7e       	andi	r24, 0xE1	; 225
    99aa:	8e 27       	eor	r24, r30
    99ac:	e2 2f       	mov	r30, r18
    99ae:	e0 72       	andi	r30, 0x20	; 32
    99b0:	8e 27       	eor	r24, r30
    99b2:	e4 2f       	mov	r30, r20
    99b4:	e4 79       	andi	r30, 0x94	; 148
    99b6:	8e 27       	eor	r24, r30
    99b8:	e3 2f       	mov	r30, r19
    99ba:	e3 77       	andi	r30, 0x73	; 115
    99bc:	8e 27       	eor	r24, r30
    99be:	e9 2f       	mov	r30, r25
    99c0:	ea 73       	andi	r30, 0x3A	; 58
    99c2:	8e 27       	eor	r24, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    99c4:	e8 2f       	mov	r30, r24
    99c6:	e2 95       	swap	r30
    99c8:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 2;
    99ca:	e8 2f       	mov	r30, r24
    99cc:	e6 95       	lsr	r30
    99ce:	e6 95       	lsr	r30
    99d0:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 1;
    99d2:	e8 2f       	mov	r30, r24
    99d4:	e6 95       	lsr	r30
    99d6:	8e 27       	eor	r24, r30

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    99d8:	86 95       	lsr	r24
    99da:	27 95       	ror	r18
    99dc:	57 95       	ror	r21
    99de:	77 95       	ror	r23
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    99e0:	e4 2f       	mov	r30, r20
    99e2:	f0 e0       	ldi	r31, 0x00	; 0
    99e4:	e0 55       	subi	r30, 0x50	; 80
    99e6:	ff 4d       	sbci	r31, 0xDF	; 223
    99e8:	03 2f       	mov	r16, r19
    99ea:	10 e0       	ldi	r17, 0x00	; 0
    99ec:	00 55       	subi	r16, 0x50	; 80
    99ee:	1e 4d       	sbci	r17, 0xDE	; 222
    99f0:	c0 81       	ld	r28, Z
    99f2:	f8 01       	movw	r30, r16
    99f4:	80 81       	ld	r24, Z
    99f6:	c8 2b       	or	r28, r24
    99f8:	09 2f       	mov	r16, r25
    99fa:	10 e0       	ldi	r17, 0x00	; 0
    99fc:	00 55       	subi	r16, 0x50	; 80
    99fe:	1d 4d       	sbci	r17, 0xDD	; 221
    9a00:	f8 01       	movw	r30, r16
    9a02:	80 81       	ld	r24, Z
    9a04:	ec 2f       	mov	r30, r28
    9a06:	e8 2b       	or	r30, r24
    9a08:	f0 e0       	ldi	r31, 0x00	; 0
    9a0a:	e0 59       	subi	r30, 0x90	; 144
    9a0c:	ff 4d       	sbci	r31, 0xDF	; 223
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    9a0e:	80 81       	ld	r24, Z
    9a10:	d8 2b       	or	r29, r24
    9a12:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9a14:	e3 2f       	mov	r30, r19
    9a16:	e0 71       	andi	r30, 0x10	; 16
    9a18:	84 2f       	mov	r24, r20
    9a1a:	81 7e       	andi	r24, 0xE1	; 225
    9a1c:	8e 27       	eor	r24, r30
    9a1e:	e9 2f       	mov	r30, r25
    9a20:	e0 72       	andi	r30, 0x20	; 32
    9a22:	8e 27       	eor	r24, r30
    9a24:	e7 2f       	mov	r30, r23
    9a26:	e4 79       	andi	r30, 0x94	; 148
    9a28:	8e 27       	eor	r24, r30
    9a2a:	e5 2f       	mov	r30, r21
    9a2c:	e3 77       	andi	r30, 0x73	; 115
    9a2e:	8e 27       	eor	r24, r30
    9a30:	e2 2f       	mov	r30, r18
    9a32:	ea 73       	andi	r30, 0x3A	; 58
    9a34:	8e 27       	eor	r24, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9a36:	e8 2f       	mov	r30, r24
    9a38:	e2 95       	swap	r30
    9a3a:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 2;
    9a3c:	e8 2f       	mov	r30, r24
    9a3e:	e6 95       	lsr	r30
    9a40:	e6 95       	lsr	r30
    9a42:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 1;
    9a44:	e8 2f       	mov	r30, r24
    9a46:	e6 95       	lsr	r30
    9a48:	8e 27       	eor	r24, r30
        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9a4a:	86 95       	lsr	r24
    9a4c:	97 95       	ror	r25
    9a4e:	37 95       	ror	r19
    9a50:	47 95       	ror	r20
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    9a52:	e7 2f       	mov	r30, r23
    9a54:	f0 e0       	ldi	r31, 0x00	; 0
    9a56:	e0 55       	subi	r30, 0x50	; 80
    9a58:	ff 4d       	sbci	r31, 0xDF	; 223
    9a5a:	05 2f       	mov	r16, r21
    9a5c:	10 e0       	ldi	r17, 0x00	; 0
    9a5e:	00 55       	subi	r16, 0x50	; 80
    9a60:	1e 4d       	sbci	r17, 0xDE	; 222
    9a62:	c0 81       	ld	r28, Z
    9a64:	f8 01       	movw	r30, r16
    9a66:	80 81       	ld	r24, Z
    9a68:	c8 2b       	or	r28, r24
    9a6a:	02 2f       	mov	r16, r18
    9a6c:	10 e0       	ldi	r17, 0x00	; 0
    9a6e:	00 55       	subi	r16, 0x50	; 80
    9a70:	1d 4d       	sbci	r17, 0xDD	; 221
    9a72:	f8 01       	movw	r30, r16
    9a74:	80 81       	ld	r24, Z
    9a76:	ec 2f       	mov	r30, r28
    9a78:	e8 2b       	or	r30, r24
    9a7a:	f0 e0       	ldi	r31, 0x00	; 0
    9a7c:	e0 59       	subi	r30, 0x90	; 144
    9a7e:	ff 4d       	sbci	r31, 0xDF	; 223
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
    9a80:	80 81       	ld	r24, Z
    9a82:	d8 2b       	or	r29, r24
    9a84:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9a86:	e5 2f       	mov	r30, r21
    9a88:	e0 71       	andi	r30, 0x10	; 16
    9a8a:	87 2f       	mov	r24, r23
    9a8c:	81 7e       	andi	r24, 0xE1	; 225
    9a8e:	8e 27       	eor	r24, r30
    9a90:	e2 2f       	mov	r30, r18
    9a92:	e0 72       	andi	r30, 0x20	; 32
    9a94:	8e 27       	eor	r24, r30
    9a96:	e4 2f       	mov	r30, r20
    9a98:	e4 79       	andi	r30, 0x94	; 148
    9a9a:	8e 27       	eor	r24, r30
    9a9c:	e3 2f       	mov	r30, r19
    9a9e:	e3 77       	andi	r30, 0x73	; 115
    9aa0:	8e 27       	eor	r24, r30
    9aa2:	e9 2f       	mov	r30, r25
    9aa4:	ea 73       	andi	r30, 0x3A	; 58
    9aa6:	8e 27       	eor	r24, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9aa8:	e8 2f       	mov	r30, r24
    9aaa:	e2 95       	swap	r30
    9aac:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 2;
    9aae:	e8 2f       	mov	r30, r24
    9ab0:	e6 95       	lsr	r30
    9ab2:	e6 95       	lsr	r30
    9ab4:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 1;
    9ab6:	e8 2f       	mov	r30, r24
    9ab8:	e6 95       	lsr	r30
    9aba:	8e 27       	eor	r24, r30

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    9abc:	86 95       	lsr	r24
    9abe:	27 95       	ror	r18
    9ac0:	57 95       	ror	r21
    9ac2:	77 95       	ror	r23
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    9ac4:	e4 2f       	mov	r30, r20
    9ac6:	f0 e0       	ldi	r31, 0x00	; 0
    9ac8:	e0 55       	subi	r30, 0x50	; 80
    9aca:	ff 4d       	sbci	r31, 0xDF	; 223
    9acc:	03 2f       	mov	r16, r19
    9ace:	10 e0       	ldi	r17, 0x00	; 0
    9ad0:	00 55       	subi	r16, 0x50	; 80
    9ad2:	1e 4d       	sbci	r17, 0xDE	; 222
    9ad4:	c0 81       	ld	r28, Z
    9ad6:	f8 01       	movw	r30, r16
    9ad8:	80 81       	ld	r24, Z
    9ada:	c8 2b       	or	r28, r24
    9adc:	09 2f       	mov	r16, r25
    9ade:	10 e0       	ldi	r17, 0x00	; 0
    9ae0:	00 55       	subi	r16, 0x50	; 80
    9ae2:	1d 4d       	sbci	r17, 0xDD	; 221
    9ae4:	f8 01       	movw	r30, r16
    9ae6:	80 81       	ld	r24, Z
    9ae8:	ec 2f       	mov	r30, r28
    9aea:	e8 2b       	or	r30, r24
    9aec:	f0 e0       	ldi	r31, 0x00	; 0
    9aee:	e0 59       	subi	r30, 0x90	; 144
    9af0:	ff 4d       	sbci	r31, 0xDF	; 223
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    9af2:	80 81       	ld	r24, Z
    9af4:	d8 2b       	or	r29, r24
    9af6:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9af8:	e3 2f       	mov	r30, r19
    9afa:	e0 71       	andi	r30, 0x10	; 16
    9afc:	84 2f       	mov	r24, r20
    9afe:	81 7e       	andi	r24, 0xE1	; 225
    9b00:	8e 27       	eor	r24, r30
    9b02:	e9 2f       	mov	r30, r25
    9b04:	e0 72       	andi	r30, 0x20	; 32
    9b06:	8e 27       	eor	r24, r30
    9b08:	e7 2f       	mov	r30, r23
    9b0a:	e4 79       	andi	r30, 0x94	; 148
    9b0c:	8e 27       	eor	r24, r30
    9b0e:	e5 2f       	mov	r30, r21
    9b10:	e3 77       	andi	r30, 0x73	; 115
    9b12:	8e 27       	eor	r24, r30
    9b14:	e2 2f       	mov	r30, r18
    9b16:	ea 73       	andi	r30, 0x3A	; 58
    9b18:	8e 27       	eor	r24, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9b1a:	e8 2f       	mov	r30, r24
    9b1c:	e2 95       	swap	r30
    9b1e:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 2;
    9b20:	e8 2f       	mov	r30, r24
    9b22:	e6 95       	lsr	r30
    9b24:	e6 95       	lsr	r30
    9b26:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 1;
    9b28:	e8 2f       	mov	r30, r24
    9b2a:	e6 95       	lsr	r30
    9b2c:	8e 27       	eor	r24, r30
        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9b2e:	86 95       	lsr	r24
    9b30:	97 95       	ror	r25
    9b32:	37 95       	ror	r19
    9b34:	47 95       	ror	r20
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    9b36:	e7 2f       	mov	r30, r23
    9b38:	f0 e0       	ldi	r31, 0x00	; 0
    9b3a:	e0 55       	subi	r30, 0x50	; 80
    9b3c:	ff 4d       	sbci	r31, 0xDF	; 223
    9b3e:	05 2f       	mov	r16, r21
    9b40:	10 e0       	ldi	r17, 0x00	; 0
    9b42:	00 55       	subi	r16, 0x50	; 80
    9b44:	1e 4d       	sbci	r17, 0xDE	; 222
    9b46:	c0 81       	ld	r28, Z
    9b48:	f8 01       	movw	r30, r16
    9b4a:	80 81       	ld	r24, Z
    9b4c:	c8 2b       	or	r28, r24
    9b4e:	02 2f       	mov	r16, r18
    9b50:	10 e0       	ldi	r17, 0x00	; 0
    9b52:	00 55       	subi	r16, 0x50	; 80
    9b54:	1d 4d       	sbci	r17, 0xDD	; 221
    9b56:	f8 01       	movw	r30, r16
    9b58:	80 81       	ld	r24, Z
    9b5a:	ec 2f       	mov	r30, r28
    9b5c:	e8 2b       	or	r30, r24
    9b5e:	f0 e0       	ldi	r31, 0x00	; 0
    9b60:	e0 59       	subi	r30, 0x90	; 144
    9b62:	ff 4d       	sbci	r31, 0xDF	; 223
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
    9b64:	80 81       	ld	r24, Z
    9b66:	d8 2b       	or	r29, r24
    9b68:	d6 95       	lsr	r29
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9b6a:	e5 2f       	mov	r30, r21
    9b6c:	e0 71       	andi	r30, 0x10	; 16
    9b6e:	87 2f       	mov	r24, r23
    9b70:	81 7e       	andi	r24, 0xE1	; 225
    9b72:	8e 27       	eor	r24, r30
    9b74:	e2 2f       	mov	r30, r18
    9b76:	e0 72       	andi	r30, 0x20	; 32
    9b78:	8e 27       	eor	r24, r30
    9b7a:	e4 2f       	mov	r30, r20
    9b7c:	e4 79       	andi	r30, 0x94	; 148
    9b7e:	8e 27       	eor	r24, r30
    9b80:	e3 2f       	mov	r30, r19
    9b82:	e3 77       	andi	r30, 0x73	; 115
    9b84:	8e 27       	eor	r24, r30
    9b86:	e9 2f       	mov	r30, r25
    9b88:	ea 73       	andi	r30, 0x3A	; 58
    9b8a:	8e 27       	eor	r24, r30

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9b8c:	e8 2f       	mov	r30, r24
    9b8e:	e2 95       	swap	r30
    9b90:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 2;
    9b92:	e8 2f       	mov	r30, r24
    9b94:	e6 95       	lsr	r30
    9b96:	e6 95       	lsr	r30
    9b98:	8e 27       	eor	r24, r30
    Feedback ^= Feedback >> 1;
    9b9a:	e8 2f       	mov	r30, r24
    9b9c:	e6 95       	lsr	r30
    9b9e:	8e 27       	eor	r24, r30

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);
    9ba0:	86 95       	lsr	r24
    9ba2:	27 95       	ror	r18
    9ba4:	57 95       	ror	r21
    9ba6:	77 95       	ror	r23
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    9ba8:	e4 2f       	mov	r30, r20
    9baa:	f0 e0       	ldi	r31, 0x00	; 0
    9bac:	e0 55       	subi	r30, 0x50	; 80
    9bae:	ff 4d       	sbci	r31, 0xDF	; 223
    9bb0:	03 2f       	mov	r16, r19
    9bb2:	10 e0       	ldi	r17, 0x00	; 0
    9bb4:	00 55       	subi	r16, 0x50	; 80
    9bb6:	1e 4d       	sbci	r17, 0xDE	; 222
    9bb8:	c0 81       	ld	r28, Z
    9bba:	f8 01       	movw	r30, r16
    9bbc:	80 81       	ld	r24, Z
    9bbe:	c8 2b       	or	r28, r24
    9bc0:	09 2f       	mov	r16, r25
    9bc2:	10 e0       	ldi	r17, 0x00	; 0
    9bc4:	00 55       	subi	r16, 0x50	; 80
    9bc6:	1d 4d       	sbci	r17, 0xDD	; 221
    9bc8:	f8 01       	movw	r30, r16
    9bca:	80 81       	ld	r24, Z
    9bcc:	ec 2f       	mov	r30, r28
    9bce:	e8 2b       	or	r30, r24
    9bd0:	f0 e0       	ldi	r31, 0x00	; 0
    9bd2:	e0 59       	subi	r30, 0x90	; 144
    9bd4:	ff 4d       	sbci	r31, 0xDF	; 223
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
    9bd6:	80 81       	ld	r24, Z
    9bd8:	d8 2b       	or	r29, r24
    9bda:	d6 95       	lsr	r29
        Feedback  = Crypto1LFSRbyteFeedback(Even0, Even1, Even2, Odd0, Odd1, Odd2);
        SHIFT24(Even0, Even1, Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
    9bdc:	e7 2f       	mov	r30, r23
    9bde:	f0 e0       	ldi	r31, 0x00	; 0
    9be0:	e0 55       	subi	r30, 0x50	; 80
    9be2:	ff 4d       	sbci	r31, 0xDF	; 223
    9be4:	05 2f       	mov	r16, r21
    9be6:	10 e0       	ldi	r17, 0x00	; 0
    9be8:	00 55       	subi	r16, 0x50	; 80
    9bea:	1e 4d       	sbci	r17, 0xDE	; 222
    9bec:	c0 81       	ld	r28, Z
    9bee:	f8 01       	movw	r30, r16
    9bf0:	80 81       	ld	r24, Z
    9bf2:	c8 2b       	or	r28, r24
    9bf4:	02 2f       	mov	r16, r18
    9bf6:	10 e0       	ldi	r17, 0x00	; 0
    9bf8:	00 55       	subi	r16, 0x50	; 80
    9bfa:	1d 4d       	sbci	r17, 0xDD	; 221
    9bfc:	f8 01       	movw	r30, r16
    9bfe:	80 81       	ld	r24, Z
    9c00:	ec 2f       	mov	r30, r28
    9c02:	e8 2b       	or	r30, r24
    9c04:	f0 e0       	ldi	r31, 0x00	; 0
    9c06:	e0 59       	subi	r30, 0x90	; 144
    9c08:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream >> 1) | Out;
    9c0a:	80 81       	ld	r24, Z
    9c0c:	d8 2b       	or	r29, r24
    Feedback ^= E1 & (uint8_t)(LFSR_MASK_EVEN >> 8);
    Feedback ^= E2 & (uint8_t)(LFSR_MASK_EVEN >> 16);

    Feedback ^= O0 & (uint8_t)(LFSR_MASK_ODD);
    Feedback ^= O1 & (uint8_t)(LFSR_MASK_ODD >> 8);
    Feedback ^= O2 & (uint8_t)(LFSR_MASK_ODD >> 16);
    9c0e:	e4 2f       	mov	r30, r20
    9c10:	e1 7e       	andi	r30, 0xE1	; 225
    9c12:	83 2f       	mov	r24, r19
    9c14:	80 71       	andi	r24, 0x10	; 16
    9c16:	e8 27       	eor	r30, r24
    9c18:	89 2f       	mov	r24, r25
    9c1a:	80 72       	andi	r24, 0x20	; 32
    9c1c:	e8 27       	eor	r30, r24
    9c1e:	87 2f       	mov	r24, r23
    9c20:	84 79       	andi	r24, 0x94	; 148
    9c22:	e8 27       	eor	r30, r24
    9c24:	85 2f       	mov	r24, r21
    9c26:	83 77       	andi	r24, 0x73	; 115
    9c28:	e8 27       	eor	r30, r24
    9c2a:	82 2f       	mov	r24, r18
    9c2c:	8a 73       	andi	r24, 0x3A	; 58
    9c2e:	e8 27       	eor	r30, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4) | (Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9c30:	8e 2f       	mov	r24, r30
    9c32:	82 95       	swap	r24
    9c34:	e8 27       	eor	r30, r24
    Feedback ^= Feedback >> 2;
    9c36:	8e 2f       	mov	r24, r30
    9c38:	86 95       	lsr	r24
    9c3a:	86 95       	lsr	r24
    9c3c:	e8 27       	eor	r30, r24
    Feedback ^= Feedback >> 1;
    9c3e:	8e 2f       	mov	r24, r30
    9c40:	86 95       	lsr	r24
    9c42:	e8 27       	eor	r30, r24
        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0, Even1, Even2);
        KeyStream = (KeyStream >> 1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0, Odd1, Odd2, Even0, Even1, Even2);
        SHIFT24(Odd0, Odd1, Odd2, Feedback);
    9c44:	e6 95       	lsr	r30
    9c46:	97 95       	ror	r25
    9c48:	37 95       	ror	r19
    9c4a:	47 95       	ror	r20
    9c4c:	c9 2f       	mov	r28, r25

        /* Next bit encodes parity */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    9c4e:	e4 2f       	mov	r30, r20
    9c50:	f0 e0       	ldi	r31, 0x00	; 0
    9c52:	e0 55       	subi	r30, 0x50	; 80
    9c54:	ff 4d       	sbci	r31, 0xDF	; 223
    9c56:	83 2f       	mov	r24, r19
    9c58:	90 e0       	ldi	r25, 0x00	; 0
    9c5a:	80 55       	subi	r24, 0x50	; 80
    9c5c:	9e 4d       	sbci	r25, 0xDE	; 222
    9c5e:	10 81       	ld	r17, Z
    9c60:	fc 01       	movw	r30, r24
    9c62:	80 81       	ld	r24, Z
    9c64:	18 2b       	or	r17, r24
    9c66:	8c 2f       	mov	r24, r28
    9c68:	90 e0       	ldi	r25, 0x00	; 0
    9c6a:	80 55       	subi	r24, 0x50	; 80
    9c6c:	9d 4d       	sbci	r25, 0xDD	; 221
    9c6e:	fc 01       	movw	r30, r24
    9c70:	80 81       	ld	r24, Z
    9c72:	e1 2f       	mov	r30, r17
    9c74:	e8 2b       	or	r30, r24
    9c76:	f0 e0       	ldi	r31, 0x00	; 0
    9c78:	e0 57       	subi	r30, 0x70	; 112
    9c7a:	ff 4d       	sbci	r31, 0xDF	; 223
    9c7c:	10 81       	ld	r17, Z
        Buffer[ISO14443A_BUFFER_PARITY_OFFSET] = ODD_PARITY(*Buffer) ^ Out;
    9c7e:	8c 91       	ld	r24, X
    9c80:	e8 2f       	mov	r30, r24
    9c82:	f0 e0       	ldi	r31, 0x00	; 0
    9c84:	ea 50       	subi	r30, 0x0A	; 10
    9c86:	f9 4f       	sbci	r31, 0xF9	; 249
    9c88:	e4 91       	lpm	r30, Z
    9c8a:	7d 01       	movw	r14, r26
    9c8c:	f0 e8       	ldi	r31, 0x80	; 128
    9c8e:	ef 0e       	add	r14, r31
    9c90:	f1 1c       	adc	r15, r1
    9c92:	9e 2f       	mov	r25, r30
    9c94:	91 27       	eor	r25, r17
    9c96:	f7 01       	movw	r30, r14
    9c98:	90 83       	st	Z, r25

        /* encode Byte */
        *Buffer++ ^= KeyStream;
    9c9a:	8d 27       	eor	r24, r29
    9c9c:	8d 93       	st	X+, r24
    9c9e:	22 ce       	rjmp	.-956    	; 0x98e4 <Crypto1ByteArrayWithParity+0x52>
    }
    /* save state */
    State.Even[0] = Even0;
    9ca0:	70 93 16 2d 	sts	0x2D16, r23	; 0x802d16 <State>
    State.Even[1] = Even1;
    9ca4:	50 93 17 2d 	sts	0x2D17, r21	; 0x802d17 <State+0x1>
    State.Even[2] = Even2;
    9ca8:	20 93 18 2d 	sts	0x2D18, r18	; 0x802d18 <State+0x2>
    State.Odd[0]  = Odd0;
    9cac:	40 93 19 2d 	sts	0x2D19, r20	; 0x802d19 <State+0x3>
    State.Odd[1]  = Odd1;
    9cb0:	30 93 1a 2d 	sts	0x2D1A, r19	; 0x802d1a <State+0x4>
    State.Odd[2]  = Odd2;
    9cb4:	c0 93 1b 2d 	sts	0x2D1B, r28	; 0x802d1b <State+0x5>
}
    9cb8:	df 91       	pop	r29
    9cba:	cf 91       	pop	r28
    9cbc:	1f 91       	pop	r17
    9cbe:	0f 91       	pop	r16
    9cc0:	ff 90       	pop	r15
    9cc2:	ef 90       	pop	r14
    9cc4:	08 95       	ret

00009cc6 <Crypto1PRNG>:
/* gives us a total of 11 valid feedback bits!                    */
/* The ClockCount for the PRNG is always multiple of 32!          */
/* Up tp 11 Bits can be calculated at once                        */
/* Split into chunks of 11+11+10 = 32 bits                        */
/* This avoids a calculated number of shifts                      */
void Crypto1PRNG(uint8_t State[4], uint8_t ClockCount) {
    9cc6:	0f 93       	push	r16
    9cc8:	1f 93       	push	r17
    9cca:	fc 01       	movw	r30, r24
    9ccc:	86 2f       	mov	r24, r22
    uint16_t Feedback;

    Temp  = (uint32_t) State[0] << 0;
    Temp |= (uint32_t) State[1] << 8;
    Temp |= (uint32_t) State[2] << 16;
    Temp |= (uint32_t) State[3] << 24;
    9cce:	40 81       	ld	r20, Z
    9cd0:	51 81       	ldd	r21, Z+1	; 0x01
    9cd2:	62 81       	ldd	r22, Z+2	; 0x02
    9cd4:	73 81       	ldd	r23, Z+3	; 0x03
    9cd6:	8b 01       	movw	r16, r22
    9cd8:	22 27       	eor	r18, r18
    9cda:	33 27       	eor	r19, r19

    /* PRNG is always a multiple of 32!        */
    /* Up tp 11 Bits can be calculated at once */
    /* Split into chunks of 11+11+10 = 32 bits */
    while (ClockCount >= 32) {
    9cdc:	80 32       	cpi	r24, 0x20	; 32
    9cde:	08 f4       	brcc	.+2      	; 0x9ce2 <Crypto1PRNG+0x1c>
    9ce0:	71 c0       	rjmp	.+226    	; 0x9dc4 <Crypto1PRNG+0xfe>
        Feedback = (uint16_t)(Temp >> 16);
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
    9ce2:	d8 01       	movw	r26, r16
    9ce4:	23 e0       	ldi	r18, 0x03	; 3
    9ce6:	b6 95       	lsr	r27
    9ce8:	a7 95       	ror	r26
    9cea:	2a 95       	dec	r18
    9cec:	e1 f7       	brne	.-8      	; 0x9ce6 <Crypto1PRNG+0x20>
    9cee:	0a 27       	eor	r16, r26
    9cf0:	1b 27       	eor	r17, r27
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    9cf2:	98 01       	movw	r18, r16
    9cf4:	36 95       	lsr	r19
    9cf6:	27 95       	ror	r18
    9cf8:	36 95       	lsr	r19
    9cfa:	27 95       	ror	r18
        /* Cycle LFSR and feed back. */
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32 - 11));
    9cfc:	bb e0       	ldi	r27, 0x0B	; 11
    9cfe:	76 95       	lsr	r23
    9d00:	67 95       	ror	r22
    9d02:	57 95       	ror	r21
    9d04:	47 95       	ror	r20
    9d06:	ba 95       	dec	r27
    9d08:	d1 f7       	brne	.-12     	; 0x9cfe <Crypto1PRNG+0x38>
    9d0a:	02 27       	eor	r16, r18
    9d0c:	13 27       	eor	r17, r19
    9d0e:	20 e0       	ldi	r18, 0x00	; 0
    9d10:	30 e0       	ldi	r19, 0x00	; 0
    9d12:	95 e1       	ldi	r25, 0x15	; 21
    9d14:	00 0f       	add	r16, r16
    9d16:	11 1f       	adc	r17, r17
    9d18:	22 1f       	adc	r18, r18
    9d1a:	33 1f       	adc	r19, r19
    9d1c:	9a 95       	dec	r25
    9d1e:	d1 f7       	brne	.-12     	; 0x9d14 <Crypto1PRNG+0x4e>
    9d20:	40 2b       	or	r20, r16
    9d22:	51 2b       	or	r21, r17
    9d24:	62 2b       	or	r22, r18
    9d26:	73 2b       	or	r23, r19

        /* Same for the next 11 Bits */
        Feedback = (uint16_t)(Temp >> 16);
    9d28:	8b 01       	movw	r16, r22
    9d2a:	22 27       	eor	r18, r18
    9d2c:	33 27       	eor	r19, r19
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
    9d2e:	d8 01       	movw	r26, r16
    9d30:	33 e0       	ldi	r19, 0x03	; 3
    9d32:	b6 95       	lsr	r27
    9d34:	a7 95       	ror	r26
    9d36:	3a 95       	dec	r19
    9d38:	e1 f7       	brne	.-8      	; 0x9d32 <Crypto1PRNG+0x6c>
    9d3a:	0a 27       	eor	r16, r26
    9d3c:	1b 27       	eor	r17, r27
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    9d3e:	98 01       	movw	r18, r16
    9d40:	36 95       	lsr	r19
    9d42:	27 95       	ror	r18
    9d44:	36 95       	lsr	r19
    9d46:	27 95       	ror	r18
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32 - 11));
    9d48:	bb e0       	ldi	r27, 0x0B	; 11
    9d4a:	76 95       	lsr	r23
    9d4c:	67 95       	ror	r22
    9d4e:	57 95       	ror	r21
    9d50:	47 95       	ror	r20
    9d52:	ba 95       	dec	r27
    9d54:	d1 f7       	brne	.-12     	; 0x9d4a <Crypto1PRNG+0x84>
    9d56:	02 27       	eor	r16, r18
    9d58:	13 27       	eor	r17, r19
    9d5a:	20 e0       	ldi	r18, 0x00	; 0
    9d5c:	30 e0       	ldi	r19, 0x00	; 0
    9d5e:	95 e1       	ldi	r25, 0x15	; 21
    9d60:	00 0f       	add	r16, r16
    9d62:	11 1f       	adc	r17, r17
    9d64:	22 1f       	adc	r18, r18
    9d66:	33 1f       	adc	r19, r19
    9d68:	9a 95       	dec	r25
    9d6a:	d1 f7       	brne	.-12     	; 0x9d60 <Crypto1PRNG+0x9a>
    9d6c:	40 2b       	or	r20, r16
    9d6e:	51 2b       	or	r21, r17
    9d70:	62 2b       	or	r22, r18
    9d72:	73 2b       	or	r23, r19

        /* Remaining 10 bits */
        Feedback = (uint16_t)(Temp >> 16);
    9d74:	8b 01       	movw	r16, r22
    9d76:	22 27       	eor	r18, r18
    9d78:	33 27       	eor	r19, r19
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
    9d7a:	d8 01       	movw	r26, r16
    9d7c:	33 e0       	ldi	r19, 0x03	; 3
    9d7e:	b6 95       	lsr	r27
    9d80:	a7 95       	ror	r26
    9d82:	3a 95       	dec	r19
    9d84:	e1 f7       	brne	.-8      	; 0x9d7e <Crypto1PRNG+0xb8>
    9d86:	0a 27       	eor	r16, r26
    9d88:	1b 27       	eor	r17, r27
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    9d8a:	98 01       	movw	r18, r16
    9d8c:	36 95       	lsr	r19
    9d8e:	27 95       	ror	r18
    9d90:	36 95       	lsr	r19
    9d92:	27 95       	ror	r18
        Temp = (Temp >> 10) | (((uint32_t)Feedback) << (32 - 10));
    9d94:	ba e0       	ldi	r27, 0x0A	; 10
    9d96:	76 95       	lsr	r23
    9d98:	67 95       	ror	r22
    9d9a:	57 95       	ror	r21
    9d9c:	47 95       	ror	r20
    9d9e:	ba 95       	dec	r27
    9da0:	d1 f7       	brne	.-12     	; 0x9d96 <Crypto1PRNG+0xd0>
    9da2:	02 27       	eor	r16, r18
    9da4:	13 27       	eor	r17, r19
    9da6:	20 e0       	ldi	r18, 0x00	; 0
    9da8:	30 e0       	ldi	r19, 0x00	; 0
    9daa:	96 e1       	ldi	r25, 0x16	; 22
    9dac:	00 0f       	add	r16, r16
    9dae:	11 1f       	adc	r17, r17
    9db0:	22 1f       	adc	r18, r18
    9db2:	33 1f       	adc	r19, r19
    9db4:	9a 95       	dec	r25
    9db6:	d1 f7       	brne	.-12     	; 0x9dac <Crypto1PRNG+0xe6>
    9db8:	40 2b       	or	r20, r16
    9dba:	51 2b       	or	r21, r17
    9dbc:	62 2b       	or	r22, r18
    9dbe:	73 2b       	or	r23, r19

        /* Now 32 bits are fed back */
        ClockCount -= 32;
    9dc0:	80 52       	subi	r24, 0x20	; 32
    9dc2:	89 cf       	rjmp	.-238    	; 0x9cd6 <Crypto1PRNG+0x10>
    }

    /* Store back state */
    State[0] = (uint8_t)(Temp >> 0);
    9dc4:	40 83       	st	Z, r20
    State[1] = (uint8_t)(Temp >> 8);
    9dc6:	51 83       	std	Z+1, r21	; 0x01
    State[2] = (uint8_t)(Temp >> 16);
    9dc8:	02 83       	std	Z+2, r16	; 0x02
    State[3] = (uint8_t)(Temp >> 24);
    9dca:	73 83       	std	Z+3, r23	; 0x03
}
    9dcc:	1f 91       	pop	r17
    9dce:	0f 91       	pop	r16
    9dd0:	08 95       	ret

00009dd2 <addParityBits>:
};

static CardType CardCandidates[ARRAY_COUNT(CardIdentificationList)];
static uint8_t CardCandidatesIdx = 0;

uint16_t addParityBits(uint8_t *Buffer, uint16_t BitCount) {
    9dd2:	af 92       	push	r10
    9dd4:	bf 92       	push	r11
    9dd6:	cf 92       	push	r12
    9dd8:	df 92       	push	r13
    9dda:	ef 92       	push	r14
    9ddc:	ff 92       	push	r15
    9dde:	0f 93       	push	r16
    9de0:	1f 93       	push	r17
    9de2:	cf 93       	push	r28
    9de4:	df 93       	push	r29
    if (BitCount == 7)
    9de6:	67 30       	cpi	r22, 0x07	; 7
    9de8:	71 05       	cpc	r23, r1
    9dea:	09 f4       	brne	.+2      	; 0x9dee <addParityBits+0x1c>
    9dec:	51 c0       	rjmp	.+162    	; 0x9e90 <addParityBits+0xbe>
        return 7;
    if (BitCount % 8)
    9dee:	9b 01       	movw	r18, r22
    9df0:	27 70       	andi	r18, 0x07	; 7
    9df2:	33 27       	eor	r19, r19
    9df4:	23 2b       	or	r18, r19
    9df6:	09 f0       	breq	.+2      	; 0x9dfa <addParityBits+0x28>
    9df8:	4e c0       	rjmp	.+156    	; 0x9e96 <addParityBits+0xc4>
    9dfa:	5b 01       	movw	r10, r22
    9dfc:	6c 01       	movw	r12, r24
        return BitCount;
    uint8_t *currByte, * tmpByte;
    uint8_t *const lastByte = Buffer + BitCount / 8 + BitCount / 64; // starting address + number of bytes + number of parity bytes
    9dfe:	eb 01       	movw	r28, r22
    9e00:	83 e0       	ldi	r24, 0x03	; 3
    9e02:	d6 95       	lsr	r29
    9e04:	c7 95       	ror	r28
    9e06:	8a 95       	dec	r24
    9e08:	e1 f7       	brne	.-8      	; 0x9e02 <addParityBits+0x30>
    9e0a:	7b 01       	movw	r14, r22
    9e0c:	96 e0       	ldi	r25, 0x06	; 6
    9e0e:	f6 94       	lsr	r15
    9e10:	e7 94       	ror	r14
    9e12:	9a 95       	dec	r25
    9e14:	e1 f7       	brne	.-8      	; 0x9e0e <addParityBits+0x3c>
    9e16:	ec 0e       	add	r14, r28
    9e18:	fd 1e       	adc	r15, r29
    9e1a:	ec 0c       	add	r14, r12
    9e1c:	fd 1c       	adc	r15, r13
    currByte = Buffer + BitCount / 8 - 1;
    9e1e:	8e 01       	movw	r16, r28
    9e20:	01 50       	subi	r16, 0x01	; 1
    9e22:	11 09       	sbc	r17, r1
    9e24:	0c 0d       	add	r16, r12
    9e26:	1d 1d       	adc	r17, r13
    uint8_t parity;
    memset(currByte + 1, 0, lastByte - currByte); // zeroize all bytes used for parity bits
    9e28:	a7 01       	movw	r20, r14
    9e2a:	40 1b       	sub	r20, r16
    9e2c:	51 0b       	sbc	r21, r17
    9e2e:	60 e0       	ldi	r22, 0x00	; 0
    9e30:	70 e0       	ldi	r23, 0x00	; 0
    9e32:	c8 01       	movw	r24, r16
    9e34:	01 96       	adiw	r24, 0x01	; 1
    9e36:	0e 94 ba 78 	call	0xf174	; 0xf174 <memset>
    while (currByte >= Buffer) { // loop over all input bytes
    9e3a:	0c 15       	cp	r16, r12
    9e3c:	1d 05       	cpc	r17, r13
    9e3e:	20 f1       	brcs	.+72     	; 0x9e88 <addParityBits+0xb6>
}

INLINE uint8_t OddParityBit(uint8_t Byte) {
    extern const uint8_t PROGMEM OddParityByteTable[];

    return pgm_read_byte(&OddParityByteTable[Byte]);
    9e40:	d8 01       	movw	r26, r16
    9e42:	ec 91       	ld	r30, X
    9e44:	f0 e0       	ldi	r31, 0x00	; 0
    9e46:	ea 50       	subi	r30, 0x0A	; 10
    9e48:	f9 4f       	sbci	r31, 0xF9	; 249
    9e4a:	24 91       	lpm	r18, Z
    9e4c:	d7 01       	movw	r26, r14
    9e4e:	cd 01       	movw	r24, r26
        parity = OddParityBit(*currByte); // get parity bit
        tmpByte = lastByte;
        while (tmpByte > currByte) { // loop over all bytes from the last byte to the current one -- shifts the whole byte string
    9e50:	0a 17       	cp	r16, r26
    9e52:	1b 07       	cpc	r17, r27
    9e54:	68 f4       	brcc	.+26     	; 0x9e70 <addParityBits+0x9e>
            *tmpByte <<= 1; // shift this byte
            *tmpByte |= (*(tmpByte - 1) & 0x80) >> 7; // insert the last bit from the previous byte
    9e56:	fc 01       	movw	r30, r24
    9e58:	80 81       	ld	r24, Z
    9e5a:	98 2f       	mov	r25, r24
    9e5c:	99 0f       	add	r25, r25
    9e5e:	8e 91       	ld	r24, -X
    9e60:	88 1f       	adc	r24, r24
    9e62:	88 27       	eor	r24, r24
    9e64:	88 1f       	adc	r24, r24
    9e66:	89 2b       	or	r24, r25
    9e68:	11 96       	adiw	r26, 0x01	; 1
    9e6a:	8c 93       	st	X, r24
    9e6c:	11 97       	sbiw	r26, 0x01	; 1
    9e6e:	ef cf       	rjmp	.-34     	; 0x9e4e <addParityBits+0x7c>
            tmpByte--; // go to the previous byte
        }
        *(++tmpByte) &= 0xFE; // zeroize the bit, where we want to put the parity bit
        *tmpByte |= parity & 1; // add the parity bit
    9e70:	11 96       	adiw	r26, 0x01	; 1
    9e72:	8c 91       	ld	r24, X
    9e74:	11 97       	sbiw	r26, 0x01	; 1
    9e76:	8e 7f       	andi	r24, 0xFE	; 254
    9e78:	e2 2f       	mov	r30, r18
    9e7a:	e1 70       	andi	r30, 0x01	; 1
    9e7c:	e8 2b       	or	r30, r24
    9e7e:	11 96       	adiw	r26, 0x01	; 1
    9e80:	ec 93       	st	X, r30
        currByte--; // go to previous input byte
    9e82:	01 50       	subi	r16, 0x01	; 1
    9e84:	11 09       	sbc	r17, r1
    9e86:	d9 cf       	rjmp	.-78     	; 0x9e3a <addParityBits+0x68>
    }
    return BitCount + (BitCount / 8);
    9e88:	c5 01       	movw	r24, r10
    9e8a:	8c 0f       	add	r24, r28
    9e8c:	9d 1f       	adc	r25, r29
    9e8e:	04 c0       	rjmp	.+8      	; 0x9e98 <addParityBits+0xc6>
static CardType CardCandidates[ARRAY_COUNT(CardIdentificationList)];
static uint8_t CardCandidatesIdx = 0;

uint16_t addParityBits(uint8_t *Buffer, uint16_t BitCount) {
    if (BitCount == 7)
        return 7;
    9e90:	87 e0       	ldi	r24, 0x07	; 7
    9e92:	90 e0       	ldi	r25, 0x00	; 0
    9e94:	01 c0       	rjmp	.+2      	; 0x9e98 <addParityBits+0xc6>
    9e96:	cb 01       	movw	r24, r22
        *(++tmpByte) &= 0xFE; // zeroize the bit, where we want to put the parity bit
        *tmpByte |= parity & 1; // add the parity bit
        currByte--; // go to previous input byte
    }
    return BitCount + (BitCount / 8);
}
    9e98:	df 91       	pop	r29
    9e9a:	cf 91       	pop	r28
    9e9c:	1f 91       	pop	r17
    9e9e:	0f 91       	pop	r16
    9ea0:	ff 90       	pop	r15
    9ea2:	ef 90       	pop	r14
    9ea4:	df 90       	pop	r13
    9ea6:	cf 90       	pop	r12
    9ea8:	bf 90       	pop	r11
    9eaa:	af 90       	pop	r10
    9eac:	08 95       	ret

00009eae <Reader14443A_Deselect>:

void Reader14443AAppTick(void) {

}

static uint16_t Reader14443A_Deselect(uint8_t *Buffer) { // deselects the card because of an error, so we will continue to select the card afterwards
    9eae:	cf 93       	push	r28
    9eb0:	df 93       	push	r29
    9eb2:	ec 01       	movw	r28, r24
    Buffer[0] = 0xC2;
    9eb4:	82 ec       	ldi	r24, 0xC2	; 194
    9eb6:	88 83       	st	Y, r24
    ISO14443AAppendCRCA(Buffer, 1);
    9eb8:	61 e0       	ldi	r22, 0x01	; 1
    9eba:	70 e0       	ldi	r23, 0x00	; 0
    9ebc:	ce 01       	movw	r24, r28
    9ebe:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
    ReaderState = STATE_DESELECT;
    9ec2:	8a e0       	ldi	r24, 0x0A	; 10
    9ec4:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <ReaderState>
    Selected = false;
    9ec8:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
    return addParityBits(Buffer, 24);
    9ecc:	68 e1       	ldi	r22, 0x18	; 24
    9ece:	70 e0       	ldi	r23, 0x00	; 0
    9ed0:	ce 01       	movw	r24, r28
}
    9ed2:	df 91       	pop	r29
    9ed4:	cf 91       	pop	r28
static uint16_t Reader14443A_Deselect(uint8_t *Buffer) { // deselects the card because of an error, so we will continue to select the card afterwards
    Buffer[0] = 0xC2;
    ISO14443AAppendCRCA(Buffer, 1);
    ReaderState = STATE_DESELECT;
    Selected = false;
    return addParityBits(Buffer, 24);
    9ed6:	7d cf       	rjmp	.-262    	; 0x9dd2 <addParityBits>

00009ed8 <removeParityBits>:
        currByte--; // go to previous input byte
    }
    return BitCount + (BitCount / 8);
}

uint16_t removeParityBits(uint8_t *Buffer, uint16_t BitCount) {
    9ed8:	ef 92       	push	r14
    9eda:	ff 92       	push	r15
    9edc:	0f 93       	push	r16
    9ede:	1f 93       	push	r17
    9ee0:	cf 93       	push	r28
    9ee2:	df 93       	push	r29
    9ee4:	ec 01       	movw	r28, r24
    9ee6:	cb 01       	movw	r24, r22
    // Short frame, no parity bit is added
    if (BitCount == 7)
    9ee8:	67 30       	cpi	r22, 0x07	; 7
    9eea:	71 05       	cpc	r23, r1
    9eec:	e1 f1       	breq	.+120    	; 0x9f66 <removeParityBits+0x8e>
        return 7;

    uint16_t i;
    for (i = 0; i < (BitCount / 9); i++) {
    9eee:	69 e0       	ldi	r22, 0x09	; 9
    9ef0:	70 e0       	ldi	r23, 0x00	; 0
    9ef2:	0e 94 ea 77 	call	0xefd4	; 0xefd4 <__udivmodhi4>
    9ef6:	de 01       	movw	r26, r28
    9ef8:	80 e0       	ldi	r24, 0x00	; 0
    9efa:	90 e0       	ldi	r25, 0x00	; 0
        Buffer[i] = (Buffer[i + i / 8] >> (i % 8));
        if (i % 8)
            Buffer[i] |= (Buffer[i + i / 8 + 1] << (8 - (i % 8)));
    9efc:	08 e0       	ldi	r16, 0x08	; 8
    9efe:	10 e0       	ldi	r17, 0x00	; 0
    // Short frame, no parity bit is added
    if (BitCount == 7)
        return 7;

    uint16_t i;
    for (i = 0; i < (BitCount / 9); i++) {
    9f00:	86 17       	cp	r24, r22
    9f02:	97 07       	cpc	r25, r23
    9f04:	51 f1       	breq	.+84     	; 0x9f5a <removeParityBits+0x82>
        Buffer[i] = (Buffer[i + i / 8] >> (i % 8));
    9f06:	fc 01       	movw	r30, r24
    9f08:	33 e0       	ldi	r19, 0x03	; 3
    9f0a:	f6 95       	lsr	r31
    9f0c:	e7 95       	ror	r30
    9f0e:	3a 95       	dec	r19
    9f10:	e1 f7       	brne	.-8      	; 0x9f0a <removeParityBits+0x32>
    9f12:	e8 0f       	add	r30, r24
    9f14:	f9 1f       	adc	r31, r25
    9f16:	ac 01       	movw	r20, r24
    9f18:	47 70       	andi	r20, 0x07	; 7
    9f1a:	55 27       	eor	r21, r21
    9f1c:	ec 0f       	add	r30, r28
    9f1e:	fd 1f       	adc	r31, r29
    9f20:	20 81       	ld	r18, Z
    9f22:	30 e0       	ldi	r19, 0x00	; 0
    9f24:	04 2e       	mov	r0, r20
    9f26:	02 c0       	rjmp	.+4      	; 0x9f2c <removeParityBits+0x54>
    9f28:	35 95       	asr	r19
    9f2a:	27 95       	ror	r18
    9f2c:	0a 94       	dec	r0
    9f2e:	e2 f7       	brpl	.-8      	; 0x9f28 <removeParityBits+0x50>
    9f30:	2c 93       	st	X, r18
        if (i % 8)
    9f32:	41 15       	cp	r20, r1
    9f34:	51 05       	cpc	r21, r1
    9f36:	71 f0       	breq	.+28     	; 0x9f54 <removeParityBits+0x7c>
            Buffer[i] |= (Buffer[i + i / 8 + 1] << (8 - (i % 8)));
    9f38:	e1 81       	ldd	r30, Z+1	; 0x01
    9f3a:	f0 e0       	ldi	r31, 0x00	; 0
    9f3c:	78 01       	movw	r14, r16
    9f3e:	e4 1a       	sub	r14, r20
    9f40:	f5 0a       	sbc	r15, r21
    9f42:	a7 01       	movw	r20, r14
    9f44:	7f 01       	movw	r14, r30
    9f46:	02 c0       	rjmp	.+4      	; 0x9f4c <removeParityBits+0x74>
    9f48:	ee 0c       	add	r14, r14
    9f4a:	ff 1c       	adc	r15, r15
    9f4c:	4a 95       	dec	r20
    9f4e:	e2 f7       	brpl	.-8      	; 0x9f48 <removeParityBits+0x70>
    9f50:	2e 29       	or	r18, r14
    9f52:	2c 93       	st	X, r18
    // Short frame, no parity bit is added
    if (BitCount == 7)
        return 7;

    uint16_t i;
    for (i = 0; i < (BitCount / 9); i++) {
    9f54:	01 96       	adiw	r24, 0x01	; 1
    9f56:	11 96       	adiw	r26, 0x01	; 1
    9f58:	d3 cf       	rjmp	.-90     	; 0x9f00 <removeParityBits+0x28>
        Buffer[i] = (Buffer[i + i / 8] >> (i % 8));
        if (i % 8)
            Buffer[i] |= (Buffer[i + i / 8 + 1] << (8 - (i % 8)));
    }
    return BitCount / 9 * 8;
    9f5a:	23 e0       	ldi	r18, 0x03	; 3
    9f5c:	88 0f       	add	r24, r24
    9f5e:	99 1f       	adc	r25, r25
    9f60:	2a 95       	dec	r18
    9f62:	e1 f7       	brne	.-8      	; 0x9f5c <removeParityBits+0x84>
    9f64:	02 c0       	rjmp	.+4      	; 0x9f6a <removeParityBits+0x92>
}

uint16_t removeParityBits(uint8_t *Buffer, uint16_t BitCount) {
    // Short frame, no parity bit is added
    if (BitCount == 7)
        return 7;
    9f66:	87 e0       	ldi	r24, 0x07	; 7
    9f68:	90 e0       	ldi	r25, 0x00	; 0
        Buffer[i] = (Buffer[i + i / 8] >> (i % 8));
        if (i % 8)
            Buffer[i] |= (Buffer[i + i / 8 + 1] << (8 - (i % 8)));
    }
    return BitCount / 9 * 8;
}
    9f6a:	df 91       	pop	r29
    9f6c:	cf 91       	pop	r28
    9f6e:	1f 91       	pop	r17
    9f70:	0f 91       	pop	r16
    9f72:	ff 90       	pop	r15
    9f74:	ef 90       	pop	r14
    9f76:	08 95       	ret

00009f78 <checkParityBits>:

bool checkParityBits(uint8_t *Buffer, uint16_t BitCount) {
    9f78:	ef 92       	push	r14
    9f7a:	ff 92       	push	r15
    9f7c:	0f 93       	push	r16
    9f7e:	1f 93       	push	r17
    9f80:	cf 93       	push	r28
    9f82:	df 93       	push	r29
    9f84:	9c 01       	movw	r18, r24
    9f86:	cb 01       	movw	r24, r22
    if (BitCount == 7)
    9f88:	67 30       	cpi	r22, 0x07	; 7
    9f8a:	71 05       	cpc	r23, r1
    9f8c:	09 f4       	brne	.+2      	; 0x9f90 <checkParityBits+0x18>
    9f8e:	40 c0       	rjmp	.+128    	; 0xa010 <checkParityBits+0x98>
    //if (BitCount % 9 || BitCount == 0)
    //	return false;

    uint16_t i;
    uint8_t currentByte, parity;
    for (i = 0; i < (BitCount / 9); i++) {
    9f90:	69 e0       	ldi	r22, 0x09	; 9
    9f92:	70 e0       	ldi	r23, 0x00	; 0
    9f94:	0e 94 ea 77 	call	0xefd4	; 0xefd4 <__udivmodhi4>
    9f98:	80 e0       	ldi	r24, 0x00	; 0
    9f9a:	90 e0       	ldi	r25, 0x00	; 0
        currentByte = (Buffer[i + i / 8] >> (i % 8));
        if (i % 8)
            currentByte |= (Buffer[i + i / 8 + 1] << (8 - (i % 8)));
    9f9c:	48 e0       	ldi	r20, 0x08	; 8
    9f9e:	50 e0       	ldi	r21, 0x00	; 0
    //if (BitCount % 9 || BitCount == 0)
    //	return false;

    uint16_t i;
    uint8_t currentByte, parity;
    for (i = 0; i < (BitCount / 9); i++) {
    9fa0:	86 17       	cp	r24, r22
    9fa2:	97 07       	cpc	r25, r23
    9fa4:	a9 f1       	breq	.+106    	; 0xa010 <checkParityBits+0x98>
        currentByte = (Buffer[i + i / 8] >> (i % 8));
    9fa6:	dc 01       	movw	r26, r24
    9fa8:	e3 e0       	ldi	r30, 0x03	; 3
    9faa:	b6 95       	lsr	r27
    9fac:	a7 95       	ror	r26
    9fae:	ea 95       	dec	r30
    9fb0:	e1 f7       	brne	.-8      	; 0x9faa <checkParityBits+0x32>
    9fb2:	a8 0f       	add	r26, r24
    9fb4:	b9 1f       	adc	r27, r25
    9fb6:	ec 01       	movw	r28, r24
    9fb8:	c7 70       	andi	r28, 0x07	; 7
    9fba:	dd 27       	eor	r29, r29
    9fbc:	a2 0f       	add	r26, r18
    9fbe:	b3 1f       	adc	r27, r19
    9fc0:	ec 91       	ld	r30, X
    9fc2:	f0 e0       	ldi	r31, 0x00	; 0
    9fc4:	0c 2e       	mov	r0, r28
    9fc6:	02 c0       	rjmp	.+4      	; 0x9fcc <checkParityBits+0x54>
    9fc8:	f5 95       	asr	r31
    9fca:	e7 95       	ror	r30
    9fcc:	0a 94       	dec	r0
    9fce:	e2 f7       	brpl	.-8      	; 0x9fc8 <checkParityBits+0x50>
        if (i % 8)
    9fd0:	20 97       	sbiw	r28, 0x00	; 0
    9fd2:	59 f0       	breq	.+22     	; 0x9fea <checkParityBits+0x72>
            currentByte |= (Buffer[i + i / 8 + 1] << (8 - (i % 8)));
    9fd4:	11 96       	adiw	r26, 0x01	; 1
    9fd6:	0c 91       	ld	r16, X
    9fd8:	11 97       	sbiw	r26, 0x01	; 1
    9fda:	7a 01       	movw	r14, r20
    9fdc:	ec 1a       	sub	r14, r28
    9fde:	fd 0a       	sbc	r15, r29
    9fe0:	01 c0       	rjmp	.+2      	; 0x9fe4 <checkParityBits+0x6c>
    9fe2:	00 0f       	add	r16, r16
    9fe4:	ea 94       	dec	r14
    9fe6:	ea f7       	brpl	.-6      	; 0x9fe2 <checkParityBits+0x6a>
    9fe8:	e0 2b       	or	r30, r16
    9fea:	f0 e0       	ldi	r31, 0x00	; 0
    9fec:	ea 50       	subi	r30, 0x0A	; 10
    9fee:	f9 4f       	sbci	r31, 0xF9	; 249
    9ff0:	e4 91       	lpm	r30, Z
        parity = OddParityBit(currentByte);
        if (((Buffer[i + i / 8 + 1] >> (i % 8)) ^ parity) & 1) {
    9ff2:	11 96       	adiw	r26, 0x01	; 1
    9ff4:	ac 91       	ld	r26, X
    9ff6:	b0 e0       	ldi	r27, 0x00	; 0
    9ff8:	02 c0       	rjmp	.+4      	; 0x9ffe <checkParityBits+0x86>
    9ffa:	b5 95       	asr	r27
    9ffc:	a7 95       	ror	r26
    9ffe:	ca 95       	dec	r28
    a000:	e2 f7       	brpl	.-8      	; 0x9ffa <checkParityBits+0x82>
    a002:	ed 01       	movw	r28, r26
    a004:	ce 27       	eor	r28, r30
    a006:	fe 01       	movw	r30, r28
    a008:	e0 fd       	sbrc	r30, 0
    a00a:	04 c0       	rjmp	.+8      	; 0xa014 <checkParityBits+0x9c>
    //if (BitCount % 9 || BitCount == 0)
    //	return false;

    uint16_t i;
    uint8_t currentByte, parity;
    for (i = 0; i < (BitCount / 9); i++) {
    a00c:	01 96       	adiw	r24, 0x01	; 1
    a00e:	c8 cf       	rjmp	.-112    	; 0x9fa0 <checkParityBits+0x28>
    return BitCount / 9 * 8;
}

bool checkParityBits(uint8_t *Buffer, uint16_t BitCount) {
    if (BitCount == 7)
        return true;
    a010:	81 e0       	ldi	r24, 0x01	; 1
    a012:	01 c0       	rjmp	.+2      	; 0xa016 <checkParityBits+0x9e>
        currentByte = (Buffer[i + i / 8] >> (i % 8));
        if (i % 8)
            currentByte |= (Buffer[i + i / 8 + 1] << (8 - (i % 8)));
        parity = OddParityBit(currentByte);
        if (((Buffer[i + i / 8 + 1] >> (i % 8)) ^ parity) & 1) {
            return false;
    a014:	80 e0       	ldi	r24, 0x00	; 0
        }
    }
    return true;
}
    a016:	df 91       	pop	r29
    a018:	cf 91       	pop	r28
    a01a:	1f 91       	pop	r17
    a01c:	0f 91       	pop	r16
    a01e:	ff 90       	pop	r15
    a020:	ef 90       	pop	r14
    a022:	08 95       	ret

0000a024 <Reader14443AAppInit>:
    Reader14443ACodecReset();
    ReaderState = STATE_IDLE;
}

void Reader14443AAppInit(void) {
    ReaderState = STATE_IDLE;
    a024:	10 92 f6 2d 	sts	0x2DF6, r1	; 0x802df6 <ReaderState>
    a028:	08 95       	ret

0000a02a <Reader14443AAppReset>:
}

void Reader14443AAppReset(void) {
    ReaderState = STATE_IDLE;
    a02a:	10 92 f6 2d 	sts	0x2DF6, r1	; 0x802df6 <ReaderState>
    Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a02e:	10 92 1c 2d 	sts	0x2D1C, r1	; 0x802d1c <Reader14443CurrentCommand>
    Selected = false;
    a032:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
    a036:	08 95       	ret

0000a038 <Reader14443AAppTimeout>:
    }
    return true;
}

void Reader14443AAppTimeout(void) {
    Reader14443AAppReset();
    a038:	f8 df       	rcall	.-16     	; 0xa02a <Reader14443AAppReset>
    Reader14443ACodecReset();
    a03a:	0e 94 32 2f 	call	0x5e64	; 0x5e64 <Reader14443ACodecReset>
    ReaderState = STATE_IDLE;
    a03e:	10 92 f6 2d 	sts	0x2DF6, r1	; 0x802df6 <ReaderState>
    a042:	08 95       	ret

0000a044 <Reader14443AAppTask>:
    a044:	08 95       	ret

0000a046 <Reader14443AAppTick>:

void Reader14443AAppTask(void) {

}

void Reader14443AAppTick(void) {
    a046:	08 95       	ret

0000a048 <ISO14443_CRCA>:
            return 0;
    }
    return 0;
}

uint16_t ISO14443_CRCA(uint8_t *Buffer, uint8_t ByteCount) {
    a048:	dc 01       	movw	r26, r24
    uint8_t *DataPtr = Buffer;
    uint16_t crc = 0x6363;
    a04a:	23 e6       	ldi	r18, 0x63	; 99
    a04c:	33 e6       	ldi	r19, 0x63	; 99
    uint8_t ch;
    while (ByteCount--) {
    a04e:	61 50       	subi	r22, 0x01	; 1
    a050:	e8 f0       	brcs	.+58     	; 0xa08c <ISO14443_CRCA+0x44>
        ch = *DataPtr++ ^ crc;
    a052:	4d 91       	ld	r20, X+
    a054:	94 2f       	mov	r25, r20
    a056:	92 27       	eor	r25, r18
        ch = ch ^ (ch << 4);
    a058:	80 e1       	ldi	r24, 0x10	; 16
    a05a:	98 9f       	mul	r25, r24
    a05c:	a0 01       	movw	r20, r0
    a05e:	11 24       	eor	r1, r1
    a060:	49 27       	eor	r20, r25
        crc = (crc >> 8) ^ (ch << 8) ^ (ch << 3) ^ (ch >> 4);
    a062:	e4 2f       	mov	r30, r20
    a064:	f0 e0       	ldi	r31, 0x00	; 0
    a066:	23 2f       	mov	r18, r19
    a068:	33 27       	eor	r19, r19
    a06a:	42 95       	swap	r20
    a06c:	4f 70       	andi	r20, 0x0F	; 15
    a06e:	c9 01       	movw	r24, r18
    a070:	84 27       	eor	r24, r20
    a072:	ac 01       	movw	r20, r24
    a074:	3e 2f       	mov	r19, r30
    a076:	22 27       	eor	r18, r18
    a078:	24 27       	eor	r18, r20
    a07a:	35 27       	eor	r19, r21
    a07c:	43 e0       	ldi	r20, 0x03	; 3
    a07e:	ee 0f       	add	r30, r30
    a080:	ff 1f       	adc	r31, r31
    a082:	4a 95       	dec	r20
    a084:	e1 f7       	brne	.-8      	; 0xa07e <ISO14443_CRCA+0x36>
    a086:	2e 27       	eor	r18, r30
    a088:	3f 27       	eor	r19, r31
    a08a:	e1 cf       	rjmp	.-62     	; 0xa04e <ISO14443_CRCA+0x6>
    }
    return crc;
}
    a08c:	c9 01       	movw	r24, r18
    a08e:	08 95       	ret

0000a090 <Reader14443A_Select>:
    ReaderState = STATE_DESELECT;
    Selected = false;
    return addParityBits(Buffer, 24);
}

static uint16_t Reader14443A_Select(uint8_t *Buffer, uint16_t BitCount) {
    a090:	ef 92       	push	r14
    a092:	ff 92       	push	r15
    a094:	1f 93       	push	r17
    a096:	cf 93       	push	r28
    a098:	df 93       	push	r29
    a09a:	ec 01       	movw	r28, r24
    a09c:	7b 01       	movw	r14, r22
    if (Selected) {
    a09e:	80 91 f7 2d 	lds	r24, 0x2DF7	; 0x802df7 <Selected>
    a0a2:	88 23       	and	r24, r24
    a0a4:	39 f0       	breq	.+14     	; 0xa0b4 <Reader14443A_Select+0x24>
        if (ReaderState > STATE_HALT)
    a0a6:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <ReaderState>
    a0aa:	82 30       	cpi	r24, 0x02	; 2
    a0ac:	08 f0       	brcs	.+2      	; 0xa0b0 <Reader14443A_Select+0x20>
    a0ae:	db c0       	rjmp	.+438    	; 0xa266 <Reader14443A_Select+0x1d6>
            return 0;
        else
            Selected = false;
    a0b0:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
    }

    // general frame handling:
    uint8_t flags = 0;
    if (BitCount > 0 && checkParityBits(Buffer, BitCount)) {
    a0b4:	e1 14       	cp	r14, r1
    a0b6:	f1 04       	cpc	r15, r1
    a0b8:	61 f0       	breq	.+24     	; 0xa0d2 <Reader14443A_Select+0x42>
    a0ba:	b7 01       	movw	r22, r14
    a0bc:	ce 01       	movw	r24, r28
    a0be:	5c df       	rcall	.-328    	; 0x9f78 <checkParityBits>
    a0c0:	88 23       	and	r24, r24
    a0c2:	09 f4       	brne	.+2      	; 0xa0c6 <Reader14443A_Select+0x36>
    a0c4:	d3 c0       	rjmp	.+422    	; 0xa26c <Reader14443A_Select+0x1dc>
        flags |= FLAGS_PARITY_OK;
        BitCount = removeParityBits(Buffer, BitCount);
    a0c6:	b7 01       	movw	r22, r14
    a0c8:	ce 01       	movw	r24, r28
    a0ca:	06 df       	rcall	.-500    	; 0x9ed8 <removeParityBits>
    a0cc:	7c 01       	movw	r14, r24
    }

    // general frame handling:
    uint8_t flags = 0;
    if (BitCount > 0 && checkParityBits(Buffer, BitCount)) {
        flags |= FLAGS_PARITY_OK;
    a0ce:	81 e0       	ldi	r24, 0x01	; 1
        BitCount = removeParityBits(Buffer, BitCount);
    a0d0:	01 c0       	rjmp	.+2      	; 0xa0d4 <Reader14443A_Select+0x44>
    } else if (BitCount == 0) {
        flags |= FLAGS_NO_DATA;
    a0d2:	82 e0       	ldi	r24, 0x02	; 2
    } else { // checkParityBits returned false
        LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (BitCount + 7) / 8);
    }


    switch (ReaderState) {
    a0d4:	10 91 f6 2d 	lds	r17, 0x2DF6	; 0x802df6 <ReaderState>
    a0d8:	16 30       	cpi	r17, 0x06	; 6
    a0da:	90 f4       	brcc	.+36     	; 0xa100 <Reader14443A_Select+0x70>
    a0dc:	13 30       	cpi	r17, 0x03	; 3
    a0de:	70 f5       	brcc	.+92     	; 0xa13c <Reader14443A_Select+0xac>
    a0e0:	12 30       	cpi	r17, 0x02	; 2
    a0e2:	a8 f4       	brcc	.+42     	; 0xa10e <Reader14443A_Select+0x7e>
        case STATE_IDLE:
        case STATE_HALT:
            Reader_FWT = 4;
    a0e4:	84 e0       	ldi	r24, 0x04	; 4
    a0e6:	90 e0       	ldi	r25, 0x00	; 0
    a0e8:	80 93 1e 20 	sts	0x201E, r24	; 0x80201e <Reader_FWT>
    a0ec:	90 93 1f 20 	sts	0x201F, r25	; 0x80201f <Reader_FWT+0x1>
            /* Send a REQA */
            Buffer[0] = ISO14443A_CMD_WUPA; // whenever REQA works, WUPA also works, so we choose WUPA always
    a0f0:	82 e5       	ldi	r24, 0x52	; 82
    a0f2:	88 83       	st	Y, r24
            ReaderState = STATE_READY;
    a0f4:	82 e0       	ldi	r24, 0x02	; 2
    a0f6:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <ReaderState>
            return 7;
    a0fa:	87 e0       	ldi	r24, 0x07	; 7
    a0fc:	90 e0       	ldi	r25, 0x00	; 0
    a0fe:	c7 c0       	rjmp	.+398    	; 0xa28e <Reader14443A_Select+0x1fe>
    } else { // checkParityBits returned false
        LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (BitCount + 7) / 8);
    }


    switch (ReaderState) {
    a100:	19 30       	cpi	r17, 0x09	; 9
    a102:	08 f4       	brcc	.+2      	; 0xa106 <Reader14443A_Select+0x76>
    a104:	67 c0       	rjmp	.+206    	; 0xa1d4 <Reader14443A_Select+0x144>
    a106:	1a 30       	cpi	r17, 0x0A	; 10
    a108:	09 f4       	brne	.+2      	; 0xa10c <Reader14443A_Select+0x7c>
    a10a:	96 c0       	rjmp	.+300    	; 0xa238 <Reader14443A_Select+0x1a8>
    a10c:	ac c0       	rjmp	.+344    	; 0xa266 <Reader14443A_Select+0x1d6>
            Buffer[0] = ISO14443A_CMD_WUPA; // whenever REQA works, WUPA also works, so we choose WUPA always
            ReaderState = STATE_READY;
            return 7;

        case STATE_READY:
            if (BitCount != 16 || (flags & FLAGS_PARITY_OK) == 0) {
    a10e:	90 e1       	ldi	r25, 0x10	; 16
    a110:	e9 16       	cp	r14, r25
    a112:	f1 04       	cpc	r15, r1
    a114:	11 f4       	brne	.+4      	; 0xa11a <Reader14443A_Select+0x8a>
    a116:	80 fd       	sbrc	r24, 0
    a118:	03 c0       	rjmp	.+6      	; 0xa120 <Reader14443A_Select+0x90>
                ReaderState = STATE_IDLE;
    a11a:	10 92 f6 2d 	sts	0x2DF6, r1	; 0x802df6 <ReaderState>
    a11e:	92 c0       	rjmp	.+292    	; 0xa244 <Reader14443A_Select+0x1b4>
    a120:	88 81       	ld	r24, Y
    a122:	99 81       	ldd	r25, Y+1	; 0x01
                Reader14443ACodecStart();
                return 0;
            }
            CardCharacteristics.ATQA = Buffer[1] << 8 | Buffer[0]; // save ATQA for possible later use
    a124:	80 93 e8 2d 	sts	0x2DE8, r24	; 0x802de8 <CardCharacteristics>
    a128:	90 93 e9 2d 	sts	0x2DE9, r25	; 0x802de9 <CardCharacteristics+0x1>
            Buffer[0] = ISO14443A_CMD_SELECT_CL1;
    a12c:	83 e9       	ldi	r24, 0x93	; 147
    a12e:	88 83       	st	Y, r24
            Buffer[1] = 0x20; // NVB = 16
    a130:	80 e2       	ldi	r24, 0x20	; 32
    a132:	89 83       	std	Y+1, r24	; 0x01
            ReaderState = STATE_ACTIVE_CL1;
    a134:	83 e0       	ldi	r24, 0x03	; 3
    a136:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <ReaderState>
    a13a:	6a c0       	rjmp	.+212    	; 0xa210 <Reader14443A_Select+0x180>
            return addParityBits(Buffer, 2 * BITS_PER_BYTE);

        case STATE_ACTIVE_CL1 ... STATE_ACTIVE_CL3:
            if ((flags & FLAGS_PARITY_OK) == 0 || BitCount < (5 * BITS_PER_BYTE) || !CHECK_BCC(Buffer)) {
    a13c:	80 ff       	sbrs	r24, 0
    a13e:	ed cf       	rjmp	.-38     	; 0xa11a <Reader14443A_Select+0x8a>
    a140:	88 e2       	ldi	r24, 0x28	; 40
    a142:	e8 16       	cp	r14, r24
    a144:	f1 04       	cpc	r15, r1
    a146:	48 f3       	brcs	.-46     	; 0xa11a <Reader14443A_Select+0x8a>
    a148:	28 81       	ld	r18, Y
    a14a:	89 81       	ldd	r24, Y+1	; 0x01
    a14c:	82 27       	eor	r24, r18
    a14e:	9a 81       	ldd	r25, Y+2	; 0x02
    a150:	89 27       	eor	r24, r25
    a152:	9b 81       	ldd	r25, Y+3	; 0x03
    a154:	89 27       	eor	r24, r25
    a156:	9c 81       	ldd	r25, Y+4	; 0x04
    a158:	89 13       	cpse	r24, r25
    a15a:	df cf       	rjmp	.-66     	; 0xa11a <Reader14443A_Select+0x8a>
    a15c:	a1 2f       	mov	r26, r17
    a15e:	b0 e0       	ldi	r27, 0x00	; 0
                Reader14443ACodecStart();
                return 0;
            }

            if (Buffer[0] == ISO14443A_UID0_CT) {
                memcpy(CardCharacteristics.UID + (ReaderState - STATE_ACTIVE_CL1) * 3, Buffer + 1, 3);
    a160:	13 97       	sbiw	r26, 0x03	; 3
    a162:	cd 01       	movw	r24, r26
    a164:	88 0f       	add	r24, r24
    a166:	99 1f       	adc	r25, r25
    a168:	a8 0f       	add	r26, r24
    a16a:	b9 1f       	adc	r27, r25
    a16c:	a5 51       	subi	r26, 0x15	; 21
    a16e:	b2 4d       	sbci	r27, 0xD2	; 210
                ReaderState = STATE_IDLE;
                Reader14443ACodecStart();
                return 0;
            }

            if (Buffer[0] == ISO14443A_UID0_CT) {
    a170:	28 38       	cpi	r18, 0x88	; 136
    a172:	21 f4       	brne	.+8      	; 0xa17c <Reader14443A_Select+0xec>
                memcpy(CardCharacteristics.UID + (ReaderState - STATE_ACTIVE_CL1) * 3, Buffer + 1, 3);
    a174:	83 e0       	ldi	r24, 0x03	; 3
    a176:	fe 01       	movw	r30, r28
    a178:	31 96       	adiw	r30, 0x01	; 1
    a17a:	02 c0       	rjmp	.+4      	; 0xa180 <Reader14443A_Select+0xf0>
            } else {
                memcpy(CardCharacteristics.UID + (ReaderState - STATE_ACTIVE_CL1) * 3, Buffer, 4);
    a17c:	84 e0       	ldi	r24, 0x04	; 4
    a17e:	fe 01       	movw	r30, r28
    a180:	01 90       	ld	r0, Z+
    a182:	0d 92       	st	X+, r0
    a184:	8a 95       	dec	r24
    a186:	e1 f7       	brne	.-8      	; 0xa180 <Reader14443A_Select+0xf0>
            }
            // shift received UID two bytes to the right
            memmove(Buffer + 2, Buffer, 5);
    a188:	45 e0       	ldi	r20, 0x05	; 5
    a18a:	50 e0       	ldi	r21, 0x00	; 0
    a18c:	be 01       	movw	r22, r28
    a18e:	ce 01       	movw	r24, r28
    a190:	02 96       	adiw	r24, 0x02	; 2
    a192:	0e 94 a9 78 	call	0xf152	; 0xf152 <memmove>
            Buffer[0] = (ReaderState == STATE_ACTIVE_CL1) ? ISO14443A_CMD_SELECT_CL1 : (ReaderState == STATE_ACTIVE_CL2) ? ISO14443A_CMD_SELECT_CL2 : ISO14443A_CMD_SELECT_CL3;
    a196:	13 30       	cpi	r17, 0x03	; 3
    a198:	21 f0       	breq	.+8      	; 0xa1a2 <Reader14443A_Select+0x112>
    a19a:	14 30       	cpi	r17, 0x04	; 4
    a19c:	21 f4       	brne	.+8      	; 0xa1a6 <Reader14443A_Select+0x116>
    a19e:	85 e9       	ldi	r24, 0x95	; 149
    a1a0:	03 c0       	rjmp	.+6      	; 0xa1a8 <Reader14443A_Select+0x118>
    a1a2:	83 e9       	ldi	r24, 0x93	; 147
    a1a4:	01 c0       	rjmp	.+2      	; 0xa1a8 <Reader14443A_Select+0x118>
    a1a6:	87 e9       	ldi	r24, 0x97	; 151
    a1a8:	88 83       	st	Y, r24
            Buffer[1] = 0x70; // NVB = 56
    a1aa:	80 e7       	ldi	r24, 0x70	; 112
    a1ac:	89 83       	std	Y+1, r24	; 0x01
            ISO14443AAppendCRCA(Buffer, 7);
    a1ae:	67 e0       	ldi	r22, 0x07	; 7
    a1b0:	70 e0       	ldi	r23, 0x00	; 0
    a1b2:	ce 01       	movw	r24, r28
    a1b4:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
            ReaderState = ReaderState - STATE_ACTIVE_CL1 + STATE_SAK_CL1;
    a1b8:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <ReaderState>
    a1bc:	8d 5f       	subi	r24, 0xFD	; 253
    a1be:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <ReaderState>
            return addParityBits(Buffer, (7 + 2) * BITS_PER_BYTE);
    a1c2:	68 e4       	ldi	r22, 0x48	; 72
    a1c4:	70 e0       	ldi	r23, 0x00	; 0
    a1c6:	ce 01       	movw	r24, r28
            return 0;

        default:
            return 0;
    }
}
    a1c8:	df 91       	pop	r29
    a1ca:	cf 91       	pop	r28
    a1cc:	1f 91       	pop	r17
    a1ce:	ff 90       	pop	r15
            memmove(Buffer + 2, Buffer, 5);
            Buffer[0] = (ReaderState == STATE_ACTIVE_CL1) ? ISO14443A_CMD_SELECT_CL1 : (ReaderState == STATE_ACTIVE_CL2) ? ISO14443A_CMD_SELECT_CL2 : ISO14443A_CMD_SELECT_CL3;
            Buffer[1] = 0x70; // NVB = 56
            ISO14443AAppendCRCA(Buffer, 7);
            ReaderState = ReaderState - STATE_ACTIVE_CL1 + STATE_SAK_CL1;
            return addParityBits(Buffer, (7 + 2) * BITS_PER_BYTE);
    a1d0:	ef 90       	pop	r14
    a1d2:	ff cd       	rjmp	.-1026   	; 0x9dd2 <addParityBits>

        case STATE_SAK_CL1 ... STATE_SAK_CL3:
            if ((flags & FLAGS_PARITY_OK) == 0 || BitCount != (3 * BITS_PER_BYTE) || ISO14443_CRCA(Buffer, 3) != 0) {
    a1d4:	80 ff       	sbrs	r24, 0
    a1d6:	a1 cf       	rjmp	.-190    	; 0xa11a <Reader14443A_Select+0x8a>
    a1d8:	98 e1       	ldi	r25, 0x18	; 24
    a1da:	e9 16       	cp	r14, r25
    a1dc:	f1 04       	cpc	r15, r1
    a1de:	09 f0       	breq	.+2      	; 0xa1e2 <Reader14443A_Select+0x152>
    a1e0:	9c cf       	rjmp	.-200    	; 0xa11a <Reader14443A_Select+0x8a>
    a1e2:	63 e0       	ldi	r22, 0x03	; 3
    a1e4:	ce 01       	movw	r24, r28
    a1e6:	30 df       	rcall	.-416    	; 0xa048 <ISO14443_CRCA>
    a1e8:	00 97       	sbiw	r24, 0x00	; 0
    a1ea:	09 f0       	breq	.+2      	; 0xa1ee <Reader14443A_Select+0x15e>
    a1ec:	96 cf       	rjmp	.-212    	; 0xa11a <Reader14443A_Select+0x8a>
                ReaderState = STATE_IDLE;
                Reader14443ACodecStart();
                return 0;
            }

            if (IS_CASCADE_BIT_SET(Buffer) && ReaderState != STATE_SAK_CL3) {
    a1ee:	28 81       	ld	r18, Y
    a1f0:	22 ff       	sbrs	r18, 2
    a1f2:	11 c0       	rjmp	.+34     	; 0xa216 <Reader14443A_Select+0x186>
    a1f4:	18 30       	cpi	r17, 0x08	; 8
    a1f6:	79 f0       	breq	.+30     	; 0xa216 <Reader14443A_Select+0x186>
                Buffer[0] = (ReaderState == STATE_SAK_CL1) ? ISO14443A_CMD_SELECT_CL2 : ISO14443A_CMD_SELECT_CL3;
    a1f8:	16 30       	cpi	r17, 0x06	; 6
    a1fa:	11 f4       	brne	.+4      	; 0xa200 <Reader14443A_Select+0x170>
    a1fc:	85 e9       	ldi	r24, 0x95	; 149
    a1fe:	01 c0       	rjmp	.+2      	; 0xa202 <Reader14443A_Select+0x172>
    a200:	87 e9       	ldi	r24, 0x97	; 151
    a202:	88 83       	st	Y, r24
                Buffer[1] = 0x20; // NVB = 16 bit
    a204:	80 e2       	ldi	r24, 0x20	; 32
    a206:	89 83       	std	Y+1, r24	; 0x01
                ReaderState = ReaderState - STATE_SAK_CL1 + STATE_ACTIVE_CL1 + 1;
    a208:	2e ef       	ldi	r18, 0xFE	; 254
    a20a:	21 0f       	add	r18, r17
    a20c:	20 93 f6 2d 	sts	0x2DF6, r18	; 0x802df6 <ReaderState>
                return addParityBits(Buffer, 2 * BITS_PER_BYTE);
    a210:	60 e1       	ldi	r22, 0x10	; 16
    a212:	70 e0       	ldi	r23, 0x00	; 0
    a214:	d8 cf       	rjmp	.-80     	; 0xa1c6 <Reader14443A_Select+0x136>
            } else if (IS_CASCADE_BIT_SET(Buffer) && ReaderState == STATE_SAK_CL3) {
                // TODO handle this very strange hopefully not happening error
            }
            Selected = true;
    a216:	21 e0       	ldi	r18, 0x01	; 1
    a218:	20 93 f7 2d 	sts	0x2DF7, r18	; 0x802df7 <Selected>
            CardCharacteristics.UIDSize = (ReaderState - STATE_SAK_CL1) * 3 + 4;
    a21c:	21 2f       	mov	r18, r17
    a21e:	30 e0       	ldi	r19, 0x00	; 0
    a220:	26 50       	subi	r18, 0x06	; 6
    a222:	31 09       	sbc	r19, r1
    a224:	32 2f       	mov	r19, r18
    a226:	33 0f       	add	r19, r19
    a228:	23 0f       	add	r18, r19
    a22a:	2c 5f       	subi	r18, 0xFC	; 252
    a22c:	20 93 f5 2d 	sts	0x2DF5, r18	; 0x802df5 <CardCharacteristics+0xd>
            CardCharacteristics.SAK = Buffer[0]; // save last SAK for possible later use
    a230:	28 81       	ld	r18, Y
    a232:	20 93 ea 2d 	sts	0x2DEA, r18	; 0x802dea <CardCharacteristics+0x2>
            return 0;
    a236:	2b c0       	rjmp	.+86     	; 0xa28e <Reader14443A_Select+0x1fe>

        case STATE_DESELECT:
            if ((flags & FLAGS_NO_DATA) != 0) { // most likely the card already understood the deselect
    a238:	98 2f       	mov	r25, r24
    a23a:	92 70       	andi	r25, 0x02	; 2
    a23c:	31 f0       	breq	.+12     	; 0xa24a <Reader14443A_Select+0x1ba>
                ReaderState = STATE_HALT;
    a23e:	81 e0       	ldi	r24, 0x01	; 1
    a240:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <ReaderState>
                Reader14443ACodecStart();
    a244:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
    a248:	0e c0       	rjmp	.+28     	; 0xa266 <Reader14443A_Select+0x1d6>
                return 0;
            }
            if ((flags & FLAGS_PARITY_OK) == 0 || ISO14443_CRCA(Buffer, 3)) {
    a24a:	80 ff       	sbrs	r24, 0
    a24c:	05 c0       	rjmp	.+10     	; 0xa258 <Reader14443A_Select+0x1c8>
    a24e:	63 e0       	ldi	r22, 0x03	; 3
    a250:	ce 01       	movw	r24, r28
    a252:	fa de       	rcall	.-524    	; 0xa048 <ISO14443_CRCA>
    a254:	89 2b       	or	r24, r25
    a256:	99 f3       	breq	.-26     	; 0xa23e <Reader14443A_Select+0x1ae>
                return Reader14443A_Deselect(Buffer);
    a258:	ce 01       	movw	r24, r28
            return 0;

        default:
            return 0;
    }
}
    a25a:	df 91       	pop	r29
    a25c:	cf 91       	pop	r28
    a25e:	1f 91       	pop	r17
    a260:	ff 90       	pop	r15
                ReaderState = STATE_HALT;
                Reader14443ACodecStart();
                return 0;
            }
            if ((flags & FLAGS_PARITY_OK) == 0 || ISO14443_CRCA(Buffer, 3)) {
                return Reader14443A_Deselect(Buffer);
    a262:	ef 90       	pop	r14
    a264:	24 ce       	rjmp	.-952    	; 0x9eae <Reader14443A_Deselect>
            ReaderState = STATE_HALT;
            Reader14443ACodecStart();
            return 0;

        default:
            return 0;
    a266:	80 e0       	ldi	r24, 0x00	; 0
    a268:	90 e0       	ldi	r25, 0x00	; 0
    a26a:	11 c0       	rjmp	.+34     	; 0xa28e <Reader14443A_Select+0x1fe>
    a26c:	a7 01       	movw	r20, r14
    a26e:	49 5f       	subi	r20, 0xF9	; 249
    a270:	5f 4f       	sbci	r21, 0xFF	; 255
    a272:	83 e0       	ldi	r24, 0x03	; 3
    a274:	56 95       	lsr	r21
    a276:	47 95       	ror	r20
    a278:	8a 95       	dec	r24
    a27a:	e1 f7       	brne	.-8      	; 0xa274 <Reader14443A_Select+0x1e4>
    a27c:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    a280:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    a284:	be 01       	movw	r22, r28
    a286:	81 ec       	ldi	r24, 0xC1	; 193
    a288:	19 95       	eicall
        else
            Selected = false;
    }

    // general frame handling:
    uint8_t flags = 0;
    a28a:	80 e0       	ldi	r24, 0x00	; 0
    a28c:	23 cf       	rjmp	.-442    	; 0xa0d4 <Reader14443A_Select+0x44>
            return 0;

        default:
            return 0;
    }
}
    a28e:	df 91       	pop	r29
    a290:	cf 91       	pop	r28
    a292:	1f 91       	pop	r17
    a294:	ff 90       	pop	r15
    a296:	ef 90       	pop	r14
    a298:	08 95       	ret

0000a29a <Identify>:
    ISO14443AAppendCRCA(Buffer, 2);
    ReaderState = STATE_ATS;
    return addParityBits(Buffer, 4 * BITS_PER_BYTE);
}

static bool Identify(uint8_t *Buffer, uint16_t *BitCount) {
    a29a:	9f 92       	push	r9
    a29c:	af 92       	push	r10
    a29e:	bf 92       	push	r11
    a2a0:	cf 92       	push	r12
    a2a2:	df 92       	push	r13
    a2a4:	ef 92       	push	r14
    a2a6:	ff 92       	push	r15
    a2a8:	0f 93       	push	r16
    a2aa:	1f 93       	push	r17
    a2ac:	cf 93       	push	r28
    a2ae:	df 93       	push	r29
    a2b0:	cd b7       	in	r28, 0x3d	; 61
    a2b2:	de b7       	in	r29, 0x3e	; 62
    a2b4:	c7 56       	subi	r28, 0x67	; 103
    a2b6:	d1 09       	sbc	r29, r1
    a2b8:	cd bf       	out	0x3d, r28	; 61
    a2ba:	de bf       	out	0x3e, r29	; 62
    a2bc:	8c 01       	movw	r16, r24
    a2be:	7b 01       	movw	r14, r22
    uint16_t rVal = Reader14443A_Select(Buffer, *BitCount);
    a2c0:	fb 01       	movw	r30, r22
    a2c2:	60 81       	ld	r22, Z
    a2c4:	71 81       	ldd	r23, Z+1	; 0x01
    a2c6:	e4 de       	rcall	.-568    	; 0xa090 <Reader14443A_Select>
    if (Selected) {
    a2c8:	d0 90 f7 2d 	lds	r13, 0x2DF7	; 0x802df7 <Selected>
    a2cc:	dd 20       	and	r13, r13
    a2ce:	09 f4       	brne	.+2      	; 0xa2d2 <Identify+0x38>
    a2d0:	45 c1       	rjmp	.+650    	; 0xa55c <Identify+0x2c2>
        if (ReaderState >= STATE_SAK_CL1 && ReaderState <= STATE_SAK_CL3) {
    a2d2:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <ReaderState>
    a2d6:	9a ef       	ldi	r25, 0xFA	; 250
    a2d8:	98 0f       	add	r25, r24
    a2da:	93 30       	cpi	r25, 0x03	; 3
    a2dc:	08 f0       	brcs	.+2      	; 0xa2e0 <Identify+0x46>
    a2de:	57 c0       	rjmp	.+174    	; 0xa38e <Identify+0xf4>
    a2e0:	f8 01       	movw	r30, r16
    a2e2:	80 81       	ld	r24, Z
    a2e4:	80 72       	andi	r24, 0x20	; 32
    a2e6:	c8 2e       	mov	r12, r24
            bool ISO14443_4A_compliant = IS_ISO14443A_4_COMPLIANT(Buffer);
            CardCandidatesIdx = 0;
    a2e8:	10 92 d8 2d 	sts	0x2DD8, r1	; 0x802dd8 <CardCandidatesIdx>
    a2ec:	52 ed       	ldi	r21, 0xD2	; 210
    a2ee:	a5 2e       	mov	r10, r21
    a2f0:	53 e1       	ldi	r21, 0x13	; 19
    a2f2:	b5 2e       	mov	r11, r21

            uint8_t i;
            for (i = 0; i < ARRAY_COUNT(CardIdentificationList); i++) {
    a2f4:	91 2c       	mov	r9, r1
                CardIdentificationType card;
                memcpy_P(&card, &CardIdentificationList[i], sizeof(CardIdentificationType));
    a2f6:	47 e6       	ldi	r20, 0x67	; 103
    a2f8:	50 e0       	ldi	r21, 0x00	; 0
    a2fa:	b5 01       	movw	r22, r10
    a2fc:	ce 01       	movw	r24, r28
    a2fe:	01 96       	adiw	r24, 0x01	; 1
    a300:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <memcpy_P>
                if (card.ATQARelevant && card.ATQA != CardCharacteristics.ATQA)
    a304:	8b 81       	ldd	r24, Y+3	; 0x03
    a306:	88 23       	and	r24, r24
    a308:	49 f0       	breq	.+18     	; 0xa31c <Identify+0x82>
    a30a:	29 81       	ldd	r18, Y+1	; 0x01
    a30c:	3a 81       	ldd	r19, Y+2	; 0x02
    a30e:	80 91 e8 2d 	lds	r24, 0x2DE8	; 0x802de8 <CardCharacteristics>
    a312:	90 91 e9 2d 	lds	r25, 0x2DE9	; 0x802de9 <CardCharacteristics+0x1>
    a316:	28 17       	cp	r18, r24
    a318:	39 07       	cpc	r19, r25
    a31a:	b9 f4       	brne	.+46     	; 0xa34a <Identify+0xb0>
                    continue;
                if (card.SAKRelevant && card.SAK != CardCharacteristics.SAK)
    a31c:	8d 81       	ldd	r24, Y+5	; 0x05
    a31e:	88 23       	and	r24, r24
    a320:	29 f0       	breq	.+10     	; 0xa32c <Identify+0x92>
    a322:	9c 81       	ldd	r25, Y+4	; 0x04
    a324:	80 91 ea 2d 	lds	r24, 0x2DEA	; 0x802dea <CardCharacteristics+0x2>
    a328:	98 13       	cpse	r25, r24
    a32a:	0f c0       	rjmp	.+30     	; 0xa34a <Identify+0xb0>
                    continue;
                if (card.ATSRelevant && !ISO14443_4A_compliant)
    a32c:	8f 89       	ldd	r24, Y+23	; 0x17
    a32e:	88 23       	and	r24, r24
    a330:	11 f0       	breq	.+4      	; 0xa336 <Identify+0x9c>
    a332:	cc 20       	and	r12, r12
    a334:	51 f0       	breq	.+20     	; 0xa34a <Identify+0xb0>
                    continue; // for this card type candidate, the ATS is relevant, but the card does not support ISO14443-4A
                CardCandidates[CardCandidatesIdx++] = i;
    a336:	e0 91 d8 2d 	lds	r30, 0x2DD8	; 0x802dd8 <CardCandidatesIdx>
    a33a:	81 e0       	ldi	r24, 0x01	; 1
    a33c:	8e 0f       	add	r24, r30
    a33e:	80 93 d8 2d 	sts	0x2DD8, r24	; 0x802dd8 <CardCandidatesIdx>
    a342:	f0 e0       	ldi	r31, 0x00	; 0
    a344:	e7 52       	subi	r30, 0x27	; 39
    a346:	f2 4d       	sbci	r31, 0xD2	; 210
    a348:	90 82       	st	Z, r9
        if (ReaderState >= STATE_SAK_CL1 && ReaderState <= STATE_SAK_CL3) {
            bool ISO14443_4A_compliant = IS_ISO14443A_4_COMPLIANT(Buffer);
            CardCandidatesIdx = 0;

            uint8_t i;
            for (i = 0; i < ARRAY_COUNT(CardIdentificationList); i++) {
    a34a:	93 94       	inc	r9
    a34c:	f7 e6       	ldi	r31, 0x67	; 103
    a34e:	af 0e       	add	r10, r31
    a350:	b1 1c       	adc	r11, r1
    a352:	8f e0       	ldi	r24, 0x0F	; 15
    a354:	98 12       	cpse	r9, r24
    a356:	cf cf       	rjmp	.-98     	; 0xa2f6 <Identify+0x5c>
                if (card.ATSRelevant && !ISO14443_4A_compliant)
                    continue; // for this card type candidate, the ATS is relevant, but the card does not support ISO14443-4A
                CardCandidates[CardCandidatesIdx++] = i;
            }

            if (ISO14443_4A_compliant) {
    a358:	c1 10       	cpse	r12, r1
    a35a:	0d c0       	rjmp	.+26     	; 0xa376 <Identify+0xdc>

        /*
         * If any cards are not distinguishable with ISO14443A commands only, this is the place to run some proprietary commands.
         */

        if ((ReaderState >= STATE_SAK_CL1 && ReaderState <= STATE_SAK_CL3) || ReaderState == STATE_ATS) {
    a35c:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <ReaderState>
    a360:	9a ef       	ldi	r25, 0xFA	; 250
    a362:	98 0f       	add	r25, r24
    a364:	94 30       	cpi	r25, 0x04	; 4
    a366:	08 f0       	brcs	.+2      	; 0xa36a <Identify+0xd0>
    a368:	ae c0       	rjmp	.+348    	; 0xa4c6 <Identify+0x22c>
            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++) {
    a36a:	20 91 d8 2d 	lds	r18, 0x2DD8	; 0x802dd8 <CardCandidatesIdx>
    a36e:	e9 ed       	ldi	r30, 0xD9	; 217
    a370:	fd e2       	ldi	r31, 0x2D	; 45
    a372:	80 e0       	ldi	r24, 0x00	; 0
    a374:	8f c0       	rjmp	.+286    	; 0xa494 <Identify+0x1fa>
    Selected = false;
    return addParityBits(Buffer, 4 * BITS_PER_BYTE);
}

INLINE uint16_t Reader14443A_RATS(uint8_t *Buffer) {
    Buffer[0] = 0xE0; // RATS command
    a376:	80 ee       	ldi	r24, 0xE0	; 224
    a378:	f8 01       	movw	r30, r16
    a37a:	80 83       	st	Z, r24
    Buffer[1] = 0x80;
    a37c:	80 e8       	ldi	r24, 0x80	; 128
    a37e:	81 83       	std	Z+1, r24	; 0x01
    ISO14443AAppendCRCA(Buffer, 2);
    a380:	62 e0       	ldi	r22, 0x02	; 2
    a382:	70 e0       	ldi	r23, 0x00	; 0
    a384:	c8 01       	movw	r24, r16
    a386:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
    ReaderState = STATE_ATS;
    a38a:	89 e0       	ldi	r24, 0x09	; 9
    a38c:	95 c0       	rjmp	.+298    	; 0xa4b8 <Identify+0x21e>
                *BitCount = Reader14443A_RATS(Buffer);
                return false;
            }
            // if we don't have to send the RATS, we are finished for distinguishing with ISO 14443A

        } else if (ReaderState == STATE_ATS) { // we have got the ATS
    a38e:	89 30       	cpi	r24, 0x09	; 9
    a390:	29 f7       	brne	.-54     	; 0xa35c <Identify+0xc2>
            if (!checkParityBits(Buffer, *BitCount)) {
    a392:	f7 01       	movw	r30, r14
    a394:	60 81       	ld	r22, Z
    a396:	71 81       	ldd	r23, Z+1	; 0x01
    a398:	c8 01       	movw	r24, r16
    a39a:	ee dd       	rcall	.-1060   	; 0x9f78 <checkParityBits>
    a39c:	f7 01       	movw	r30, r14
    a39e:	60 81       	ld	r22, Z
    a3a0:	71 81       	ldd	r23, Z+1	; 0x01
    a3a2:	81 11       	cpse	r24, r1
    a3a4:	15 c0       	rjmp	.+42     	; 0xa3d0 <Identify+0x136>
    a3a6:	cb 01       	movw	r24, r22
    a3a8:	08 96       	adiw	r24, 0x08	; 8
    a3aa:	67 e0       	ldi	r22, 0x07	; 7
    a3ac:	70 e0       	ldi	r23, 0x00	; 0
    a3ae:	0e 94 ea 77 	call	0xefd4	; 0xefd4 <__udivmodhi4>
    a3b2:	46 2f       	mov	r20, r22
    a3b4:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    a3b8:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    a3bc:	b8 01       	movw	r22, r16
    a3be:	81 ec       	ldi	r24, 0xC1	; 193
                LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (*BitCount + 8) / 7);
                *BitCount = Reader14443A_Deselect(Buffer);
    a3c0:	19 95       	eicall
    a3c2:	c8 01       	movw	r24, r16
    a3c4:	74 dd       	rcall	.-1304   	; 0x9eae <Reader14443A_Deselect>
    a3c6:	f7 01       	movw	r30, r14
    a3c8:	80 83       	st	Z, r24
    a3ca:	91 83       	std	Z+1, r25	; 0x01
                return false;
    a3cc:	d1 2c       	mov	r13, r1
            }
            *BitCount = removeParityBits(Buffer, *BitCount);
    a3ce:	c9 c0       	rjmp	.+402    	; 0xa562 <Identify+0x2c8>
    a3d0:	c8 01       	movw	r24, r16
    a3d2:	82 dd       	rcall	.-1276   	; 0x9ed8 <removeParityBits>
    a3d4:	f7 01       	movw	r30, r14
    a3d6:	80 83       	st	Z, r24
    a3d8:	91 83       	std	Z+1, r25	; 0x01

            if (Buffer[0] != *BitCount / 8 - 2 || ISO14443_CRCA(Buffer, Buffer[0] + 2)) {
    a3da:	f8 01       	movw	r30, r16
    a3dc:	60 81       	ld	r22, Z
    a3de:	26 2f       	mov	r18, r22
    a3e0:	30 e0       	ldi	r19, 0x00	; 0
    a3e2:	43 e0       	ldi	r20, 0x03	; 3
    a3e4:	96 95       	lsr	r25
    a3e6:	87 95       	ror	r24
    a3e8:	4a 95       	dec	r20
    a3ea:	e1 f7       	brne	.-8      	; 0xa3e4 <Identify+0x14a>
    a3ec:	02 97       	sbiw	r24, 0x02	; 2
    a3ee:	28 17       	cp	r18, r24
    a3f0:	39 07       	cpc	r19, r25
    a3f2:	39 f7       	brne	.-50     	; 0xa3c2 <Identify+0x128>
    a3f4:	6e 5f       	subi	r22, 0xFE	; 254
    a3f6:	c8 01       	movw	r24, r16
    a3f8:	27 de       	rcall	.-946    	; 0xa048 <ISO14443_CRCA>
    a3fa:	89 2b       	or	r24, r25
    a3fc:	11 f7       	brne	.-60     	; 0xa3c2 <Identify+0x128>
    a3fe:	c1 2c       	mov	r12, r1
            }

            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++) {
                CardIdentificationType card;
                memcpy_P(&card, &CardIdentificationList[CardCandidates[i]], sizeof(CardIdentificationType));
    a400:	97 e6       	ldi	r25, 0x67	; 103
    a402:	99 2e       	mov	r9, r25
                if (!card.ATSRelevant || (card.ATSRelevant && card.ATSSize == Buffer[0] - 1 && memcmp(card.ATS, Buffer + 1, card.ATSSize) == 0))
    a404:	58 01       	movw	r10, r16
    a406:	ff ef       	ldi	r31, 0xFF	; 255
    a408:	af 1a       	sub	r10, r31
    a40a:	bf 0a       	sbc	r11, r31
                *BitCount = Reader14443A_Deselect(Buffer);
                return false;
            }

            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++) {
    a40c:	80 91 d8 2d 	lds	r24, 0x2DD8	; 0x802dd8 <CardCandidatesIdx>
    a410:	c8 16       	cp	r12, r24
    a412:	08 f0       	brcs	.+2      	; 0xa416 <Identify+0x17c>
    a414:	a3 cf       	rjmp	.-186    	; 0xa35c <Identify+0xc2>
                CardIdentificationType card;
                memcpy_P(&card, &CardIdentificationList[CardCandidates[i]], sizeof(CardIdentificationType));
    a416:	ec 2d       	mov	r30, r12
    a418:	f0 e0       	ldi	r31, 0x00	; 0
    a41a:	e7 52       	subi	r30, 0x27	; 39
    a41c:	f2 4d       	sbci	r31, 0xD2	; 210
    a41e:	60 81       	ld	r22, Z
    a420:	96 9e       	mul	r9, r22
    a422:	b0 01       	movw	r22, r0
    a424:	11 24       	eor	r1, r1
    a426:	6e 52       	subi	r22, 0x2E	; 46
    a428:	7c 4e       	sbci	r23, 0xEC	; 236
    a42a:	47 e6       	ldi	r20, 0x67	; 103
    a42c:	50 e0       	ldi	r21, 0x00	; 0
    a42e:	ce 01       	movw	r24, r28
    a430:	01 96       	adiw	r24, 0x01	; 1
    a432:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <memcpy_P>
                if (!card.ATSRelevant || (card.ATSRelevant && card.ATSSize == Buffer[0] - 1 && memcmp(card.ATS, Buffer + 1, card.ATSSize) == 0))
    a436:	8f 89       	ldd	r24, Y+23	; 0x17
    a438:	88 23       	and	r24, r24
    a43a:	49 f1       	breq	.+82     	; 0xa48e <Identify+0x1f4>
    a43c:	4e 89       	ldd	r20, Y+22	; 0x16
    a43e:	50 e0       	ldi	r21, 0x00	; 0
    a440:	f8 01       	movw	r30, r16
    a442:	80 81       	ld	r24, Z
    a444:	90 e0       	ldi	r25, 0x00	; 0
    a446:	01 97       	sbiw	r24, 0x01	; 1
    a448:	48 17       	cp	r20, r24
    a44a:	59 07       	cpc	r21, r25
    a44c:	41 f0       	breq	.+16     	; 0xa45e <Identify+0x1c4>
                     */
                    continue;

                // Else, we have to delete this candidate
                uint8_t j;
                for (j = i; j < CardCandidatesIdx - 1; j++)
    a44e:	20 91 d8 2d 	lds	r18, 0x2DD8	; 0x802dd8 <CardCandidatesIdx>
    a452:	42 2f       	mov	r20, r18
    a454:	50 e0       	ldi	r21, 0x00	; 0
    a456:	41 50       	subi	r20, 0x01	; 1
    a458:	51 09       	sbc	r21, r1
    a45a:	3c 2d       	mov	r19, r12
    a45c:	08 c0       	rjmp	.+16     	; 0xa46e <Identify+0x1d4>

            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++) {
                CardIdentificationType card;
                memcpy_P(&card, &CardIdentificationList[CardCandidates[i]], sizeof(CardIdentificationType));
                if (!card.ATSRelevant || (card.ATSRelevant && card.ATSSize == Buffer[0] - 1 && memcmp(card.ATS, Buffer + 1, card.ATSSize) == 0))
    a45e:	b5 01       	movw	r22, r10
    a460:	ce 01       	movw	r24, r28
    a462:	06 96       	adiw	r24, 0x06	; 6
    a464:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    a468:	89 2b       	or	r24, r25
    a46a:	89 f7       	brne	.-30     	; 0xa44e <Identify+0x1b4>
    a46c:	10 c0       	rjmp	.+32     	; 0xa48e <Identify+0x1f4>
                     */
                    continue;

                // Else, we have to delete this candidate
                uint8_t j;
                for (j = i; j < CardCandidatesIdx - 1; j++)
    a46e:	83 2f       	mov	r24, r19
    a470:	90 e0       	ldi	r25, 0x00	; 0
    a472:	84 17       	cp	r24, r20
    a474:	95 07       	cpc	r25, r21
    a476:	3c f4       	brge	.+14     	; 0xa486 <Identify+0x1ec>
                    CardCandidates[j] = CardCandidates[j + 1];
    a478:	fc 01       	movw	r30, r24
    a47a:	e7 52       	subi	r30, 0x27	; 39
    a47c:	f2 4d       	sbci	r31, 0xD2	; 210
    a47e:	81 81       	ldd	r24, Z+1	; 0x01
    a480:	80 83       	st	Z, r24
                     */
                    continue;

                // Else, we have to delete this candidate
                uint8_t j;
                for (j = i; j < CardCandidatesIdx - 1; j++)
    a482:	3f 5f       	subi	r19, 0xFF	; 255
    a484:	f4 cf       	rjmp	.-24     	; 0xa46e <Identify+0x1d4>
                    CardCandidates[j] = CardCandidates[j + 1];
                CardCandidatesIdx--;
    a486:	21 50       	subi	r18, 0x01	; 1
    a488:	20 93 d8 2d 	sts	0x2DD8, r18	; 0x802dd8 <CardCandidatesIdx>
                i--;
    a48c:	ca 94       	dec	r12
                *BitCount = Reader14443A_Deselect(Buffer);
                return false;
            }

            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++) {
    a48e:	c3 94       	inc	r12
    a490:	bd cf       	rjmp	.-134    	; 0xa40c <Identify+0x172>
         * If any cards are not distinguishable with ISO14443A commands only, this is the place to run some proprietary commands.
         */

        if ((ReaderState >= STATE_SAK_CL1 && ReaderState <= STATE_SAK_CL3) || ReaderState == STATE_ATS) {
            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++) {
    a492:	8f 5f       	subi	r24, 0xFF	; 255
    a494:	82 17       	cp	r24, r18
    a496:	09 f4       	brne	.+2      	; 0xa49a <Identify+0x200>
    a498:	64 c0       	rjmp	.+200    	; 0xa562 <Identify+0x2c8>
                switch (CardCandidates[i]) {
    a49a:	91 91       	ld	r25, Z+
    a49c:	94 50       	subi	r25, 0x04	; 4
    a49e:	92 30       	cpi	r25, 0x02	; 2
    a4a0:	c0 f7       	brcc	.-16     	; 0xa492 <Identify+0x1f8>
                    case CardType_NXP_MIFARE_DESFire:
                    case CardType_NXP_MIFARE_DESFire_EV1:
                        Buffer[0] = 0x02;
    a4a2:	82 e0       	ldi	r24, 0x02	; 2
    a4a4:	f8 01       	movw	r30, r16
    a4a6:	80 83       	st	Z, r24
                        Buffer[1] = 0x60;
    a4a8:	80 e6       	ldi	r24, 0x60	; 96
    a4aa:	81 83       	std	Z+1, r24	; 0x01
                        ISO14443AAppendCRCA(Buffer, 2);
    a4ac:	62 e0       	ldi	r22, 0x02	; 2
    a4ae:	70 e0       	ldi	r23, 0x00	; 0
    a4b0:	c8 01       	movw	r24, r16
    a4b2:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                        ReaderState = STATE_DESFIRE_INFO;
    a4b6:	8b e0       	ldi	r24, 0x0B	; 11
    a4b8:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <ReaderState>
                        *BitCount = addParityBits(Buffer, 4 * BITS_PER_BYTE);
    a4bc:	60 e2       	ldi	r22, 0x20	; 32
    a4be:	70 e0       	ldi	r23, 0x00	; 0
    a4c0:	c8 01       	movw	r24, r16
    a4c2:	87 dc       	rcall	.-1778   	; 0x9dd2 <addParityBits>
    a4c4:	80 cf       	rjmp	.-256    	; 0xa3c6 <Identify+0x12c>
                    default:
                        break;
                }
            }
        } else {
            switch (ReaderState) {
    a4c6:	8b 30       	cpi	r24, 0x0B	; 11
    a4c8:	09 f0       	breq	.+2      	; 0xa4cc <Identify+0x232>
    a4ca:	4b c0       	rjmp	.+150    	; 0xa562 <Identify+0x2c8>
                case STATE_DESFIRE_INFO:
                    if (*BitCount == 0) {
    a4cc:	f7 01       	movw	r30, r14
    a4ce:	60 81       	ld	r22, Z
    a4d0:	71 81       	ldd	r23, Z+1	; 0x01
    a4d2:	61 15       	cp	r22, r1
    a4d4:	71 05       	cpc	r23, r1
    a4d6:	09 f4       	brne	.+2      	; 0xa4da <Identify+0x240>
                        CardCandidatesIdx = 0; // this will return that this card is unknown to us
                        break;
                    }
                    if (!checkParityBits(Buffer, *BitCount)) {
    a4d8:	3e c0       	rjmp	.+124    	; 0xa556 <Identify+0x2bc>
    a4da:	c8 01       	movw	r24, r16
    a4dc:	4d dd       	rcall	.-1382   	; 0x9f78 <checkParityBits>
    a4de:	d8 2e       	mov	r13, r24
    a4e0:	f7 01       	movw	r30, r14
    a4e2:	60 81       	ld	r22, Z
    a4e4:	71 81       	ldd	r23, Z+1	; 0x01
    a4e6:	81 11       	cpse	r24, r1
    a4e8:	13 c0       	rjmp	.+38     	; 0xa510 <Identify+0x276>
    a4ea:	cb 01       	movw	r24, r22
    a4ec:	08 96       	adiw	r24, 0x08	; 8
    a4ee:	67 e0       	ldi	r22, 0x07	; 7
    a4f0:	70 e0       	ldi	r23, 0x00	; 0
    a4f2:	0e 94 ea 77 	call	0xefd4	; 0xefd4 <__udivmodhi4>
    a4f6:	46 2f       	mov	r20, r22
    a4f8:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    a4fc:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    a500:	b8 01       	movw	r22, r16
    a502:	81 ec       	ldi	r24, 0xC1	; 193
                        LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (*BitCount + 8) / 7);
                        CardCandidatesIdx = 0;
    a504:	19 95       	eicall
    a506:	10 92 d8 2d 	sts	0x2DD8, r1	; 0x802dd8 <CardCandidatesIdx>
                        *BitCount = Reader14443A_Deselect(Buffer);
    a50a:	c8 01       	movw	r24, r16
    a50c:	d0 dc       	rcall	.-1632   	; 0x9eae <Reader14443A_Deselect>
    a50e:	26 c0       	rjmp	.+76     	; 0xa55c <Identify+0x2c2>
                        return false;
                    }
                    *BitCount = removeParityBits(Buffer, *BitCount);
    a510:	c8 01       	movw	r24, r16
    a512:	e2 dc       	rcall	.-1596   	; 0x9ed8 <removeParityBits>
    a514:	f7 01       	movw	r30, r14
    a516:	80 83       	st	Z, r24
    a518:	91 83       	std	Z+1, r25	; 0x01
                    if (ISO14443_CRCA(Buffer, *BitCount / 8)) {
    a51a:	bc 01       	movw	r22, r24
    a51c:	83 e0       	ldi	r24, 0x03	; 3
    a51e:	76 95       	lsr	r23
    a520:	67 95       	ror	r22
    a522:	8a 95       	dec	r24
    a524:	e1 f7       	brne	.-8      	; 0xa51e <Identify+0x284>
    a526:	c8 01       	movw	r24, r16
    a528:	8f dd       	rcall	.-1250   	; 0xa048 <ISO14443_CRCA>
    a52a:	89 2b       	or	r24, r25
    a52c:	19 f0       	breq	.+6      	; 0xa534 <Identify+0x29a>
    a52e:	10 92 d8 2d 	sts	0x2DD8, r1	; 0x802dd8 <CardCandidatesIdx>
                        CardCandidatesIdx = 0;
    a532:	47 cf       	rjmp	.-370    	; 0xa3c2 <Identify+0x128>
    a534:	f8 01       	movw	r30, r16
                        *BitCount = Reader14443A_Deselect(Buffer);
                        return false;
                    }
                    switch (Buffer[5]) {
    a536:	85 81       	ldd	r24, Z+5	; 0x05
    a538:	88 23       	and	r24, r24
    a53a:	31 f0       	breq	.+12     	; 0xa548 <Identify+0x2ae>
    a53c:	81 30       	cpi	r24, 0x01	; 1
    a53e:	59 f4       	brne	.+22     	; 0xa556 <Identify+0x2bc>
    a540:	80 93 d8 2d 	sts	0x2DD8, r24	; 0x802dd8 <CardCandidatesIdx>
                            CardCandidatesIdx = 1;
                            CardCandidates[0] = CardType_NXP_MIFARE_DESFire;
                            break;

                        case 0x01:
                            CardCandidatesIdx = 1;
    a544:	85 e0       	ldi	r24, 0x05	; 5
                            CardCandidates[0] = CardType_NXP_MIFARE_DESFire_EV1;
    a546:	04 c0       	rjmp	.+8      	; 0xa550 <Identify+0x2b6>
    a548:	81 e0       	ldi	r24, 0x01	; 1
                        *BitCount = Reader14443A_Deselect(Buffer);
                        return false;
                    }
                    switch (Buffer[5]) {
                        case 0x00:
                            CardCandidatesIdx = 1;
    a54a:	80 93 d8 2d 	sts	0x2DD8, r24	; 0x802dd8 <CardCandidatesIdx>
    a54e:	84 e0       	ldi	r24, 0x04	; 4
                            CardCandidates[0] = CardType_NXP_MIFARE_DESFire;
    a550:	80 93 d9 2d 	sts	0x2DD9, r24	; 0x802dd9 <CardCandidates>
                            break;

                        case 0x01:
                            CardCandidatesIdx = 1;
                            CardCandidates[0] = CardType_NXP_MIFARE_DESFire_EV1;
    a554:	06 c0       	rjmp	.+12     	; 0xa562 <Identify+0x2c8>
                            break;
    a556:	10 92 d8 2d 	sts	0x2DD8, r1	; 0x802dd8 <CardCandidatesIdx>

                        default:
                            CardCandidatesIdx = 0;
    a55a:	03 c0       	rjmp	.+6      	; 0xa562 <Identify+0x2c8>
    a55c:	f7 01       	movw	r30, r14
                    break;
            }
        }
        return true;
    }
    *BitCount = rVal;
    a55e:	80 83       	st	Z, r24
    a560:	91 83       	std	Z+1, r25	; 0x01
    a562:	8d 2d       	mov	r24, r13
    return false;
}
    a564:	c9 59       	subi	r28, 0x99	; 153
    a566:	df 4f       	sbci	r29, 0xFF	; 255
    a568:	cd bf       	out	0x3d, r28	; 61
    a56a:	de bf       	out	0x3e, r29	; 62
    a56c:	df 91       	pop	r29
    a56e:	cf 91       	pop	r28
    a570:	1f 91       	pop	r17
    a572:	0f 91       	pop	r16
    a574:	ff 90       	pop	r15
    a576:	ef 90       	pop	r14
    a578:	df 90       	pop	r13
    a57a:	cf 90       	pop	r12
    a57c:	bf 90       	pop	r11
    a57e:	af 90       	pop	r10
    a580:	9f 90       	pop	r9
    a582:	08 95       	ret

0000a584 <Reader14443AAppProcess>:
    a584:	5f 92       	push	r5

uint16_t Reader14443AAppProcess(uint8_t *Buffer, uint16_t BitCount) {
    a586:	6f 92       	push	r6
    a588:	7f 92       	push	r7
    a58a:	8f 92       	push	r8
    a58c:	9f 92       	push	r9
    a58e:	af 92       	push	r10
    a590:	bf 92       	push	r11
    a592:	cf 92       	push	r12
    a594:	df 92       	push	r13
    a596:	ef 92       	push	r14
    a598:	ff 92       	push	r15
    a59a:	0f 93       	push	r16
    a59c:	1f 93       	push	r17
    a59e:	cf 93       	push	r28
    a5a0:	df 93       	push	r29
    a5a2:	cd b7       	in	r28, 0x3d	; 61
    a5a4:	de b7       	in	r29, 0x3e	; 62
    a5a6:	c2 54       	subi	r28, 0x42	; 66
    a5a8:	d2 40       	sbci	r29, 0x02	; 2
    a5aa:	cd bf       	out	0x3d, r28	; 61
    a5ac:	de bf       	out	0x3e, r29	; 62
    a5ae:	7c 01       	movw	r14, r24
    a5b0:	cf 5b       	subi	r28, 0xBF	; 191
    a5b2:	dd 4f       	sbci	r29, 0xFD	; 253
    a5b4:	68 83       	st	Y, r22
    a5b6:	79 83       	std	Y+1, r23	; 0x01
    a5b8:	c1 54       	subi	r28, 0x41	; 65
    a5ba:	d2 40       	sbci	r29, 0x02	; 2
    switch (Reader14443CurrentCommand) {
    a5bc:	80 91 1c 2d 	lds	r24, 0x2D1C	; 0x802d1c <Reader14443CurrentCommand>
    a5c0:	84 30       	cpi	r24, 0x04	; 4
    a5c2:	09 f4       	brne	.+2      	; 0xa5c6 <Reader14443AAppProcess+0x42>
    a5c4:	a8 c1       	rjmp	.+848    	; 0xa916 <Reader14443AAppProcess+0x392>
    a5c6:	40 f4       	brcc	.+16     	; 0xa5d8 <Reader14443AAppProcess+0x54>
    a5c8:	82 30       	cpi	r24, 0x02	; 2
    a5ca:	09 f4       	brne	.+2      	; 0xa5ce <Reader14443AAppProcess+0x4a>
    a5cc:	d9 c0       	rjmp	.+434    	; 0xa780 <Reader14443AAppProcess+0x1fc>
    a5ce:	08 f0       	brcs	.+2      	; 0xa5d2 <Reader14443AAppProcess+0x4e>
    a5d0:	63 c1       	rjmp	.+710    	; 0xa898 <Reader14443AAppProcess+0x314>
    a5d2:	81 30       	cpi	r24, 0x01	; 1
    a5d4:	69 f0       	breq	.+26     	; 0xa5f0 <Reader14443AAppProcess+0x6c>
    a5d6:	c8 c4       	rjmp	.+2448   	; 0xaf68 <Reader14443AAppProcess+0x9e4>
    a5d8:	86 30       	cpi	r24, 0x06	; 6
    a5da:	09 f4       	brne	.+2      	; 0xa5de <Reader14443AAppProcess+0x5a>
    a5dc:	58 c3       	rjmp	.+1712   	; 0xac8e <Reader14443AAppProcess+0x70a>
    a5de:	08 f4       	brcc	.+2      	; 0xa5e2 <Reader14443AAppProcess+0x5e>
    a5e0:	63 c2       	rjmp	.+1222   	; 0xaaa8 <Reader14443AAppProcess+0x524>
    a5e2:	87 30       	cpi	r24, 0x07	; 7
    a5e4:	09 f4       	brne	.+2      	; 0xa5e8 <Reader14443AAppProcess+0x64>
    a5e6:	02 c4       	rjmp	.+2052   	; 0xadec <Reader14443AAppProcess+0x868>
    a5e8:	88 30       	cpi	r24, 0x08	; 8
    a5ea:	09 f4       	brne	.+2      	; 0xa5ee <Reader14443AAppProcess+0x6a>
    a5ec:	5d c2       	rjmp	.+1210   	; 0xaaa8 <Reader14443AAppProcess+0x524>
    a5ee:	bc c4       	rjmp	.+2424   	; 0xaf68 <Reader14443AAppProcess+0x9e4>
        case Reader14443_Send: {
            if (ReaderSendBitCount) {
    a5f0:	00 91 bb 2f 	lds	r16, 0x2FBB	; 0x802fbb <ReaderSendBitCount>
    a5f4:	10 91 bc 2f 	lds	r17, 0x2FBC	; 0x802fbc <ReaderSendBitCount+0x1>
    a5f8:	01 15       	cp	r16, r1
    a5fa:	11 05       	cpc	r17, r1
    a5fc:	c1 f0       	breq	.+48     	; 0xa62e <Reader14443AAppProcess+0xaa>
                memcpy(Buffer, ReaderSendBuffer, (ReaderSendBitCount + 7) / 8);
    a5fe:	a8 01       	movw	r20, r16
    a600:	49 5f       	subi	r20, 0xF9	; 249
    a602:	5f 4f       	sbci	r21, 0xFF	; 255
    a604:	63 e0       	ldi	r22, 0x03	; 3
    a606:	56 95       	lsr	r21
    a608:	47 95       	ror	r20
    a60a:	6a 95       	dec	r22
    a60c:	e1 f7       	brne	.-8      	; 0xa606 <Reader14443AAppProcess+0x82>
    a60e:	69 eb       	ldi	r22, 0xB9	; 185
    a610:	7e e2       	ldi	r23, 0x2E	; 46
    a612:	c7 01       	movw	r24, r14
    a614:	0e 94 a0 78 	call	0xf140	; 0xf140 <memcpy>
                uint16_t tmp = addParityBits(Buffer, ReaderSendBitCount);
    a618:	60 91 bb 2f 	lds	r22, 0x2FBB	; 0x802fbb <ReaderSendBitCount>
    a61c:	70 91 bc 2f 	lds	r23, 0x2FBC	; 0x802fbc <ReaderSendBitCount+0x1>
    a620:	c7 01       	movw	r24, r14
    a622:	d7 db       	rcall	.-2130   	; 0x9dd2 <addParityBits>
                ReaderSendBitCount = 0;
    a624:	10 92 bb 2f 	sts	0x2FBB, r1	; 0x802fbb <ReaderSendBitCount>
    a628:	10 92 bc 2f 	sts	0x2FBC, r1	; 0x802fbc <ReaderSendBitCount+0x1>
    a62c:	3b c2       	rjmp	.+1142   	; 0xaaa4 <Reader14443AAppProcess+0x520>
                return tmp;
            }

            if (BitCount == 0) {
    a62e:	cf 5b       	subi	r28, 0xBF	; 191
    a630:	dd 4f       	sbci	r29, 0xFD	; 253
    a632:	68 81       	ld	r22, Y
    a634:	79 81       	ldd	r23, Y+1	; 0x01
    a636:	c1 54       	subi	r28, 0x41	; 65
    a638:	d2 40       	sbci	r29, 0x02	; 2
    a63a:	61 15       	cp	r22, r1
    a63c:	71 05       	cpc	r23, r1
    a63e:	09 f4       	brne	.+2      	; 0xa642 <Reader14443AAppProcess+0xbe>
    a640:	c7 c0       	rjmp	.+398    	; 0xa7d0 <Reader14443AAppProcess+0x24c>
                Reader14443CurrentCommand = Reader14443_Do_Nothing;
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
                return 0;
            }
            char tmpBuf[128];
            bool parity = checkParityBits(Buffer, BitCount);
    a642:	c7 01       	movw	r24, r14
    a644:	99 dc       	rcall	.-1742   	; 0x9f78 <checkParityBits>
    a646:	d8 2e       	mov	r13, r24
            BitCount = removeParityBits(Buffer, BitCount);
    a648:	cf 5b       	subi	r28, 0xBF	; 191
    a64a:	dd 4f       	sbci	r29, 0xFD	; 253
    a64c:	68 81       	ld	r22, Y
    a64e:	79 81       	ldd	r23, Y+1	; 0x01
    a650:	c1 54       	subi	r28, 0x41	; 65
    a652:	d2 40       	sbci	r29, 0x02	; 2
    a654:	c7 01       	movw	r24, r14
    a656:	40 dc       	rcall	.-1920   	; 0x9ed8 <removeParityBits>
    a658:	cf 5b       	subi	r28, 0xBF	; 191
    a65a:	dd 4f       	sbci	r29, 0xFD	; 253
    a65c:	88 83       	st	Y, r24
    a65e:	99 83       	std	Y+1, r25	; 0x01
    a660:	c1 54       	subi	r28, 0x41	; 65
    a662:	d2 40       	sbci	r29, 0x02	; 2
            if ((2 * (BitCount + 7) / 8 + 2 + 4) > 128) { // 2 = \r\n, 4 = size of bitcount in hex
    a664:	9c 01       	movw	r18, r24
    a666:	29 5f       	subi	r18, 0xF9	; 249
    a668:	3f 4f       	sbci	r19, 0xFF	; 255
    a66a:	c9 01       	movw	r24, r18
    a66c:	88 0f       	add	r24, r24
    a66e:	99 1f       	adc	r25, r25
    a670:	53 e0       	ldi	r21, 0x03	; 3
    a672:	96 95       	lsr	r25
    a674:	87 95       	ror	r24
    a676:	5a 95       	dec	r21
    a678:	e1 f7       	brne	.-8      	; 0xa672 <Reader14443AAppProcess+0xee>
    a67a:	06 96       	adiw	r24, 0x06	; 6
    a67c:	81 38       	cpi	r24, 0x81	; 129
    a67e:	91 05       	cpc	r25, r1
    a680:	78 f0       	brcs	.+30     	; 0xa6a0 <Reader14443AAppProcess+0x11c>
                sprintf(tmpBuf, "Too many data.");
    a682:	68 ed       	ldi	r22, 0xD8	; 216
    a684:	73 e2       	ldi	r23, 0x23	; 35
    a686:	ce 01       	movw	r24, r28
    a688:	01 96       	adiw	r24, 0x01	; 1
    a68a:	0e 94 cc 78 	call	0xf198	; 0xf198 <strcpy>
                Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a68e:	10 92 1c 2d 	sts	0x2D1C, r1	; 0x802d1c <Reader14443CurrentCommand>
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    a692:	be 01       	movw	r22, r28
    a694:	6f 5f       	subi	r22, 0xFF	; 255
    a696:	7f 4f       	sbci	r23, 0xFF	; 255
    a698:	85 e6       	ldi	r24, 0x65	; 101
    a69a:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
                return 0;
    a69e:	b9 c4       	rjmp	.+2418   	; 0xb012 <Reader14443AAppProcess+0xa8e>
            }
            uint16_t charCnt = BufferToHexString(tmpBuf, 128, Buffer, (BitCount + 7) / 8);
    a6a0:	b3 e0       	ldi	r27, 0x03	; 3
    a6a2:	36 95       	lsr	r19
    a6a4:	27 95       	ror	r18
    a6a6:	ba 95       	dec	r27
    a6a8:	e1 f7       	brne	.-8      	; 0xa6a2 <Reader14443AAppProcess+0x11e>
    a6aa:	a7 01       	movw	r20, r14
    a6ac:	60 e8       	ldi	r22, 0x80	; 128
    a6ae:	70 e0       	ldi	r23, 0x00	; 0
    a6b0:	ce 01       	movw	r24, r28
    a6b2:	01 96       	adiw	r24, 0x01	; 1
    a6b4:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
    a6b8:	7c 01       	movw	r14, r24
            uint8_t count[2] = {(BitCount >> 8) & 0xFF, BitCount & 0xFF};
    a6ba:	cf 5b       	subi	r28, 0xBF	; 191
    a6bc:	dd 4f       	sbci	r29, 0xFD	; 253
    a6be:	88 81       	ld	r24, Y
    a6c0:	c1 54       	subi	r28, 0x41	; 65
    a6c2:	d2 40       	sbci	r29, 0x02	; 2
    a6c4:	ce 5b       	subi	r28, 0xBE	; 190
    a6c6:	dd 4f       	sbci	r29, 0xFD	; 253
    a6c8:	98 81       	ld	r25, Y
    a6ca:	c2 54       	subi	r28, 0x42	; 66
    a6cc:	d2 40       	sbci	r29, 0x02	; 2
    a6ce:	cf 5f       	subi	r28, 0xFF	; 255
    a6d0:	dd 4f       	sbci	r29, 0xFD	; 253
    a6d2:	98 83       	st	Y, r25
    a6d4:	c1 50       	subi	r28, 0x01	; 1
    a6d6:	d2 40       	sbci	r29, 0x02	; 2
    a6d8:	ce 5f       	subi	r28, 0xFE	; 254
    a6da:	dd 4f       	sbci	r29, 0xFD	; 253
    a6dc:	88 83       	st	Y, r24
    a6de:	c2 50       	subi	r28, 0x02	; 2
    a6e0:	d2 40       	sbci	r29, 0x02	; 2
            charCnt += snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\n");
    a6e2:	87 ee       	ldi	r24, 0xE7	; 231
    a6e4:	93 e2       	ldi	r25, 0x23	; 35
    a6e6:	9f 93       	push	r25
    a6e8:	8f 93       	push	r24
    a6ea:	80 e8       	ldi	r24, 0x80	; 128
    a6ec:	a8 2e       	mov	r10, r24
    a6ee:	b1 2c       	mov	r11, r1
    a6f0:	c5 01       	movw	r24, r10
    a6f2:	8e 19       	sub	r24, r14
    a6f4:	9f 09       	sbc	r25, r15
    a6f6:	9f 93       	push	r25
    a6f8:	8f 93       	push	r24
    a6fa:	81 e0       	ldi	r24, 0x01	; 1
    a6fc:	90 e0       	ldi	r25, 0x00	; 0
    a6fe:	8c 0f       	add	r24, r28
    a700:	9d 1f       	adc	r25, r29
    a702:	8e 0d       	add	r24, r14
    a704:	9f 1d       	adc	r25, r15
    a706:	9f 93       	push	r25
    a708:	8f 93       	push	r24
    a70a:	0e 94 d3 78 	call	0xf1a6	; 0xf1a6 <snprintf>
    a70e:	e8 0e       	add	r14, r24
    a710:	f9 1e       	adc	r15, r25
            charCnt += BufferToHexString(tmpBuf + charCnt, 128 - charCnt, count, 2);
    a712:	b5 01       	movw	r22, r10
    a714:	6e 19       	sub	r22, r14
    a716:	7f 09       	sbc	r23, r15
    a718:	22 e0       	ldi	r18, 0x02	; 2
    a71a:	30 e0       	ldi	r19, 0x00	; 0
    a71c:	ae 01       	movw	r20, r28
    a71e:	4f 5f       	subi	r20, 0xFF	; 255
    a720:	5d 4f       	sbci	r21, 0xFD	; 253
    a722:	81 e0       	ldi	r24, 0x01	; 1
    a724:	90 e0       	ldi	r25, 0x00	; 0
    a726:	8c 0f       	add	r24, r28
    a728:	9d 1f       	adc	r25, r29
    a72a:	8e 0d       	add	r24, r14
    a72c:	9f 1d       	adc	r25, r15
    a72e:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
    a732:	8e 0d       	add	r24, r14
    a734:	9f 1d       	adc	r25, r15
            if (!parity)
    a736:	0f 90       	pop	r0
    a738:	0f 90       	pop	r0
    a73a:	0f 90       	pop	r0
    a73c:	0f 90       	pop	r0
    a73e:	0f 90       	pop	r0
    a740:	0f 90       	pop	r0
    a742:	95 01       	movw	r18, r10
    a744:	28 1b       	sub	r18, r24
    a746:	39 0b       	sbc	r19, r25
    a748:	41 e0       	ldi	r20, 0x01	; 1
    a74a:	50 e0       	ldi	r21, 0x00	; 0
    a74c:	4c 0f       	add	r20, r28
    a74e:	5d 1f       	adc	r21, r29
    a750:	84 0f       	add	r24, r20
    a752:	95 1f       	adc	r25, r21
    a754:	d1 10       	cpse	r13, r1
    a756:	03 c0       	rjmp	.+6      	; 0xa75e <Reader14443AAppProcess+0x1da>
                snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\nPARITY ERROR");
    a758:	4a ee       	ldi	r20, 0xEA	; 234
    a75a:	53 e2       	ldi	r21, 0x23	; 35
    a75c:	02 c0       	rjmp	.+4      	; 0xa762 <Reader14443AAppProcess+0x1de>
            else
                snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\nPARITY OK");
    a75e:	49 ef       	ldi	r20, 0xF9	; 249
    a760:	53 e2       	ldi	r21, 0x23	; 35
    a762:	5f 93       	push	r21
    a764:	4f 93       	push	r20
    a766:	3f 93       	push	r19
    a768:	2f 93       	push	r18
    a76a:	9f 93       	push	r25
    a76c:	8f 93       	push	r24
    a76e:	0e 94 d3 78 	call	0xf1a6	; 0xf1a6 <snprintf>
    a772:	0f 90       	pop	r0
    a774:	0f 90       	pop	r0
    a776:	0f 90       	pop	r0
    a778:	0f 90       	pop	r0
    a77a:	0f 90       	pop	r0
    a77c:	0f 90       	pop	r0
    a77e:	87 cf       	rjmp	.-242    	; 0xa68e <Reader14443AAppProcess+0x10a>
            return 0;
        }


        case Reader14443_Send_Raw: {
            if (ReaderSendBitCount) {
    a780:	00 91 bb 2f 	lds	r16, 0x2FBB	; 0x802fbb <ReaderSendBitCount>
    a784:	10 91 bc 2f 	lds	r17, 0x2FBC	; 0x802fbc <ReaderSendBitCount+0x1>
    a788:	01 15       	cp	r16, r1
    a78a:	11 05       	cpc	r17, r1
    a78c:	c1 f0       	breq	.+48     	; 0xa7be <Reader14443AAppProcess+0x23a>
                memcpy(Buffer, ReaderSendBuffer, (ReaderSendBitCount + 7) / 8);
    a78e:	a8 01       	movw	r20, r16
    a790:	49 5f       	subi	r20, 0xF9	; 249
    a792:	5f 4f       	sbci	r21, 0xFF	; 255
    a794:	a3 e0       	ldi	r26, 0x03	; 3
    a796:	56 95       	lsr	r21
    a798:	47 95       	ror	r20
    a79a:	aa 95       	dec	r26
    a79c:	e1 f7       	brne	.-8      	; 0xa796 <Reader14443AAppProcess+0x212>
    a79e:	69 eb       	ldi	r22, 0xB9	; 185
    a7a0:	7e e2       	ldi	r23, 0x2E	; 46
    a7a2:	c7 01       	movw	r24, r14
    a7a4:	0e 94 a0 78 	call	0xf140	; 0xf140 <memcpy>
                uint16_t tmp = ReaderSendBitCount;
    a7a8:	90 91 bb 2f 	lds	r25, 0x2FBB	; 0x802fbb <ReaderSendBitCount>
    a7ac:	80 91 bc 2f 	lds	r24, 0x2FBC	; 0x802fbc <ReaderSendBitCount+0x1>
                ReaderSendBitCount = 0;
    a7b0:	10 92 bb 2f 	sts	0x2FBB, r1	; 0x802fbb <ReaderSendBitCount>
    a7b4:	10 92 bc 2f 	sts	0x2FBC, r1	; 0x802fbc <ReaderSendBitCount+0x1>
                return tmp;
    a7b8:	09 2f       	mov	r16, r25
    a7ba:	18 2f       	mov	r17, r24
    a7bc:	2a c4       	rjmp	.+2132   	; 0xb012 <Reader14443AAppProcess+0xa8e>
            }

            if (BitCount == 0) {
    a7be:	cf 5b       	subi	r28, 0xBF	; 191
    a7c0:	dd 4f       	sbci	r29, 0xFD	; 253
    a7c2:	28 81       	ld	r18, Y
    a7c4:	39 81       	ldd	r19, Y+1	; 0x01
    a7c6:	c1 54       	subi	r28, 0x41	; 65
    a7c8:	d2 40       	sbci	r29, 0x02	; 2
    a7ca:	21 15       	cp	r18, r1
    a7cc:	31 05       	cpc	r19, r1
    a7ce:	51 f4       	brne	.+20     	; 0xa7e4 <Reader14443AAppProcess+0x260>
                char tmpBuf[] = "NO DATA";
    a7d0:	88 e0       	ldi	r24, 0x08	; 8
    a7d2:	e1 e8       	ldi	r30, 0x81	; 129
    a7d4:	f4 e2       	ldi	r31, 0x24	; 36
    a7d6:	de 01       	movw	r26, r28
    a7d8:	11 96       	adiw	r26, 0x01	; 1
    a7da:	01 90       	ld	r0, Z+
    a7dc:	0d 92       	st	X+, r0
    a7de:	8a 95       	dec	r24
    a7e0:	e1 f7       	brne	.-8      	; 0xa7da <Reader14443AAppProcess+0x256>
    a7e2:	55 cf       	rjmp	.-342    	; 0xa68e <Reader14443AAppProcess+0x10a>
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
                return 0;
            }

            char tmpBuf[128];
            uint16_t charCnt = BufferToHexString(tmpBuf, 128, Buffer, (BitCount + 7) / 8);
    a7e4:	29 5f       	subi	r18, 0xF9	; 249
    a7e6:	3f 4f       	sbci	r19, 0xFF	; 255
    a7e8:	e3 e0       	ldi	r30, 0x03	; 3
    a7ea:	36 95       	lsr	r19
    a7ec:	27 95       	ror	r18
    a7ee:	ea 95       	dec	r30
    a7f0:	e1 f7       	brne	.-8      	; 0xa7ea <Reader14443AAppProcess+0x266>
    a7f2:	a7 01       	movw	r20, r14
    a7f4:	60 e8       	ldi	r22, 0x80	; 128
    a7f6:	70 e0       	ldi	r23, 0x00	; 0
    a7f8:	ce 01       	movw	r24, r28
    a7fa:	01 96       	adiw	r24, 0x01	; 1
    a7fc:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
    a800:	7c 01       	movw	r14, r24
            uint8_t count[2] = {(BitCount >> 8) & 0xFF, BitCount & 0xFF};
    a802:	cf 5b       	subi	r28, 0xBF	; 191
    a804:	dd 4f       	sbci	r29, 0xFD	; 253
    a806:	88 81       	ld	r24, Y
    a808:	c1 54       	subi	r28, 0x41	; 65
    a80a:	d2 40       	sbci	r29, 0x02	; 2
    a80c:	ce 5b       	subi	r28, 0xBE	; 190
    a80e:	dd 4f       	sbci	r29, 0xFD	; 253
    a810:	98 81       	ld	r25, Y
    a812:	c2 54       	subi	r28, 0x42	; 66
    a814:	d2 40       	sbci	r29, 0x02	; 2
    a816:	cf 5f       	subi	r28, 0xFF	; 255
    a818:	dd 4f       	sbci	r29, 0xFD	; 253
    a81a:	98 83       	st	Y, r25
    a81c:	c1 50       	subi	r28, 0x01	; 1
    a81e:	d2 40       	sbci	r29, 0x02	; 2
    a820:	ce 5f       	subi	r28, 0xFE	; 254
    a822:	dd 4f       	sbci	r29, 0xFD	; 253
    a824:	88 83       	st	Y, r24
    a826:	c2 50       	subi	r28, 0x02	; 2
    a828:	d2 40       	sbci	r29, 0x02	; 2
            charCnt += snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\n");
    a82a:	87 ee       	ldi	r24, 0xE7	; 231
    a82c:	93 e2       	ldi	r25, 0x23	; 35
    a82e:	9f 93       	push	r25
    a830:	8f 93       	push	r24
    a832:	f0 e8       	ldi	r31, 0x80	; 128
    a834:	cf 2e       	mov	r12, r31
    a836:	d1 2c       	mov	r13, r1
    a838:	c6 01       	movw	r24, r12
    a83a:	8e 19       	sub	r24, r14
    a83c:	9f 09       	sbc	r25, r15
    a83e:	9f 93       	push	r25
    a840:	8f 93       	push	r24
    a842:	81 e0       	ldi	r24, 0x01	; 1
    a844:	90 e0       	ldi	r25, 0x00	; 0
    a846:	8c 0f       	add	r24, r28
    a848:	9d 1f       	adc	r25, r29
    a84a:	8e 0d       	add	r24, r14
    a84c:	9f 1d       	adc	r25, r15
    a84e:	9f 93       	push	r25
    a850:	8f 93       	push	r24
    a852:	0e 94 d3 78 	call	0xf1a6	; 0xf1a6 <snprintf>
    a856:	8e 0d       	add	r24, r14
    a858:	9f 1d       	adc	r25, r15
            charCnt += BufferToHexString(tmpBuf + charCnt, 128 - charCnt, count, 2);
    a85a:	b6 01       	movw	r22, r12
    a85c:	68 1b       	sub	r22, r24
    a85e:	79 0b       	sbc	r23, r25
    a860:	22 e0       	ldi	r18, 0x02	; 2
    a862:	30 e0       	ldi	r19, 0x00	; 0
    a864:	ae 01       	movw	r20, r28
    a866:	4f 5f       	subi	r20, 0xFF	; 255
    a868:	5d 4f       	sbci	r21, 0xFD	; 253
    a86a:	a1 e0       	ldi	r26, 0x01	; 1
    a86c:	b0 e0       	ldi	r27, 0x00	; 0
    a86e:	ac 0f       	add	r26, r28
    a870:	bd 1f       	adc	r27, r29
    a872:	8a 0f       	add	r24, r26
    a874:	9b 1f       	adc	r25, r27
    a876:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
            Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a87a:	10 92 1c 2d 	sts	0x2D1C, r1	; 0x802d1c <Reader14443CurrentCommand>
            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    a87e:	be 01       	movw	r22, r28
    a880:	6f 5f       	subi	r22, 0xFF	; 255
    a882:	7f 4f       	sbci	r23, 0xFF	; 255
    a884:	85 e6       	ldi	r24, 0x65	; 101
    a886:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
            return 0;
    a88a:	0f 90       	pop	r0
    a88c:	0f 90       	pop	r0
    a88e:	0f 90       	pop	r0
    a890:	0f 90       	pop	r0
    a892:	0f 90       	pop	r0
    a894:	0f 90       	pop	r0
    a896:	bd c3       	rjmp	.+1914   	; 0xb012 <Reader14443AAppProcess+0xa8e>
        }

        case Reader14443_Get_UID: {
            uint16_t rVal = Reader14443A_Select(Buffer, BitCount);
    a898:	cf 5b       	subi	r28, 0xBF	; 191
    a89a:	dd 4f       	sbci	r29, 0xFD	; 253
    a89c:	68 81       	ld	r22, Y
    a89e:	79 81       	ldd	r23, Y+1	; 0x01
    a8a0:	c1 54       	subi	r28, 0x41	; 65
    a8a2:	d2 40       	sbci	r29, 0x02	; 2
    a8a4:	c7 01       	movw	r24, r14
    a8a6:	f4 db       	rcall	.-2072   	; 0xa090 <Reader14443A_Select>
            if (Selected) { // we are done finding the UID
    a8a8:	20 91 f7 2d 	lds	r18, 0x2DF7	; 0x802df7 <Selected>
    a8ac:	22 23       	and	r18, r18
    a8ae:	09 f4       	brne	.+2      	; 0xa8b2 <Reader14443AAppProcess+0x32e>
    a8b0:	5e c3       	rjmp	.+1724   	; 0xaf6e <Reader14443AAppProcess+0x9ea>
                char tmpBuf[20];
                //Debug
                snprintf_P(Buffer , BitCount, PSTR("Buffer === %d"), *Buffer);
    a8b2:	f7 01       	movw	r30, r14
    a8b4:	80 81       	ld	r24, Z
    a8b6:	1f 92       	push	r1
    a8b8:	8f 93       	push	r24
    a8ba:	84 ec       	ldi	r24, 0xC4	; 196
    a8bc:	93 e1       	ldi	r25, 0x13	; 19
    a8be:	9f 93       	push	r25
    a8c0:	8f 93       	push	r24
    a8c2:	ce 5b       	subi	r28, 0xBE	; 190
    a8c4:	dd 4f       	sbci	r29, 0xFD	; 253
    a8c6:	88 81       	ld	r24, Y
    a8c8:	c2 54       	subi	r28, 0x42	; 66
    a8ca:	d2 40       	sbci	r29, 0x02	; 2
    a8cc:	8f 93       	push	r24
    a8ce:	cf 5b       	subi	r28, 0xBF	; 191
    a8d0:	dd 4f       	sbci	r29, 0xFD	; 253
    a8d2:	88 81       	ld	r24, Y
    a8d4:	c1 54       	subi	r28, 0x41	; 65
    a8d6:	d2 40       	sbci	r29, 0x02	; 2
    a8d8:	8f 93       	push	r24
    a8da:	ff 92       	push	r15
    a8dc:	ef 92       	push	r14
    a8de:	0e 94 09 79 	call	0xf212	; 0xf212 <snprintf_P>
                BufferToHexString(tmpBuf, 20, CardCharacteristics.UID, CardCharacteristics.UIDSize);
    a8e2:	20 91 f5 2d 	lds	r18, 0x2DF5	; 0x802df5 <CardCharacteristics+0xd>
    a8e6:	30 e0       	ldi	r19, 0x00	; 0
    a8e8:	4b ee       	ldi	r20, 0xEB	; 235
    a8ea:	5d e2       	ldi	r21, 0x2D	; 45
    a8ec:	64 e1       	ldi	r22, 0x14	; 20
    a8ee:	70 e0       	ldi	r23, 0x00	; 0
    a8f0:	ce 01       	movw	r24, r28
    a8f2:	01 96       	adiw	r24, 0x01	; 1
    a8f4:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    a8f8:	be 01       	movw	r22, r28
    a8fa:	6f 5f       	subi	r22, 0xFF	; 255
    a8fc:	7f 4f       	sbci	r23, 0xFF	; 255
    a8fe:	85 e6       	ldi	r24, 0x65	; 101
    a900:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
                Selected = false;
    a904:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
                Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a908:	10 92 1c 2d 	sts	0x2D1C, r1	; 0x802d1c <Reader14443CurrentCommand>
                CodecReaderFieldStop();
    a90c:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <CodecReaderFieldStop>
    a910:	cd bf       	out	0x3d, r28	; 61
    a912:	de bf       	out	0x3e, r29	; 62
    a914:	29 c3       	rjmp	.+1618   	; 0xaf68 <Reader14443AAppProcess+0x9e4>
                RT_STATE_SEARCHING
            } RTState = RT_STATE_IDLE;
            static uint8_t TryCount = 0;
            static uint8_t Thresholds[(CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] = {0};

            if (RTState == RT_STATE_IDLE) {
    a916:	80 91 d7 2d 	lds	r24, 0x2DD7	; 0x802dd7 <RTState.7433>
    a91a:	81 11       	cpse	r24, r1
    a91c:	08 c0       	rjmp	.+16     	; 0xa92e <Reader14443AAppProcess+0x3aa>
                CodecThresholdSet(CODEC_THRESHOLD_CALIBRATE_MIN);
    a91e:	80 e8       	ldi	r24, 0x80	; 128
    a920:	90 e0       	ldi	r25, 0x00	; 0
    a922:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <CodecThresholdSet>
                RTState = RT_STATE_SEARCHING;
    a926:	81 e0       	ldi	r24, 0x01	; 1
    a928:	80 93 d7 2d 	sts	0x2DD7, r24	; 0x802dd7 <RTState.7433>
    a92c:	7b c0       	rjmp	.+246    	; 0xaa24 <Reader14443AAppProcess+0x4a0>
                TryCount = 0;
            } else if (RTState == RT_STATE_SEARCHING && ReaderState <= STATE_HALT) {
    a92e:	81 30       	cpi	r24, 0x01	; 1
    a930:	09 f0       	breq	.+2      	; 0xa934 <Reader14443AAppProcess+0x3b0>
    a932:	7a c0       	rjmp	.+244    	; 0xaa28 <Reader14443AAppProcess+0x4a4>
    a934:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <ReaderState>
    a938:	82 30       	cpi	r24, 0x02	; 2
    a93a:	08 f0       	brcs	.+2      	; 0xa93e <Reader14443AAppProcess+0x3ba>
    a93c:	75 c0       	rjmp	.+234    	; 0xaa28 <Reader14443AAppProcess+0x4a4>
                if (++TryCount == TRYCOUNT_MAX) {
    a93e:	80 91 d6 2d 	lds	r24, 0x2DD6	; 0x802dd6 <TryCount.7434>
    a942:	8f 5f       	subi	r24, 0xFF	; 255
    a944:	80 93 d6 2d 	sts	0x2DD6, r24	; 0x802dd6 <TryCount.7434>
    a948:	80 31       	cpi	r24, 0x10	; 16
    a94a:	09 f0       	breq	.+2      	; 0xa94e <Reader14443AAppProcess+0x3ca>
    a94c:	6d c0       	rjmp	.+218    	; 0xaa28 <Reader14443AAppProcess+0x4a4>
                    uint16_t tmp_th = CodecThresholdIncrement();
    a94e:	0e 94 d4 26 	call	0x4da8	; 0x4da8 <CodecThresholdIncrement>
    a952:	8c 01       	movw	r16, r24
                    if ((tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID)
    a954:	93 50       	subi	r25, 0x03	; 3
    a956:	40 97       	sbiw	r24, 0x10	; 16
    a958:	68 f0       	brcs	.+26     	; 0xa974 <Reader14443AAppProcess+0x3f0>
                            ||
    a95a:	01 15       	cp	r16, r1
    a95c:	38 e0       	ldi	r19, 0x08	; 8
    a95e:	13 07       	cpc	r17, r19
    a960:	08 f4       	brcc	.+2      	; 0xa964 <Reader14443AAppProcess+0x3e0>
    a962:	60 c0       	rjmp	.+192    	; 0xaa24 <Reader14443AAppProcess+0x4a0>
    a964:	e0 e1       	ldi	r30, 0x10	; 16
    a966:	f0 e0       	ldi	r31, 0x00	; 0
    a968:	20 e0       	ldi	r18, 0x00	; 0
    a96a:	30 e0       	ldi	r19, 0x00	; 0
    a96c:	a1 2c       	mov	r10, r1
    a96e:	b1 2c       	mov	r11, r1
    a970:	60 e0       	ldi	r22, 0x00	; 0
    a972:	40 c0       	rjmp	.+128    	; 0xa9f4 <Reader14443AAppProcess+0x470>
    a974:	ae e5       	ldi	r26, 0x5E	; 94
    a976:	bd e2       	ldi	r27, 0x2D	; 45
                RTState = RT_STATE_SEARCHING;
                TryCount = 0;
            } else if (RTState == RT_STATE_SEARCHING && ReaderState <= STATE_HALT) {
                if (++TryCount == TRYCOUNT_MAX) {
                    uint16_t tmp_th = CodecThresholdIncrement();
                    if ((tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID)
    a978:	40 e0       	ldi	r20, 0x00	; 0
    a97a:	50 e0       	ldi	r21, 0x00	; 0
    a97c:	20 e0       	ldi	r18, 0x00	; 0
    a97e:	30 e0       	ldi	r19, 0x00	; 0
    a980:	80 e0       	ldi	r24, 0x00	; 0
    a982:	90 e0       	ldi	r25, 0x00	; 0
    a984:	e0 e0       	ldi	r30, 0x00	; 0
    a986:	f0 e0       	ldi	r31, 0x00	; 0
    a988:	60 e0       	ldi	r22, 0x00	; 0
                        uint16_t i;

                        // first, search inside the usual search space
                        if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID) {
                            for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++) {
                                if (Thresholds[i] == TRYCOUNT_MAX && i < ((CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS - 1)) {
    a98a:	7d 91       	ld	r23, X+
    a98c:	70 31       	cpi	r23, 0x10	; 16
    a98e:	49 f4       	brne	.+18     	; 0xa9a2 <Reader14443AAppProcess+0x41e>
    a990:	47 32       	cpi	r20, 0x27	; 39
    a992:	51 05       	cpc	r21, r1
    a994:	09 f4       	brne	.+2      	; 0xa998 <Reader14443AAppProcess+0x414>
    a996:	39 c3       	rjmp	.+1650   	; 0xb00a <Reader14443AAppProcess+0xa86>
                                    if (!block) {
    a998:	61 11       	cpse	r22, r1
    a99a:	0e c0       	rjmp	.+28     	; 0xa9b8 <Reader14443AAppProcess+0x434>
    a99c:	fa 01       	movw	r30, r20
                                        block = true;
    a99e:	61 e0       	ldi	r22, 0x01	; 1
    a9a0:	0b c0       	rjmp	.+22     	; 0xa9b8 <Reader14443AAppProcess+0x434>
                                        min = i;
                                    }
                                } else {
                                    if (block) {
    a9a2:	66 23       	and	r22, r22
    a9a4:	49 f0       	breq	.+18     	; 0xa9b8 <Reader14443AAppProcess+0x434>
                                        block = false;
                                        max = i;
                                        if ((max - min) >= maxdiff) {
    a9a6:	ba 01       	movw	r22, r20
    a9a8:	6e 1b       	sub	r22, r30
    a9aa:	7f 0b       	sbc	r23, r31
    a9ac:	68 17       	cp	r22, r24
    a9ae:	79 07       	cpc	r23, r25
    a9b0:	10 f0       	brcs	.+4      	; 0xa9b6 <Reader14443AAppProcess+0x432>
    a9b2:	9f 01       	movw	r18, r30
    a9b4:	cb 01       	movw	r24, r22
                                        block = true;
                                        min = i;
                                    }
                                } else {
                                    if (block) {
                                        block = false;
    a9b6:	60 e0       	ldi	r22, 0x00	; 0
                        uint16_t numworked;
                        uint16_t i;

                        // first, search inside the usual search space
                        if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID) {
                            for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++) {
    a9b8:	4f 5f       	subi	r20, 0xFF	; 255
    a9ba:	5f 4f       	sbci	r21, 0xFF	; 255
    a9bc:	48 32       	cpi	r20, 0x28	; 40
    a9be:	51 05       	cpc	r21, r1
    a9c0:	21 f7       	brne	.-56     	; 0xa98a <Reader14443AAppProcess+0x406>
                                            maxdiffoffset = min;
                                        }
                                    }
                                }
                            }
                            if (maxdiff >= 4) { // if we have found something with at least 5 consecutive working thresholds (only if these thresholds have worked for evers attempt), we are done
    a9c2:	84 30       	cpi	r24, 0x04	; 4
    a9c4:	91 05       	cpc	r25, r1
    a9c6:	08 f0       	brcs	.+2      	; 0xa9ca <Reader14443AAppProcess+0x446>
    a9c8:	5a c2       	rjmp	.+1204   	; 0xae7e <Reader14443AAppProcess+0x8fa>
    a9ca:	2c c0       	rjmp	.+88     	; 0xaa24 <Reader14443AAppProcess+0x4a0>
                                finished = true;
                            }
                        } else { // we have searched the whole space
                            for (numworked = TRYCOUNT_MAX; numworked > 0; numworked--) {
                                for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++) {
                                    if (Thresholds[i] >= numworked) {
    a9cc:	d6 01       	movw	r26, r12
    a9ce:	ed 90       	ld	r14, X+
    a9d0:	6d 01       	movw	r12, r26
    a9d2:	f1 2c       	mov	r15, r1
    a9d4:	ee 16       	cp	r14, r30
    a9d6:	ff 06       	cpc	r15, r31
    a9d8:	b0 f4       	brcc	.+44     	; 0xaa06 <Reader14443AAppProcess+0x482>
                                        if (!block) {
                                            block = true;
                                            min = i;
                                        }
                                    } else {
                                        if (block) {
    a9da:	61 11       	cpse	r22, r1
    a9dc:	19 c0       	rjmp	.+50     	; 0xaa10 <Reader14443AAppProcess+0x48c>
                            if (maxdiff >= 4) { // if we have found something with at least 5 consecutive working thresholds (only if these thresholds have worked for evers attempt), we are done
                                finished = true;
                            }
                        } else { // we have searched the whole space
                            for (numworked = TRYCOUNT_MAX; numworked > 0; numworked--) {
                                for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++) {
    a9de:	4f 5f       	subi	r20, 0xFF	; 255
    a9e0:	5f 4f       	sbci	r21, 0xFF	; 255
    a9e2:	48 37       	cpi	r20, 0x78	; 120
    a9e4:	51 05       	cpc	r21, r1
    a9e6:	91 f7       	brne	.-28     	; 0xa9cc <Reader14443AAppProcess+0x448>
                                                maxdiffoffset = min;
                                            }
                                        }
                                    }
                                }
                                if (maxdiff > 0) {
    a9e8:	00 97       	sbiw	r24, 0x00	; 0
    a9ea:	09 f0       	breq	.+2      	; 0xa9ee <Reader14443AAppProcess+0x46a>
    a9ec:	48 c2       	rjmp	.+1168   	; 0xae7e <Reader14443AAppProcess+0x8fa>
    a9ee:	31 97       	sbiw	r30, 0x01	; 1
                            }
                            if (maxdiff >= 4) { // if we have found something with at least 5 consecutive working thresholds (only if these thresholds have worked for evers attempt), we are done
                                finished = true;
                            }
                        } else { // we have searched the whole space
                            for (numworked = TRYCOUNT_MAX; numworked > 0; numworked--) {
    a9f0:	09 f4       	brne	.+2      	; 0xa9f4 <Reader14443AAppProcess+0x470>
    a9f2:	45 c2       	rjmp	.+1162   	; 0xae7e <Reader14443AAppProcess+0x8fa>
    a9f4:	7e e5       	ldi	r23, 0x5E	; 94
    a9f6:	c7 2e       	mov	r12, r23
    a9f8:	7d e2       	ldi	r23, 0x2D	; 45
    a9fa:	d7 2e       	mov	r13, r23
                                        block = true;
                                        min = i;
                                    }
                                } else {
                                    if (block) {
                                        block = false;
    a9fc:	40 e0       	ldi	r20, 0x00	; 0
    a9fe:	50 e0       	ldi	r21, 0x00	; 0
    aa00:	80 e0       	ldi	r24, 0x00	; 0
    aa02:	90 e0       	ldi	r25, 0x00	; 0
    aa04:	e3 cf       	rjmp	.-58     	; 0xa9cc <Reader14443AAppProcess+0x448>
                            }
                        } else { // we have searched the whole space
                            for (numworked = TRYCOUNT_MAX; numworked > 0; numworked--) {
                                for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++) {
                                    if (Thresholds[i] >= numworked) {
                                        if (!block) {
    aa06:	61 11       	cpse	r22, r1
    aa08:	ea cf       	rjmp	.-44     	; 0xa9de <Reader14443AAppProcess+0x45a>
    aa0a:	5a 01       	movw	r10, r20
                                            block = true;
    aa0c:	61 e0       	ldi	r22, 0x01	; 1
    aa0e:	e7 cf       	rjmp	.-50     	; 0xa9de <Reader14443AAppProcess+0x45a>
                                        }
                                    } else {
                                        if (block) {
                                            block = false;
                                            max = i;
                                            if ((max - min) >= maxdiff) {
    aa10:	ba 01       	movw	r22, r20
    aa12:	6a 19       	sub	r22, r10
    aa14:	7b 09       	sbc	r23, r11
    aa16:	68 17       	cp	r22, r24
    aa18:	79 07       	cpc	r23, r25
    aa1a:	10 f0       	brcs	.+4      	; 0xaa20 <Reader14443AAppProcess+0x49c>
    aa1c:	95 01       	movw	r18, r10
    aa1e:	cb 01       	movw	r24, r22
                                            block = true;
                                            min = i;
                                        }
                                    } else {
                                        if (block) {
                                            block = false;
    aa20:	60 e0       	ldi	r22, 0x00	; 0
    aa22:	dd cf       	rjmp	.-70     	; 0xa9de <Reader14443AAppProcess+0x45a>
                            Reader14443CurrentCommand = Reader14443_Do_Nothing;
                            Reader14443ACodecReset();
                            return 0;
                        }
                    }
                    TryCount = 0;
    aa24:	10 92 d6 2d 	sts	0x2DD6, r1	; 0x802dd6 <TryCount.7434>
                }
            }

            uint16_t rVal = Reader14443A_Select(Buffer, BitCount);
    aa28:	cf 5b       	subi	r28, 0xBF	; 191
    aa2a:	dd 4f       	sbci	r29, 0xFD	; 253
    aa2c:	68 81       	ld	r22, Y
    aa2e:	79 81       	ldd	r23, Y+1	; 0x01
    aa30:	c1 54       	subi	r28, 0x41	; 65
    aa32:	d2 40       	sbci	r29, 0x02	; 2
    aa34:	c7 01       	movw	r24, r14
    aa36:	2c db       	rcall	.-2472   	; 0xa090 <Reader14443A_Select>
            if (Selected) { // we are done finding the threshold
    aa38:	20 91 f7 2d 	lds	r18, 0x2DF7	; 0x802df7 <Selected>
    aa3c:	22 23       	and	r18, r18
    aa3e:	09 f4       	brne	.+2      	; 0xaa42 <Reader14443AAppProcess+0x4be>
    aa40:	96 c2       	rjmp	.+1324   	; 0xaf6e <Reader14443AAppProcess+0x9ea>
                Thresholds[(GlobalSettings.ActiveSettingPtr->ReaderThreshold - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] += 1;
    aa42:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    aa46:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    aa4a:	02 84       	ldd	r0, Z+10	; 0x0a
    aa4c:	f3 85       	ldd	r31, Z+11	; 0x0b
    aa4e:	e0 2d       	mov	r30, r0
    aa50:	e0 58       	subi	r30, 0x80	; 128
    aa52:	f1 09       	sbc	r31, r1
    aa54:	54 e0       	ldi	r21, 0x04	; 4
    aa56:	f6 95       	lsr	r31
    aa58:	e7 95       	ror	r30
    aa5a:	5a 95       	dec	r21
    aa5c:	e1 f7       	brne	.-8      	; 0xaa56 <Reader14443AAppProcess+0x4d2>
    aa5e:	e2 5a       	subi	r30, 0xA2	; 162
    aa60:	f2 4d       	sbci	r31, 0xD2	; 210
    aa62:	80 81       	ld	r24, Z
    aa64:	8f 5f       	subi	r24, 0xFF	; 255
    aa66:	80 83       	st	Z, r24
                if (TryCount == TRYCOUNT_MAX) {
    aa68:	80 91 d6 2d 	lds	r24, 0x2DD6	; 0x802dd6 <TryCount.7434>
    aa6c:	80 31       	cpi	r24, 0x10	; 16
    aa6e:	21 f4       	brne	.+8      	; 0xaa78 <Reader14443AAppProcess+0x4f4>
                    CodecThresholdIncrement();
    aa70:	0e 94 d4 26 	call	0x4da8	; 0x4da8 <CodecThresholdIncrement>
                    TryCount = 0;
    aa74:	10 92 d6 2d 	sts	0x2DD6, r1	; 0x802dd6 <TryCount.7434>
                }
                ReaderState = STATE_IDLE;
    aa78:	10 92 f6 2d 	sts	0x2DF6, r1	; 0x802df6 <ReaderState>
                Reader14443ACodecStart();
    aa7c:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
            return 0;
    }
}

INLINE uint16_t Reader14443A_Halt(uint8_t *Buffer) {
    Buffer[0] = ISO14443A_CMD_HLTA;
    aa80:	80 e5       	ldi	r24, 0x50	; 80
    aa82:	f7 01       	movw	r30, r14
    aa84:	80 83       	st	Z, r24
    Buffer[1] = 0x00;
    aa86:	11 82       	std	Z+1, r1	; 0x01
    ISO14443AAppendCRCA(Buffer, 2);
    aa88:	62 e0       	ldi	r22, 0x02	; 2
    aa8a:	70 e0       	ldi	r23, 0x00	; 0
    aa8c:	c7 01       	movw	r24, r14
    aa8e:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
    ReaderState = STATE_HALT;
    aa92:	81 e0       	ldi	r24, 0x01	; 1
    aa94:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <ReaderState>
    Selected = false;
    aa98:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
    return addParityBits(Buffer, 4 * BITS_PER_BYTE);
    aa9c:	60 e2       	ldi	r22, 0x20	; 32
    aa9e:	70 e0       	ldi	r23, 0x00	; 0
    aaa0:	c7 01       	movw	r24, r14
    aaa2:	97 d9       	rcall	.-3282   	; 0x9dd2 <addParityBits>
    aaa4:	8c 01       	movw	r16, r24
                    CodecThresholdIncrement();
                    TryCount = 0;
                }
                ReaderState = STATE_IDLE;
                Reader14443ACodecStart();
                return Reader14443A_Halt(Buffer);
    aaa6:	b5 c2       	rjmp	.+1386   	; 0xb012 <Reader14443AAppProcess+0xa8e>
        case Reader14443_Clone_MF_Ultralight:
        case Reader14443_Read_MF_Ultralight: {
            static uint8_t MFURead_CurrentAdress = 0;
            static uint8_t MFUContents[64];

            uint16_t rVal = Reader14443A_Select(Buffer, BitCount);
    aaa8:	cf 5b       	subi	r28, 0xBF	; 191
    aaaa:	dd 4f       	sbci	r29, 0xFD	; 253
    aaac:	68 81       	ld	r22, Y
    aaae:	79 81       	ldd	r23, Y+1	; 0x01
    aab0:	c1 54       	subi	r28, 0x41	; 65
    aab2:	d2 40       	sbci	r29, 0x02	; 2
    aab4:	c7 01       	movw	r24, r14
    aab6:	ec da       	rcall	.-2600   	; 0xa090 <Reader14443A_Select>
            if (Selected) {
    aab8:	20 91 f7 2d 	lds	r18, 0x2DF7	; 0x802df7 <Selected>
    aabc:	22 23       	and	r18, r18
    aabe:	09 f4       	brne	.+2      	; 0xaac2 <Reader14443AAppProcess+0x53e>
    aac0:	56 c2       	rjmp	.+1196   	; 0xaf6e <Reader14443AAppProcess+0x9ea>
                if (MFURead_CurrentAdress != 0) {
    aac2:	d0 90 5d 2d 	lds	r13, 0x2D5D	; 0x802d5d <MFURead_CurrentAdress.7464>
    aac6:	dd 20       	and	r13, r13
    aac8:	09 f4       	brne	.+2      	; 0xaacc <Reader14443AAppProcess+0x548>
    aaca:	45 c0       	rjmp	.+138    	; 0xab56 <Reader14443AAppProcess+0x5d2>
                    if (BitCount == 0) { // relaunch select protocol
    aacc:	cf 5b       	subi	r28, 0xBF	; 191
    aace:	dd 4f       	sbci	r29, 0xFD	; 253
    aad0:	08 81       	ld	r16, Y
    aad2:	19 81       	ldd	r17, Y+1	; 0x01
    aad4:	c1 54       	subi	r28, 0x41	; 65
    aad6:	d2 40       	sbci	r29, 0x02	; 2
    aad8:	01 15       	cp	r16, r1
    aada:	11 05       	cpc	r17, r1
    aadc:	49 f4       	brne	.+18     	; 0xaaf0 <Reader14443AAppProcess+0x56c>
                        MFURead_CurrentAdress = 0; // reset read address
    aade:	10 92 5d 2d 	sts	0x2D5D, r1	; 0x802d5d <MFURead_CurrentAdress.7464>
                        Selected = false;
    aae2:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
                        ReaderState = STATE_IDLE;
    aae6:	10 92 f6 2d 	sts	0x2DF6, r1	; 0x802df6 <ReaderState>
                        Reader14443ACodecStart();
    aaea:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
                        return 0;
                    }
                    bool readPageAgain = (BitCount < 162) || !checkParityBits(Buffer, BitCount);
    aaee:	91 c2       	rjmp	.+1314   	; 0xb012 <Reader14443AAppProcess+0xa8e>
    aaf0:	02 3a       	cpi	r16, 0xA2	; 162
    aaf2:	11 05       	cpc	r17, r1
    aaf4:	38 f0       	brcs	.+14     	; 0xab04 <Reader14443AAppProcess+0x580>
    aaf6:	b8 01       	movw	r22, r16
    aaf8:	c7 01       	movw	r24, r14
    aafa:	3e da       	rcall	.-2948   	; 0x9f78 <checkParityBits>
    aafc:	01 e0       	ldi	r16, 0x01	; 1
    aafe:	80 27       	eor	r24, r16
    ab00:	08 2f       	mov	r16, r24
    ab02:	02 c0       	rjmp	.+4      	; 0xab08 <Reader14443AAppProcess+0x584>
    ab04:	01 e0       	ldi	r16, 0x01	; 1
                    BitCount = removeParityBits(Buffer, BitCount);
    ab06:	10 e0       	ldi	r17, 0x00	; 0
    ab08:	cf 5b       	subi	r28, 0xBF	; 191
    ab0a:	dd 4f       	sbci	r29, 0xFD	; 253
    ab0c:	68 81       	ld	r22, Y
    ab0e:	79 81       	ldd	r23, Y+1	; 0x01
    ab10:	c1 54       	subi	r28, 0x41	; 65
    ab12:	d2 40       	sbci	r29, 0x02	; 2
    ab14:	c7 01       	movw	r24, r14
    ab16:	e0 d9       	rcall	.-3136   	; 0x9ed8 <removeParityBits>
    ab18:	cf 5b       	subi	r28, 0xBF	; 191
    ab1a:	dd 4f       	sbci	r29, 0xFD	; 253
    ab1c:	88 83       	st	Y, r24
    ab1e:	99 83       	std	Y+1, r25	; 0x01
    ab20:	c1 54       	subi	r28, 0x41	; 65
                    if (readPageAgain || ISO14443_CRCA(Buffer, 18)) { // the CRC function should return 0 if everything is ok
    ab22:	d2 40       	sbci	r29, 0x02	; 2
    ab24:	00 fd       	sbrc	r16, 0
    ab26:	05 c0       	rjmp	.+10     	; 0xab32 <Reader14443AAppProcess+0x5ae>
    ab28:	62 e1       	ldi	r22, 0x12	; 18
    ab2a:	c7 01       	movw	r24, r14
    ab2c:	8d da       	rcall	.-2790   	; 0xa048 <ISO14443_CRCA>
    ab2e:	89 2b       	or	r24, r25
    ab30:	29 f0       	breq	.+10     	; 0xab3c <Reader14443AAppProcess+0x5b8>
                        MFURead_CurrentAdress -= 4;
    ab32:	ac ef       	ldi	r26, 0xFC	; 252
    ab34:	ad 0d       	add	r26, r13
    ab36:	a0 93 5d 2d 	sts	0x2D5D, r26	; 0x802d5d <MFURead_CurrentAdress.7464>
    ab3a:	2a c0       	rjmp	.+84     	; 0xab90 <Reader14443AAppProcess+0x60c>
                    } else { // everything is ok for this page
                        memcpy(MFUContents + (MFURead_CurrentAdress - 4) * 4, Buffer, 16);
    ab3c:	f4 e0       	ldi	r31, 0x04	; 4
    ab3e:	df 9e       	mul	r13, r31
    ab40:	d0 01       	movw	r26, r0
    ab42:	11 24       	eor	r1, r1
    ab44:	a3 5f       	subi	r26, 0xF3	; 243
    ab46:	b2 4d       	sbci	r27, 0xD2	; 210
    ab48:	80 e1       	ldi	r24, 0x10	; 16
    ab4a:	f7 01       	movw	r30, r14
    ab4c:	01 90       	ld	r0, Z+
    ab4e:	0d 92       	st	X+, r0
    ab50:	8a 95       	dec	r24
    ab52:	e1 f7       	brne	.-8      	; 0xab4c <Reader14443AAppProcess+0x5c8>
    ab54:	1d c0       	rjmp	.+58     	; 0xab90 <Reader14443AAppProcess+0x60c>
                    }
                } else {
                    uint16_t RefATQA;
                    memcpy_P(&RefATQA, &CardIdentificationList[CardType_NXP_MIFARE_Ultralight].ATQA, 2);
    ab56:	42 e0       	ldi	r20, 0x02	; 2
    ab58:	50 e0       	ldi	r21, 0x00	; 0
    ab5a:	67 e0       	ldi	r22, 0x07	; 7
    ab5c:	75 e1       	ldi	r23, 0x15	; 21
    ab5e:	ce 01       	movw	r24, r28
    ab60:	01 96       	adiw	r24, 0x01	; 1
    ab62:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <memcpy_P>
                    uint8_t RefSAK = pgm_read_byte(&CardIdentificationList[CardType_NXP_MIFARE_Ultralight].SAK);
    ab66:	ea e0       	ldi	r30, 0x0A	; 10
    ab68:	f5 e1       	ldi	r31, 0x15	; 21
    ab6a:	e4 91       	lpm	r30, Z
                    if (CardCharacteristics.ATQA != RefATQA || CardCharacteristics.SAK != RefSAK) { // seems to be no MiFare Ultralight card, so retry
    ab6c:	20 91 e8 2d 	lds	r18, 0x2DE8	; 0x802de8 <CardCharacteristics>
    ab70:	30 91 e9 2d 	lds	r19, 0x2DE9	; 0x802de9 <CardCharacteristics+0x1>
    ab74:	89 81       	ldd	r24, Y+1	; 0x01
    ab76:	9a 81       	ldd	r25, Y+2	; 0x02
    ab78:	28 17       	cp	r18, r24
    ab7a:	39 07       	cpc	r19, r25
    ab7c:	21 f4       	brne	.+8      	; 0xab86 <Reader14443AAppProcess+0x602>
    ab7e:	80 91 ea 2d 	lds	r24, 0x2DEA	; 0x802dea <CardCharacteristics+0x2>
    ab82:	e8 17       	cp	r30, r24
    ab84:	29 f0       	breq	.+10     	; 0xab90 <Reader14443AAppProcess+0x60c>
                        ReaderState = STATE_IDLE;
    ab86:	10 92 f6 2d 	sts	0x2DF6, r1	; 0x802df6 <ReaderState>
                        Reader14443ACodecStart();
    ab8a:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <Reader14443ACodecStart>
    ab8e:	ec c1       	rjmp	.+984    	; 0xaf68 <Reader14443AAppProcess+0x9e4>
                        return 0;
                    }
                }
                if (MFURead_CurrentAdress == 16) {
    ab90:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <MFURead_CurrentAdress.7464>
    ab94:	80 31       	cpi	r24, 0x10	; 16
    ab96:	09 f0       	breq	.+2      	; 0xab9a <Reader14443AAppProcess+0x616>
    ab98:	6a c0       	rjmp	.+212    	; 0xac6e <Reader14443AAppProcess+0x6ea>
                    Selected = false;
    ab9a:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
                    MFURead_CurrentAdress = 0;
    ab9e:	10 92 5d 2d 	sts	0x2D5D, r1	; 0x802d5d <MFURead_CurrentAdress.7464>

                    if (Reader14443CurrentCommand == Reader14443_Read_MF_Ultralight) { // dump
    aba2:	80 91 1c 2d 	lds	r24, 0x2D1C	; 0x802d1c <Reader14443CurrentCommand>
                        Reader14443CurrentCommand = Reader14443_Do_Nothing;
    aba6:	10 92 1c 2d 	sts	0x2D1C, r1	; 0x802d1c <Reader14443CurrentCommand>
                }
                if (MFURead_CurrentAdress == 16) {
                    Selected = false;
                    MFURead_CurrentAdress = 0;

                    if (Reader14443CurrentCommand == Reader14443_Read_MF_Ultralight) { // dump
    abaa:	85 30       	cpi	r24, 0x05	; 5
    abac:	09 f0       	breq	.+2      	; 0xabb0 <Reader14443AAppProcess+0x62c>
    abae:	47 c0       	rjmp	.+142    	; 0xac3e <Reader14443AAppProcess+0x6ba>
                        Reader14443CurrentCommand = Reader14443_Do_Nothing;
                        char tmpBuf[135]; // 135 = 128 hex digits + 3 * \r\n + \0
                        BufferToHexString(tmpBuf, 							135, 							MFUContents, 16);
    abb0:	20 e1       	ldi	r18, 0x10	; 16
    abb2:	30 e0       	ldi	r19, 0x00	; 0
    abb4:	4d e1       	ldi	r20, 0x1D	; 29
    abb6:	5d e2       	ldi	r21, 0x2D	; 45
    abb8:	67 e8       	ldi	r22, 0x87	; 135
    abba:	70 e0       	ldi	r23, 0x00	; 0
    abbc:	ce 01       	movw	r24, r28
    abbe:	01 96       	adiw	r24, 0x01	; 1
    abc0:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
                        snprintf(tmpBuf + 32, 						135 - 32, 						"\r\n");
    abc4:	67 ee       	ldi	r22, 0xE7	; 231
    abc6:	73 e2       	ldi	r23, 0x23	; 35
    abc8:	ce 01       	movw	r24, r28
    abca:	81 96       	adiw	r24, 0x21	; 33
    abcc:	0e 94 cc 78 	call	0xf198	; 0xf198 <strcpy>
                        BufferToHexString(tmpBuf + 32 + 2, 					135 - 32 - 2, 					MFUContents + 16, 16);
    abd0:	20 e1       	ldi	r18, 0x10	; 16
    abd2:	30 e0       	ldi	r19, 0x00	; 0
    abd4:	4d e2       	ldi	r20, 0x2D	; 45
    abd6:	5d e2       	ldi	r21, 0x2D	; 45
    abd8:	65 e6       	ldi	r22, 0x65	; 101
    abda:	70 e0       	ldi	r23, 0x00	; 0
    abdc:	ce 01       	movw	r24, r28
    abde:	83 96       	adiw	r24, 0x23	; 35
    abe0:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
                        snprintf(tmpBuf + 32 + 2 + 32, 				135 - 32 - 2 - 32, 				"\r\n");
    abe4:	67 ee       	ldi	r22, 0xE7	; 231
    abe6:	73 e2       	ldi	r23, 0x23	; 35
    abe8:	ce 01       	movw	r24, r28
    abea:	8d 5b       	subi	r24, 0xBD	; 189
    abec:	9f 4f       	sbci	r25, 0xFF	; 255
    abee:	0e 94 cc 78 	call	0xf198	; 0xf198 <strcpy>
                        BufferToHexString(tmpBuf + 32 + 2 + 32 + 2, 			135 - 32 - 2 - 32 - 2, 			MFUContents + 32, 16);
    abf2:	20 e1       	ldi	r18, 0x10	; 16
    abf4:	30 e0       	ldi	r19, 0x00	; 0
    abf6:	4d e3       	ldi	r20, 0x3D	; 61
    abf8:	5d e2       	ldi	r21, 0x2D	; 45
    abfa:	63 e4       	ldi	r22, 0x43	; 67
    abfc:	70 e0       	ldi	r23, 0x00	; 0
    abfe:	ce 01       	movw	r24, r28
    ac00:	8b 5b       	subi	r24, 0xBB	; 187
    ac02:	9f 4f       	sbci	r25, 0xFF	; 255
    ac04:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
                        snprintf(tmpBuf + 32 + 2 + 32 + 2 + 32, 		135 - 32 - 2 - 32 - 2 - 32, 	"\r\n");
    ac08:	67 ee       	ldi	r22, 0xE7	; 231
    ac0a:	73 e2       	ldi	r23, 0x23	; 35
    ac0c:	ce 01       	movw	r24, r28
    ac0e:	8b 59       	subi	r24, 0x9B	; 155
    ac10:	9f 4f       	sbci	r25, 0xFF	; 255
    ac12:	0e 94 cc 78 	call	0xf198	; 0xf198 <strcpy>
                        BufferToHexString(tmpBuf + 32 + 2 + 32 + 2 + 32 + 2, 	135 - 32 - 2 - 32 - 2 - 32 - 2, MFUContents + 48, 16);
    ac16:	20 e1       	ldi	r18, 0x10	; 16
    ac18:	30 e0       	ldi	r19, 0x00	; 0
    ac1a:	4d e4       	ldi	r20, 0x4D	; 77
    ac1c:	5d e2       	ldi	r21, 0x2D	; 45
    ac1e:	61 e2       	ldi	r22, 0x21	; 33
    ac20:	70 e0       	ldi	r23, 0x00	; 0
    ac22:	ce 01       	movw	r24, r28
    ac24:	89 59       	subi	r24, 0x99	; 153
    ac26:	9f 4f       	sbci	r25, 0xFF	; 255
    ac28:	0e 94 32 11 	call	0x2264	; 0x2264 <BufferToHexString>
                        CodecReaderFieldStop();
    ac2c:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <CodecReaderFieldStop>
                        CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    ac30:	be 01       	movw	r22, r28
    ac32:	6f 5f       	subi	r22, 0xFF	; 255
    ac34:	7f 4f       	sbci	r23, 0xFF	; 255
    ac36:	85 e6       	ldi	r24, 0x65	; 101
    ac38:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
    ac3c:	95 c1       	rjmp	.+810    	; 0xaf68 <Reader14443AAppProcess+0x9e4>
                    } else { // clone
                        Reader14443CurrentCommand = Reader14443_Do_Nothing;
                        CodecReaderFieldStop();
    ac3e:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <CodecReaderFieldStop>
                        MemoryUploadBlock(&MFUContents, 0, 64);
    ac42:	20 e4       	ldi	r18, 0x40	; 64
    ac44:	30 e0       	ldi	r19, 0x00	; 0
    ac46:	40 e0       	ldi	r20, 0x00	; 0
    ac48:	50 e0       	ldi	r21, 0x00	; 0
    ac4a:	ba 01       	movw	r22, r20
    ac4c:	8d e1       	ldi	r24, 0x1D	; 29
    ac4e:	9d e2       	ldi	r25, 0x2D	; 45
    ac50:	0e 94 bf 13 	call	0x277e	; 0x277e <MemoryUploadBlock>
                        CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Card Cloned to Slot");
    ac54:	6f e0       	ldi	r22, 0x0F	; 15
    ac56:	74 e2       	ldi	r23, 0x24	; 36
    ac58:	85 e6       	ldi	r24, 0x65	; 101
    ac5a:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
                        ConfigurationSetById(CONFIG_MF_ULTRALIGHT);
    ac5e:	81 e0       	ldi	r24, 0x01	; 1
    ac60:	0e 94 95 10 	call	0x212a	; 0x212a <ConfigurationSetById>
                        MemoryStore();
    ac64:	0e 94 28 13 	call	0x2650	; 0x2650 <MemoryStore>
                        SettingsSave();
    ac68:	0e 94 b7 19 	call	0x336e	; 0x336e <SettingsSave>
    ac6c:	7d c1       	rjmp	.+762    	; 0xaf68 <Reader14443AAppProcess+0x9e4>
                    }
                    return 0;
                }
                Buffer[0] = 0x30; // MiFare Ultralight read command
    ac6e:	90 e3       	ldi	r25, 0x30	; 48
    ac70:	d7 01       	movw	r26, r14
    ac72:	9c 93       	st	X, r25
                Buffer[1] = MFURead_CurrentAdress;
    ac74:	11 96       	adiw	r26, 0x01	; 1
    ac76:	8c 93       	st	X, r24
                ISO14443AAppendCRCA(Buffer, 2);
    ac78:	62 e0       	ldi	r22, 0x02	; 2
    ac7a:	70 e0       	ldi	r23, 0x00	; 0
    ac7c:	c7 01       	movw	r24, r14
    ac7e:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>

                MFURead_CurrentAdress += 4;
    ac82:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <MFURead_CurrentAdress.7464>
    ac86:	8c 5f       	subi	r24, 0xFC	; 252
    ac88:	80 93 5d 2d 	sts	0x2D5D, r24	; 0x802d5d <MFURead_CurrentAdress.7464>

        /************************************
         * This function identifies a PICC. *
         ************************************/
        case Reader14443_Identify: {
            if (Identify(Buffer, &BitCount)) {
    ac8c:	07 cf       	rjmp	.-498    	; 0xaa9c <Reader14443AAppProcess+0x518>
    ac8e:	be 01       	movw	r22, r28
    ac90:	6f 5b       	subi	r22, 0xBF	; 191
    ac92:	7d 4f       	sbci	r23, 0xFD	; 253
    ac94:	c7 01       	movw	r24, r14
    ac96:	01 db       	rcall	.-2558   	; 0xa29a <Identify>
    ac98:	88 23       	and	r24, r24
    ac9a:	09 f4       	brne	.+2      	; 0xac9e <Reader14443AAppProcess+0x71a>
    ac9c:	e9 c0       	rjmp	.+466    	; 0xae70 <Reader14443AAppProcess+0x8ec>
                if (CardCandidatesIdx == 0) {
    ac9e:	80 91 d8 2d 	lds	r24, 0x2DD8	; 0x802dd8 <CardCandidatesIdx>
    aca2:	81 11       	cpse	r24, r1
    aca4:	03 c0       	rjmp	.+6      	; 0xacac <Reader14443AAppProcess+0x728>
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Unknown card type.");
    aca6:	63 e2       	ldi	r22, 0x23	; 35
    aca8:	74 e2       	ldi	r23, 0x24	; 36
    acaa:	27 c0       	rjmp	.+78     	; 0xacfa <Reader14443AAppProcess+0x776>
                } else if (CardCandidatesIdx == 1) {
    acac:	81 30       	cpi	r24, 0x01	; 1
    acae:	a1 f0       	breq	.+40     	; 0xacd8 <Reader14443AAppProcess+0x754>
    acb0:	91 2c       	mov	r9, r1
    acb2:	80 e0       	ldi	r24, 0x00	; 0
    acb4:	90 e0       	ldi	r25, 0x00	; 0
    acb6:	00 e0       	ldi	r16, 0x00	; 0
    acb8:	10 e0       	ldi	r17, 0x00	; 0

                    uint8_t i;
                    for (i = 0; i < CardCandidatesIdx; i++) {
                        if (size <= TERMINAL_BUFFER_SIZE) { // prevents buffer overflow
                            char tmpType[64];
                            memcpy_P(tmpType, &CardIdentificationList[CardCandidates[i]].Type, 64);
    acba:	27 e6       	ldi	r18, 0x67	; 103
    acbc:	82 2e       	mov	r8, r18
    acbe:	7e 01       	movw	r14, r28
    acc0:	bf ef       	ldi	r27, 0xFF	; 255
    acc2:	eb 1a       	sub	r14, r27
    acc4:	bd ef       	ldi	r27, 0xFD	; 253
    acc6:	fb 0a       	sbc	r15, r27
                            tmpsize = snprintf(tmpBuf + size, TERMINAL_BUFFER_SIZE - size, "%s or ", tmpType);
    acc8:	36 e3       	ldi	r19, 0x36	; 54
    acca:	c3 2e       	mov	r12, r19
    accc:	34 e2       	ldi	r19, 0x24	; 36
    acce:	d3 2e       	mov	r13, r19
    acd0:	a1 2c       	mov	r10, r1
    acd2:	42 e0       	ldi	r20, 0x02	; 2
    acd4:	b4 2e       	mov	r11, r20
    acd6:	40 c0       	rjmp	.+128    	; 0xad58 <Reader14443AAppProcess+0x7d4>
            if (Identify(Buffer, &BitCount)) {
                if (CardCandidatesIdx == 0) {
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Unknown card type.");
                } else if (CardCandidatesIdx == 1) {
                    char tmpType[64];
                    memcpy_P(tmpType, &CardIdentificationList[CardCandidates[0]].Type, 64);
    acd8:	60 91 d9 2d 	lds	r22, 0x2DD9	; 0x802dd9 <CardCandidates>
    acdc:	e7 e6       	ldi	r30, 0x67	; 103
    acde:	6e 9f       	mul	r22, r30
    ace0:	b0 01       	movw	r22, r0
    ace2:	11 24       	eor	r1, r1
    ace4:	67 50       	subi	r22, 0x07	; 7
    ace6:	7c 4e       	sbci	r23, 0xEC	; 236
    ace8:	40 e4       	ldi	r20, 0x40	; 64
    acea:	50 e0       	ldi	r21, 0x00	; 0
    acec:	ce 01       	movw	r24, r28
    acee:	01 96       	adiw	r24, 0x01	; 1
    acf0:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <memcpy_P>
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpType);
    acf4:	be 01       	movw	r22, r28
    acf6:	6f 5f       	subi	r22, 0xFF	; 255
    acf8:	7f 4f       	sbci	r23, 0xFF	; 255
    acfa:	85 e6       	ldi	r24, 0x65	; 101
    acfc:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
    ad00:	55 c0       	rjmp	.+170    	; 0xadac <Reader14443AAppProcess+0x828>
                    uint16_t size = 0, tmpsize = 0;
                    bool enoughspace = true;

                    uint8_t i;
                    for (i = 0; i < CardCandidatesIdx; i++) {
                        if (size <= TERMINAL_BUFFER_SIZE) { // prevents buffer overflow
    ad02:	01 30       	cpi	r16, 0x01	; 1
    ad04:	f2 e0       	ldi	r31, 0x02	; 2
    ad06:	1f 07       	cpc	r17, r31
    ad08:	60 f5       	brcc	.+88     	; 0xad62 <Reader14443AAppProcess+0x7de>
                            char tmpType[64];
                            memcpy_P(tmpType, &CardIdentificationList[CardCandidates[i]].Type, 64);
    ad0a:	e9 2d       	mov	r30, r9
    ad0c:	f0 e0       	ldi	r31, 0x00	; 0
    ad0e:	e7 52       	subi	r30, 0x27	; 39
    ad10:	f2 4d       	sbci	r31, 0xD2	; 210
    ad12:	60 81       	ld	r22, Z
    ad14:	86 9e       	mul	r8, r22
    ad16:	b0 01       	movw	r22, r0
    ad18:	11 24       	eor	r1, r1
    ad1a:	67 50       	subi	r22, 0x07	; 7
    ad1c:	7c 4e       	sbci	r23, 0xEC	; 236
    ad1e:	40 e4       	ldi	r20, 0x40	; 64
    ad20:	50 e0       	ldi	r21, 0x00	; 0
    ad22:	c7 01       	movw	r24, r14
    ad24:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <memcpy_P>
                            tmpsize = snprintf(tmpBuf + size, TERMINAL_BUFFER_SIZE - size, "%s or ", tmpType);
    ad28:	ff 92       	push	r15
    ad2a:	ef 92       	push	r14
    ad2c:	df 92       	push	r13
    ad2e:	cf 92       	push	r12
    ad30:	c5 01       	movw	r24, r10
    ad32:	80 1b       	sub	r24, r16
    ad34:	91 0b       	sbc	r25, r17
    ad36:	9f 93       	push	r25
    ad38:	8f 93       	push	r24
    ad3a:	81 e0       	ldi	r24, 0x01	; 1
    ad3c:	90 e0       	ldi	r25, 0x00	; 0
    ad3e:	8c 0f       	add	r24, r28
    ad40:	9d 1f       	adc	r25, r29
    ad42:	80 0f       	add	r24, r16
    ad44:	91 1f       	adc	r25, r17
    ad46:	9f 93       	push	r25
    ad48:	8f 93       	push	r24
    ad4a:	0e 94 d3 78 	call	0xf1a6	; 0xf1a6 <snprintf>
                            size += tmpsize;
    ad4e:	08 0f       	add	r16, r24
    ad50:	19 1f       	adc	r17, r25
                    char tmpBuf[TERMINAL_BUFFER_SIZE];
                    uint16_t size = 0, tmpsize = 0;
                    bool enoughspace = true;

                    uint8_t i;
                    for (i = 0; i < CardCandidatesIdx; i++) {
    ad52:	93 94       	inc	r9
    ad54:	cd bf       	out	0x3d, r28	; 61
    ad56:	de bf       	out	0x3e, r29	; 62
    ad58:	20 91 d8 2d 	lds	r18, 0x2DD8	; 0x802dd8 <CardCandidatesIdx>
    ad5c:	92 16       	cp	r9, r18
    ad5e:	88 f2       	brcs	.-94     	; 0xad02 <Reader14443AAppProcess+0x77e>
    ad60:	04 c0       	rjmp	.+8      	; 0xad6a <Reader14443AAppProcess+0x7e6>
                        } else {
                            break;
                        }
                    }
                    if (size > TERMINAL_BUFFER_SIZE) {
                        size -= tmpsize;
    ad62:	08 1b       	sub	r16, r24
    ad64:	19 0b       	sbc	r17, r25
                        enoughspace = false;
    ad66:	f1 2c       	mov	r15, r1
    ad68:	06 c0       	rjmp	.+12     	; 0xad76 <Reader14443AAppProcess+0x7f2>
                            size += tmpsize;
                        } else {
                            break;
                        }
                    }
                    if (size > TERMINAL_BUFFER_SIZE) {
    ad6a:	01 30       	cpi	r16, 0x01	; 1
    ad6c:	32 e0       	ldi	r19, 0x02	; 2
    ad6e:	13 07       	cpc	r17, r19
    ad70:	c0 f7       	brcc	.-16     	; 0xad62 <Reader14443AAppProcess+0x7de>
                    memcpy_P(tmpType, &CardIdentificationList[CardCandidates[0]].Type, 64);
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpType);
                } else {
                    char tmpBuf[TERMINAL_BUFFER_SIZE];
                    uint16_t size = 0, tmpsize = 0;
                    bool enoughspace = true;
    ad72:	ff 24       	eor	r15, r15
    ad74:	f3 94       	inc	r15
                    }
                    if (size > TERMINAL_BUFFER_SIZE) {
                        size -= tmpsize;
                        enoughspace = false;
                    }
                    tmpBuf[size - 4] = '.';
    ad76:	ed ef       	ldi	r30, 0xFD	; 253
    ad78:	ff ef       	ldi	r31, 0xFF	; 255
    ad7a:	ec 0f       	add	r30, r28
    ad7c:	fd 1f       	adc	r31, r29
    ad7e:	e0 0f       	add	r30, r16
    ad80:	f1 1f       	adc	r31, r17
    ad82:	8e e2       	ldi	r24, 0x2E	; 46
    ad84:	80 83       	st	Z, r24
                    tmpBuf[size - 3] = '\0';
    ad86:	ee ef       	ldi	r30, 0xFE	; 254
    ad88:	ff ef       	ldi	r31, 0xFF	; 255
    ad8a:	ec 0f       	add	r30, r28
    ad8c:	fd 1f       	adc	r31, r29
    ad8e:	e0 0f       	add	r30, r16
    ad90:	f1 1f       	adc	r31, r17
    ad92:	10 82       	st	Z, r1
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    ad94:	be 01       	movw	r22, r28
    ad96:	6f 5f       	subi	r22, 0xFF	; 255
    ad98:	7f 4f       	sbci	r23, 0xFF	; 255
    ad9a:	85 e6       	ldi	r24, 0x65	; 101
    ad9c:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
                    if (!enoughspace)
    ada0:	f1 10       	cpse	r15, r1
    ada2:	04 c0       	rjmp	.+8      	; 0xadac <Reader14443AAppProcess+0x828>
                        TerminalSendStringP(PSTR("There is at least one more card type candidate, but there was not enough terminal buffer space.\r\n"));
    ada4:	8f e5       	ldi	r24, 0x5F	; 95
    ada6:	93 e1       	ldi	r25, 0x13	; 19
    ada8:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
                }
                // print general data
                TerminalSendStringP(PSTR("ATQA:\t"));
    adac:	88 e5       	ldi	r24, 0x58	; 88
    adae:	93 e1       	ldi	r25, 0x13	; 19
    adb0:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
                CommandLineAppendData(&CardCharacteristics.ATQA, 2);
    adb4:	62 e0       	ldi	r22, 0x02	; 2
    adb6:	70 e0       	ldi	r23, 0x00	; 0
    adb8:	88 ee       	ldi	r24, 0xE8	; 232
    adba:	9d e2       	ldi	r25, 0x2D	; 45
    adbc:	0e 94 04 26 	call	0x4c08	; 0x4c08 <CommandLineAppendData>
                TerminalSendStringP(PSTR("UID:\t"));
    adc0:	82 e5       	ldi	r24, 0x52	; 82
    adc2:	93 e1       	ldi	r25, 0x13	; 19
    adc4:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
                CommandLineAppendData(CardCharacteristics.UID, CardCharacteristics.UIDSize);
    adc8:	60 91 f5 2d 	lds	r22, 0x2DF5	; 0x802df5 <CardCharacteristics+0xd>
    adcc:	70 e0       	ldi	r23, 0x00	; 0
    adce:	8b ee       	ldi	r24, 0xEB	; 235
    add0:	9d e2       	ldi	r25, 0x2D	; 45
    add2:	0e 94 04 26 	call	0x4c08	; 0x4c08 <CommandLineAppendData>
                TerminalSendStringP(PSTR("SAK:\t"));
    add6:	8c e4       	ldi	r24, 0x4C	; 76
    add8:	93 e1       	ldi	r25, 0x13	; 19
    adda:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
                CommandLineAppendData(&CardCharacteristics.SAK, 1);
    adde:	61 e0       	ldi	r22, 0x01	; 1
    ade0:	70 e0       	ldi	r23, 0x00	; 0
    ade2:	8a ee       	ldi	r24, 0xEA	; 234
    ade4:	9d e2       	ldi	r25, 0x2D	; 45
    ade6:	0e 94 04 26 	call	0x4c08	; 0x4c08 <CommandLineAppendData>
        }
        /****************************************
         * This function do simple cloning UID. *
         ****************************************/
        case Reader14443_Identify_Clone: {
            if (Identify(Buffer, &BitCount)) {
    adea:	39 c0       	rjmp	.+114    	; 0xae5e <Reader14443AAppProcess+0x8da>
    adec:	be 01       	movw	r22, r28
    adee:	6f 5b       	subi	r22, 0xBF	; 191
    adf0:	7d 4f       	sbci	r23, 0xFD	; 253
    adf2:	c7 01       	movw	r24, r14
    adf4:	52 da       	rcall	.-2908   	; 0xa29a <Identify>
    adf6:	88 23       	and	r24, r24
    adf8:	d9 f1       	breq	.+118    	; 0xae70 <Reader14443AAppProcess+0x8ec>
                if (CardCandidatesIdx == 1) {
    adfa:	80 91 d8 2d 	lds	r24, 0x2DD8	; 0x802dd8 <CardCandidatesIdx>
    adfe:	81 30       	cpi	r24, 0x01	; 1
    ae00:	49 f5       	brne	.+82     	; 0xae54 <Reader14443AAppProcess+0x8d0>
                    int cfgid = -1;
                    switch (CardCandidates[0]) {
    ae02:	80 91 d9 2d 	lds	r24, 0x2DD9	; 0x802dd9 <CardCandidates>
    ae06:	85 30       	cpi	r24, 0x05	; 5
    ae08:	09 f4       	brne	.+2      	; 0xae0c <Reader14443AAppProcess+0x888>
    ae0a:	c3 c0       	rjmp	.+390    	; 0xaf92 <Reader14443AAppProcess+0xa0e>
    ae0c:	48 f4       	brcc	.+18     	; 0xae20 <Reader14443AAppProcess+0x89c>
    ae0e:	82 30       	cpi	r24, 0x02	; 2
    ae10:	c1 f0       	breq	.+48     	; 0xae42 <Reader14443AAppProcess+0x8be>
    ae12:	83 30       	cpi	r24, 0x03	; 3
    ae14:	09 f4       	brne	.+2      	; 0xae18 <Reader14443AAppProcess+0x894>
    ae16:	bd c0       	rjmp	.+378    	; 0xaf92 <Reader14443AAppProcess+0xa0e>
    ae18:	81 30       	cpi	r24, 0x01	; 1
    ae1a:	09 f0       	breq	.+2      	; 0xae1e <Reader14443AAppProcess+0x89a>
    ae1c:	b7 c0       	rjmp	.+366    	; 0xaf8c <Reader14443AAppProcess+0xa08>
    ae1e:	08 c0       	rjmp	.+16     	; 0xae30 <Reader14443AAppProcess+0x8ac>
    ae20:	8a 30       	cpi	r24, 0x0A	; 10
    ae22:	31 f0       	breq	.+12     	; 0xae30 <Reader14443AAppProcess+0x8ac>
    ae24:	08 f4       	brcc	.+2      	; 0xae28 <Reader14443AAppProcess+0x8a4>
    ae26:	b2 c0       	rjmp	.+356    	; 0xaf8c <Reader14443AAppProcess+0xa08>
    ae28:	8d 50       	subi	r24, 0x0D	; 13
    ae2a:	82 30       	cpi	r24, 0x02	; 2
    ae2c:	50 f0       	brcs	.+20     	; 0xae42 <Reader14443AAppProcess+0x8be>
    ae2e:	ae c0       	rjmp	.+348    	; 0xaf8c <Reader14443AAppProcess+0xa08>
                            // Only set UL for DESFire_EV1 and read UID for some small tests - simple UID cloning
                            break;
                        }
                        case CardType_NXP_MIFARE_Classic_1k:
                        case CardType_Infineon_MIFARE_Classic_1k: {
                            if (CardCharacteristics.UIDSize == UIDSize_Single) {
    ae30:	80 91 f5 2d 	lds	r24, 0x2DF5	; 0x802df5 <CardCharacteristics+0xd>
    ae34:	84 30       	cpi	r24, 0x04	; 4
    ae36:	09 f4       	brne	.+2      	; 0xae3a <Reader14443AAppProcess+0x8b6>
    ae38:	ae c0       	rjmp	.+348    	; 0xaf96 <Reader14443AAppProcess+0xa12>
#ifdef CONFIG_MF_CLASSIC_1K_SUPPORT
                                cfgid = CONFIG_MF_CLASSIC_1K;
#endif
                            } else if (CardCharacteristics.UIDSize == UIDSize_Double) {
    ae3a:	87 30       	cpi	r24, 0x07	; 7
    ae3c:	09 f0       	breq	.+2      	; 0xae40 <Reader14443AAppProcess+0x8bc>
    ae3e:	a6 c0       	rjmp	.+332    	; 0xaf8c <Reader14443AAppProcess+0xa08>
    ae40:	ac c0       	rjmp	.+344    	; 0xaf9a <Reader14443AAppProcess+0xa16>
                            break;
                        }
                        case CardType_NXP_MIFARE_Classic_4k:
                        case CardType_Nokia_MIFARE_Classic_4k_emulated_6212:
                        case CardType_Nokia_MIFARE_Classic_4k_emulated_6131: {
                            if (CardCharacteristics.UIDSize == UIDSize_Single) {
    ae42:	80 91 f5 2d 	lds	r24, 0x2DF5	; 0x802df5 <CardCharacteristics+0xd>
    ae46:	84 30       	cpi	r24, 0x04	; 4
    ae48:	09 f4       	brne	.+2      	; 0xae4c <Reader14443AAppProcess+0x8c8>
    ae4a:	a9 c0       	rjmp	.+338    	; 0xaf9e <Reader14443AAppProcess+0xa1a>
#ifdef CONFIG_MF_CLASSIC_4K_SUPPORT
                                cfgid = CONFIG_MF_CLASSIC_4K;
#endif
                            } else if (CardCharacteristics.UIDSize == UIDSize_Double) {
    ae4c:	87 30       	cpi	r24, 0x07	; 7
    ae4e:	09 f0       	breq	.+2      	; 0xae52 <Reader14443AAppProcess+0x8ce>
    ae50:	9d c0       	rjmp	.+314    	; 0xaf8c <Reader14443AAppProcess+0xa08>
    ae52:	a7 c0       	rjmp	.+334    	; 0xafa2 <Reader14443AAppProcess+0xa1e>
                        SettingsSave();
                    } else {
                        CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Clone unsupported!");
                    }
                } else {
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Multiple possibilities, not clonable!");
    ae54:	6d e3       	ldi	r22, 0x3D	; 61
    ae56:	74 e2       	ldi	r23, 0x24	; 36
    ae58:	85 e6       	ldi	r24, 0x65	; 101
    ae5a:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
                }
                Reader14443CurrentCommand = Reader14443_Do_Nothing;
    ae5e:	10 92 1c 2d 	sts	0x2D1C, r1	; 0x802d1c <Reader14443CurrentCommand>
                CardCandidatesIdx = 0;
    ae62:	10 92 d8 2d 	sts	0x2DD8, r1	; 0x802dd8 <CardCandidatesIdx>
                CodecReaderFieldStop();
    ae66:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <CodecReaderFieldStop>
                Selected = false;
    ae6a:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
    ae6e:	7c c0       	rjmp	.+248    	; 0xaf68 <Reader14443AAppProcess+0x9e4>
                return 0;
            } else {
                return BitCount;
    ae70:	cf 5b       	subi	r28, 0xBF	; 191
    ae72:	dd 4f       	sbci	r29, 0xFD	; 253
    ae74:	08 81       	ld	r16, Y
    ae76:	19 81       	ldd	r17, Y+1	; 0x01
    ae78:	c1 54       	subi	r28, 0x41	; 65
    ae7a:	d2 40       	sbci	r29, 0x02	; 2
    ae7c:	ca c0       	rjmp	.+404    	; 0xb012 <Reader14443AAppProcess+0xa8e>
                            finished = true;
                        }

                        if (finished) {

                            RTState = RT_STATE_IDLE;
    ae7e:	10 92 d7 2d 	sts	0x2DD7, r1	; 0x802dd7 <RTState.7433>

                            if (maxdiff != 0)
    ae82:	00 97       	sbiw	r24, 0x00	; 0
    ae84:	09 f4       	brne	.+2      	; 0xae88 <Reader14443AAppProcess+0x904>
    ae86:	75 c0       	rjmp	.+234    	; 0xaf72 <Reader14443AAppProcess+0x9ee>
                                CodecThresholdSet((maxdiffoffset + maxdiff / 2) * CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
    ae88:	96 95       	lsr	r25
    ae8a:	87 95       	ror	r24
    ae8c:	28 5f       	subi	r18, 0xF8	; 248
    ae8e:	3f 4f       	sbci	r19, 0xFF	; 255
    ae90:	82 0f       	add	r24, r18
    ae92:	93 1f       	adc	r25, r19
    ae94:	54 e0       	ldi	r21, 0x04	; 4
    ae96:	88 0f       	add	r24, r24
    ae98:	99 1f       	adc	r25, r25
    ae9a:	5a 95       	dec	r21
    ae9c:	e1 f7       	brne	.-8      	; 0xae96 <Reader14443AAppProcess+0x912>
    ae9e:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <CodecThresholdSet>
                            else
                                CodecThresholdReset();
                            SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    aea2:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    aea6:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
        case 1:
            eeprom_update_byte((uint8_t *)EEAddr, *(uint8_t *)addr);
            break;

        case 2:
            eeprom_update_word((uint16_t *)EEAddr, *(uint16_t *)addr);
    aeaa:	62 85       	ldd	r22, Z+10	; 0x0a
    aeac:	73 85       	ldd	r23, Z+11	; 0x0b
    aeae:	cf 01       	movw	r24, r30
    aeb0:	8e 5c       	subi	r24, 0xCE	; 206
    aeb2:	9f 42       	sbci	r25, 0x2F	; 47
    aeb4:	8f 5f       	subi	r24, 0xFF	; 255
    aeb6:	9f 4f       	sbci	r25, 0xFF	; 255
    aeb8:	0e 94 4a 7f 	call	0xfe94	; 0xfe94 <eeprom_update_word>

                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
    aebc:	60 e0       	ldi	r22, 0x00	; 0
    aebe:	70 e0       	ldi	r23, 0x00	; 0
    aec0:	85 e6       	ldi	r24, 0x65	; 101
    aec2:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
                            uint16_t i_max = (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MAX)
    aec6:	01 15       	cp	r16, r1
    aec8:	18 40       	sbci	r17, 0x08	; 8
    aeca:	08 f4       	brcc	.+2      	; 0xaece <Reader14443AAppProcess+0x94a>
    aecc:	55 c0       	rjmp	.+170    	; 0xaf78 <Reader14443AAppProcess+0x9f4>
                                i_max = (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
    aece:	b8 e7       	ldi	r27, 0x78	; 120
    aed0:	ab 2e       	mov	r10, r27
    aed2:	b1 2c       	mov	r11, r1
    aed4:	0e e5       	ldi	r16, 0x5E	; 94
    aed6:	1d e2       	ldi	r17, 0x2D	; 45
    aed8:	60 e8       	ldi	r22, 0x80	; 128
    aeda:	e6 2e       	mov	r14, r22
    aedc:	f1 2c       	mov	r15, r1
                            for (i = 0; i < i_max; i++) {
                                char tmpBuf[10];
                                snprintf(tmpBuf, 10, "%4" PRIu16 ": ", i * CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
    aede:	75 e0       	ldi	r23, 0x05	; 5
    aee0:	67 2e       	mov	r6, r23
    aee2:	74 e2       	ldi	r23, 0x24	; 36
    aee4:	77 2e       	mov	r7, r23
    aee6:	ea e0       	ldi	r30, 0x0A	; 10
    aee8:	5e 2e       	mov	r5, r30
    aeea:	fe 01       	movw	r30, r28
    aeec:	31 96       	adiw	r30, 0x01	; 1
    aeee:	6f 01       	movw	r12, r30
                                TerminalSendString(tmpBuf);
                                if (Thresholds[i]) {
                                    snprintf(tmpBuf, 10, "%3" PRIu16, Thresholds[i]);
    aef0:	fb e0       	ldi	r31, 0x0B	; 11
    aef2:	8f 2e       	mov	r8, r31
    aef4:	f4 e2       	ldi	r31, 0x24	; 36
    aef6:	9f 2e       	mov	r9, r31
                            uint16_t i_max = (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MAX)
                                i_max = (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            for (i = 0; i < i_max; i++) {
                                char tmpBuf[10];
                                snprintf(tmpBuf, 10, "%4" PRIu16 ": ", i * CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
    aef8:	ff 92       	push	r15
    aefa:	ef 92       	push	r14
    aefc:	7f 92       	push	r7
    aefe:	6f 92       	push	r6
    af00:	1f 92       	push	r1
    af02:	5f 92       	push	r5
    af04:	df 92       	push	r13
    af06:	cf 92       	push	r12
    af08:	0e 94 d3 78 	call	0xf1a6	; 0xf1a6 <snprintf>
                                TerminalSendString(tmpBuf);
    af0c:	c6 01       	movw	r24, r12
    af0e:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>
                                if (Thresholds[i]) {
    af12:	d8 01       	movw	r26, r16
    af14:	8c 91       	ld	r24, X
    af16:	cd bf       	out	0x3d, r28	; 61
    af18:	de bf       	out	0x3e, r29	; 62
    af1a:	88 23       	and	r24, r24
    af1c:	89 f1       	breq	.+98     	; 0xaf80 <Reader14443AAppProcess+0x9fc>
                                    snprintf(tmpBuf, 10, "%3" PRIu16, Thresholds[i]);
    af1e:	1f 92       	push	r1
    af20:	8f 93       	push	r24
    af22:	9f 92       	push	r9
    af24:	8f 92       	push	r8
    af26:	1f 92       	push	r1
    af28:	5f 92       	push	r5
    af2a:	df 92       	push	r13
    af2c:	cf 92       	push	r12
    af2e:	0e 94 d3 78 	call	0xf1a6	; 0xf1a6 <snprintf>
                                    TerminalSendString(tmpBuf);
    af32:	c6 01       	movw	r24, r12
    af34:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>
    af38:	cd bf       	out	0x3d, r28	; 61
    af3a:	de bf       	out	0x3e, r29	; 62
                                } else {
                                    TerminalSendChar('-');
                                }
                                TerminalSendStringP(PSTR("\r\n"));
    af3c:	81 ec       	ldi	r24, 0xC1	; 193
    af3e:	93 e1       	ldi	r25, 0x13	; 19
    af40:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <TerminalSendStringP>
                                Thresholds[i] = 0; // reset the threshold so the next run won't show old results
    af44:	d8 01       	movw	r26, r16
    af46:	1d 92       	st	X+, r1
    af48:	8d 01       	movw	r16, r26
    af4a:	b0 e1       	ldi	r27, 0x10	; 16
    af4c:	eb 0e       	add	r14, r27
    af4e:	f1 1c       	adc	r15, r1

                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
                            uint16_t i_max = (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MAX)
                                i_max = (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            for (i = 0; i < i_max; i++) {
    af50:	c8 01       	movw	r24, r16
    af52:	8e 55       	subi	r24, 0x5E	; 94
    af54:	9d 42       	sbci	r25, 0x2D	; 45
    af56:	8a 15       	cp	r24, r10
    af58:	9b 05       	cpc	r25, r11
    af5a:	70 f2       	brcs	.-100    	; 0xaef8 <Reader14443AAppProcess+0x974>
                                TerminalSendStringP(PSTR("\r\n"));
                                Thresholds[i] = 0; // reset the threshold so the next run won't show old results
                            }


                            Selected = false;
    af5c:	10 92 f7 2d 	sts	0x2DF7, r1	; 0x802df7 <Selected>
                            Reader14443CurrentCommand = Reader14443_Do_Nothing;
    af60:	10 92 1c 2d 	sts	0x2D1C, r1	; 0x802d1c <Reader14443CurrentCommand>
                            Reader14443ACodecReset();
    af64:	0e 94 32 2f 	call	0x5e64	; 0x5e64 <Reader14443ACodecReset>
            }
            return 0;
        }

        default: // e.g. Do_Nothing
            return 0;
    af68:	00 e0       	ldi	r16, 0x00	; 0
    af6a:	10 e0       	ldi	r17, 0x00	; 0
    af6c:	52 c0       	rjmp	.+164    	; 0xb012 <Reader14443AAppProcess+0xa8e>

                MFURead_CurrentAdress += 4;

                return addParityBits(Buffer, 4 * BITS_PER_BYTE);
            }
            return rVal;
    af6e:	8c 01       	movw	r16, r24
    af70:	50 c0       	rjmp	.+160    	; 0xb012 <Reader14443AAppProcess+0xa8e>
                            RTState = RT_STATE_IDLE;

                            if (maxdiff != 0)
                                CodecThresholdSet((maxdiffoffset + maxdiff / 2) * CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
                            else
                                CodecThresholdReset();
    af72:	0e 94 e4 26 	call	0x4dc8	; 0x4dc8 <CodecThresholdReset>
    af76:	95 cf       	rjmp	.-214    	; 0xaea2 <Reader14443AAppProcess+0x91e>
                            SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);

                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
                            uint16_t i_max = (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
    af78:	a8 e2       	ldi	r26, 0x28	; 40
    af7a:	aa 2e       	mov	r10, r26
    af7c:	b1 2c       	mov	r11, r1
    af7e:	aa cf       	rjmp	.-172    	; 0xaed4 <Reader14443AAppProcess+0x950>
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    af80:	6d e2       	ldi	r22, 0x2D	; 45
    af82:	83 e0       	ldi	r24, 0x03	; 3
    af84:	90 e2       	ldi	r25, 0x20	; 32
    af86:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
    af8a:	d8 cf       	rjmp	.-80     	; 0xaf3c <Reader14443AAppProcess+0x9b8>
                        ApplicationReset();
                        ApplicationSetUid(CardCharacteristics.UID);
                        MemoryStore();
                        SettingsSave();
                    } else {
                        CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Clone unsupported!");
    af8c:	63 e6       	ldi	r22, 0x63	; 99
    af8e:	74 e2       	ldi	r23, 0x24	; 36
    af90:	63 cf       	rjmp	.-314    	; 0xae58 <Reader14443AAppProcess+0x8d4>
                if (CardCandidatesIdx == 1) {
                    int cfgid = -1;
                    switch (CardCandidates[0]) {
                        case CardType_NXP_MIFARE_Ultralight: {
#ifdef CONFIG_MF_ULTRALIGHT_SUPPORT
                            cfgid = CONFIG_MF_ULTRALIGHT;
    af92:	11 e0       	ldi	r17, 0x01	; 1
    af94:	07 c0       	rjmp	.+14     	; 0xafa4 <Reader14443AAppProcess+0xa20>
                        }
                        case CardType_NXP_MIFARE_Classic_1k:
                        case CardType_Infineon_MIFARE_Classic_1k: {
                            if (CardCharacteristics.UIDSize == UIDSize_Single) {
#ifdef CONFIG_MF_CLASSIC_1K_SUPPORT
                                cfgid = CONFIG_MF_CLASSIC_1K;
    af96:	16 e0       	ldi	r17, 0x06	; 6
    af98:	05 c0       	rjmp	.+10     	; 0xafa4 <Reader14443AAppProcess+0xa20>
#endif
                            } else if (CardCharacteristics.UIDSize == UIDSize_Double) {
#ifdef CONFIG_MF_CLASSIC_1K_7B_SUPPORT
                                cfgid = CONFIG_MF_CLASSIC_1K_7B;
    af9a:	17 e0       	ldi	r17, 0x07	; 7
    af9c:	03 c0       	rjmp	.+6      	; 0xafa4 <Reader14443AAppProcess+0xa20>
                        case CardType_NXP_MIFARE_Classic_4k:
                        case CardType_Nokia_MIFARE_Classic_4k_emulated_6212:
                        case CardType_Nokia_MIFARE_Classic_4k_emulated_6131: {
                            if (CardCharacteristics.UIDSize == UIDSize_Single) {
#ifdef CONFIG_MF_CLASSIC_4K_SUPPORT
                                cfgid = CONFIG_MF_CLASSIC_4K;
    af9e:	18 e0       	ldi	r17, 0x08	; 8
    afa0:	01 c0       	rjmp	.+2      	; 0xafa4 <Reader14443AAppProcess+0xa20>
#endif
                            } else if (CardCharacteristics.UIDSize == UIDSize_Double) {
#ifdef CONFIG_MF_CLASSIC_4K_7B_SUPPORT
                                cfgid = CONFIG_MF_CLASSIC_4K_7B;
    afa2:	19 e0       	ldi	r17, 0x09	; 9
                        default:
                            cfgid = -1;
                    }

                    if (cfgid > -1) {
                        CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Cloned OK!");
    afa4:	66 e7       	ldi	r22, 0x76	; 118
    afa6:	74 e2       	ldi	r23, 0x24	; 36
    afa8:	85 e6       	ldi	r24, 0x65	; 101
    afaa:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    afae:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    afb2:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    afb6:	87 81       	ldd	r24, Z+7	; 0x07
    afb8:	84 30       	cpi	r24, 0x04	; 4
    afba:	19 f4       	brne	.+6      	; 0xafc2 <Reader14443AAppProcess+0xa3e>
        LEDGreenAction = Action;
    afbc:	81 e2       	ldi	r24, 0x21	; 33
    afbe:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    afc2:	86 81       	ldd	r24, Z+6	; 0x06
    afc4:	84 30       	cpi	r24, 0x04	; 4
    afc6:	19 f4       	brne	.+6      	; 0xafce <Reader14443AAppProcess+0xa4a>
        LEDRedAction = Action;
    afc8:	81 e2       	ldi	r24, 0x21	; 33
    afca:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
                        /* Notify LED. blink when clone is done - ToDo: maybe use other LEDHook */
                        LEDHook(LED_SETTING_CHANGE, LED_BLINK_2X);
                        ConfigurationSetById(cfgid);
    afce:	81 2f       	mov	r24, r17
    afd0:	0e 94 95 10 	call	0x212a	; 0x212a <ConfigurationSetById>
    afd4:	e0 91 c5 2f 	lds	r30, 0x2FC5	; 0x802fc5 <ActiveConfiguration+0x8>
    afd8:	f0 91 c6 2f 	lds	r31, 0x2FC6	; 0x802fc6 <ActiveConfiguration+0x9>
    afdc:	19 95       	eicall
INLINE void ApplicationGetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationGetUidFunc(Uid);
}

INLINE void ApplicationSetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationSetUidFunc(Uid);
    afde:	e0 91 cf 2f 	lds	r30, 0x2FCF	; 0x802fcf <ActiveConfiguration+0x12>
    afe2:	f0 91 d0 2f 	lds	r31, 0x2FD0	; 0x802fd0 <ActiveConfiguration+0x13>
    afe6:	8b ee       	ldi	r24, 0xEB	; 235
    afe8:	9d e2       	ldi	r25, 0x2D	; 45
    afea:	19 95       	eicall
    afec:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    aff0:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    aff4:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    aff8:	6b ee       	ldi	r22, 0xEB	; 235
    affa:	7d e2       	ldi	r23, 0x2D	; 45
    affc:	83 e1       	ldi	r24, 0x13	; 19
    affe:	19 95       	eicall
                        ApplicationReset();
                        ApplicationSetUid(CardCharacteristics.UID);
                        MemoryStore();
    b000:	0e 94 28 13 	call	0x2650	; 0x2650 <MemoryStore>
                        SettingsSave();
    b004:	0e 94 b7 19 	call	0x336e	; 0x336e <SettingsSave>
    b008:	2a cf       	rjmp	.-428    	; 0xae5e <Reader14443AAppProcess+0x8da>
                                    if (!block) {
                                        block = true;
                                        min = i;
                                    }
                                } else {
                                    if (block) {
    b00a:	66 23       	and	r22, r22
    b00c:	09 f4       	brne	.+2      	; 0xb010 <Reader14443AAppProcess+0xa8c>
    b00e:	d9 cc       	rjmp	.-1614   	; 0xa9c2 <Reader14443AAppProcess+0x43e>
    b010:	ca cc       	rjmp	.-1644   	; 0xa9a6 <Reader14443AAppProcess+0x422>

        default: // e.g. Do_Nothing
            return 0;
    }
    return 0;
}
    b012:	c8 01       	movw	r24, r16
    b014:	ce 5b       	subi	r28, 0xBE	; 190
    b016:	dd 4f       	sbci	r29, 0xFD	; 253
    b018:	cd bf       	out	0x3d, r28	; 61
    b01a:	de bf       	out	0x3e, r29	; 62
    b01c:	df 91       	pop	r29
    b01e:	cf 91       	pop	r28
    b020:	1f 91       	pop	r17
    b022:	0f 91       	pop	r16
    b024:	ff 90       	pop	r15
    b026:	ef 90       	pop	r14
    b028:	df 90       	pop	r13
    b02a:	cf 90       	pop	r12
    b02c:	bf 90       	pop	r11
    b02e:	af 90       	pop	r10
    b030:	9f 90       	pop	r9
    b032:	8f 90       	pop	r8
    b034:	7f 90       	pop	r7
    b036:	6f 90       	pop	r6
    b038:	5f 90       	pop	r5
    b03a:	08 95       	ret

0000b03c <Sniff14443AAppInit>:
static uint16_t tmp_th = CODEC_THRESHOLD_CALIBRATE_MIN;
static uint8_t Thresholds[(CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) /
                          CODEC_THRESHOLD_CALIBRATE_STEPS] = {0};

void Sniff14443AAppInit(void) {
    SniffState = STATE_REQA;
    b03c:	81 e0       	ldi	r24, 0x01	; 1
    b03e:	80 93 71 2e 	sts	0x2E71, r24	; 0x802e71 <SniffState>
    // Get current threshold and continue searching from here
    tmp_th = GlobalSettings.ActiveSettingPtr->ReaderThreshold;
    b042:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    b046:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    b04a:	82 85       	ldd	r24, Z+10	; 0x0a
    b04c:	93 85       	ldd	r25, Z+11	; 0x0b
    b04e:	80 93 20 20 	sts	0x2020, r24	; 0x802020 <tmp_th>
    b052:	90 93 21 20 	sts	0x2021, r25	; 0x802021 <tmp_th+0x1>
    b056:	08 95       	ret

0000b058 <Sniff14443AAppReset>:
}

void Sniff14443AAppReset(void) {
    SniffState = STATE_IDLE;
    b058:	10 92 71 2e 	sts	0x2E71, r1	; 0x802e71 <SniffState>

    Sniff14443CurrentCommand = Sniff14443_Do_Nothing;
    b05c:	10 92 f8 2d 	sts	0x2DF8, r1	; 0x802df8 <Sniff14443CurrentCommand>
    b060:	08 95       	ret

0000b062 <Sniff14443AAppTask>:
    b062:	08 95       	ret

0000b064 <Sniff14443AAppTick>:
}
// Currently APPTask and AppTick is not being used
void Sniff14443AAppTask(void) {/* Empty */}
void Sniff14443AAppTick(void) {/* Empty */}
    b064:	08 95       	ret

0000b066 <Sniff14443AAppTimeout>:

void Sniff14443AAppTimeout(void) {
    Sniff14443AAppReset();
    b066:	f8 cf       	rjmp	.-16     	; 0xb058 <Sniff14443AAppReset>

0000b068 <Sniff14443AAppProcess>:
    } else {
        // mark finish
        CommandLinePendingTaskFinished(COMMAND_INFO_FALSE_ID, NULL);
    }
}
uint16_t Sniff14443AAppProcess(uint8_t *Buffer, uint16_t BitCount) {
    b068:	0f 93       	push	r16
    b06a:	1f 93       	push	r17
    b06c:	cf 93       	push	r28
    b06e:	df 93       	push	r29
    b070:	cd b7       	in	r28, 0x3d	; 61
    b072:	de b7       	in	r29, 0x3e	; 62
    b074:	2a 97       	sbiw	r28, 0x0a	; 10
    b076:	cd bf       	out	0x3d, r28	; 61
    b078:	de bf       	out	0x3e, r29	; 62
    switch (Sniff14443CurrentCommand) {
    b07a:	20 91 f8 2d 	lds	r18, 0x2DF8	; 0x802df8 <Sniff14443CurrentCommand>
    b07e:	21 30       	cpi	r18, 0x01	; 1
    b080:	09 f0       	breq	.+2      	; 0xb084 <Sniff14443AAppProcess+0x1c>
    b082:	23 c1       	rjmp	.+582    	; 0xb2ca <Sniff14443AAppProcess+0x262>
    b084:	8c 01       	movw	r16, r24
        case Sniff14443_Do_Nothing: {
            return 0;
        }
        case Sniff14443_Autocalibrate: {

            switch (SniffState) {
    b086:	80 91 71 2e 	lds	r24, 0x2E71	; 0x802e71 <SniffState>
    b08a:	83 30       	cpi	r24, 0x03	; 3
    b08c:	09 f4       	brne	.+2      	; 0xb090 <Sniff14443AAppProcess+0x28>
    b08e:	46 c0       	rjmp	.+140    	; 0xb11c <Sniff14443AAppProcess+0xb4>
    b090:	28 f4       	brcc	.+10     	; 0xb09c <Sniff14443AAppProcess+0x34>
    b092:	81 30       	cpi	r24, 0x01	; 1
    b094:	61 f0       	breq	.+24     	; 0xb0ae <Sniff14443AAppProcess+0x46>
    b096:	82 30       	cpi	r24, 0x02	; 2
    b098:	d1 f0       	breq	.+52     	; 0xb0ce <Sniff14443AAppProcess+0x66>
    b09a:	17 c1       	rjmp	.+558    	; 0xb2ca <Sniff14443AAppProcess+0x262>
    b09c:	85 30       	cpi	r24, 0x05	; 5
    b09e:	09 f4       	brne	.+2      	; 0xb0a2 <Sniff14443AAppProcess+0x3a>
    b0a0:	51 c0       	rjmp	.+162    	; 0xb144 <Sniff14443AAppProcess+0xdc>
    b0a2:	08 f4       	brcc	.+2      	; 0xb0a6 <Sniff14443AAppProcess+0x3e>
    b0a4:	74 c0       	rjmp	.+232    	; 0xb18e <Sniff14443AAppProcess+0x126>
    b0a6:	86 30       	cpi	r24, 0x06	; 6
    b0a8:	09 f4       	brne	.+2      	; 0xb0ac <Sniff14443AAppProcess+0x44>
    b0aa:	97 c0       	rjmp	.+302    	; 0xb1da <Sniff14443AAppProcess+0x172>
    b0ac:	0e c1       	rjmp	.+540    	; 0xb2ca <Sniff14443AAppProcess+0x262>
                case STATE_REQA:
                    LED_PORT.OUTCLR = LED_RED;
    b0ae:	88 e0       	ldi	r24, 0x08	; 8
    b0b0:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
                    // If received Reader REQA or WUPA
                    if (TrafficSource == TRAFFIC_READER &&
    b0b4:	80 91 b4 2e 	lds	r24, 0x2EB4	; 0x802eb4 <TrafficSource>
    b0b8:	81 11       	cpse	r24, r1
    b0ba:	07 c1       	rjmp	.+526    	; 0xb2ca <Sniff14443AAppProcess+0x262>
                            (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    b0bc:	f8 01       	movw	r30, r16
    b0be:	80 81       	ld	r24, Z

            switch (SniffState) {
                case STATE_REQA:
                    LED_PORT.OUTCLR = LED_RED;
                    // If received Reader REQA or WUPA
                    if (TrafficSource == TRAFFIC_READER &&
    b0c0:	86 32       	cpi	r24, 0x26	; 38
    b0c2:	19 f0       	breq	.+6      	; 0xb0ca <Sniff14443AAppProcess+0x62>
                            (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    b0c4:	82 35       	cpi	r24, 0x52	; 82
    b0c6:	09 f0       	breq	.+2      	; 0xb0ca <Sniff14443AAppProcess+0x62>
    b0c8:	00 c1       	rjmp	.+512    	; 0xb2ca <Sniff14443AAppProcess+0x262>
                        SniffState = STATE_ATQA;
    b0ca:	82 e0       	ldi	r24, 0x02	; 2
    b0cc:	74 c0       	rjmp	.+232    	; 0xb1b6 <Sniff14443AAppProcess+0x14e>
                        // Stay in this state, do noting
                    }
                    break;
                case STATE_ATQA:
                    // ATQA: P RRRR XXXX  P XXRX XXXX
                    if (TrafficSource == TRAFFIC_CARD &&
    b0ce:	80 91 b4 2e 	lds	r24, 0x2EB4	; 0x802eb4 <TrafficSource>
    b0d2:	81 30       	cpi	r24, 0x01	; 1
    b0d4:	b1 f4       	brne	.+44     	; 0xb102 <Sniff14443AAppProcess+0x9a>
    b0d6:	62 31       	cpi	r22, 0x12	; 18
    b0d8:	71 05       	cpc	r23, r1
    b0da:	99 f4       	brne	.+38     	; 0xb102 <Sniff14443AAppProcess+0x9a>
                            BitCount == 2 * 9 &&
    b0dc:	f8 01       	movw	r30, r16
    b0de:	80 81       	ld	r24, Z
    b0e0:	85 fd       	sbrc	r24, 5
    b0e2:	0f c0       	rjmp	.+30     	; 0xb102 <Sniff14443AAppProcess+0x9a>
                            (Buffer[0] & 0x20) == 0x00 &&        // Bit6 RFU shall be 0
    b0e4:	81 81       	ldd	r24, Z+1	; 0x01
    b0e6:	80 7e       	andi	r24, 0xE0	; 224
    b0e8:	61 f4       	brne	.+24     	; 0xb102 <Sniff14443AAppProcess+0x9a>
                            (Buffer[1] & 0xE0) == 0x00 &&      // bit13-16 RFU shall be 0
    b0ea:	82 81       	ldd	r24, Z+2	; 0x02
    b0ec:	80 fd       	sbrc	r24, 0
    b0ee:	09 c0       	rjmp	.+18     	; 0xb102 <Sniff14443AAppProcess+0x9a>
                            (Buffer[2] & 0x01) == 0x00 &&
                            checkParityBits(Buffer, BitCount)) {
    b0f0:	62 e1       	ldi	r22, 0x12	; 18
    b0f2:	70 e0       	ldi	r23, 0x00	; 0
    b0f4:	c8 01       	movw	r24, r16
    b0f6:	0e 94 bc 4f 	call	0x9f78	; 0x9f78 <checkParityBits>
                    // ATQA: P RRRR XXXX  P XXRX XXXX
                    if (TrafficSource == TRAFFIC_CARD &&
                            BitCount == 2 * 9 &&
                            (Buffer[0] & 0x20) == 0x00 &&        // Bit6 RFU shall be 0
                            (Buffer[1] & 0xE0) == 0x00 &&      // bit13-16 RFU shall be 0
                            (Buffer[2] & 0x01) == 0x00 &&
    b0fa:	88 23       	and	r24, r24
    b0fc:	11 f0       	breq	.+4      	; 0xb102 <Sniff14443AAppProcess+0x9a>
                            checkParityBits(Buffer, BitCount)) {
                        // Assume this is a good ATQA
                        SniffState = STATE_ANTICOLLI;
    b0fe:	83 e0       	ldi	r24, 0x03	; 3
    b100:	5a c0       	rjmp	.+180    	; 0xb1b6 <Sniff14443AAppProcess+0x14e>
                    } else {
                        // If not ATQA, but REQA, then stay on this state,
                        // Reset to REQA, save the counter and reset the counter
                        if (TrafficSource == TRAFFIC_READER &&
    b102:	80 91 b4 2e 	lds	r24, 0x2EB4	; 0x802eb4 <TrafficSource>
    b106:	81 11       	cpse	r24, r1
    b108:	59 c0       	rjmp	.+178    	; 0xb1bc <Sniff14443AAppProcess+0x154>
                                (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    b10a:	f8 01       	movw	r30, r16
    b10c:	80 81       	ld	r24, Z
                        // Assume this is a good ATQA
                        SniffState = STATE_ANTICOLLI;
                    } else {
                        // If not ATQA, but REQA, then stay on this state,
                        // Reset to REQA, save the counter and reset the counter
                        if (TrafficSource == TRAFFIC_READER &&
    b10e:	86 32       	cpi	r24, 0x26	; 38
    b110:	09 f4       	brne	.+2      	; 0xb114 <Sniff14443AAppProcess+0xac>
    b112:	db c0       	rjmp	.+438    	; 0xb2ca <Sniff14443AAppProcess+0x262>
                                (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    b114:	82 35       	cpi	r24, 0x52	; 82
    b116:	09 f0       	breq	.+2      	; 0xb11a <Sniff14443AAppProcess+0xb2>
    b118:	51 c0       	rjmp	.+162    	; 0xb1bc <Sniff14443AAppProcess+0x154>
    b11a:	d7 c0       	rjmp	.+430    	; 0xb2ca <Sniff14443AAppProcess+0x262>
                        }
                    }
                    break;
                case STATE_ANTICOLLI:
                    // SEL: 93/95/97
                    if (TrafficSource == TRAFFIC_READER &&
    b11c:	80 91 b4 2e 	lds	r24, 0x2EB4	; 0x802eb4 <TrafficSource>
    b120:	81 11       	cpse	r24, r1
    b122:	4c c0       	rjmp	.+152    	; 0xb1bc <Sniff14443AAppProcess+0x154>
    b124:	60 31       	cpi	r22, 0x10	; 16
    b126:	71 05       	cpc	r23, r1
    b128:	09 f0       	breq	.+2      	; 0xb12c <Sniff14443AAppProcess+0xc4>
    b12a:	48 c0       	rjmp	.+144    	; 0xb1bc <Sniff14443AAppProcess+0x154>
                            BitCount == 2 * 8 &&
                            (Buffer[0] & 0xf0) == 0x90 &&
    b12c:	f8 01       	movw	r30, r16
    b12e:	80 81       	ld	r24, Z
                    }
                    break;
                case STATE_ANTICOLLI:
                    // SEL: 93/95/97
                    if (TrafficSource == TRAFFIC_READER &&
                            BitCount == 2 * 8 &&
    b130:	98 2f       	mov	r25, r24
    b132:	90 7f       	andi	r25, 0xF0	; 240
    b134:	90 39       	cpi	r25, 0x90	; 144
    b136:	09 f0       	breq	.+2      	; 0xb13a <Sniff14443AAppProcess+0xd2>
    b138:	41 c0       	rjmp	.+130    	; 0xb1bc <Sniff14443AAppProcess+0x154>
                            (Buffer[0] & 0xf0) == 0x90 &&
    b13a:	89 70       	andi	r24, 0x09	; 9
    b13c:	81 30       	cpi	r24, 0x01	; 1
    b13e:	f1 f5       	brne	.+124    	; 0xb1bc <Sniff14443AAppProcess+0x154>
                            (Buffer[0] & 0x09) == 0x01) {
                        SniffState = STATE_UID;
    b140:	85 e0       	ldi	r24, 0x05	; 5
    b142:	39 c0       	rjmp	.+114    	; 0xb1b6 <Sniff14443AAppProcess+0x14e>
                    } else {
                        reset2REQA();
                    }
                    break;
                case STATE_UID:
                    if (TrafficSource == TRAFFIC_CARD &&
    b144:	80 91 b4 2e 	lds	r24, 0x2EB4	; 0x802eb4 <TrafficSource>
    b148:	81 30       	cpi	r24, 0x01	; 1
    b14a:	61 f4       	brne	.+24     	; 0xb164 <Sniff14443AAppProcess+0xfc>
    b14c:	6d 32       	cpi	r22, 0x2D	; 45
    b14e:	71 05       	cpc	r23, r1
    b150:	49 f4       	brne	.+18     	; 0xb164 <Sniff14443AAppProcess+0xfc>
                            BitCount == 5 * 9 &&
                            checkParityBits(Buffer, BitCount)) {
    b152:	6d e2       	ldi	r22, 0x2D	; 45
    b154:	70 e0       	ldi	r23, 0x00	; 0
    b156:	c8 01       	movw	r24, r16
    b158:	0e 94 bc 4f 	call	0x9f78	; 0x9f78 <checkParityBits>
                        reset2REQA();
                    }
                    break;
                case STATE_UID:
                    if (TrafficSource == TRAFFIC_CARD &&
                            BitCount == 5 * 9 &&
    b15c:	88 23       	and	r24, r24
    b15e:	11 f0       	breq	.+4      	; 0xb164 <Sniff14443AAppProcess+0xfc>
                            checkParityBits(Buffer, BitCount)) {
                        SniffState = STATE_SELECT;
    b160:	84 e0       	ldi	r24, 0x04	; 4
    b162:	29 c0       	rjmp	.+82     	; 0xb1b6 <Sniff14443AAppProcess+0x14e>
void Sniff14443AAppTimeout(void) {
    Sniff14443AAppReset();
}

INLINE void reset2REQA(void) {
    SniffState = STATE_REQA;
    b164:	81 e0       	ldi	r24, 0x01	; 1
    b166:	80 93 71 2e 	sts	0x2E71, r24	; 0x802e71 <SniffState>
    LED_PORT.OUTCLR = LED_RED;
    b16a:	88 e0       	ldi	r24, 0x08	; 8
    b16c:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>

    // Mark the current threshold as fail and continue
    if (tmp_th < CODEC_THRESHOLD_CALIBRATE_MAX) {
    b170:	80 91 20 20 	lds	r24, 0x2020	; 0x802020 <tmp_th>
    b174:	90 91 21 20 	lds	r25, 0x2021	; 0x802021 <tmp_th+0x1>
    b178:	81 15       	cp	r24, r1
    b17a:	28 e0       	ldi	r18, 0x08	; 8
    b17c:	92 07       	cpc	r25, r18
    b17e:	08 f4       	brcc	.+2      	; 0xb182 <Sniff14443AAppProcess+0x11a>
    b180:	93 c0       	rjmp	.+294    	; 0xb2a8 <Sniff14443AAppProcess+0x240>
        Thresholds[(tmp_th - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] = 0;
        tmp_th = CodecThresholdIncrement();
    } else {
        // mark finish
        CommandLinePendingTaskFinished(COMMAND_INFO_FALSE_ID, NULL);
    b182:	60 e0       	ldi	r22, 0x00	; 0
    b184:	70 e0       	ldi	r23, 0x00	; 0
    b186:	88 e7       	ldi	r24, 0x78	; 120
    b188:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
    b18c:	9e c0       	rjmp	.+316    	; 0xb2ca <Sniff14443AAppProcess+0x262>
                    }
                    break;
                case STATE_SELECT:

                    // SELECT: 9 bytes, SEL = 93/95/97, NVB=70
                    if (TrafficSource == TRAFFIC_READER &&
    b18e:	80 91 b4 2e 	lds	r24, 0x2EB4	; 0x802eb4 <TrafficSource>
    b192:	81 11       	cpse	r24, r1
    b194:	13 c0       	rjmp	.+38     	; 0xb1bc <Sniff14443AAppProcess+0x154>
    b196:	68 34       	cpi	r22, 0x48	; 72
    b198:	71 05       	cpc	r23, r1
    b19a:	81 f4       	brne	.+32     	; 0xb1bc <Sniff14443AAppProcess+0x154>
                            BitCount == 9 * 8 &&
                            (Buffer[0] & 0xf0) == 0x90 &&
    b19c:	f8 01       	movw	r30, r16
    b19e:	80 81       	ld	r24, Z
                    break;
                case STATE_SELECT:

                    // SELECT: 9 bytes, SEL = 93/95/97, NVB=70
                    if (TrafficSource == TRAFFIC_READER &&
                            BitCount == 9 * 8 &&
    b1a0:	98 2f       	mov	r25, r24
    b1a2:	90 7f       	andi	r25, 0xF0	; 240
    b1a4:	90 39       	cpi	r25, 0x90	; 144
    b1a6:	51 f4       	brne	.+20     	; 0xb1bc <Sniff14443AAppProcess+0x154>
                            (Buffer[0] & 0xf0) == 0x90 &&
    b1a8:	89 70       	andi	r24, 0x09	; 9
    b1aa:	81 30       	cpi	r24, 0x01	; 1
    b1ac:	39 f4       	brne	.+14     	; 0xb1bc <Sniff14443AAppProcess+0x154>
                            (Buffer[0] & 0x09) == 0x01 &&
    b1ae:	81 81       	ldd	r24, Z+1	; 0x01
    b1b0:	80 37       	cpi	r24, 0x70	; 112
    b1b2:	21 f4       	brne	.+8      	; 0xb1bc <Sniff14443AAppProcess+0x154>
                            Buffer[1] == 0x70) {
                        SniffState = STATE_SAK;
    b1b4:	86 e0       	ldi	r24, 0x06	; 6
    b1b6:	80 93 71 2e 	sts	0x2E71, r24	; 0x802e71 <SniffState>
    b1ba:	87 c0       	rjmp	.+270    	; 0xb2ca <Sniff14443AAppProcess+0x262>
void Sniff14443AAppTimeout(void) {
    Sniff14443AAppReset();
}

INLINE void reset2REQA(void) {
    SniffState = STATE_REQA;
    b1bc:	81 e0       	ldi	r24, 0x01	; 1
    b1be:	80 93 71 2e 	sts	0x2E71, r24	; 0x802e71 <SniffState>
    LED_PORT.OUTCLR = LED_RED;
    b1c2:	88 e0       	ldi	r24, 0x08	; 8
    b1c4:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>

    // Mark the current threshold as fail and continue
    if (tmp_th < CODEC_THRESHOLD_CALIBRATE_MAX) {
    b1c8:	80 91 20 20 	lds	r24, 0x2020	; 0x802020 <tmp_th>
    b1cc:	90 91 21 20 	lds	r25, 0x2021	; 0x802021 <tmp_th+0x1>
    b1d0:	81 15       	cp	r24, r1
    b1d2:	f8 e0       	ldi	r31, 0x08	; 8
    b1d4:	9f 07       	cpc	r25, r31
    b1d6:	a8 f6       	brcc	.-86     	; 0xb182 <Sniff14443AAppProcess+0x11a>
    b1d8:	67 c0       	rjmp	.+206    	; 0xb2a8 <Sniff14443AAppProcess+0x240>
                        reset2REQA();
                    }
                    break;
                case STATE_SAK:
                    // SAK: 1Byte SAK + CRC
                    if (TrafficSource == TRAFFIC_CARD &&
    b1da:	80 91 b4 2e 	lds	r24, 0x2EB4	; 0x802eb4 <TrafficSource>
    b1de:	81 30       	cpi	r24, 0x01	; 1
    b1e0:	09 f0       	breq	.+2      	; 0xb1e4 <Sniff14443AAppProcess+0x17c>
    b1e2:	53 c0       	rjmp	.+166    	; 0xb28a <Sniff14443AAppProcess+0x222>
    b1e4:	6b 31       	cpi	r22, 0x1B	; 27
    b1e6:	71 05       	cpc	r23, r1
    b1e8:	09 f0       	breq	.+2      	; 0xb1ec <Sniff14443AAppProcess+0x184>
    b1ea:	4f c0       	rjmp	.+158    	; 0xb28a <Sniff14443AAppProcess+0x222>
                            BitCount == 3 * 9 &&
                            checkParityBits(Buffer, BitCount)) {
    b1ec:	6b e1       	ldi	r22, 0x1B	; 27
    b1ee:	70 e0       	ldi	r23, 0x00	; 0
    b1f0:	c8 01       	movw	r24, r16
    b1f2:	0e 94 bc 4f 	call	0x9f78	; 0x9f78 <checkParityBits>
                    }
                    break;
                case STATE_SAK:
                    // SAK: 1Byte SAK + CRC
                    if (TrafficSource == TRAFFIC_CARD &&
                            BitCount == 3 * 9 &&
    b1f6:	88 23       	and	r24, r24
    b1f8:	09 f4       	brne	.+2      	; 0xb1fc <Sniff14443AAppProcess+0x194>
    b1fa:	47 c0       	rjmp	.+142    	; 0xb28a <Sniff14443AAppProcess+0x222>
                            checkParityBits(Buffer, BitCount)) {
                        if ((Buffer[0] & 0x04) == 0x00) {
    b1fc:	f8 01       	movw	r30, r16
    b1fe:	80 81       	ld	r24, Z
    b200:	82 fd       	sbrc	r24, 2
    b202:	7d cf       	rjmp	.-262    	; 0xb0fe <Sniff14443AAppProcess+0x96>
                            // UID complete, success SELECTED,
                            // Mark the current threshold as ok and finish
                            // reset
                            SniffState = STATE_REQA;
    b204:	81 e0       	ldi	r24, 0x01	; 1
    b206:	80 93 71 2e 	sts	0x2E71, r24	; 0x802e71 <SniffState>
                            LED_PORT.OUTSET = LED_RED;
    b20a:	88 e0       	ldi	r24, 0x08	; 8
    b20c:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
                            Thresholds[(tmp_th - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] += 1;
    b210:	e0 91 20 20 	lds	r30, 0x2020	; 0x802020 <tmp_th>
    b214:	f0 91 21 20 	lds	r31, 0x2021	; 0x802021 <tmp_th+0x1>
    b218:	e0 58       	subi	r30, 0x80	; 128
    b21a:	f1 09       	sbc	r31, r1
    b21c:	94 e0       	ldi	r25, 0x04	; 4
    b21e:	f6 95       	lsr	r31
    b220:	e7 95       	ror	r30
    b222:	9a 95       	dec	r25
    b224:	e1 f7       	brne	.-8      	; 0xb21e <Sniff14443AAppProcess+0x1b6>
    b226:	e7 50       	subi	r30, 0x07	; 7
    b228:	f2 4d       	sbci	r31, 0xD2	; 210
    b22a:	80 81       	ld	r24, Z
    b22c:	8f 5f       	subi	r24, 0xFF	; 255
    b22e:	80 83       	st	Z, r24
                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
    b230:	60 e0       	ldi	r22, 0x00	; 0
    b232:	70 e0       	ldi	r23, 0x00	; 0
    b234:	85 e6       	ldi	r24, 0x65	; 101
    b236:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <CommandLinePendingTaskFinished>
                            // Send this threshold to terminal
                            char tmpBuf[10];
                            snprintf(tmpBuf, 10, "%4" PRIu16 ": ", tmp_th);
    b23a:	80 91 21 20 	lds	r24, 0x2021	; 0x802021 <tmp_th+0x1>
    b23e:	8f 93       	push	r24
    b240:	80 91 20 20 	lds	r24, 0x2020	; 0x802020 <tmp_th>
    b244:	8f 93       	push	r24
    b246:	85 e0       	ldi	r24, 0x05	; 5
    b248:	94 e2       	ldi	r25, 0x24	; 36
    b24a:	9f 93       	push	r25
    b24c:	8f 93       	push	r24
    b24e:	1f 92       	push	r1
    b250:	8a e0       	ldi	r24, 0x0A	; 10
    b252:	8f 93       	push	r24
    b254:	8e 01       	movw	r16, r28
    b256:	0f 5f       	subi	r16, 0xFF	; 255
    b258:	1f 4f       	sbci	r17, 0xFF	; 255
    b25a:	1f 93       	push	r17
    b25c:	0f 93       	push	r16
    b25e:	0e 94 d3 78 	call	0xf1a6	; 0xf1a6 <snprintf>
                            TerminalSendString(tmpBuf);
    b262:	c8 01       	movw	r24, r16
    b264:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>

                            // Save value to EEPROM
                            SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    b268:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    b26c:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    b270:	62 85       	ldd	r22, Z+10	; 0x0a
    b272:	73 85       	ldd	r23, Z+11	; 0x0b
    b274:	cf 01       	movw	r24, r30
    b276:	8e 5c       	subi	r24, 0xCE	; 206
    b278:	9f 42       	sbci	r25, 0x2F	; 47
    b27a:	8f 5f       	subi	r24, 0xFF	; 255
    b27c:	9f 4f       	sbci	r25, 0xFF	; 255
    b27e:	0e 94 4a 7f 	call	0xfe94	; 0xfe94 <eeprom_update_word>

                            Sniff14443AAppReset();
    b282:	ea de       	rcall	.-556    	; 0xb058 <Sniff14443AAppReset>
    b284:	cd bf       	out	0x3d, r28	; 61
    b286:	de bf       	out	0x3e, r29	; 62
    b288:	20 c0       	rjmp	.+64     	; 0xb2ca <Sniff14443AAppProcess+0x262>
void Sniff14443AAppTimeout(void) {
    Sniff14443AAppReset();
}

INLINE void reset2REQA(void) {
    SniffState = STATE_REQA;
    b28a:	81 e0       	ldi	r24, 0x01	; 1
    b28c:	80 93 71 2e 	sts	0x2E71, r24	; 0x802e71 <SniffState>
    LED_PORT.OUTCLR = LED_RED;
    b290:	88 e0       	ldi	r24, 0x08	; 8
    b292:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>

    // Mark the current threshold as fail and continue
    if (tmp_th < CODEC_THRESHOLD_CALIBRATE_MAX) {
    b296:	80 91 20 20 	lds	r24, 0x2020	; 0x802020 <tmp_th>
    b29a:	90 91 21 20 	lds	r25, 0x2021	; 0x802021 <tmp_th+0x1>
    b29e:	81 15       	cp	r24, r1
    b2a0:	e8 e0       	ldi	r30, 0x08	; 8
    b2a2:	9e 07       	cpc	r25, r30
    b2a4:	08 f0       	brcs	.+2      	; 0xb2a8 <Sniff14443AAppProcess+0x240>
    b2a6:	6d cf       	rjmp	.-294    	; 0xb182 <Sniff14443AAppProcess+0x11a>
        Thresholds[(tmp_th - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] = 0;
    b2a8:	fc 01       	movw	r30, r24
    b2aa:	e0 58       	subi	r30, 0x80	; 128
    b2ac:	f1 09       	sbc	r31, r1
    b2ae:	84 e0       	ldi	r24, 0x04	; 4
    b2b0:	f6 95       	lsr	r31
    b2b2:	e7 95       	ror	r30
    b2b4:	8a 95       	dec	r24
    b2b6:	e1 f7       	brne	.-8      	; 0xb2b0 <Sniff14443AAppProcess+0x248>
    b2b8:	e7 50       	subi	r30, 0x07	; 7
    b2ba:	f2 4d       	sbci	r31, 0xD2	; 210
    b2bc:	10 82       	st	Z, r1
        tmp_th = CodecThresholdIncrement();
    b2be:	0e 94 d4 26 	call	0x4da8	; 0x4da8 <CodecThresholdIncrement>
    b2c2:	80 93 20 20 	sts	0x2020, r24	; 0x802020 <tmp_th>
    b2c6:	90 93 21 20 	sts	0x2021, r25	; 0x802021 <tmp_th+0x1>
        }
        default:
            return 0;
    }
    return 0;
}
    b2ca:	80 e0       	ldi	r24, 0x00	; 0
    b2cc:	90 e0       	ldi	r25, 0x00	; 0
    b2ce:	2a 96       	adiw	r28, 0x0a	; 10
    b2d0:	cd bf       	out	0x3d, r28	; 61
    b2d2:	de bf       	out	0x3e, r29	; 62
    b2d4:	df 91       	pop	r29
    b2d6:	cf 91       	pop	r28
    b2d8:	1f 91       	pop	r17
    b2da:	0f 91       	pop	r16
    b2dc:	08 95       	ret

0000b2de <NFCWritePage>:
        return false;
    }
}

/* Perform access verification and commit data if passed */
static uint8_t NFCWritePage(uint8_t PageAddress, uint8_t * const Buffer) {
    b2de:	98 2f       	mov	r25, r24
    if (!ActiveConfiguration.ReadOnly) {
    b2e0:	80 91 d4 2f 	lds	r24, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    b2e4:	81 11       	cpse	r24, r1
    b2e6:	0a c0       	rjmp	.+20     	; 0xb2fc <NFCWritePage+0x1e>
    b2e8:	9b 01       	movw	r18, r22
        MemoryWriteBlock(Buffer, PageAddress * NFC_COMMAND_PAGE_SIZE, NFC_COMMAND_PAGE_SIZE);
    b2ea:	84 e0       	ldi	r24, 0x04	; 4
    b2ec:	98 9f       	mul	r25, r24
    b2ee:	b0 01       	movw	r22, r0
    b2f0:	11 24       	eor	r1, r1
    b2f2:	44 e0       	ldi	r20, 0x04	; 4
    b2f4:	50 e0       	ldi	r21, 0x00	; 0
    b2f6:	c9 01       	movw	r24, r18
    b2f8:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    } else {
        /* If the chameleon is in read only mode, it silently
         * ignores any attempt to write data. */
    }
    return 0;
}
    b2fc:	80 e0       	ldi	r24, 0x00	; 0
    b2fe:	08 95       	ret

0000b300 <IncrementCounter>:
    }
    /* Otherwise, verify the accessed page is below the limit */
    return PageAddress < FirstAuthenticatedPage;
}

static bool IncrementCounter(uint8_t *IncrementValue) {
    b300:	0f 93       	push	r16
    b302:	1f 93       	push	r17
    b304:	cf 93       	push	r28
    b306:	df 93       	push	r29
    b308:	1f 92       	push	r1
    b30a:	1f 92       	push	r1
    b30c:	cd b7       	in	r28, 0x3d	; 61
    b30e:	de b7       	in	r29, 0x3e	; 62
    b310:	8c 01       	movw	r16, r24
    uint16_t CounterValue;
    MemoryReadBlock(&CounterValue, NFC_CMD_COUNTER_ADDRESS, 2);
    b312:	42 e0       	ldi	r20, 0x02	; 2
    b314:	50 e0       	ldi	r21, 0x00	; 0
    b316:	69 e2       	ldi	r22, 0x29	; 41
    b318:	70 e0       	ldi	r23, 0x00	; 0
    b31a:	ce 01       	movw	r24, r28
    b31c:	01 96       	adiw	r24, 0x01	; 1
    b31e:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    if (CounterValue == 0) {
    b322:	29 81       	ldd	r18, Y+1	; 0x01
    b324:	3a 81       	ldd	r19, Y+2	; 0x02
    b326:	f8 01       	movw	r30, r16
    b328:	90 81       	ld	r25, Z
    b32a:	21 15       	cp	r18, r1
    b32c:	31 05       	cpc	r19, r1
    b32e:	49 f4       	brne	.+18     	; 0xb342 <IncrementCounter+0x42>
        CounterValue = IncrementValue[0] + (IncrementValue[1] << 8);
    b330:	21 81       	ldd	r18, Z+1	; 0x01
    b332:	30 e0       	ldi	r19, 0x00	; 0
    b334:	32 2f       	mov	r19, r18
    b336:	22 27       	eor	r18, r18
    b338:	a9 01       	movw	r20, r18
    b33a:	49 0f       	add	r20, r25
    b33c:	51 1d       	adc	r21, r1
    b33e:	ca 01       	movw	r24, r20
    b340:	0d c0       	rjmp	.+26     	; 0xb35c <IncrementCounter+0x5c>
        MemoryWriteBlock(&CounterValue, NFC_CMD_COUNTER_ADDRESS, 2);
        return true;
    } else {
        IncrementValue[0] &= 0x0f;
    b342:	9f 70       	andi	r25, 0x0F	; 15
    b344:	f8 01       	movw	r30, r16
    b346:	90 83       	st	Z, r25
        if (IncrementValue[0] <= (0xffff - CounterValue)) {
    b348:	89 2f       	mov	r24, r25
    b34a:	90 e0       	ldi	r25, 0x00	; 0
    b34c:	a9 01       	movw	r20, r18
    b34e:	40 95       	com	r20
    b350:	50 95       	com	r21
    b352:	48 17       	cp	r20, r24
    b354:	59 07       	cpc	r21, r25
    b356:	70 f0       	brcs	.+28     	; 0xb374 <IncrementCounter+0x74>
            CounterValue += IncrementValue[0];
    b358:	82 0f       	add	r24, r18
    b35a:	93 1f       	adc	r25, r19
    b35c:	89 83       	std	Y+1, r24	; 0x01
    b35e:	9a 83       	std	Y+2, r25	; 0x02
            MemoryWriteBlock(&CounterValue, NFC_CMD_COUNTER_ADDRESS, 2);
    b360:	42 e0       	ldi	r20, 0x02	; 2
    b362:	50 e0       	ldi	r21, 0x00	; 0
    b364:	69 e2       	ldi	r22, 0x29	; 41
    b366:	70 e0       	ldi	r23, 0x00	; 0
    b368:	ce 01       	movw	r24, r28
    b36a:	01 96       	adiw	r24, 0x01	; 1
    b36c:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
            return true;
    b370:	81 e0       	ldi	r24, 0x01	; 1
    b372:	01 c0       	rjmp	.+2      	; 0xb376 <IncrementCounter+0x76>
        }
        return false;
    b374:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    b376:	0f 90       	pop	r0
    b378:	0f 90       	pop	r0
    b37a:	df 91       	pop	r29
    b37c:	cf 91       	pop	r28
    b37e:	1f 91       	pop	r17
    b380:	0f 91       	pop	r16
    b382:	08 95       	ret

0000b384 <NFCCommandAppInit>:
    ArmedForCompatWrite = false;
}

void NFCCommandAppInit(void) {
    /* Set up the emulation flavor */
    Flavor = UL_EV0;
    b384:	10 92 93 2e 	sts	0x2E93, r1	; 0x802e93 <Flavor>
    /* EV0 cards have fixed size */
    PageCount = NFC_COMMAND_PAGES;
    b388:	80 e1       	ldi	r24, 0x10	; 16
    b38a:	80 93 90 2e 	sts	0x2E90, r24	; 0x802e90 <PageCount>
    /* Default values */
    FirstAuthenticatedPage = 0xFF;
    b38e:	8f ef       	ldi	r24, 0xFF	; 255
    b390:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <FirstAuthenticatedPage>
    ReadAccessProtected = false;
    b394:	10 92 8b 2e 	sts	0x2E8B, r1	; 0x802e8b <ReadAccessProtected>
static bool ReadAccessProtected;
static uint8_t InitialVector[8] = {0};
static uint8_t TripleDesKey [16];

static void AppInitCommon(void) {
    State = STATE_IDLE;
    b398:	81 e0       	ldi	r24, 0x01	; 1
    b39a:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <State>
    FromHalt = false;
    b39e:	10 92 91 2e 	sts	0x2E91, r1	; 0x802e91 <FromHalt>
    Authenticated = false;
    b3a2:	10 92 8d 2e 	sts	0x2E8D, r1	; 0x802e8d <Authenticated>
    ArmedForCompatWrite = false;
    b3a6:	10 92 8f 2e 	sts	0x2E8F, r1	; 0x802e8f <ArmedForCompatWrite>
    b3aa:	08 95       	ret

0000b3ac <NFCCommandAppReset>:
    ReadAccessProtected = false;
    AppInitCommon();
}

void NFCCommandAppReset(void) {
    State = STATE_IDLE;
    b3ac:	81 e0       	ldi	r24, 0x01	; 1
    b3ae:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <State>
    b3b2:	08 95       	ret

0000b3b4 <NFCCommandAppTask>:
}

void NFCCommandAppTask(void) {
    b3b4:	08 95       	ret

0000b3b6 <NFCStatusId>:

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
}
//---- Writes the Status ID and message to pages -----
void NFCStatusId(const char *s) {
    b3b6:	ff 92       	push	r15
    b3b8:	0f 93       	push	r16
    b3ba:	1f 93       	push	r17
    b3bc:	cf 93       	push	r28
    b3be:	df 93       	push	r29
    b3c0:	cd b7       	in	r28, 0x3d	; 61
    b3c2:	de b7       	in	r29, 0x3e	; 62
    b3c4:	e0 97       	sbiw	r28, 0x30	; 48
    b3c6:	cd bf       	out	0x3d, r28	; 61
    b3c8:	de bf       	out	0x3e, r29	; 62
    b3ca:	48 2f       	mov	r20, r24
    uint8_t Status[48];
    uint8_t i = 0, k = 0;
    char c;

    while ((c = pgm_read_byte(s++)) != '\0') {
    b3cc:	fc 01       	movw	r30, r24
    b3ce:	8e 2f       	mov	r24, r30
    b3d0:	84 1b       	sub	r24, r20
    b3d2:	94 91       	lpm	r25, Z
    b3d4:	31 96       	adiw	r30, 0x01	; 1
    b3d6:	28 2f       	mov	r18, r24
    b3d8:	30 e0       	ldi	r19, 0x00	; 0
    b3da:	99 23       	and	r25, r25
    b3dc:	41 f0       	breq	.+16     	; 0xb3ee <NFCStatusId+0x38>
        Status[i] = c;
    b3de:	a1 e0       	ldi	r26, 0x01	; 1
    b3e0:	b0 e0       	ldi	r27, 0x00	; 0
    b3e2:	ac 0f       	add	r26, r28
    b3e4:	bd 1f       	adc	r27, r29
    b3e6:	a2 0f       	add	r26, r18
    b3e8:	b3 1f       	adc	r27, r19
    b3ea:	9c 93       	st	X, r25
    b3ec:	f0 cf       	rjmp	.-32     	; 0xb3ce <NFCStatusId+0x18>
        i++;
    }
    Status[i] = '\n';
    b3ee:	e1 e0       	ldi	r30, 0x01	; 1
    b3f0:	f0 e0       	ldi	r31, 0x00	; 0
    b3f2:	ec 0f       	add	r30, r28
    b3f4:	fd 1f       	adc	r31, r29
    b3f6:	e2 0f       	add	r30, r18
    b3f8:	f3 1f       	adc	r31, r19
    b3fa:	9a e0       	ldi	r25, 0x0A	; 10
    b3fc:	90 83       	st	Z, r25
    i++;
    for (i = i; i < 48; i++) {
    b3fe:	8f 5f       	subi	r24, 0xFF	; 255
    b400:	80 33       	cpi	r24, 0x30	; 48
    b402:	40 f4       	brcc	.+16     	; 0xb414 <NFCStatusId+0x5e>
        Status[i] = 0;
    b404:	e1 e0       	ldi	r30, 0x01	; 1
    b406:	f0 e0       	ldi	r31, 0x00	; 0
    b408:	ec 0f       	add	r30, r28
    b40a:	fd 1f       	adc	r31, r29
    b40c:	e8 0f       	add	r30, r24
    b40e:	f1 1d       	adc	r31, r1
    b410:	10 82       	st	Z, r1
    b412:	f5 cf       	rjmp	.-22     	; 0xb3fe <NFCStatusId+0x48>
    b414:	8e 01       	movw	r16, r28
    b416:	0f 5f       	subi	r16, 0xFF	; 255
    b418:	1f 4f       	sbci	r17, 0xFF	; 255
        Status[i] = c;
        i++;
    }
    Status[i] = '\n';
    i++;
    for (i = i; i < 48; i++) {
    b41a:	84 e0       	ldi	r24, 0x04	; 4
    b41c:	f8 2e       	mov	r15, r24
        Status[i] = 0;
    }
    for (uint8_t j = 4; j < 16; j++) {
        NFCWritePage(j, &Status[k]);
    b41e:	b8 01       	movw	r22, r16
    b420:	8f 2d       	mov	r24, r15
    b422:	5d df       	rcall	.-326    	; 0xb2de <NFCWritePage>
    Status[i] = '\n';
    i++;
    for (i = i; i < 48; i++) {
        Status[i] = 0;
    }
    for (uint8_t j = 4; j < 16; j++) {
    b424:	f3 94       	inc	r15
    b426:	0c 5f       	subi	r16, 0xFC	; 252
    b428:	1f 4f       	sbci	r17, 0xFF	; 255
    b42a:	80 e1       	ldi	r24, 0x10	; 16
    b42c:	f8 12       	cpse	r15, r24
    b42e:	f7 cf       	rjmp	.-18     	; 0xb41e <NFCStatusId+0x68>
        NFCWritePage(j, &Status[k]);
        k += 4;
    }
}
    b430:	e0 96       	adiw	r28, 0x30	; 48
    b432:	cd bf       	out	0x3d, r28	; 61
    b434:	de bf       	out	0x3e, r29	; 62
    b436:	df 91       	pop	r29
    b438:	cf 91       	pop	r28
    b43a:	1f 91       	pop	r17
    b43c:	0f 91       	pop	r16
    b43e:	ff 90       	pop	r15
    b440:	08 95       	ret

0000b442 <NFCAnswer>:

//---- Writes command response
void NFCAnswer(const char *s) {
    b442:	2f 92       	push	r2
    b444:	3f 92       	push	r3
    b446:	4f 92       	push	r4
    b448:	5f 92       	push	r5
    b44a:	6f 92       	push	r6
    b44c:	7f 92       	push	r7
    b44e:	8f 92       	push	r8
    b450:	9f 92       	push	r9
    b452:	af 92       	push	r10
    b454:	bf 92       	push	r11
    b456:	cf 92       	push	r12
    b458:	df 92       	push	r13
    b45a:	ef 92       	push	r14
    b45c:	ff 92       	push	r15
    b45e:	0f 93       	push	r16
    b460:	1f 93       	push	r17
    b462:	cf 93       	push	r28
    b464:	df 93       	push	r29
    b466:	cd b7       	in	r28, 0x3d	; 61
    b468:	de b7       	in	r29, 0x3e	; 62
    b46a:	e2 97       	sbiw	r28, 0x32	; 50
    b46c:	cd bf       	out	0x3d, r28	; 61
    b46e:	de bf       	out	0x3e, r29	; 62
    b470:	98 2e       	mov	r9, r24
    b472:	b9 2e       	mov	r11, r25
            t++;
        } else {
            t = 0;
        }
    }
}
    b474:	8d b7       	in	r24, 0x3d	; 61
    b476:	9e b7       	in	r25, 0x3e	; 62
    b478:	89 ab       	std	Y+49, r24	; 0x31
    b47a:	9a ab       	std	Y+50, r25	; 0x32

    uint8_t k = 0, i;

    const char *message;

    if (NFCResponse[0] != '\0') {
    b47c:	e0 91 3b 32 	lds	r30, 0x323B	; 0x80323b <NFCResponse>
    b480:	f0 91 3c 32 	lds	r31, 0x323C	; 0x80323c <NFCResponse+0x1>
    b484:	80 81       	ld	r24, Z
    b486:	88 23       	and	r24, r24
    b488:	09 f4       	brne	.+2      	; 0xb48c <NFCAnswer+0x4a>
    b48a:	7c c0       	rjmp	.+248    	; 0xb584 <NFCAnswer+0x142>
    b48c:	6d b6       	in	r6, 0x3d	; 61
    b48e:	7e b6       	in	r7, 0x3e	; 62
        message = s;
        float len = strlen(message); //length of message
    b490:	a9 2d       	mov	r26, r9
    b492:	bb 2d       	mov	r27, r11
    b494:	fd 01       	movw	r30, r26
    b496:	01 90       	ld	r0, Z+
    b498:	00 20       	and	r0, r0
    b49a:	e9 f7       	brne	.-6      	; 0xb496 <NFCAnswer+0x54>
    b49c:	31 97       	sbiw	r30, 0x01	; 1
    b49e:	bf 01       	movw	r22, r30
    b4a0:	6a 1b       	sub	r22, r26
    b4a2:	7b 0b       	sbc	r23, r27
    b4a4:	80 e0       	ldi	r24, 0x00	; 0
    b4a6:	90 e0       	ldi	r25, 0x00	; 0
    b4a8:	0e 94 f4 76 	call	0xede8	; 0xede8 <__floatunsisf>
    b4ac:	1b 01       	movw	r2, r22
    b4ae:	2c 01       	movw	r4, r24
        uint8_t m = ceil(len / 48); // number of writes needed
    b4b0:	20 e0       	ldi	r18, 0x00	; 0
    b4b2:	30 e0       	ldi	r19, 0x00	; 0
    b4b4:	40 e4       	ldi	r20, 0x40	; 64
    b4b6:	52 e4       	ldi	r21, 0x42	; 66
    b4b8:	0e 94 60 76 	call	0xecc0	; 0xecc0 <__divsf3>
    b4bc:	0e 94 4d 76 	call	0xec9a	; 0xec9a <ceil>
    b4c0:	0e 94 c8 76 	call	0xed90	; 0xed90 <__fixunssfsi>
        uint16_t n = m * 48; //number of bytes that will be sent
    b4c4:	90 e3       	ldi	r25, 0x30	; 48
    b4c6:	69 9f       	mul	r22, r25
    b4c8:	60 01       	movw	r12, r0
    b4ca:	11 24       	eor	r1, r1
        uint8_t Status[n];
    b4cc:	ad b7       	in	r26, 0x3d	; 61
    b4ce:	be b7       	in	r27, 0x3e	; 62
    b4d0:	ac 19       	sub	r26, r12
    b4d2:	bd 09       	sbc	r27, r13
    b4d4:	ad bf       	out	0x3d, r26	; 61
    b4d6:	be bf       	out	0x3e, r27	; 62
    b4d8:	0d b7       	in	r16, 0x3d	; 61
    b4da:	1e b7       	in	r17, 0x3e	; 62
    b4dc:	0f 5f       	subi	r16, 0xFF	; 255
    b4de:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t k = 0, i;

    const char *message;

    if (NFCResponse[0] != '\0') {
        message = s;
    b4e0:	e9 2c       	mov	r14, r9
    b4e2:	fb 2c       	mov	r15, r11
    b4e4:	8e 2c       	mov	r8, r14
    b4e6:	89 18       	sub	r8, r9
        uint8_t m = ceil(len / 48); // number of writes needed
        uint16_t n = m * 48; //number of bytes that will be sent
        uint8_t Status[n];


        for (i = 0; i < len; i++) {
    b4e8:	a8 2c       	mov	r10, r8
    b4ea:	b1 2c       	mov	r11, r1
    b4ec:	b5 01       	movw	r22, r10
    b4ee:	0b 2c       	mov	r0, r11
    b4f0:	00 0c       	add	r0, r0
    b4f2:	88 0b       	sbc	r24, r24
    b4f4:	99 0b       	sbc	r25, r25
    b4f6:	0e 94 f6 76 	call	0xedec	; 0xedec <__floatsisf>
    b4fa:	9b 01       	movw	r18, r22
    b4fc:	ac 01       	movw	r20, r24
    b4fe:	c2 01       	movw	r24, r4
    b500:	b1 01       	movw	r22, r2
    b502:	0e 94 c2 77 	call	0xef84	; 0xef84 <__gesf2>
    b506:	18 16       	cp	r1, r24
    b508:	44 f4       	brge	.+16     	; 0xb51a <NFCAnswer+0xd8>
            Status[i] = *message; //converts message to int array
    b50a:	f8 01       	movw	r30, r16
    b50c:	ea 0d       	add	r30, r10
    b50e:	fb 1d       	adc	r31, r11
    b510:	d7 01       	movw	r26, r14
    b512:	8d 91       	ld	r24, X+
    b514:	7d 01       	movw	r14, r26
    b516:	80 83       	st	Z, r24
    b518:	e5 cf       	rjmp	.-54     	; 0xb4e4 <NFCAnswer+0xa2>
            message++;
        }
        for (i = i + 1; i < n; i++) {
    b51a:	83 94       	inc	r8
    b51c:	88 2d       	mov	r24, r8
    b51e:	90 e0       	ldi	r25, 0x00	; 0
    b520:	8c 15       	cp	r24, r12
    b522:	9d 05       	cpc	r25, r13
    b524:	28 f4       	brcc	.+10     	; 0xb530 <NFCAnswer+0xee>
            Status[i] = '\0'; //pads with null characters
    b526:	f8 01       	movw	r30, r16
    b528:	e8 0f       	add	r30, r24
    b52a:	f9 1f       	adc	r31, r25
    b52c:	10 82       	st	Z, r1
    b52e:	f5 cf       	rjmp	.-22     	; 0xb51a <NFCAnswer+0xd8>
    b530:	80 91 72 2e 	lds	r24, 0x2E72	; 0x802e72 <t>
    b534:	90 e3       	ldi	r25, 0x30	; 48
    b536:	89 9f       	mul	r24, r25
    b538:	80 2d       	mov	r24, r0
    b53a:	11 24       	eor	r1, r1
    b53c:	f8 01       	movw	r30, r16
    b53e:	e8 0f       	add	r30, r24
    b540:	f1 1d       	adc	r31, r1
    b542:	ce 01       	movw	r24, r28
    b544:	01 96       	adiw	r24, 0x01	; 1
    b546:	7c 01       	movw	r14, r24
    b548:	c0 96       	adiw	r24, 0x30	; 48
        }

        uint8_t tmpBuffer[48];
        uint8_t q = t * 48; //number of characters into message that have been written
    b54a:	d7 01       	movw	r26, r14
        for (uint8_t i = 0; i < 48; i++) {
            tmpBuffer[i] = Status[q + i];
    b54c:	21 91       	ld	r18, Z+
    b54e:	2d 93       	st	X+, r18
            Status[i] = '\0'; //pads with null characters
        }

        uint8_t tmpBuffer[48];
        uint8_t q = t * 48; //number of characters into message that have been written
        for (uint8_t i = 0; i < 48; i++) {
    b550:	a8 17       	cp	r26, r24
    b552:	b9 07       	cpc	r27, r25
    b554:	d9 f7       	brne	.-10     	; 0xb54c <NFCAnswer+0x10a>
    b556:	14 e0       	ldi	r17, 0x04	; 4
            tmpBuffer[i] = Status[q + i];
        }

        for (uint8_t j = 4; j < 16; j++) {
            NFCWritePage(j, &tmpBuffer[k]); //write message
    b558:	b7 01       	movw	r22, r14
    b55a:	81 2f       	mov	r24, r17
    b55c:	c0 de       	rcall	.-640    	; 0xb2de <NFCWritePage>
        uint8_t q = t * 48; //number of characters into message that have been written
        for (uint8_t i = 0; i < 48; i++) {
            tmpBuffer[i] = Status[q + i];
        }

        for (uint8_t j = 4; j < 16; j++) {
    b55e:	1f 5f       	subi	r17, 0xFF	; 255
    b560:	94 e0       	ldi	r25, 0x04	; 4
    b562:	e9 0e       	add	r14, r25
    b564:	f1 1c       	adc	r15, r1
    b566:	10 31       	cpi	r17, 0x10	; 16
    b568:	b9 f7       	brne	.-18     	; 0xb558 <NFCAnswer+0x116>
            NFCWritePage(j, &tmpBuffer[k]); //write message
            k += 4;
        }
        if (tmpBuffer[47] != '\0') {
    b56a:	88 a9       	ldd	r24, Y+48	; 0x30
    b56c:	88 23       	and	r24, r24
    b56e:	31 f0       	breq	.+12     	; 0xb57c <NFCAnswer+0x13a>
            t++;
    b570:	80 91 72 2e 	lds	r24, 0x2E72	; 0x802e72 <t>
    b574:	8f 5f       	subi	r24, 0xFF	; 255
    b576:	80 93 72 2e 	sts	0x2E72, r24	; 0x802e72 <t>
    b57a:	02 c0       	rjmp	.+4      	; 0xb580 <NFCAnswer+0x13e>
        } else {
            t = 0;
    b57c:	10 92 72 2e 	sts	0x2E72, r1	; 0x802e72 <t>
    b580:	6d be       	out	0x3d, r6	; 61
    b582:	7e be       	out	0x3e, r7	; 62
        }
    }
}
    b584:	a9 a9       	ldd	r26, Y+49	; 0x31
    b586:	ba a9       	ldd	r27, Y+50	; 0x32
    b588:	ad bf       	out	0x3d, r26	; 61
    b58a:	be bf       	out	0x3e, r27	; 62
    b58c:	e2 96       	adiw	r28, 0x32	; 50
    b58e:	cd bf       	out	0x3d, r28	; 61
    b590:	de bf       	out	0x3e, r29	; 62
    b592:	df 91       	pop	r29
    b594:	cf 91       	pop	r28
    b596:	1f 91       	pop	r17
    b598:	0f 91       	pop	r16
    b59a:	ff 90       	pop	r15
    b59c:	ef 90       	pop	r14
    b59e:	df 90       	pop	r13
    b5a0:	cf 90       	pop	r12
    b5a2:	bf 90       	pop	r11
    b5a4:	af 90       	pop	r10
    b5a6:	9f 90       	pop	r9
    b5a8:	8f 90       	pop	r8
    b5aa:	7f 90       	pop	r7
    b5ac:	6f 90       	pop	r6
    b5ae:	5f 90       	pop	r5
    b5b0:	4f 90       	pop	r4
    b5b2:	3f 90       	pop	r3
    b5b4:	2f 90       	pop	r2
    b5b6:	08 95       	ret

0000b5b8 <NFCCommandAppProcess>:
    // Command not handled. Switch to idle. 
    State = STATE_IDLE;
    return ISO14443A_APP_NO_RESPONSE;
}

uint16_t NFCCommandAppProcess(uint8_t *Buffer, uint16_t BitCount) {
    b5b8:	af 92       	push	r10
    b5ba:	bf 92       	push	r11
    b5bc:	cf 92       	push	r12
    b5be:	df 92       	push	r13
    b5c0:	ef 92       	push	r14
    b5c2:	ff 92       	push	r15
    b5c4:	0f 93       	push	r16
    b5c6:	1f 93       	push	r17
    b5c8:	cf 93       	push	r28
    b5ca:	df 93       	push	r29
    b5cc:	cd b7       	in	r28, 0x3d	; 61
    b5ce:	de b7       	in	r29, 0x3e	; 62
    b5d0:	60 97       	sbiw	r28, 0x10	; 16
    b5d2:	cd bf       	out	0x3d, r28	; 61
    b5d4:	de bf       	out	0x3e, r29	; 62
    b5d6:	7c 01       	movw	r14, r24
    uint8_t Cmd = Buffer[0];
    b5d8:	fc 01       	movw	r30, r24
    b5da:	80 81       	ld	r24, Z
    uint16_t ByteCount;

    switch (State) {
    b5dc:	90 91 92 2e 	lds	r25, 0x2E92	; 0x802e92 <State>
    b5e0:	92 30       	cpi	r25, 0x02	; 2
    b5e2:	e9 f0       	breq	.+58     	; 0xb61e <NFCCommandAppProcess+0x66>
    b5e4:	38 f0       	brcs	.+14     	; 0xb5f4 <NFCCommandAppProcess+0x3c>
    b5e6:	94 30       	cpi	r25, 0x04	; 4
    b5e8:	71 f1       	breq	.+92     	; 0xb646 <NFCCommandAppProcess+0x8e>
    b5ea:	18 f1       	brcs	.+70     	; 0xb632 <NFCCommandAppProcess+0x7a>
    b5ec:	96 30       	cpi	r25, 0x06	; 6
    b5ee:	09 f4       	brne	.+2      	; 0xb5f2 <NFCCommandAppProcess+0x3a>
    b5f0:	4c c0       	rjmp	.+152    	; 0xb68a <NFCCommandAppProcess+0xd2>
    b5f2:	4c c1       	rjmp	.+664    	; 0xb88c <NFCCommandAppProcess+0x2d4>
        case STATE_IDLE:
        case STATE_HALT:
            FromHalt = State == STATE_HALT;
    b5f4:	29 2f       	mov	r18, r25
    b5f6:	20 95       	com	r18
    b5f8:	21 70       	andi	r18, 0x01	; 1
    b5fa:	20 93 91 2e 	sts	0x2E91, r18	; 0x802e91 <FromHalt>

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    b5fe:	99 23       	and	r25, r25
    b600:	11 f0       	breq	.+4      	; 0xb606 <NFCCommandAppProcess+0x4e>
    b602:	86 32       	cpi	r24, 0x26	; 38
    b604:	19 f0       	breq	.+6      	; 0xb60c <NFCCommandAppProcess+0x54>
    b606:	82 35       	cpi	r24, 0x52	; 82
    b608:	09 f0       	breq	.+2      	; 0xb60c <NFCCommandAppProcess+0x54>
    b60a:	40 c1       	rjmp	.+640    	; 0xb88c <NFCCommandAppProcess+0x2d4>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    b60c:	84 e4       	ldi	r24, 0x44	; 68
    b60e:	f7 01       	movw	r30, r14
    b610:	80 83       	st	Z, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    b612:	11 82       	std	Z+1, r1	; 0x01
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                // We received a REQA or WUPA command, so wake up. 
                State = STATE_READY1;
    b614:	82 e0       	ldi	r24, 0x02	; 2
    b616:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <State>

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;
    b61a:	80 e1       	ldi	r24, 0x10	; 16
    b61c:	38 c1       	rjmp	.+624    	; 0xb88e <NFCCommandAppProcess+0x2d6>
                return BitCount;
            }
            break;

        case STATE_READY1:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    b61e:	90 91 91 2e 	lds	r25, 0x2E91	; 0x802e91 <FromHalt>

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    b622:	91 11       	cpse	r25, r1
    b624:	02 c0       	rjmp	.+4      	; 0xb62a <NFCCommandAppProcess+0x72>
    b626:	86 32       	cpi	r24, 0x26	; 38
    b628:	b9 f0       	breq	.+46     	; 0xb658 <NFCCommandAppProcess+0xa0>
    b62a:	82 35       	cpi	r24, 0x52	; 82
    b62c:	09 f0       	breq	.+2      	; 0xb630 <NFCCommandAppProcess+0x78>
    b62e:	64 c0       	rjmp	.+200    	; 0xb6f8 <NFCCommandAppProcess+0x140>
    b630:	13 c0       	rjmp	.+38     	; 0xb658 <NFCCommandAppProcess+0xa0>
                State = STATE_IDLE;
            }
            break;

        case STATE_READY2:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    b632:	90 91 91 2e 	lds	r25, 0x2E91	; 0x802e91 <FromHalt>
    b636:	91 11       	cpse	r25, r1
    b638:	02 c0       	rjmp	.+4      	; 0xb63e <NFCCommandAppProcess+0x86>
    b63a:	86 32       	cpi	r24, 0x26	; 38
    b63c:	69 f0       	breq	.+26     	; 0xb658 <NFCCommandAppProcess+0xa0>
    b63e:	82 35       	cpi	r24, 0x52	; 82
    b640:	09 f0       	breq	.+2      	; 0xb644 <NFCCommandAppProcess+0x8c>
    b642:	8c c0       	rjmp	.+280    	; 0xb75c <NFCCommandAppProcess+0x1a4>
    b644:	09 c0       	rjmp	.+18     	; 0xb658 <NFCCommandAppProcess+0xa0>
            break;

        case STATE_ACTIVE:
            /* Preserve incoming data length */
            ByteCount = (BitCount + 7) >> 3;
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    b646:	90 91 91 2e 	lds	r25, 0x2E91	; 0x802e91 <FromHalt>
    b64a:	91 11       	cpse	r25, r1
    b64c:	02 c0       	rjmp	.+4      	; 0xb652 <NFCCommandAppProcess+0x9a>
    b64e:	86 32       	cpi	r24, 0x26	; 38
    b650:	19 f0       	breq	.+6      	; 0xb658 <NFCCommandAppProcess+0xa0>
    b652:	82 35       	cpi	r24, 0x52	; 82
    b654:	09 f0       	breq	.+2      	; 0xb658 <NFCCommandAppProcess+0xa0>
    b656:	2a c1       	rjmp	.+596    	; 0xb8ac <NFCCommandAppProcess+0x2f4>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    b658:	84 e4       	ldi	r24, 0x44	; 68
    b65a:	f7 01       	movw	r30, r14
    b65c:	80 83       	st	Z, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    b65e:	11 82       	std	Z+1, r1	; 0x01
                State = FromHalt ? STATE_HALT : STATE_IDLE;
    b660:	81 e0       	ldi	r24, 0x01	; 1
    b662:	89 27       	eor	r24, r25
    b664:	0f c0       	rjmp	.+30     	; 0xb684 <NFCCommandAppProcess+0xcc>
/* Handles processing of MF commands */
static uint16_t AppProcess(uint8_t * const Buffer, uint16_t ByteCount) {
    uint8_t Cmd = Buffer[0];

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
    b666:	80 91 8f 2e 	lds	r24, 0x2E8F	; 0x802e8f <ArmedForCompatWrite>
    b66a:	81 11       	cpse	r24, r1
    b66c:	33 c1       	rjmp	.+614    	; 0xb8d4 <NFCCommandAppProcess+0x31c>
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

    /* Handle EV0 commands */
    switch (Cmd) {
    b66e:	f7 01       	movw	r30, r14
    b670:	80 81       	ld	r24, Z
    b672:	80 35       	cpi	r24, 0x50	; 80
    b674:	09 f4       	brne	.+2      	; 0xb678 <NFCCommandAppProcess+0xc0>
    b676:	d6 c1       	rjmp	.+940    	; 0xba24 <NFCCommandAppProcess+0x46c>
    b678:	08 f0       	brcs	.+2      	; 0xb67c <NFCCommandAppProcess+0xc4>
    b67a:	3e c1       	rjmp	.+636    	; 0xb8f8 <NFCCommandAppProcess+0x340>
    b67c:	80 33       	cpi	r24, 0x30	; 48
    b67e:	09 f4       	brne	.+2      	; 0xb682 <NFCCommandAppProcess+0xca>
    b680:	4d c1       	rjmp	.+666    	; 0xb91c <NFCCommandAppProcess+0x364>
        default:
            break;
    }

    // Command not handled. Switch to idle. 
    State = STATE_IDLE;
    b682:	81 e0       	ldi	r24, 0x01	; 1
    b684:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <State>
    b688:	01 c1       	rjmp	.+514    	; 0xb88c <NFCCommandAppProcess+0x2d4>
            return AppProcess(Buffer, ByteCount);

        case STATE_AUTH: // ULC Authing
            ByteCount = (BitCount + 7) >> 3;
            /* We check if we received an auth message */
            if (Buffer[0] == CMD_ULC_AUTH_2 && ISO14443ACheckCRCA(Buffer, ByteCount - 2)) {
    b68a:	8f 3a       	cpi	r24, 0xAF	; 175
    b68c:	69 f5       	brne	.+90     	; 0xb6e8 <NFCCommandAppProcess+0x130>
    b68e:	69 5f       	subi	r22, 0xF9	; 249
    b690:	7f 4f       	sbci	r23, 0xFF	; 255
    b692:	93 e0       	ldi	r25, 0x03	; 3
    b694:	76 95       	lsr	r23
    b696:	67 95       	ror	r22
    b698:	9a 95       	dec	r25
    b69a:	e1 f7       	brne	.-8      	; 0xb694 <NFCCommandAppProcess+0xdc>
    b69c:	62 50       	subi	r22, 0x02	; 2
    b69e:	71 09       	sbc	r23, r1
    b6a0:	c7 01       	movw	r24, r14
    b6a2:	0e 94 8b 41 	call	0x8316	; 0x8316 <ISO14443ACheckCRCA>
    b6a6:	88 23       	and	r24, r24
    b6a8:	f9 f0       	breq	.+62     	; 0xb6e8 <NFCCommandAppProcess+0x130>
                uint8_t tmpBuff [8];
                uint8_t RNDA [8] = {0};
    b6aa:	ae 01       	movw	r20, r28
    b6ac:	4f 5f       	subi	r20, 0xFF	; 255
    b6ae:	5f 4f       	sbci	r21, 0xFF	; 255
    b6b0:	88 e0       	ldi	r24, 0x08	; 8
    b6b2:	fa 01       	movw	r30, r20
    b6b4:	11 92       	st	Z+, r1
    b6b6:	8a 95       	dec	r24
    b6b8:	e9 f7       	brne	.-6      	; 0xb6b4 <NFCCommandAppProcess+0xfc>
                CryptoDecrypt2KTDEA_CBCReceive(1, &Buffer[1], RNDA, InitialVector, TripleDesKey);
    b6ba:	03 e7       	ldi	r16, 0x73	; 115
    b6bc:	1e e2       	ldi	r17, 0x2E	; 46
    b6be:	23 e8       	ldi	r18, 0x83	; 131
    b6c0:	3e e2       	ldi	r19, 0x2E	; 46
    b6c2:	b7 01       	movw	r22, r14
    b6c4:	6f 5f       	subi	r22, 0xFF	; 255
    b6c6:	7f 4f       	sbci	r23, 0xFF	; 255
    b6c8:	81 e0       	ldi	r24, 0x01	; 1
    b6ca:	90 e0       	ldi	r25, 0x00	; 0
    b6cc:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <CryptoDecrypt2KTDEA_CBCReceive>

                CryptoDecrypt2KTDEA_CBCReceive(1, &Buffer[9], tmpBuff, InitialVector, TripleDesKey);
    b6d0:	23 e8       	ldi	r18, 0x83	; 131
    b6d2:	3e e2       	ldi	r19, 0x2E	; 46
    b6d4:	ae 01       	movw	r20, r28
    b6d6:	47 5f       	subi	r20, 0xF7	; 247
    b6d8:	5f 4f       	sbci	r21, 0xFF	; 255
    b6da:	b7 01       	movw	r22, r14
    b6dc:	67 5f       	subi	r22, 0xF7	; 247
    b6de:	7f 4f       	sbci	r23, 0xFF	; 255
    b6e0:	81 e0       	ldi	r24, 0x01	; 1
    b6e2:	90 e0       	ldi	r25, 0x00	; 0
    b6e4:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <CryptoDecrypt2KTDEA_CBCReceive>

            }

            State = STATE_IDLE;
    b6e8:	81 e0       	ldi	r24, 0x01	; 1
    b6ea:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <State>
            Buffer[0] = NAK_AUTH_FAILED;
    b6ee:	86 e0       	ldi	r24, 0x06	; 6
    b6f0:	f7 01       	movw	r30, r14
    b6f2:	80 83       	st	Z, r24
            return NAK_FRAME_SIZE;
    b6f4:	84 e0       	ldi	r24, 0x04	; 4
    b6f6:	cb c0       	rjmp	.+406    	; 0xb88e <NFCCommandAppProcess+0x2d6>

        case STATE_READY1:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Cmd == ISO14443A_CMD_SELECT_CL1) {
    b6f8:	83 39       	cpi	r24, 0x93	; 147
    b6fa:	19 f6       	brne	.-122    	; 0xb682 <NFCCommandAppProcess+0xca>
                /* Load UID CL1 and perform anticollision. Since
                 * MF Ultralight use a double-sized UID, the first byte
                 * of CL1 has to be the cascade-tag byte. */
                uint8_t UidCL1[ISO14443A_CL_UID_SIZE] = {[0] = ISO14443A_UID0_CT};
    b6fc:	19 82       	std	Y+1, r1	; 0x01
    b6fe:	1a 82       	std	Y+2, r1	; 0x02
    b700:	1b 82       	std	Y+3, r1	; 0x03
    b702:	1c 82       	std	Y+4, r1	; 0x04
    b704:	88 e8       	ldi	r24, 0x88	; 136
    b706:	89 83       	std	Y+1, r24	; 0x01

                MemoryReadBlock(&UidCL1[1], UID_CL1_ADDRESS, UID_CL1_SIZE);
    b708:	43 e0       	ldi	r20, 0x03	; 3
    b70a:	50 e0       	ldi	r21, 0x00	; 0
    b70c:	60 e0       	ldi	r22, 0x00	; 0
    b70e:	70 e0       	ldi	r23, 0x00	; 0
    b710:	ce 01       	movw	r24, r28
    b712:	02 96       	adiw	r24, 0x02	; 2
    b714:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    b718:	f7 01       	movw	r30, r14
    b71a:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    b71c:	80 32       	cpi	r24, 0x20	; 32
    b71e:	09 f4       	brne	.+2      	; 0xb722 <NFCCommandAppProcess+0x16a>
    b720:	a6 c0       	rjmp	.+332    	; 0xb86e <NFCCommandAppProcess+0x2b6>
    b722:	80 37       	cpi	r24, 0x70	; 112
    b724:	09 f0       	breq	.+2      	; 0xb728 <NFCCommandAppProcess+0x170>
    b726:	48 c0       	rjmp	.+144    	; 0xb7b8 <NFCCommandAppProcess+0x200>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    b728:	f7 01       	movw	r30, r14
    b72a:	92 81       	ldd	r25, Z+2	; 0x02
    b72c:	89 81       	ldd	r24, Y+1	; 0x01
    b72e:	98 13       	cpse	r25, r24
    b730:	ad c0       	rjmp	.+346    	; 0xb88c <NFCCommandAppProcess+0x2d4>
    b732:	93 81       	ldd	r25, Z+3	; 0x03
    b734:	8a 81       	ldd	r24, Y+2	; 0x02
    b736:	98 13       	cpse	r25, r24
    b738:	a9 c0       	rjmp	.+338    	; 0xb88c <NFCCommandAppProcess+0x2d4>
                    (DataPtr[3] == UidCL[1]) &&
    b73a:	94 81       	ldd	r25, Z+4	; 0x04
    b73c:	8b 81       	ldd	r24, Y+3	; 0x03
    b73e:	98 13       	cpse	r25, r24
    b740:	a5 c0       	rjmp	.+330    	; 0xb88c <NFCCommandAppProcess+0x2d4>
                    (DataPtr[4] == UidCL[2]) &&
    b742:	95 81       	ldd	r25, Z+5	; 0x05
    b744:	8c 81       	ldd	r24, Y+4	; 0x04
    b746:	98 13       	cpse	r25, r24
    b748:	a1 c0       	rjmp	.+322    	; 0xb88c <NFCCommandAppProcess+0x2d4>
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    b74a:	84 e0       	ldi	r24, 0x04	; 4
    b74c:	80 83       	st	Z, r24
                ISO14443AAppendCRCA(Buffer, 1);
    b74e:	61 e0       	ldi	r22, 0x01	; 1
    b750:	70 e0       	ldi	r23, 0x00	; 0
    b752:	c7 01       	movw	r24, r14
    b754:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>

                if (ISO14443ASelect(Buffer, &BitCount, UidCL1, SAK_CL1_VALUE)) {
                    /* CL1 stage has ended successfully */
                    State = STATE_READY2;
    b758:	83 e0       	ldi	r24, 0x03	; 3
    b75a:	2a c0       	rjmp	.+84     	; 0xb7b0 <NFCCommandAppProcess+0x1f8>

        case STATE_READY2:
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            } else if (Cmd == ISO14443A_CMD_SELECT_CL2) {
    b75c:	85 39       	cpi	r24, 0x95	; 149
    b75e:	09 f0       	breq	.+2      	; 0xb762 <NFCCommandAppProcess+0x1aa>
    b760:	90 cf       	rjmp	.-224    	; 0xb682 <NFCCommandAppProcess+0xca>
                /* Load UID CL2 and perform anticollision */
                uint8_t UidCL2[ISO14443A_CL_UID_SIZE];

                MemoryReadBlock(UidCL2, UID_CL2_ADDRESS, UID_CL2_SIZE);
    b762:	44 e0       	ldi	r20, 0x04	; 4
    b764:	50 e0       	ldi	r21, 0x00	; 0
    b766:	64 e0       	ldi	r22, 0x04	; 4
    b768:	70 e0       	ldi	r23, 0x00	; 0
    b76a:	ce 01       	movw	r24, r28
    b76c:	01 96       	adiw	r24, 0x01	; 1
    b76e:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    b772:	f7 01       	movw	r30, r14
    b774:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    b776:	80 32       	cpi	r24, 0x20	; 32
    b778:	09 f4       	brne	.+2      	; 0xb77c <NFCCommandAppProcess+0x1c4>
    b77a:	79 c0       	rjmp	.+242    	; 0xb86e <NFCCommandAppProcess+0x2b6>
    b77c:	80 37       	cpi	r24, 0x70	; 112
    b77e:	e1 f4       	brne	.+56     	; 0xb7b8 <NFCCommandAppProcess+0x200>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    b780:	f7 01       	movw	r30, r14
    b782:	92 81       	ldd	r25, Z+2	; 0x02
    b784:	89 81       	ldd	r24, Y+1	; 0x01
    b786:	98 13       	cpse	r25, r24
    b788:	81 c0       	rjmp	.+258    	; 0xb88c <NFCCommandAppProcess+0x2d4>
    b78a:	93 81       	ldd	r25, Z+3	; 0x03
    b78c:	8a 81       	ldd	r24, Y+2	; 0x02
    b78e:	98 13       	cpse	r25, r24
    b790:	7d c0       	rjmp	.+250    	; 0xb88c <NFCCommandAppProcess+0x2d4>
                    (DataPtr[3] == UidCL[1]) &&
    b792:	94 81       	ldd	r25, Z+4	; 0x04
    b794:	8b 81       	ldd	r24, Y+3	; 0x03
    b796:	98 13       	cpse	r25, r24
    b798:	79 c0       	rjmp	.+242    	; 0xb88c <NFCCommandAppProcess+0x2d4>
                    (DataPtr[4] == UidCL[2]) &&
    b79a:	95 81       	ldd	r25, Z+5	; 0x05
    b79c:	8c 81       	ldd	r24, Y+4	; 0x04
    b79e:	98 13       	cpse	r25, r24
    b7a0:	75 c0       	rjmp	.+234    	; 0xb88c <NFCCommandAppProcess+0x2d4>
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    b7a2:	10 82       	st	Z, r1
                ISO14443AAppendCRCA(Buffer, 1);
    b7a4:	61 e0       	ldi	r22, 0x01	; 1
    b7a6:	70 e0       	ldi	r23, 0x00	; 0
    b7a8:	c7 01       	movw	r24, r14
    b7aa:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>

                if (ISO14443ASelect(Buffer, &BitCount, UidCL2, SAK_CL2_VALUE)) {
                    /* CL2 stage has ended successfully. This means
                     * our complete UID has been sent to the reader. */
                    State = STATE_ACTIVE;
    b7ae:	84 e0       	ldi	r24, 0x04	; 4
    b7b0:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <State>
    b7b4:	88 e1       	ldi	r24, 0x18	; 24
    b7b6:	6b c0       	rjmp	.+214    	; 0xb88e <NFCCommandAppProcess+0x2d6>
                /* We have not been selected. Don't send anything. */
                *BitCount = 0;
                return false;
            }
        default: {
            uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    b7b8:	08 2f       	mov	r16, r24
    b7ba:	02 95       	swap	r16
    b7bc:	0f 70       	andi	r16, 0x0F	; 15
    b7be:	02 50       	subi	r16, 0x02	; 2
            uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    b7c0:	18 2f       	mov	r17, r24
    b7c2:	1f 70       	andi	r17, 0x0F	; 15
            uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    b7c4:	88 e0       	ldi	r24, 0x08	; 8
    b7c6:	90 e0       	ldi	r25, 0x00	; 0
    b7c8:	81 1b       	sub	r24, r17
    b7ca:	91 09       	sbc	r25, r1
    b7cc:	2f ef       	ldi	r18, 0xFF	; 255
    b7ce:	30 e0       	ldi	r19, 0x00	; 0
    b7d0:	69 01       	movw	r12, r18
    b7d2:	02 c0       	rjmp	.+4      	; 0xb7d8 <NFCCommandAppProcess+0x220>
    b7d4:	d5 94       	asr	r13
    b7d6:	c7 94       	ror	r12
    b7d8:	8a 95       	dec	r24
    b7da:	e2 f7       	brpl	.-8      	; 0xb7d4 <NFCCommandAppProcess+0x21c>
            // Since the UidCL does not contain the BCC, we have to distinguish here
            if (
    b7dc:	05 30       	cpi	r16, 0x05	; 5
    b7de:	21 f0       	breq	.+8      	; 0xb7e8 <NFCCommandAppProcess+0x230>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    b7e0:	04 30       	cpi	r16, 0x04	; 4
    b7e2:	49 f5       	brne	.+82     	; 0xb836 <NFCCommandAppProcess+0x27e>
    b7e4:	11 23       	and	r17, r17
    b7e6:	d9 f0       	breq	.+54     	; 0xb81e <NFCCommandAppProcess+0x266>
    b7e8:	44 e0       	ldi	r20, 0x04	; 4
    b7ea:	50 e0       	ldi	r21, 0x00	; 0
    b7ec:	b7 01       	movw	r22, r14
    b7ee:	6e 5f       	subi	r22, 0xFE	; 254
    b7f0:	7f 4f       	sbci	r23, 0xFF	; 255
    b7f2:	ce 01       	movw	r24, r28
    b7f4:	01 96       	adiw	r24, 0x01	; 1
    b7f6:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    b7fa:	89 2b       	or	r24, r25
    b7fc:	61 f4       	brne	.+24     	; 0xb816 <NFCCommandAppProcess+0x25e>
    b7fe:	99 81       	ldd	r25, Y+1	; 0x01
    b800:	8a 81       	ldd	r24, Y+2	; 0x02
    b802:	89 27       	eor	r24, r25
    b804:	9b 81       	ldd	r25, Y+3	; 0x03
    b806:	89 27       	eor	r24, r25
    b808:	9c 81       	ldd	r25, Y+4	; 0x04
    b80a:	89 27       	eor	r24, r25
    b80c:	f7 01       	movw	r30, r14
    b80e:	96 81       	ldd	r25, Z+6	; 0x06
    b810:	89 27       	eor	r24, r25
    b812:	8c 21       	and	r24, r12
    b814:	61 f1       	breq	.+88     	; 0xb86e <NFCCommandAppProcess+0x2b6>
                ||
    b816:	04 30       	cpi	r16, 0x04	; 4
    b818:	71 f4       	brne	.+28     	; 0xb836 <NFCCommandAppProcess+0x27e>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    b81a:	11 11       	cpse	r17, r1
    b81c:	37 c0       	rjmp	.+110    	; 0xb88c <NFCCommandAppProcess+0x2d4>
    b81e:	44 e0       	ldi	r20, 0x04	; 4
    b820:	50 e0       	ldi	r21, 0x00	; 0
    b822:	b7 01       	movw	r22, r14
    b824:	6e 5f       	subi	r22, 0xFE	; 254
    b826:	7f 4f       	sbci	r23, 0xFF	; 255
    b828:	ce 01       	movw	r24, r28
    b82a:	01 96       	adiw	r24, 0x01	; 1
    b82c:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    b830:	89 2b       	or	r24, r25
    b832:	e9 f0       	breq	.+58     	; 0xb86e <NFCCommandAppProcess+0x2b6>
    b834:	2b c0       	rjmp	.+86     	; 0xb88c <NFCCommandAppProcess+0x2d4>
                ||
    b836:	04 30       	cpi	r16, 0x04	; 4
    b838:	48 f5       	brcc	.+82     	; 0xb88c <NFCCommandAppProcess+0x2d4>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    b83a:	10 e0       	ldi	r17, 0x00	; 0
    b83c:	a8 01       	movw	r20, r16
    b83e:	b7 01       	movw	r22, r14
    b840:	6e 5f       	subi	r22, 0xFE	; 254
    b842:	7f 4f       	sbci	r23, 0xFF	; 255
    b844:	ce 01       	movw	r24, r28
    b846:	01 96       	adiw	r24, 0x01	; 1
    b848:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    b84c:	89 2b       	or	r24, r25
    b84e:	f1 f4       	brne	.+60     	; 0xb88c <NFCCommandAppProcess+0x2d4>
    b850:	d7 01       	movw	r26, r14
    b852:	a0 0f       	add	r26, r16
    b854:	b1 1f       	adc	r27, r17
    b856:	e1 e0       	ldi	r30, 0x01	; 1
    b858:	f0 e0       	ldi	r31, 0x00	; 0
    b85a:	ec 0f       	add	r30, r28
    b85c:	fd 1f       	adc	r31, r29
    b85e:	e0 0f       	add	r30, r16
    b860:	f1 1f       	adc	r31, r17
    b862:	12 96       	adiw	r26, 0x02	; 2
    b864:	9c 91       	ld	r25, X
    b866:	80 81       	ld	r24, Z
    b868:	89 27       	eor	r24, r25
    b86a:	c8 22       	and	r12, r24
    b86c:	79 f4       	brne	.+30     	; 0xb88c <NFCCommandAppProcess+0x2d4>
            ) {
                DataPtr[0] = UidCL[0];
    b86e:	39 81       	ldd	r19, Y+1	; 0x01
    b870:	f7 01       	movw	r30, r14
    b872:	30 83       	st	Z, r19
                DataPtr[1] = UidCL[1];
    b874:	2a 81       	ldd	r18, Y+2	; 0x02
    b876:	21 83       	std	Z+1, r18	; 0x01
                DataPtr[2] = UidCL[2];
    b878:	9b 81       	ldd	r25, Y+3	; 0x03
    b87a:	92 83       	std	Z+2, r25	; 0x02
                DataPtr[3] = UidCL[3];
    b87c:	8c 81       	ldd	r24, Y+4	; 0x04
    b87e:	83 83       	std	Z+3, r24	; 0x03
                DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    b880:	23 27       	eor	r18, r19
    b882:	92 27       	eor	r25, r18
    b884:	89 27       	eor	r24, r25
    b886:	84 83       	std	Z+4, r24	; 0x04

                *BitCount = ISO14443A_CL_FRAME_SIZE;
    b888:	88 e2       	ldi	r24, 0x28	; 40
    b88a:	01 c0       	rjmp	.+2      	; 0xb88e <NFCCommandAppProcess+0x2d6>

                *BitCount = ISO14443A_SAK_FRAME_SIZE;
                return true;
            } else {
                /* We have not been selected. Don't send anything. */
                *BitCount = 0;
    b88c:	80 e0       	ldi	r24, 0x00	; 0
    b88e:	90 e0       	ldi	r25, 0x00	; 0
            break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
}
    b890:	60 96       	adiw	r28, 0x10	; 16
    b892:	cd bf       	out	0x3d, r28	; 61
    b894:	de bf       	out	0x3e, r29	; 62
    b896:	df 91       	pop	r29
    b898:	cf 91       	pop	r28
    b89a:	1f 91       	pop	r17
    b89c:	0f 91       	pop	r16
    b89e:	ff 90       	pop	r15
    b8a0:	ef 90       	pop	r14
    b8a2:	df 90       	pop	r13
    b8a4:	cf 90       	pop	r12
    b8a6:	bf 90       	pop	r11
    b8a8:	af 90       	pop	r10
    b8aa:	08 95       	ret
            }
            break;

        case STATE_ACTIVE:
            /* Preserve incoming data length */
            ByteCount = (BitCount + 7) >> 3;
    b8ac:	69 5f       	subi	r22, 0xF9	; 249
    b8ae:	7f 4f       	sbci	r23, 0xFF	; 255
    b8b0:	83 e0       	ldi	r24, 0x03	; 3
    b8b2:	76 95       	lsr	r23
    b8b4:	67 95       	ror	r22
    b8b6:	8a 95       	dec	r24
    b8b8:	e1 f7       	brne	.-8      	; 0xb8b2 <NFCCommandAppProcess+0x2fa>
            if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
                State = FromHalt ? STATE_HALT : STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            }
            /* At the very least, there should be 3 bytes in the buffer. */
            if (ByteCount < (1 + ISO14443A_CRCA_SIZE)) {
    b8ba:	63 30       	cpi	r22, 0x03	; 3
    b8bc:	71 05       	cpc	r23, r1
    b8be:	08 f4       	brcc	.+2      	; 0xb8c2 <NFCCommandAppProcess+0x30a>
    b8c0:	e0 ce       	rjmp	.-576    	; 0xb682 <NFCCommandAppProcess+0xca>
                State = STATE_IDLE;
                return ISO14443A_APP_NO_RESPONSE;
            }
            /* All commands here have CRCA appended; verify it right away */
            ByteCount -= 2;
            if (!ISO14443ACheckCRCA(Buffer, ByteCount)) {
    b8c2:	62 50       	subi	r22, 0x02	; 2
    b8c4:	71 09       	sbc	r23, r1
    b8c6:	c7 01       	movw	r24, r14
    b8c8:	0e 94 8b 41 	call	0x8316	; 0x8316 <ISO14443ACheckCRCA>
    b8cc:	81 11       	cpse	r24, r1
    b8ce:	cb ce       	rjmp	.-618    	; 0xb666 <NFCCommandAppProcess+0xae>
                Buffer[0] = NAK_CRC_ERROR;
    b8d0:	81 e0       	ldi	r24, 0x01	; 1
    b8d2:	0e cf       	rjmp	.-484    	; 0xb6f0 <NFCCommandAppProcess+0x138>
static uint16_t AppProcess(uint8_t * const Buffer, uint16_t ByteCount) {
    uint8_t Cmd = Buffer[0];

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
        ArmedForCompatWrite = false;
    b8d4:	10 92 8f 2e 	sts	0x2E8F, r1	; 0x802e8f <ArmedForCompatWrite>

        //Handle MF ULC counter
        if (CompatWritePageAddress == NFC_CMD_COUNTER_ADDRESS && Flavor == UL_C) {
    b8d8:	80 91 8e 2e 	lds	r24, 0x2E8E	; 0x802e8e <CompatWritePageAddress>
    b8dc:	b7 01       	movw	r22, r14
    b8de:	6e 5f       	subi	r22, 0xFE	; 254
    b8e0:	7f 4f       	sbci	r23, 0xFF	; 255
    b8e2:	89 32       	cpi	r24, 0x29	; 41
    b8e4:	c1 f4       	brne	.+48     	; 0xb916 <NFCCommandAppProcess+0x35e>
    b8e6:	90 91 93 2e 	lds	r25, 0x2E93	; 0x802e93 <Flavor>
    b8ea:	91 30       	cpi	r25, 0x01	; 1
    b8ec:	a1 f4       	brne	.+40     	; 0xb916 <NFCCommandAppProcess+0x35e>
            if (IncrementCounter(&Buffer[2])) {
    b8ee:	cb 01       	movw	r24, r22
    b8f0:	07 dd       	rcall	.-1522   	; 0xb300 <IncrementCounter>
    b8f2:	88 23       	and	r24, r24
    b8f4:	69 f0       	breq	.+26     	; 0xb910 <NFCCommandAppProcess+0x358>
    b8f6:	10 c0       	rjmp	.+32     	; 0xb918 <NFCCommandAppProcess+0x360>
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

    /* Handle EV0 commands */
    switch (Cmd) {
    b8f8:	80 3a       	cpi	r24, 0xA0	; 160
    b8fa:	09 f4       	brne	.+2      	; 0xb8fe <NFCCommandAppProcess+0x346>
    b8fc:	76 c0       	rjmp	.+236    	; 0xb9ea <NFCCommandAppProcess+0x432>
    b8fe:	82 3a       	cpi	r24, 0xA2	; 162
    b900:	09 f0       	breq	.+2      	; 0xb904 <NFCCommandAppProcess+0x34c>
    b902:	bf ce       	rjmp	.-642    	; 0xb682 <NFCCommandAppProcess+0xca>

        case CMD_WRITE:
        {
            /* This is a write command containing 4 bytes of data that
             * should be written to the given page address. */
            uint8_t PageAddress = Buffer[1];
    b904:	f7 01       	movw	r30, r14
    b906:	81 81       	ldd	r24, Z+1	; 0x01

            //Handle MF ULC counter
            if (PageAddress == NFC_CMD_COUNTER_ADDRESS && Flavor == UL_C) {
    b908:	89 32       	cpi	r24, 0x29	; 41
    b90a:	89 f1       	breq	.+98     	; 0xb96e <NFCCommandAppProcess+0x3b6>
                    return NAK_FRAME_SIZE;
                }
            }

            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    b90c:	82 30       	cpi	r24, 0x02	; 2
    b90e:	b0 f5       	brcc	.+108    	; 0xb97c <NFCCommandAppProcess+0x3c4>
        if (CompatWritePageAddress == NFC_CMD_COUNTER_ADDRESS && Flavor == UL_C) {
            if (IncrementCounter(&Buffer[2])) {
                Buffer[0] = ACK_VALUE;
                return ACK_FRAME_SIZE;
            } else {
                Buffer[0] = NAK_INVALID_ARG;
    b910:	f7 01       	movw	r30, r14
    b912:	10 82       	st	Z, r1
                return NAK_FRAME_SIZE;
            }
        }
        NFCWritePage(CompatWritePageAddress, &Buffer[2]);
    b914:	ef ce       	rjmp	.-546    	; 0xb6f4 <NFCCommandAppProcess+0x13c>
    b916:	e3 dc       	rcall	.-1594   	; 0xb2de <NFCWritePage>
        Buffer[0] = ACK_VALUE;
    b918:	8a e0       	ldi	r24, 0x0A	; 10
    b91a:	ea ce       	rjmp	.-556    	; 0xb6f0 <NFCCommandAppProcess+0x138>
    switch (Cmd) {

        case CMD_READ:
        {

            uint8_t PageAddress = Buffer[1];
    b91c:	f7 01       	movw	r30, r14
    b91e:	61 81       	ldd	r22, Z+1	; 0x01
            uint8_t PageLimit;
            uint8_t Offset;
            /* For EV1+ cards, ensure the wraparound is at the first protected page */
            if (Flavor >= UL_C && ReadAccessProtected && !Authenticated) {
    b920:	80 91 93 2e 	lds	r24, 0x2E93	; 0x802e93 <Flavor>
    b924:	88 23       	and	r24, r24
    b926:	69 f0       	breq	.+26     	; 0xb942 <NFCCommandAppProcess+0x38a>
    b928:	90 91 8b 2e 	lds	r25, 0x2E8B	; 0x802e8b <ReadAccessProtected>
    b92c:	99 23       	and	r25, r25
    b92e:	39 f0       	breq	.+14     	; 0xb93e <NFCCommandAppProcess+0x386>
    b930:	90 91 8d 2e 	lds	r25, 0x2E8D	; 0x802e8d <Authenticated>
    b934:	91 11       	cpse	r25, r1
    b936:	03 c0       	rjmp	.+6      	; 0xb93e <NFCCommandAppProcess+0x386>
                PageLimit = FirstAuthenticatedPage;
    b938:	80 91 8c 2e 	lds	r24, 0x2E8C	; 0x802e8c <FirstAuthenticatedPage>
    b93c:	06 c0       	rjmp	.+12     	; 0xb94a <NFCCommandAppProcess+0x392>
            } else {
                if (Flavor == UL_C) PageLimit = MF_ULC_READ_MAX_PAGE; // For ULC make sure wraparound is at the first key page
    b93e:	81 30       	cpi	r24, 0x01	; 1
    b940:	19 f0       	breq	.+6      	; 0xb948 <NFCCommandAppProcess+0x390>
                else PageLimit = PageCount;
    b942:	80 91 90 2e 	lds	r24, 0x2E90	; 0x802e90 <PageCount>
    b946:	01 c0       	rjmp	.+2      	; 0xb94a <NFCCommandAppProcess+0x392>
            uint8_t Offset;
            /* For EV1+ cards, ensure the wraparound is at the first protected page */
            if (Flavor >= UL_C && ReadAccessProtected && !Authenticated) {
                PageLimit = FirstAuthenticatedPage;
            } else {
                if (Flavor == UL_C) PageLimit = MF_ULC_READ_MAX_PAGE; // For ULC make sure wraparound is at the first key page
    b948:	8c e2       	ldi	r24, 0x2C	; 44
                else PageLimit = PageCount;
            }
            /* Validation */
            if (PageAddress >= PageLimit) {
    b94a:	68 17       	cp	r22, r24
    b94c:	08 f7       	brcc	.-62     	; 0xb910 <NFCCommandAppProcess+0x358>
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            /* Read out, emulating the wraparound */
            for (Offset = 0; Offset < 4; Offset += 4) { //BYTES_PER_READ   Offset += 4
                MemoryReadBlock(&Buffer[Offset], PageAddress * NFC_COMMAND_PAGE_SIZE, NFC_COMMAND_PAGE_SIZE);
    b94e:	f4 e0       	ldi	r31, 0x04	; 4
    b950:	6f 9f       	mul	r22, r31
    b952:	b0 01       	movw	r22, r0
    b954:	11 24       	eor	r1, r1
    b956:	44 e0       	ldi	r20, 0x04	; 4
    b958:	50 e0       	ldi	r21, 0x00	; 0
    b95a:	c7 01       	movw	r24, r14
    b95c:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                PageAddress++;
                if (PageAddress == PageLimit) {
                    PageAddress = 0;
                }
            }
            ISO14443AAppendCRCA(Buffer, BYTES_PER_READ);
    b960:	64 e0       	ldi	r22, 0x04	; 4
    b962:	70 e0       	ldi	r23, 0x00	; 0
    b964:	c7 01       	movw	r24, r14
    b966:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
            return (BYTES_PER_READ + ISO14443A_CRCA_SIZE) * 8;
    b96a:	80 e3       	ldi	r24, 0x30	; 48
    b96c:	90 cf       	rjmp	.-224    	; 0xb88e <NFCCommandAppProcess+0x2d6>
            /* This is a write command containing 4 bytes of data that
             * should be written to the given page address. */
            uint8_t PageAddress = Buffer[1];

            //Handle MF ULC counter
            if (PageAddress == NFC_CMD_COUNTER_ADDRESS && Flavor == UL_C) {
    b96e:	90 91 93 2e 	lds	r25, 0x2E93	; 0x802e93 <Flavor>
    b972:	91 30       	cpi	r25, 0x01	; 1
    b974:	19 f4       	brne	.+6      	; 0xb97c <NFCCommandAppProcess+0x3c4>
                if (IncrementCounter(&Buffer[2])) {
    b976:	c7 01       	movw	r24, r14
    b978:	02 96       	adiw	r24, 0x02	; 2
    b97a:	ba cf       	rjmp	.-140    	; 0xb8f0 <NFCCommandAppProcess+0x338>
                    return NAK_FRAME_SIZE;
                }
            }

            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    b97c:	90 91 90 2e 	lds	r25, 0x2E90	; 0x802e90 <PageCount>
    b980:	89 17       	cp	r24, r25
    b982:	30 f6       	brcc	.-116    	; 0xb910 <NFCCommandAppProcess+0x358>

}

static bool VerifyAuthentication(uint8_t PageAddress) {
    /* No authentication for EV0 cards; always pass */
    if (Flavor < UL_C) {
    b984:	90 91 93 2e 	lds	r25, 0x2E93	; 0x802e93 <Flavor>
    b988:	99 23       	and	r25, r25
    b98a:	49 f0       	breq	.+18     	; 0xb99e <NFCCommandAppProcess+0x3e6>
        return true;
    }
    /* If authenticated, no verification needed */
    if (Authenticated) {
    b98c:	90 91 8d 2e 	lds	r25, 0x2E8D	; 0x802e8d <Authenticated>
    b990:	91 11       	cpse	r25, r1
    b992:	05 c0       	rjmp	.+10     	; 0xb99e <NFCCommandAppProcess+0x3e6>
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    b994:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <FirstAuthenticatedPage>
    b998:	89 17       	cp	r24, r25
    b99a:	08 f0       	brcs	.+2      	; 0xb99e <NFCCommandAppProcess+0x3e6>
    b99c:	a8 ce       	rjmp	.-688    	; 0xb6ee <NFCCommandAppProcess+0x136>
    b99e:	67 01       	movw	r12, r14
    b9a0:	f2 e0       	ldi	r31, 0x02	; 2
    b9a2:	cf 0e       	add	r12, r31
    b9a4:	d1 1c       	adc	r13, r1
    b9a6:	57 01       	movw	r10, r14
    b9a8:	86 e0       	ldi	r24, 0x06	; 6
    b9aa:	a8 0e       	add	r10, r24
    b9ac:	b1 1c       	adc	r11, r1
                Buffer[0] = NAK_AUTH_REQUIRED;
                return NAK_FRAME_SIZE;
            }
            ///Handles NFC Commands
            for (uint8_t i = 2; i < 6; i++) {
                uint8_t byte = Buffer[i];
    b9ae:	f6 01       	movw	r30, r12
    b9b0:	11 91       	ld	r17, Z+
    b9b2:	6f 01       	movw	r12, r30
                if (byte == '\n') { //catches line feed as termination character and converts to carriage return
    b9b4:	1a 30       	cpi	r17, 0x0A	; 10
    b9b6:	31 f4       	brne	.+12     	; 0xb9c4 <NFCCommandAppProcess+0x40c>
                    byte = '\r';
                    TerminalSendString("\n\r");
    b9b8:	89 e8       	ldi	r24, 0x89	; 137
    b9ba:	94 e2       	ldi	r25, 0x24	; 36
    b9bc:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <TerminalSendString>
            }
            ///Handles NFC Commands
            for (uint8_t i = 2; i < 6; i++) {
                uint8_t byte = Buffer[i];
                if (byte == '\n') { //catches line feed as termination character and converts to carriage return
                    byte = '\r';
    b9c0:	1d e0       	ldi	r17, 0x0D	; 13
    b9c2:	07 c0       	rjmp	.+14     	; 0xb9d2 <NFCCommandAppProcess+0x41a>
                    TerminalSendString("\n\r");
                }
                if (byte == 6) { // if Acknowledgment received
    b9c4:	16 30       	cpi	r17, 0x06	; 6
    b9c6:	29 f4       	brne	.+10     	; 0xb9d2 <NFCCommandAppProcess+0x41a>
                    NFCAnswer(NFCResponse); //send command response
    b9c8:	80 91 3b 32 	lds	r24, 0x323B	; 0x80323b <NFCResponse>
    b9cc:	90 91 3c 32 	lds	r25, 0x323C	; 0x80323c <NFCResponse+0x1>
    b9d0:	38 dd       	rcall	.-1424   	; 0xb442 <NFCAnswer>
                }
                CommandLineProcessByte(byte); //process the byte and trigger command on termination character
    b9d2:	81 2f       	mov	r24, r17
    b9d4:	0e 94 cd 24 	call	0x499a	; 0x499a <CommandLineProcessByte>
    b9d8:	61 2f       	mov	r22, r17
    b9da:	83 e0       	ldi	r24, 0x03	; 3
    b9dc:	90 e2       	ldi	r25, 0x20	; 32
    b9de:	0e 94 d7 74 	call	0xe9ae	; 0xe9ae <CDC_Device_SendByte>
            if (!VerifyAuthentication(PageAddress)) {
                Buffer[0] = NAK_AUTH_REQUIRED;
                return NAK_FRAME_SIZE;
            }
            ///Handles NFC Commands
            for (uint8_t i = 2; i < 6; i++) {
    b9e2:	ac 14       	cp	r10, r12
    b9e4:	bd 04       	cpc	r11, r13
    b9e6:	19 f7       	brne	.-58     	; 0xb9ae <NFCCommandAppProcess+0x3f6>
    b9e8:	97 cf       	rjmp	.-210    	; 0xb918 <NFCCommandAppProcess+0x360>
            return ACK_FRAME_SIZE;
        }

        case CMD_COMPAT_WRITE:
        {
            uint8_t PageAddress = Buffer[1];
    b9ea:	f7 01       	movw	r30, r14
    b9ec:	81 81       	ldd	r24, Z+1	; 0x01
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    b9ee:	82 30       	cpi	r24, 0x02	; 2
    b9f0:	08 f4       	brcc	.+2      	; 0xb9f4 <NFCCommandAppProcess+0x43c>
    b9f2:	8e cf       	rjmp	.-228    	; 0xb910 <NFCCommandAppProcess+0x358>
    b9f4:	90 91 90 2e 	lds	r25, 0x2E90	; 0x802e90 <PageCount>
    b9f8:	89 17       	cp	r24, r25
    b9fa:	08 f0       	brcs	.+2      	; 0xb9fe <NFCCommandAppProcess+0x446>
    b9fc:	89 cf       	rjmp	.-238    	; 0xb910 <NFCCommandAppProcess+0x358>

}

static bool VerifyAuthentication(uint8_t PageAddress) {
    /* No authentication for EV0 cards; always pass */
    if (Flavor < UL_C) {
    b9fe:	90 91 93 2e 	lds	r25, 0x2E93	; 0x802e93 <Flavor>
    ba02:	99 23       	and	r25, r25
    ba04:	49 f0       	breq	.+18     	; 0xba18 <NFCCommandAppProcess+0x460>
        return true;
    }
    /* If authenticated, no verification needed */
    if (Authenticated) {
    ba06:	90 91 8d 2e 	lds	r25, 0x2E8D	; 0x802e8d <Authenticated>
    ba0a:	91 11       	cpse	r25, r1
    ba0c:	05 c0       	rjmp	.+10     	; 0xba18 <NFCCommandAppProcess+0x460>
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    ba0e:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <FirstAuthenticatedPage>
    ba12:	89 17       	cp	r24, r25
    ba14:	08 f0       	brcs	.+2      	; 0xba18 <NFCCommandAppProcess+0x460>
    ba16:	6b ce       	rjmp	.-810    	; 0xb6ee <NFCCommandAppProcess+0x136>
                Buffer[0] = NAK_AUTH_REQUIRED;
                return NAK_FRAME_SIZE;
            }
            /* CRC check passed and page-address is within bounds.
             * Store address and proceed to receiving the data. */
            CompatWritePageAddress = PageAddress;
    ba18:	80 93 8e 2e 	sts	0x2E8E, r24	; 0x802e8e <CompatWritePageAddress>
            ArmedForCompatWrite = true;
    ba1c:	81 e0       	ldi	r24, 0x01	; 1
    ba1e:	80 93 8f 2e 	sts	0x2E8F, r24	; 0x802e8f <ArmedForCompatWrite>
    ba22:	7a cf       	rjmp	.-268    	; 0xb918 <NFCCommandAppProcess+0x360>

        case CMD_HALT:
        {
            /* Halts the tag. According to the ISO14443, the second
             * byte is supposed to be 0. */
            if (Buffer[1] == 0) {
    ba24:	f7 01       	movw	r30, r14
    ba26:	81 81       	ldd	r24, Z+1	; 0x01
    ba28:	81 11       	cpse	r24, r1
    ba2a:	72 cf       	rjmp	.-284    	; 0xb910 <NFCCommandAppProcess+0x358>
                /* According to ISO14443, we must not send anything
                 * in order to acknowledge the HALT command. */
                State = STATE_HALT;
    ba2c:	10 92 92 2e 	sts	0x2E92, r1	; 0x802e92 <State>
    ba30:	2e cf       	rjmp	.-420    	; 0xb88e <NFCCommandAppProcess+0x2d6>

0000ba32 <NTAG215AppInit>:


void NTAG215AppInit(void)
{

    State = STATE_IDLE;
    ba32:	81 e0       	ldi	r24, 0x01	; 1
    ba34:	80 93 9c 2e 	sts	0x2E9C, r24	; 0x802e9c <State>
    FromHalt = false;
    ba38:	10 92 9b 2e 	sts	0x2E9B, r1	; 0x802e9b <FromHalt>
    ArmedForCompatWrite = false;
    ba3c:	10 92 99 2e 	sts	0x2E99, r1	; 0x802e99 <ArmedForCompatWrite>
    Authenticated = false;
    ba40:	10 92 97 2e 	sts	0x2E97, r1	; 0x802e97 <Authenticated>
    PageCount = NTAG215_PAGES;
    ba44:	87 e8       	ldi	r24, 0x87	; 135
    ba46:	80 93 9a 2e 	sts	0x2E9A, r24	; 0x802e9a <PageCount>

    /* Fetch some of the configuration into RAM */
    MemoryReadBlock(&FirstAuthenticatedPage, CONFIG_AREA_START_ADDRESS + CONF_AUTH0_OFFSET, 1);
    ba4a:	41 e0       	ldi	r20, 0x01	; 1
    ba4c:	50 e0       	ldi	r21, 0x00	; 0
    ba4e:	6f e0       	ldi	r22, 0x0F	; 15
    ba50:	72 e0       	ldi	r23, 0x02	; 2
    ba52:	86 e9       	ldi	r24, 0x96	; 150
    ba54:	9e e2       	ldi	r25, 0x2E	; 46
    ba56:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    MemoryReadBlock(&Access, CONFIG_AREA_START_ADDRESS + CONF_ACCESS_OFFSET, 1);
    ba5a:	41 e0       	ldi	r20, 0x01	; 1
    ba5c:	50 e0       	ldi	r21, 0x00	; 0
    ba5e:	60 e1       	ldi	r22, 0x10	; 16
    ba60:	72 e0       	ldi	r23, 0x02	; 2
    ba62:	84 e9       	ldi	r24, 0x94	; 148
    ba64:	9e e2       	ldi	r25, 0x2E	; 46
    ba66:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    ReadAccessProtected = !!(Access & CONF_ACCESS_PROT);
    ba6a:	80 91 94 2e 	lds	r24, 0x2E94	; 0x802e94 <Access>
    ba6e:	88 1f       	adc	r24, r24
    ba70:	88 27       	eor	r24, r24
    ba72:	88 1f       	adc	r24, r24
    ba74:	80 93 95 2e 	sts	0x2E95, r24	; 0x802e95 <ReadAccessProtected>
    ba78:	08 95       	ret

0000ba7a <NTAG215AppReset>:
}

void NTAG215AppReset(void)
{
    State = STATE_IDLE;
    ba7a:	81 e0       	ldi	r24, 0x01	; 1
    ba7c:	80 93 9c 2e 	sts	0x2E9C, r24	; 0x802e9c <State>
    ba80:	08 95       	ret

0000ba82 <NTAG215AppTask>:
}

void NTAG215AppTask(void)
{
    ba82:	08 95       	ret

0000ba84 <NTAG215AppProcess>:
}


//FINITE STATE MACHINE STUFF, SHOULD BE THE VERY SIMILAR TO Mifare Ultralight
uint16_t NTAG215AppProcess(uint8_t* Buffer, uint16_t BitCount)
{
    ba84:	cf 92       	push	r12
    ba86:	df 92       	push	r13
    ba88:	ef 92       	push	r14
    ba8a:	ff 92       	push	r15
    ba8c:	0f 93       	push	r16
    ba8e:	1f 93       	push	r17
    ba90:	cf 93       	push	r28
    ba92:	df 93       	push	r29
    ba94:	00 d0       	rcall	.+0      	; 0xba96 <NTAG215AppProcess+0x12>
    ba96:	1f 92       	push	r1
    ba98:	cd b7       	in	r28, 0x3d	; 61
    ba9a:	de b7       	in	r29, 0x3e	; 62
    ba9c:	8c 01       	movw	r16, r24
    uint8_t Cmd = Buffer[0];
    ba9e:	fc 01       	movw	r30, r24
    baa0:	80 81       	ld	r24, Z
    uint16_t ByteCount;

    switch(State) {
    baa2:	90 91 9c 2e 	lds	r25, 0x2E9C	; 0x802e9c <State>
    baa6:	92 30       	cpi	r25, 0x02	; 2
    baa8:	e1 f0       	breq	.+56     	; 0xbae2 <NTAG215AppProcess+0x5e>
    baaa:	28 f0       	brcs	.+10     	; 0xbab6 <NTAG215AppProcess+0x32>
    baac:	93 30       	cpi	r25, 0x03	; 3
    baae:	11 f1       	breq	.+68     	; 0xbaf4 <NTAG215AppProcess+0x70>
    bab0:	94 30       	cpi	r25, 0x04	; 4
    bab2:	51 f1       	breq	.+84     	; 0xbb08 <NTAG215AppProcess+0x84>
    bab4:	50 c0       	rjmp	.+160    	; 0xbb56 <NTAG215AppProcess+0xd2>
    case STATE_IDLE:
    case STATE_HALT:
        FromHalt = State == STATE_HALT;
    bab6:	29 2f       	mov	r18, r25
    bab8:	20 95       	com	r18
    baba:	21 70       	andi	r18, 0x01	; 1
    babc:	20 93 9b 2e 	sts	0x2E9B, r18	; 0x802e9b <FromHalt>

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    bac0:	99 23       	and	r25, r25
    bac2:	11 f0       	breq	.+4      	; 0xbac8 <NTAG215AppProcess+0x44>
    bac4:	86 32       	cpi	r24, 0x26	; 38
    bac6:	19 f0       	breq	.+6      	; 0xbace <NTAG215AppProcess+0x4a>
    bac8:	82 35       	cpi	r24, 0x52	; 82
    baca:	09 f0       	breq	.+2      	; 0xbace <NTAG215AppProcess+0x4a>
    bacc:	44 c0       	rjmp	.+136    	; 0xbb56 <NTAG215AppProcess+0xd2>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    bace:	84 e4       	ldi	r24, 0x44	; 68
    bad0:	f8 01       	movw	r30, r16
    bad2:	80 83       	st	Z, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    bad4:	11 82       	std	Z+1, r1	; 0x01
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            /* We received a REQA or WUPA command, so wake up. */
            State = STATE_READY1;
    bad6:	82 e0       	ldi	r24, 0x02	; 2
    bad8:	80 93 9c 2e 	sts	0x2E9C, r24	; 0x802e9c <State>

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;
    badc:	80 e1       	ldi	r24, 0x10	; 16
    bade:	90 e0       	ldi	r25, 0x00	; 0
            return BitCount;
    bae0:	48 c2       	rjmp	.+1168   	; 0xbf72 <NTAG215AppProcess+0x4ee>
        }
        break;

    case STATE_READY1:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    bae2:	90 91 9b 2e 	lds	r25, 0x2E9B	; 0x802e9b <FromHalt>

INLINE
bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt) {
    uint8_t *DataPtr = (uint8_t *) Buffer;

    if (((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    bae6:	91 11       	cpse	r25, r1
    bae8:	02 c0       	rjmp	.+4      	; 0xbaee <NTAG215AppProcess+0x6a>
    baea:	86 32       	cpi	r24, 0x26	; 38
    baec:	b1 f0       	breq	.+44     	; 0xbb1a <NTAG215AppProcess+0x96>
    baee:	82 35       	cpi	r24, 0x52	; 82
    baf0:	a9 f5       	brne	.+106    	; 0xbb5c <NTAG215AppProcess+0xd8>
    baf2:	13 c0       	rjmp	.+38     	; 0xbb1a <NTAG215AppProcess+0x96>
            State = STATE_IDLE;
        }
        break;

    case STATE_READY2:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    baf4:	90 91 9b 2e 	lds	r25, 0x2E9B	; 0x802e9b <FromHalt>
    baf8:	91 11       	cpse	r25, r1
    bafa:	02 c0       	rjmp	.+4      	; 0xbb00 <NTAG215AppProcess+0x7c>
    bafc:	86 32       	cpi	r24, 0x26	; 38
    bafe:	69 f0       	breq	.+26     	; 0xbb1a <NTAG215AppProcess+0x96>
    bb00:	82 35       	cpi	r24, 0x52	; 82
    bb02:	09 f0       	breq	.+2      	; 0xbb06 <NTAG215AppProcess+0x82>
    bb04:	5d c0       	rjmp	.+186    	; 0xbbc0 <NTAG215AppProcess+0x13c>
    bb06:	09 c0       	rjmp	.+18     	; 0xbb1a <NTAG215AppProcess+0x96>

    //Only ACTIVE state, no AUTHENTICATED state, PWD_AUTH is handled in commands.
    case STATE_ACTIVE:
        /* Preserve incoming data length */
        ByteCount = (BitCount + 7) >> 3;
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    bb08:	90 91 9b 2e 	lds	r25, 0x2E9B	; 0x802e9b <FromHalt>
    bb0c:	91 11       	cpse	r25, r1
    bb0e:	02 c0       	rjmp	.+4      	; 0xbb14 <NTAG215AppProcess+0x90>
    bb10:	86 32       	cpi	r24, 0x26	; 38
    bb12:	19 f0       	breq	.+6      	; 0xbb1a <NTAG215AppProcess+0x96>
    bb14:	82 35       	cpi	r24, 0x52	; 82
    bb16:	09 f0       	breq	.+2      	; 0xbb1a <NTAG215AppProcess+0x96>
    bb18:	f5 c0       	rjmp	.+490    	; 0xbd04 <NTAG215AppProcess+0x280>
            (DataPtr[0] == ISO14443A_CMD_WUPA)) {
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    bb1a:	84 e4       	ldi	r24, 0x44	; 68
    bb1c:	f8 01       	movw	r30, r16
    bb1e:	80 83       	st	Z, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    bb20:	11 82       	std	Z+1, r1	; 0x01
            State = FromHalt ? STATE_HALT : STATE_IDLE;
    bb22:	81 e0       	ldi	r24, 0x01	; 1
    bb24:	89 27       	eor	r24, r25
    bb26:	15 c0       	rjmp	.+42     	; 0xbb52 <NTAG215AppProcess+0xce>
static uint16_t AppProcess(uint8_t* const Buffer, uint16_t ByteCount)
{
     uint8_t Cmd = Buffer[0];

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
    bb28:	80 91 99 2e 	lds	r24, 0x2E99	; 0x802e99 <ArmedForCompatWrite>
    bb2c:	81 11       	cpse	r24, r1
    bb2e:	fe c0       	rjmp	.+508    	; 0xbd2c <NTAG215AppProcess+0x2a8>
        AppWritePage(CompatWritePageAddress, &Buffer[2]);
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

      switch (Cmd) {
    bb30:	f8 01       	movw	r30, r16
    bb32:	80 81       	ld	r24, Z
    bb34:	8c 33       	cpi	r24, 0x3C	; 60
    bb36:	09 f4       	brne	.+2      	; 0xbb3a <NTAG215AppProcess+0xb6>
    bb38:	06 c2       	rjmp	.+1036   	; 0xbf46 <NTAG215AppProcess+0x4c2>
    bb3a:	08 f0       	brcs	.+2      	; 0xbb3e <NTAG215AppProcess+0xba>
    bb3c:	0a c1       	rjmp	.+532    	; 0xbd52 <NTAG215AppProcess+0x2ce>
    bb3e:	80 33       	cpi	r24, 0x30	; 48
    bb40:	09 f4       	brne	.+2      	; 0xbb44 <NTAG215AppProcess+0xc0>
    bb42:	2b c1       	rjmp	.+598    	; 0xbd9a <NTAG215AppProcess+0x316>
    bb44:	8a 33       	cpi	r24, 0x3A	; 58
    bb46:	09 f4       	brne	.+2      	; 0xbb4a <NTAG215AppProcess+0xc6>
    bb48:	5c c1       	rjmp	.+696    	; 0xbe02 <NTAG215AppProcess+0x37e>
    bb4a:	8b 31       	cpi	r24, 0x1B	; 27
    bb4c:	09 f4       	brne	.+2      	; 0xbb50 <NTAG215AppProcess+0xcc>
    bb4e:	91 c1       	rjmp	.+802    	; 0xbe72 <NTAG215AppProcess+0x3ee>
        }
    
    }
    /* Command not handled. Switch to idle. */

    State = STATE_IDLE;
    bb50:	81 e0       	ldi	r24, 0x01	; 1
    bb52:	80 93 9c 2e 	sts	0x2E9C, r24	; 0x802e9c <State>
        /* Unknown state? Should never happen. */
        break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
    bb56:	80 e0       	ldi	r24, 0x00	; 0
    bb58:	90 e0       	ldi	r25, 0x00	; 0
    bb5a:	0b c2       	rjmp	.+1046   	; 0xbf72 <NTAG215AppProcess+0x4ee>

    case STATE_READY1:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            State = FromHalt ? STATE_HALT : STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        } else if (Cmd == ISO14443A_CMD_SELECT_CL1) {
    bb5c:	83 39       	cpi	r24, 0x93	; 147
    bb5e:	c1 f7       	brne	.-16     	; 0xbb50 <NTAG215AppProcess+0xcc>
            /* Load UID CL1 and perform anticollision. Since
            * MF Ultralight use a double-sized UID, the first byte
            * of CL1 has to be the cascade-tag byte. */
            uint8_t UidCL1[ISO14443A_CL_UID_SIZE] = { [0] = ISO14443A_UID0_CT };
    bb60:	19 82       	std	Y+1, r1	; 0x01
    bb62:	1a 82       	std	Y+2, r1	; 0x02
    bb64:	1b 82       	std	Y+3, r1	; 0x03
    bb66:	1c 82       	std	Y+4, r1	; 0x04
    bb68:	88 e8       	ldi	r24, 0x88	; 136
    bb6a:	89 83       	std	Y+1, r24	; 0x01

            MemoryReadBlock(&UidCL1[1], UID_CL1_ADDRESS, UID_CL1_SIZE);
    bb6c:	43 e0       	ldi	r20, 0x03	; 3
    bb6e:	50 e0       	ldi	r21, 0x00	; 0
    bb70:	60 e0       	ldi	r22, 0x00	; 0
    bb72:	70 e0       	ldi	r23, 0x00	; 0
    bb74:	ce 01       	movw	r24, r28
    bb76:	02 96       	adiw	r24, 0x02	; 2
    bb78:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    bb7c:	f8 01       	movw	r30, r16
    bb7e:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    bb80:	80 32       	cpi	r24, 0x20	; 32
    bb82:	09 f4       	brne	.+2      	; 0xbb86 <NTAG215AppProcess+0x102>
    bb84:	ab c0       	rjmp	.+342    	; 0xbcdc <NTAG215AppProcess+0x258>
    bb86:	80 37       	cpi	r24, 0x70	; 112
    bb88:	09 f0       	breq	.+2      	; 0xbb8c <NTAG215AppProcess+0x108>
    bb8a:	47 c0       	rjmp	.+142    	; 0xbc1a <NTAG215AppProcess+0x196>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    bb8c:	f8 01       	movw	r30, r16
    bb8e:	92 81       	ldd	r25, Z+2	; 0x02
    bb90:	89 81       	ldd	r24, Y+1	; 0x01
    bb92:	98 13       	cpse	r25, r24
    bb94:	b2 c0       	rjmp	.+356    	; 0xbcfa <NTAG215AppProcess+0x276>
    bb96:	93 81       	ldd	r25, Z+3	; 0x03
    bb98:	8a 81       	ldd	r24, Y+2	; 0x02
    bb9a:	98 13       	cpse	r25, r24
    bb9c:	ae c0       	rjmp	.+348    	; 0xbcfa <NTAG215AppProcess+0x276>
                    (DataPtr[3] == UidCL[1]) &&
    bb9e:	94 81       	ldd	r25, Z+4	; 0x04
    bba0:	8b 81       	ldd	r24, Y+3	; 0x03
    bba2:	98 13       	cpse	r25, r24
    bba4:	aa c0       	rjmp	.+340    	; 0xbcfa <NTAG215AppProcess+0x276>
                    (DataPtr[4] == UidCL[2]) &&
    bba6:	95 81       	ldd	r25, Z+5	; 0x05
    bba8:	8c 81       	ldd	r24, Y+4	; 0x04
    bbaa:	98 13       	cpse	r25, r24
    bbac:	a6 c0       	rjmp	.+332    	; 0xbcfa <NTAG215AppProcess+0x276>
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    bbae:	84 e0       	ldi	r24, 0x04	; 4
    bbb0:	80 83       	st	Z, r24
                ISO14443AAppendCRCA(Buffer, 1);
    bbb2:	61 e0       	ldi	r22, 0x01	; 1
    bbb4:	70 e0       	ldi	r23, 0x00	; 0
    bbb6:	c8 01       	movw	r24, r16
    bbb8:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>

            if (ISO14443ASelect(Buffer, &BitCount, UidCL1, SAK_CL1_VALUE)) {
                /* CL1 stage has ended successfully */
                State = STATE_READY2;
    bbbc:	83 e0       	ldi	r24, 0x03	; 3
    bbbe:	29 c0       	rjmp	.+82     	; 0xbc12 <NTAG215AppProcess+0x18e>

    case STATE_READY2:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            State = FromHalt ? STATE_HALT : STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        } else if (Cmd == ISO14443A_CMD_SELECT_CL2) {
    bbc0:	85 39       	cpi	r24, 0x95	; 149
    bbc2:	31 f6       	brne	.-116    	; 0xbb50 <NTAG215AppProcess+0xcc>
            /* Load UID CL2 and perform anticollision */
            uint8_t UidCL2[ISO14443A_CL_UID_SIZE];

            MemoryReadBlock(UidCL2, UID_CL2_ADDRESS, UID_CL2_SIZE);
    bbc4:	44 e0       	ldi	r20, 0x04	; 4
    bbc6:	50 e0       	ldi	r21, 0x00	; 0
    bbc8:	64 e0       	ldi	r22, 0x04	; 4
    bbca:	70 e0       	ldi	r23, 0x00	; 0
    bbcc:	ce 01       	movw	r24, r28
    bbce:	01 96       	adiw	r24, 0x01	; 1
    bbd0:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
INLINE bool ISO14443AWakeUp(void *Buffer, uint16_t *BitCount, uint16_t ATQAValue, bool FromHalt);

INLINE
bool ISO14443ASelect(void *Buffer, uint16_t *BitCount, uint8_t *UidCL, uint8_t SAKValue) {
    uint8_t *DataPtr = (uint8_t *) Buffer;
    uint8_t NVB = DataPtr[1];
    bbd4:	f8 01       	movw	r30, r16
    bbd6:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    bbd8:	80 32       	cpi	r24, 0x20	; 32
    bbda:	09 f4       	brne	.+2      	; 0xbbde <NTAG215AppProcess+0x15a>
    bbdc:	7f c0       	rjmp	.+254    	; 0xbcdc <NTAG215AppProcess+0x258>
    bbde:	80 37       	cpi	r24, 0x70	; 112
    bbe0:	e1 f4       	brne	.+56     	; 0xbc1a <NTAG215AppProcess+0x196>
            return false;

        case ISO14443A_NVB_AC_END:
            /* End of anticollision procedure.
            * Send SAK CLn if we are selected. */
            if ((DataPtr[2] == UidCL[0]) &&
    bbe2:	f8 01       	movw	r30, r16
    bbe4:	92 81       	ldd	r25, Z+2	; 0x02
    bbe6:	89 81       	ldd	r24, Y+1	; 0x01
    bbe8:	98 13       	cpse	r25, r24
    bbea:	87 c0       	rjmp	.+270    	; 0xbcfa <NTAG215AppProcess+0x276>
    bbec:	93 81       	ldd	r25, Z+3	; 0x03
    bbee:	8a 81       	ldd	r24, Y+2	; 0x02
    bbf0:	98 13       	cpse	r25, r24
    bbf2:	83 c0       	rjmp	.+262    	; 0xbcfa <NTAG215AppProcess+0x276>
                    (DataPtr[3] == UidCL[1]) &&
    bbf4:	94 81       	ldd	r25, Z+4	; 0x04
    bbf6:	8b 81       	ldd	r24, Y+3	; 0x03
    bbf8:	98 13       	cpse	r25, r24
    bbfa:	7f c0       	rjmp	.+254    	; 0xbcfa <NTAG215AppProcess+0x276>
                    (DataPtr[4] == UidCL[2]) &&
    bbfc:	95 81       	ldd	r25, Z+5	; 0x05
    bbfe:	8c 81       	ldd	r24, Y+4	; 0x04
    bc00:	98 13       	cpse	r25, r24
    bc02:	7b c0       	rjmp	.+246    	; 0xbcfa <NTAG215AppProcess+0x276>
                    (DataPtr[5] == UidCL[3])) {

                DataPtr[0] = SAKValue;
    bc04:	10 82       	st	Z, r1
                ISO14443AAppendCRCA(Buffer, 1);
    bc06:	61 e0       	ldi	r22, 0x01	; 1
    bc08:	70 e0       	ldi	r23, 0x00	; 0
    bc0a:	c8 01       	movw	r24, r16
    bc0c:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>

            if (ISO14443ASelect(Buffer, &BitCount, UidCL2, SAK_CL2_VALUE)) {
                /* CL2 stage has ended successfully. This means
                * our complete UID has been sent to the reader. */
                State = STATE_ACTIVE;
    bc10:	84 e0       	ldi	r24, 0x04	; 4
    bc12:	80 93 9c 2e 	sts	0x2E9C, r24	; 0x802e9c <State>
    bc16:	38 e1       	ldi	r19, 0x18	; 24
    bc18:	71 c0       	rjmp	.+226    	; 0xbcfc <NTAG215AppProcess+0x278>
                /* We have not been selected. Don't send anything. */
                *BitCount = 0;
                return false;
            }
        default: {
            uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    bc1a:	e8 2e       	mov	r14, r24
    bc1c:	e2 94       	swap	r14
    bc1e:	4f e0       	ldi	r20, 0x0F	; 15
    bc20:	e4 22       	and	r14, r20
    bc22:	ea 94       	dec	r14
    bc24:	ea 94       	dec	r14
            uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    bc26:	8f 70       	andi	r24, 0x0F	; 15
    bc28:	f8 2e       	mov	r15, r24
            uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    bc2a:	88 e0       	ldi	r24, 0x08	; 8
    bc2c:	90 e0       	ldi	r25, 0x00	; 0
    bc2e:	8f 19       	sub	r24, r15
    bc30:	91 09       	sbc	r25, r1
    bc32:	2f ef       	ldi	r18, 0xFF	; 255
    bc34:	30 e0       	ldi	r19, 0x00	; 0
    bc36:	69 01       	movw	r12, r18
    bc38:	02 c0       	rjmp	.+4      	; 0xbc3e <NTAG215AppProcess+0x1ba>
    bc3a:	d5 94       	asr	r13
    bc3c:	c7 94       	ror	r12
    bc3e:	8a 95       	dec	r24
    bc40:	e2 f7       	brpl	.-8      	; 0xbc3a <NTAG215AppProcess+0x1b6>
            // Since the UidCL does not contain the BCC, we have to distinguish here
            if (
    bc42:	f5 e0       	ldi	r31, 0x05	; 5
    bc44:	ef 16       	cp	r14, r31
    bc46:	29 f0       	breq	.+10     	; 0xbc52 <NTAG215AppProcess+0x1ce>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    bc48:	24 e0       	ldi	r18, 0x04	; 4
    bc4a:	e2 12       	cpse	r14, r18
    bc4c:	2a c0       	rjmp	.+84     	; 0xbca2 <NTAG215AppProcess+0x21e>
    bc4e:	ff 20       	and	r15, r15
    bc50:	e1 f0       	breq	.+56     	; 0xbc8a <NTAG215AppProcess+0x206>
    bc52:	44 e0       	ldi	r20, 0x04	; 4
    bc54:	50 e0       	ldi	r21, 0x00	; 0
    bc56:	b8 01       	movw	r22, r16
    bc58:	6e 5f       	subi	r22, 0xFE	; 254
    bc5a:	7f 4f       	sbci	r23, 0xFF	; 255
    bc5c:	ce 01       	movw	r24, r28
    bc5e:	01 96       	adiw	r24, 0x01	; 1
    bc60:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    bc64:	89 2b       	or	r24, r25
    bc66:	61 f4       	brne	.+24     	; 0xbc80 <NTAG215AppProcess+0x1fc>
    bc68:	99 81       	ldd	r25, Y+1	; 0x01
    bc6a:	8a 81       	ldd	r24, Y+2	; 0x02
    bc6c:	89 27       	eor	r24, r25
    bc6e:	9b 81       	ldd	r25, Y+3	; 0x03
    bc70:	89 27       	eor	r24, r25
    bc72:	9c 81       	ldd	r25, Y+4	; 0x04
    bc74:	89 27       	eor	r24, r25
    bc76:	f8 01       	movw	r30, r16
    bc78:	96 81       	ldd	r25, Z+6	; 0x06
    bc7a:	89 27       	eor	r24, r25
    bc7c:	8c 21       	and	r24, r12
    bc7e:	71 f1       	breq	.+92     	; 0xbcdc <NTAG215AppProcess+0x258>
                ||
    bc80:	f4 e0       	ldi	r31, 0x04	; 4
    bc82:	ef 12       	cpse	r14, r31
    bc84:	0e c0       	rjmp	.+28     	; 0xbca2 <NTAG215AppProcess+0x21e>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    bc86:	f1 10       	cpse	r15, r1
    bc88:	38 c0       	rjmp	.+112    	; 0xbcfa <NTAG215AppProcess+0x276>
    bc8a:	44 e0       	ldi	r20, 0x04	; 4
    bc8c:	50 e0       	ldi	r21, 0x00	; 0
    bc8e:	b8 01       	movw	r22, r16
    bc90:	6e 5f       	subi	r22, 0xFE	; 254
    bc92:	7f 4f       	sbci	r23, 0xFF	; 255
    bc94:	ce 01       	movw	r24, r28
    bc96:	01 96       	adiw	r24, 0x01	; 1
    bc98:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    bc9c:	89 2b       	or	r24, r25
    bc9e:	f1 f0       	breq	.+60     	; 0xbcdc <NTAG215AppProcess+0x258>
    bca0:	2c c0       	rjmp	.+88     	; 0xbcfa <NTAG215AppProcess+0x276>
                ||
    bca2:	23 e0       	ldi	r18, 0x03	; 3
    bca4:	2e 15       	cp	r18, r14
    bca6:	48 f1       	brcs	.+82     	; 0xbcfa <NTAG215AppProcess+0x276>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    bca8:	f1 2c       	mov	r15, r1
    bcaa:	a7 01       	movw	r20, r14
    bcac:	b8 01       	movw	r22, r16
    bcae:	6e 5f       	subi	r22, 0xFE	; 254
    bcb0:	7f 4f       	sbci	r23, 0xFF	; 255
    bcb2:	ce 01       	movw	r24, r28
    bcb4:	01 96       	adiw	r24, 0x01	; 1
    bcb6:	0e 94 93 78 	call	0xf126	; 0xf126 <memcmp>
    bcba:	89 2b       	or	r24, r25
    bcbc:	f1 f4       	brne	.+60     	; 0xbcfa <NTAG215AppProcess+0x276>
    bcbe:	d8 01       	movw	r26, r16
    bcc0:	ae 0d       	add	r26, r14
    bcc2:	bf 1d       	adc	r27, r15
    bcc4:	e1 e0       	ldi	r30, 0x01	; 1
    bcc6:	f0 e0       	ldi	r31, 0x00	; 0
    bcc8:	ec 0f       	add	r30, r28
    bcca:	fd 1f       	adc	r31, r29
    bccc:	ee 0d       	add	r30, r14
    bcce:	ff 1d       	adc	r31, r15
    bcd0:	12 96       	adiw	r26, 0x02	; 2
    bcd2:	9c 91       	ld	r25, X
    bcd4:	80 81       	ld	r24, Z
    bcd6:	89 27       	eor	r24, r25
    bcd8:	c8 22       	and	r12, r24
    bcda:	79 f4       	brne	.+30     	; 0xbcfa <NTAG215AppProcess+0x276>
            ) {
                DataPtr[0] = UidCL[0];
    bcdc:	39 81       	ldd	r19, Y+1	; 0x01
    bcde:	f8 01       	movw	r30, r16
    bce0:	30 83       	st	Z, r19
                DataPtr[1] = UidCL[1];
    bce2:	2a 81       	ldd	r18, Y+2	; 0x02
    bce4:	21 83       	std	Z+1, r18	; 0x01
                DataPtr[2] = UidCL[2];
    bce6:	9b 81       	ldd	r25, Y+3	; 0x03
    bce8:	92 83       	std	Z+2, r25	; 0x02
                DataPtr[3] = UidCL[3];
    bcea:	8c 81       	ldd	r24, Y+4	; 0x04
    bcec:	83 83       	std	Z+3, r24	; 0x03
                DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    bcee:	23 27       	eor	r18, r19
    bcf0:	92 27       	eor	r25, r18
    bcf2:	89 27       	eor	r24, r25
    bcf4:	84 83       	std	Z+4, r24	; 0x04

                *BitCount = ISO14443A_CL_FRAME_SIZE;
    bcf6:	38 e2       	ldi	r19, 0x28	; 40
    bcf8:	01 c0       	rjmp	.+2      	; 0xbcfc <NTAG215AppProcess+0x278>
            uint8_t mask = 0xFF >> (8 - CollisionBitCount);
            // Since the UidCL does not contain the BCC, we have to distinguish here
            if (
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
                ||
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    bcfa:	30 e0       	ldi	r19, 0x00	; 0
    bcfc:	20 e0       	ldi	r18, 0x00	; 0
    bcfe:	83 2f       	mov	r24, r19
    bd00:	92 2f       	mov	r25, r18
    bd02:	37 c1       	rjmp	.+622    	; 0xbf72 <NTAG215AppProcess+0x4ee>
        break;

    //Only ACTIVE state, no AUTHENTICATED state, PWD_AUTH is handled in commands.
    case STATE_ACTIVE:
        /* Preserve incoming data length */
        ByteCount = (BitCount + 7) >> 3;
    bd04:	69 5f       	subi	r22, 0xF9	; 249
    bd06:	7f 4f       	sbci	r23, 0xFF	; 255
    bd08:	83 e0       	ldi	r24, 0x03	; 3
    bd0a:	76 95       	lsr	r23
    bd0c:	67 95       	ror	r22
    bd0e:	8a 95       	dec	r24
    bd10:	e1 f7       	brne	.-8      	; 0xbd0a <NTAG215AppProcess+0x286>
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            State = FromHalt ? STATE_HALT : STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        }
        /* At the very least, there should be 3 bytes in the buffer. */
        if (ByteCount < (1 + ISO14443A_CRCA_SIZE)) {
    bd12:	63 30       	cpi	r22, 0x03	; 3
    bd14:	71 05       	cpc	r23, r1
    bd16:	08 f4       	brcc	.+2      	; 0xbd1a <NTAG215AppProcess+0x296>
    bd18:	1b cf       	rjmp	.-458    	; 0xbb50 <NTAG215AppProcess+0xcc>
            State = STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        }
        /* All commands here have CRCA appended; verify it right away */
        ByteCount -= 2;
        if (!ISO14443ACheckCRCA(Buffer, ByteCount)) {
    bd1a:	62 50       	subi	r22, 0x02	; 2
    bd1c:	71 09       	sbc	r23, r1
    bd1e:	c8 01       	movw	r24, r16
    bd20:	0e 94 8b 41 	call	0x8316	; 0x8316 <ISO14443ACheckCRCA>
    bd24:	81 11       	cpse	r24, r1
    bd26:	00 cf       	rjmp	.-512    	; 0xbb28 <NTAG215AppProcess+0xa4>
            Buffer[0] = NAK_CRC_ERROR;
    bd28:	81 e0       	ldi	r24, 0x01	; 1
    bd2a:	08 c1       	rjmp	.+528    	; 0xbf3c <NTAG215AppProcess+0x4b8>
{
     uint8_t Cmd = Buffer[0];

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
        ArmedForCompatWrite = false;
    bd2c:	10 92 99 2e 	sts	0x2E99, r1	; 0x802e99 <ArmedForCompatWrite>
}

//Writes a page
static uint8_t AppWritePage(uint8_t PageAddress, uint8_t* const Buffer)
{
    if (!ActiveConfiguration.ReadOnly) {
    bd30:	80 91 d4 2f 	lds	r24, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    bd34:	81 11       	cpse	r24, r1
    bd36:	01 c1       	rjmp	.+514    	; 0xbf3a <NTAG215AppProcess+0x4b6>

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
        ArmedForCompatWrite = false;

        AppWritePage(CompatWritePageAddress, &Buffer[2]);
    bd38:	60 91 98 2e 	lds	r22, 0x2E98	; 0x802e98 <CompatWritePageAddress>

//Writes a page
static uint8_t AppWritePage(uint8_t PageAddress, uint8_t* const Buffer)
{
    if (!ActiveConfiguration.ReadOnly) {
        MemoryWriteBlock(Buffer, PageAddress * NTAG215_PAGE_SIZE, NTAG215_PAGE_SIZE);
    bd3c:	f4 e0       	ldi	r31, 0x04	; 4
    bd3e:	6f 9f       	mul	r22, r31
    bd40:	b0 01       	movw	r22, r0
    bd42:	11 24       	eor	r1, r1
    bd44:	44 e0       	ldi	r20, 0x04	; 4
    bd46:	50 e0       	ldi	r21, 0x00	; 0
    bd48:	c8 01       	movw	r24, r16
    bd4a:	02 96       	adiw	r24, 0x02	; 2
    bd4c:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    bd50:	f4 c0       	rjmp	.+488    	; 0xbf3a <NTAG215AppProcess+0x4b6>
        AppWritePage(CompatWritePageAddress, &Buffer[2]);
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

      switch (Cmd) {
    bd52:	80 36       	cpi	r24, 0x60	; 96
    bd54:	61 f0       	breq	.+24     	; 0xbd6e <NTAG215AppProcess+0x2ea>
    bd56:	20 f4       	brcc	.+8      	; 0xbd60 <NTAG215AppProcess+0x2dc>
    bd58:	80 35       	cpi	r24, 0x50	; 80
    bd5a:	09 f4       	brne	.+2      	; 0xbd5e <NTAG215AppProcess+0x2da>
    bd5c:	03 c1       	rjmp	.+518    	; 0xbf64 <NTAG215AppProcess+0x4e0>
    bd5e:	f8 ce       	rjmp	.-528    	; 0xbb50 <NTAG215AppProcess+0xcc>
    bd60:	80 3a       	cpi	r24, 0xA0	; 160
    bd62:	09 f4       	brne	.+2      	; 0xbd66 <NTAG215AppProcess+0x2e2>
    bd64:	d2 c0       	rjmp	.+420    	; 0xbf0a <NTAG215AppProcess+0x486>
    bd66:	82 3a       	cpi	r24, 0xA2	; 162
    bd68:	09 f4       	brne	.+2      	; 0xbd6c <NTAG215AppProcess+0x2e8>
    bd6a:	b0 c0       	rjmp	.+352    	; 0xbecc <NTAG215AppProcess+0x448>
    bd6c:	f1 ce       	rjmp	.-542    	; 0xbb50 <NTAG215AppProcess+0xcc>
        case CMD_GET_VERSION: {
            /* Provide hardcoded version response */ //VERSION RESPONSE FOR NTAG 215
            Buffer[0] = 0x00;
    bd6e:	f8 01       	movw	r30, r16
    bd70:	10 82       	st	Z, r1
            Buffer[1] = 0x04;
    bd72:	84 e0       	ldi	r24, 0x04	; 4
    bd74:	81 83       	std	Z+1, r24	; 0x01
            Buffer[2] = 0x04;
    bd76:	82 83       	std	Z+2, r24	; 0x02
            Buffer[3] = 0x02;
    bd78:	82 e0       	ldi	r24, 0x02	; 2
    bd7a:	83 83       	std	Z+3, r24	; 0x03
            Buffer[4] = 0x01;
    bd7c:	81 e0       	ldi	r24, 0x01	; 1
    bd7e:	84 83       	std	Z+4, r24	; 0x04
            Buffer[5] = 0x00;
    bd80:	15 82       	std	Z+5, r1	; 0x05
            Buffer[6] = 0x11;
    bd82:	81 e1       	ldi	r24, 0x11	; 17
    bd84:	86 83       	std	Z+6, r24	; 0x06
            Buffer[7] = 0x03;
    bd86:	83 e0       	ldi	r24, 0x03	; 3
    bd88:	87 83       	std	Z+7, r24	; 0x07
            ISO14443AAppendCRCA(Buffer, VERSION_INFO_LENGTH);
    bd8a:	68 e0       	ldi	r22, 0x08	; 8
    bd8c:	70 e0       	ldi	r23, 0x00	; 0
    bd8e:	c8 01       	movw	r24, r16
    bd90:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
            return (VERSION_INFO_LENGTH + ISO14443A_CRCA_SIZE) * 8;
    bd94:	80 e5       	ldi	r24, 0x50	; 80
    bd96:	90 e0       	ldi	r25, 0x00	; 0
    bd98:	ec c0       	rjmp	.+472    	; 0xbf72 <NTAG215AppProcess+0x4ee>
        }

        case CMD_READ: {
            uint8_t PageAddress = Buffer[1];
    bd9a:	f8 01       	movw	r30, r16
    bd9c:	f1 80       	ldd	r15, Z+1	; 0x01
            uint8_t Offset;
            
            PageLimit = PageCount;
            
            /* if protected and not autenticated, ensure the wraparound is at the first protected page */
            if (ReadAccessProtected && !Authenticated) {
    bd9e:	80 91 95 2e 	lds	r24, 0x2E95	; 0x802e95 <ReadAccessProtected>
    bda2:	88 23       	and	r24, r24
    bda4:	39 f0       	breq	.+14     	; 0xbdb4 <NTAG215AppProcess+0x330>
    bda6:	80 91 97 2e 	lds	r24, 0x2E97	; 0x802e97 <Authenticated>
    bdaa:	81 11       	cpse	r24, r1
    bdac:	03 c0       	rjmp	.+6      	; 0xbdb4 <NTAG215AppProcess+0x330>
                PageLimit = FirstAuthenticatedPage;
    bdae:	e0 90 96 2e 	lds	r14, 0x2E96	; 0x802e96 <FirstAuthenticatedPage>
    bdb2:	02 c0       	rjmp	.+4      	; 0xbdb8 <NTAG215AppProcess+0x334>
            } 
            else {
                PageLimit = PageCount;
    bdb4:	e0 90 9a 2e 	lds	r14, 0x2E9A	; 0x802e9a <PageCount>
            }

            /* Validation */
            if (PageAddress >= PageLimit) {
    bdb8:	fe 14       	cp	r15, r14
    bdba:	18 f0       	brcs	.+6      	; 0xbdc2 <NTAG215AppProcess+0x33e>
                Buffer[0] = NAK_INVALID_ARG;
    bdbc:	f8 01       	movw	r30, r16
    bdbe:	10 82       	st	Z, r1
    bdc0:	bf c0       	rjmp	.+382    	; 0xbf40 <NTAG215AppProcess+0x4bc>
            else {
                PageLimit = PageCount;
            }

            /* Validation */
            if (PageAddress >= PageLimit) {
    bdc2:	c1 2c       	mov	r12, r1
    bdc4:	d1 2c       	mov	r13, r1
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            /* Read out, emulating the wraparound */
            for (Offset = 0; Offset < BYTES_PER_READ; Offset += 4) {
                MemoryReadBlock(&Buffer[Offset], PageAddress * NTAG215_PAGE_SIZE, NTAG215_PAGE_SIZE);
    bdc6:	f4 e0       	ldi	r31, 0x04	; 4
    bdc8:	ff 9e       	mul	r15, r31
    bdca:	b0 01       	movw	r22, r0
    bdcc:	11 24       	eor	r1, r1
    bdce:	44 e0       	ldi	r20, 0x04	; 4
    bdd0:	50 e0       	ldi	r21, 0x00	; 0
    bdd2:	c8 01       	movw	r24, r16
    bdd4:	8c 0d       	add	r24, r12
    bdd6:	9d 1d       	adc	r25, r13
    bdd8:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                PageAddress++;
    bddc:	f3 94       	inc	r15
                if (PageAddress == PageLimit) { // if arrived ad the last page, start reading from page 0
    bdde:	ef 10       	cpse	r14, r15
    bde0:	01 c0       	rjmp	.+2      	; 0xbde4 <NTAG215AppProcess+0x360>
                    PageAddress = 0;
    bde2:	f1 2c       	mov	r15, r1
    bde4:	24 e0       	ldi	r18, 0x04	; 4
    bde6:	c2 0e       	add	r12, r18
    bde8:	d1 1c       	adc	r13, r1
            if (PageAddress >= PageLimit) {
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            /* Read out, emulating the wraparound */
            for (Offset = 0; Offset < BYTES_PER_READ; Offset += 4) {
    bdea:	80 e1       	ldi	r24, 0x10	; 16
    bdec:	c8 16       	cp	r12, r24
    bdee:	d1 04       	cpc	r13, r1
    bdf0:	51 f7       	brne	.-44     	; 0xbdc6 <NTAG215AppProcess+0x342>
                PageAddress++;
                if (PageAddress == PageLimit) { // if arrived ad the last page, start reading from page 0
                    PageAddress = 0;
                }
            }
            ISO14443AAppendCRCA(Buffer, BYTES_PER_READ);
    bdf2:	60 e1       	ldi	r22, 0x10	; 16
    bdf4:	70 e0       	ldi	r23, 0x00	; 0
    bdf6:	c8 01       	movw	r24, r16
    bdf8:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
            return (BYTES_PER_READ + ISO14443A_CRCA_SIZE) * 8;
    bdfc:	80 e9       	ldi	r24, 0x90	; 144
    bdfe:	90 e0       	ldi	r25, 0x00	; 0
    be00:	b8 c0       	rjmp	.+368    	; 0xbf72 <NTAG215AppProcess+0x4ee>
        }
        
        case CMD_FAST_READ: {
                uint8_t StartPageAddress = Buffer[1];
    be02:	f8 01       	movw	r30, r16
    be04:	61 81       	ldd	r22, Z+1	; 0x01
                uint8_t EndPageAddress = Buffer[2];
    be06:	e2 80       	ldd	r14, Z+2	; 0x02
                /* Validation */
                if ((StartPageAddress > EndPageAddress) || (StartPageAddress >= PageCount) || (EndPageAddress >= PageCount)) {
    be08:	e6 16       	cp	r14, r22
    be0a:	c0 f2       	brcs	.-80     	; 0xbdbc <NTAG215AppProcess+0x338>
    be0c:	80 91 9a 2e 	lds	r24, 0x2E9A	; 0x802e9a <PageCount>
    be10:	68 17       	cp	r22, r24
    be12:	a0 f6       	brcc	.-88     	; 0xbdbc <NTAG215AppProcess+0x338>
    be14:	e8 16       	cp	r14, r24
    be16:	90 f6       	brcc	.-92     	; 0xbdbc <NTAG215AppProcess+0x338>
                    Buffer[0] = NAK_INVALID_ARG;
                    return NAK_FRAME_SIZE;
                }

                /* Check authentication only if protection is read&write (instead of only write protection) */
                if (ReadAccessProtected) {
    be18:	80 91 95 2e 	lds	r24, 0x2E95	; 0x802e95 <ReadAccessProtected>
    be1c:	88 23       	and	r24, r24
    be1e:	51 f0       	breq	.+20     	; 0xbe34 <NTAG215AppProcess+0x3b0>

//Verify authentication
static bool VerifyAuthentication(uint8_t PageAddress)
{
    /* If authenticated, no verification needed */
    if (Authenticated) {
    be20:	80 91 97 2e 	lds	r24, 0x2E97	; 0x802e97 <Authenticated>
    be24:	81 11       	cpse	r24, r1
    be26:	06 c0       	rjmp	.+12     	; 0xbe34 <NTAG215AppProcess+0x3b0>
        return true;
    }
    /* Otherwise, verify the accessed page is below the limit */
    return PageAddress < FirstAuthenticatedPage;
    be28:	80 91 96 2e 	lds	r24, 0x2E96	; 0x802e96 <FirstAuthenticatedPage>
                    return NAK_FRAME_SIZE;
                }

                /* Check authentication only if protection is read&write (instead of only write protection) */
                if (ReadAccessProtected) {
                    if (!VerifyAuthentication(StartPageAddress) || !VerifyAuthentication(EndPageAddress)) {
    be2c:	68 17       	cp	r22, r24
    be2e:	d0 f5       	brcc	.+116    	; 0xbea4 <NTAG215AppProcess+0x420>
    be30:	e8 16       	cp	r14, r24
    be32:	c0 f5       	brcc	.+112    	; 0xbea4 <NTAG215AppProcess+0x420>
                        Buffer[0] = NAK_NOT_AUTHED;
                        return NAK_FRAME_SIZE;
                    }
                }

                ByteCount = (EndPageAddress - StartPageAddress + 1) * NTAG215_PAGE_SIZE;
    be34:	f1 2c       	mov	r15, r1
    be36:	70 e0       	ldi	r23, 0x00	; 0
    be38:	e6 1a       	sub	r14, r22
    be3a:	f7 0a       	sbc	r15, r23
    be3c:	ff ef       	ldi	r31, 0xFF	; 255
    be3e:	ef 1a       	sub	r14, r31
    be40:	ff 0a       	sbc	r15, r31
    be42:	ee 0c       	add	r14, r14
    be44:	ff 1c       	adc	r15, r15
    be46:	ee 0c       	add	r14, r14
    be48:	ff 1c       	adc	r15, r15
                MemoryReadBlock(Buffer, StartPageAddress * NTAG215_PAGE_SIZE, ByteCount);
    be4a:	66 0f       	add	r22, r22
    be4c:	77 1f       	adc	r23, r23
    be4e:	66 0f       	add	r22, r22
    be50:	77 1f       	adc	r23, r23
    be52:	a7 01       	movw	r20, r14
    be54:	c8 01       	movw	r24, r16
    be56:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, ByteCount);
    be5a:	b7 01       	movw	r22, r14
    be5c:	c8 01       	movw	r24, r16
    be5e:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                return (ByteCount + ISO14443A_CRCA_SIZE) * 8;
    be62:	c7 01       	movw	r24, r14
    be64:	02 96       	adiw	r24, 0x02	; 2
    be66:	33 e0       	ldi	r19, 0x03	; 3
    be68:	88 0f       	add	r24, r24
    be6a:	99 1f       	adc	r25, r25
    be6c:	3a 95       	dec	r19
    be6e:	e1 f7       	brne	.-8      	; 0xbe68 <NTAG215AppProcess+0x3e4>
    be70:	80 c0       	rjmp	.+256    	; 0xbf72 <NTAG215AppProcess+0x4ee>

                /* For now I don't care about bruteforce protection, so: */
                /* TODO: IMPLEMENT COUNTER AUTHLIM */

                /* Read and compare the password */
                MemoryReadBlock(Password, CONFIG_AREA_START_ADDRESS + CONF_PASSWORD_OFFSET, 4);
    be72:	44 e0       	ldi	r20, 0x04	; 4
    be74:	50 e0       	ldi	r21, 0x00	; 0
    be76:	64 e1       	ldi	r22, 0x14	; 20
    be78:	72 e0       	ldi	r23, 0x02	; 2
    be7a:	ce 01       	movw	r24, r28
    be7c:	01 96       	adiw	r24, 0x01	; 1
    be7e:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                if (Password[0] != Buffer[1] || Password[1] != Buffer[2] || Password[2] != Buffer[3] || Password[3] != Buffer[4]) {
    be82:	99 81       	ldd	r25, Y+1	; 0x01
    be84:	f8 01       	movw	r30, r16
    be86:	81 81       	ldd	r24, Z+1	; 0x01
    be88:	98 13       	cpse	r25, r24
    be8a:	0c c0       	rjmp	.+24     	; 0xbea4 <NTAG215AppProcess+0x420>
    be8c:	9a 81       	ldd	r25, Y+2	; 0x02
    be8e:	82 81       	ldd	r24, Z+2	; 0x02
    be90:	98 13       	cpse	r25, r24
    be92:	08 c0       	rjmp	.+16     	; 0xbea4 <NTAG215AppProcess+0x420>
    be94:	9b 81       	ldd	r25, Y+3	; 0x03
    be96:	83 81       	ldd	r24, Z+3	; 0x03
    be98:	98 13       	cpse	r25, r24
    be9a:	04 c0       	rjmp	.+8      	; 0xbea4 <NTAG215AppProcess+0x420>
    be9c:	9c 81       	ldd	r25, Y+4	; 0x04
    be9e:	84 81       	ldd	r24, Z+4	; 0x04
    bea0:	98 17       	cp	r25, r24
    bea2:	11 f0       	breq	.+4      	; 0xbea8 <NTAG215AppProcess+0x424>
                    Buffer[0] = NAK_NOT_AUTHED;
    bea4:	84 e0       	ldi	r24, 0x04	; 4
    bea6:	4a c0       	rjmp	.+148    	; 0xbf3c <NTAG215AppProcess+0x4b8>
                    return NAK_FRAME_SIZE;
                }
                /* Authenticate the user */
		        //RESET AUTHLIM COUNTER, CURRENTLY NOT IMPLEMENTED 
                Authenticated = 1;
    bea8:	81 e0       	ldi	r24, 0x01	; 1
    beaa:	80 93 97 2e 	sts	0x2E97, r24	; 0x802e97 <Authenticated>
                /* Send the PACK value back */
                MemoryReadBlock(Buffer, CONFIG_AREA_START_ADDRESS + CONF_PACK_OFFSET, 2);
    beae:	42 e0       	ldi	r20, 0x02	; 2
    beb0:	50 e0       	ldi	r21, 0x00	; 0
    beb2:	68 e1       	ldi	r22, 0x18	; 24
    beb4:	72 e0       	ldi	r23, 0x02	; 2
    beb6:	c8 01       	movw	r24, r16
    beb8:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, 2);
    bebc:	62 e0       	ldi	r22, 0x02	; 2
    bebe:	70 e0       	ldi	r23, 0x00	; 0
    bec0:	c8 01       	movw	r24, r16
    bec2:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                return (2 + ISO14443A_CRCA_SIZE) * 8;
    bec6:	80 e2       	ldi	r24, 0x20	; 32
    bec8:	90 e0       	ldi	r25, 0x00	; 0
    beca:	53 c0       	rjmp	.+166    	; 0xbf72 <NTAG215AppProcess+0x4ee>
        }

        case CMD_WRITE: {
            /* This is a write command containing 4 bytes of data that
            * should be written to the given page address. */
            uint8_t PageAddress = Buffer[1];
    becc:	f8 01       	movw	r30, r16
    bece:	61 81       	ldd	r22, Z+1	; 0x01
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    bed0:	62 30       	cpi	r22, 0x02	; 2
    bed2:	08 f4       	brcc	.+2      	; 0xbed6 <NTAG215AppProcess+0x452>
    bed4:	73 cf       	rjmp	.-282    	; 0xbdbc <NTAG215AppProcess+0x338>
    bed6:	80 91 9a 2e 	lds	r24, 0x2E9A	; 0x802e9a <PageCount>
    beda:	68 17       	cp	r22, r24
    bedc:	08 f0       	brcs	.+2      	; 0xbee0 <NTAG215AppProcess+0x45c>
    bede:	6e cf       	rjmp	.-292    	; 0xbdbc <NTAG215AppProcess+0x338>

//Verify authentication
static bool VerifyAuthentication(uint8_t PageAddress)
{
    /* If authenticated, no verification needed */
    if (Authenticated) {
    bee0:	80 91 97 2e 	lds	r24, 0x2E97	; 0x802e97 <Authenticated>
    bee4:	81 11       	cpse	r24, r1
    bee6:	04 c0       	rjmp	.+8      	; 0xbef0 <NTAG215AppProcess+0x46c>
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    bee8:	80 91 96 2e 	lds	r24, 0x2E96	; 0x802e96 <FirstAuthenticatedPage>
    beec:	68 17       	cp	r22, r24
    beee:	d0 f6       	brcc	.-76     	; 0xbea4 <NTAG215AppProcess+0x420>
                Buffer[0] = NAK_NOT_AUTHED;
                return NAK_FRAME_SIZE;
            }
            AppWritePage(PageAddress, &Buffer[2]);
    bef0:	c8 01       	movw	r24, r16
    bef2:	02 96       	adiw	r24, 0x02	; 2
}

//Writes a page
static uint8_t AppWritePage(uint8_t PageAddress, uint8_t* const Buffer)
{
    if (!ActiveConfiguration.ReadOnly) {
    bef4:	20 91 d4 2f 	lds	r18, 0x2FD4	; 0x802fd4 <ActiveConfiguration+0x17>
    bef8:	21 11       	cpse	r18, r1
    befa:	1f c0       	rjmp	.+62     	; 0xbf3a <NTAG215AppProcess+0x4b6>
        MemoryWriteBlock(Buffer, PageAddress * NTAG215_PAGE_SIZE, NTAG215_PAGE_SIZE);
    befc:	f4 e0       	ldi	r31, 0x04	; 4
    befe:	6f 9f       	mul	r22, r31
    bf00:	b0 01       	movw	r22, r0
    bf02:	11 24       	eor	r1, r1
    bf04:	44 e0       	ldi	r20, 0x04	; 4
    bf06:	50 e0       	ldi	r21, 0x00	; 0
    bf08:	21 cf       	rjmp	.-446    	; 0xbd4c <NTAG215AppProcess+0x2c8>
            Buffer[0] = ACK_VALUE;
            return ACK_FRAME_SIZE;
        }

        case CMD_COMPAT_WRITE: {
            uint8_t PageAddress = Buffer[1];
    bf0a:	f8 01       	movw	r30, r16
    bf0c:	81 81       	ldd	r24, Z+1	; 0x01
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    bf0e:	82 30       	cpi	r24, 0x02	; 2
    bf10:	08 f4       	brcc	.+2      	; 0xbf14 <NTAG215AppProcess+0x490>
    bf12:	54 cf       	rjmp	.-344    	; 0xbdbc <NTAG215AppProcess+0x338>
    bf14:	90 91 9a 2e 	lds	r25, 0x2E9A	; 0x802e9a <PageCount>
    bf18:	89 17       	cp	r24, r25
    bf1a:	08 f0       	brcs	.+2      	; 0xbf1e <NTAG215AppProcess+0x49a>
    bf1c:	4f cf       	rjmp	.-354    	; 0xbdbc <NTAG215AppProcess+0x338>

//Verify authentication
static bool VerifyAuthentication(uint8_t PageAddress)
{
    /* If authenticated, no verification needed */
    if (Authenticated) {
    bf1e:	90 91 97 2e 	lds	r25, 0x2E97	; 0x802e97 <Authenticated>
    bf22:	91 11       	cpse	r25, r1
    bf24:	05 c0       	rjmp	.+10     	; 0xbf30 <NTAG215AppProcess+0x4ac>
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    bf26:	90 91 96 2e 	lds	r25, 0x2E96	; 0x802e96 <FirstAuthenticatedPage>
    bf2a:	89 17       	cp	r24, r25
    bf2c:	08 f0       	brcs	.+2      	; 0xbf30 <NTAG215AppProcess+0x4ac>
    bf2e:	ba cf       	rjmp	.-140    	; 0xbea4 <NTAG215AppProcess+0x420>
                Buffer[0] = NAK_NOT_AUTHED;
                return NAK_FRAME_SIZE;
            }
            /* CRC check passed and page-address is within bounds.
            * Store address and proceed to receiving the data. */
            CompatWritePageAddress = PageAddress;
    bf30:	80 93 98 2e 	sts	0x2E98, r24	; 0x802e98 <CompatWritePageAddress>
            ArmedForCompatWrite = true; //TODO:IMPLEMENT ARMED COMPAT WRITE
    bf34:	81 e0       	ldi	r24, 0x01	; 1
    bf36:	80 93 99 2e 	sts	0x2E99, r24	; 0x802e99 <ArmedForCompatWrite>
            Buffer[0] = ACK_VALUE;
    bf3a:	8a e0       	ldi	r24, 0x0A	; 10
    bf3c:	f8 01       	movw	r30, r16
    bf3e:	80 83       	st	Z, r24
            return ACK_FRAME_SIZE;
    bf40:	84 e0       	ldi	r24, 0x04	; 4
    bf42:	90 e0       	ldi	r25, 0x00	; 0
    bf44:	16 c0       	rjmp	.+44     	; 0xbf72 <NTAG215AppProcess+0x4ee>
        }


        case CMD_READ_SIG: {
                /* Hardcoded response */
                memset(Buffer, 0xCA, SIGNATURE_LENGTH);
    bf46:	40 e2       	ldi	r20, 0x20	; 32
    bf48:	50 e0       	ldi	r21, 0x00	; 0
    bf4a:	6a ec       	ldi	r22, 0xCA	; 202
    bf4c:	70 e0       	ldi	r23, 0x00	; 0
    bf4e:	c8 01       	movw	r24, r16
    bf50:	0e 94 ba 78 	call	0xf174	; 0xf174 <memset>
                ISO14443AAppendCRCA(Buffer, SIGNATURE_LENGTH);
    bf54:	60 e2       	ldi	r22, 0x20	; 32
    bf56:	70 e0       	ldi	r23, 0x00	; 0
    bf58:	c8 01       	movw	r24, r16
    bf5a:	0e 94 60 41 	call	0x82c0	; 0x82c0 <ISO14443AAppendCRCA>
                return (SIGNATURE_LENGTH + ISO14443A_CRCA_SIZE) * 8;
    bf5e:	80 e1       	ldi	r24, 0x10	; 16
    bf60:	91 e0       	ldi	r25, 0x01	; 1
    bf62:	07 c0       	rjmp	.+14     	; 0xbf72 <NTAG215AppProcess+0x4ee>
        
        //PART OF ISO STANDARD, NOT OF NTAG DATASHEET
        case CMD_HALT: {
            /* Halts the tag. According to the ISO14443, the second
            * byte is supposed to be 0. */
                if (Buffer[1] == 0) {
    bf64:	f8 01       	movw	r30, r16
    bf66:	81 81       	ldd	r24, Z+1	; 0x01
    bf68:	81 11       	cpse	r24, r1
    bf6a:	28 cf       	rjmp	.-432    	; 0xbdbc <NTAG215AppProcess+0x338>
                    /* According to ISO14443, we must not send anything
                    * in order to acknowledge the HALT command. */
                    State = STATE_HALT;
    bf6c:	10 92 9c 2e 	sts	0x2E9C, r1	; 0x802e9c <State>
    bf70:	f2 cd       	rjmp	.-1052   	; 0xbb56 <NTAG215AppProcess+0xd2>
        break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
}
    bf72:	24 96       	adiw	r28, 0x04	; 4
    bf74:	cd bf       	out	0x3d, r28	; 61
    bf76:	de bf       	out	0x3e, r29	; 62
    bf78:	df 91       	pop	r29
    bf7a:	cf 91       	pop	r28
    bf7c:	1f 91       	pop	r17
    bf7e:	0f 91       	pop	r16
    bf80:	ff 90       	pop	r15
    bf82:	ef 90       	pop	r14
    bf84:	df 90       	pop	r13
    bf86:	cf 90       	pop	r12
    bf88:	08 95       	ret

0000bf8a <NTAG215GetUid>:

//HELPER FUNCTIONS
void NTAG215GetUid(ConfigurationUidType Uid)
{
    bf8a:	cf 93       	push	r28
    bf8c:	df 93       	push	r29
    bf8e:	ec 01       	movw	r28, r24
    /* Read UID from memory */
    MemoryReadBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    bf90:	43 e0       	ldi	r20, 0x03	; 3
    bf92:	50 e0       	ldi	r21, 0x00	; 0
    bf94:	60 e0       	ldi	r22, 0x00	; 0
    bf96:	70 e0       	ldi	r23, 0x00	; 0
    bf98:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    MemoryReadBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    bf9c:	44 e0       	ldi	r20, 0x04	; 4
    bf9e:	50 e0       	ldi	r21, 0x00	; 0
    bfa0:	64 e0       	ldi	r22, 0x04	; 4
    bfa2:	70 e0       	ldi	r23, 0x00	; 0
    bfa4:	ce 01       	movw	r24, r28
    bfa6:	03 96       	adiw	r24, 0x03	; 3
}
    bfa8:	df 91       	pop	r29
    bfaa:	cf 91       	pop	r28
//HELPER FUNCTIONS
void NTAG215GetUid(ConfigurationUidType Uid)
{
    /* Read UID from memory */
    MemoryReadBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    MemoryReadBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    bfac:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

0000bfb0 <NTAG215SetUid>:
}

void NTAG215SetUid(ConfigurationUidType Uid)
{
    bfb0:	0f 93       	push	r16
    bfb2:	1f 93       	push	r17
    bfb4:	cf 93       	push	r28
    bfb6:	df 93       	push	r29
    bfb8:	1f 92       	push	r1
    bfba:	1f 92       	push	r1
    bfbc:	cd b7       	in	r28, 0x3d	; 61
    bfbe:	de b7       	in	r29, 0x3e	; 62
    bfc0:	8c 01       	movw	r16, r24
    /* Calculate check bytes and write everything into memory */
    uint8_t BCC1 = ISO14443A_UID0_CT ^ Uid[0] ^ Uid[1] ^ Uid[2];
    bfc2:	fc 01       	movw	r30, r24
    bfc4:	90 81       	ld	r25, Z
    bfc6:	81 81       	ldd	r24, Z+1	; 0x01
    bfc8:	89 27       	eor	r24, r25
    bfca:	98 e8       	ldi	r25, 0x88	; 136
    bfcc:	89 27       	eor	r24, r25
    bfce:	92 81       	ldd	r25, Z+2	; 0x02
    bfd0:	89 27       	eor	r24, r25
    bfd2:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t BCC2 = Uid[3] ^ Uid[4] ^ Uid[5] ^ Uid[6];
    bfd4:	93 81       	ldd	r25, Z+3	; 0x03
    bfd6:	84 81       	ldd	r24, Z+4	; 0x04
    bfd8:	89 27       	eor	r24, r25
    bfda:	95 81       	ldd	r25, Z+5	; 0x05
    bfdc:	89 27       	eor	r24, r25
    bfde:	96 81       	ldd	r25, Z+6	; 0x06
    bfe0:	89 27       	eor	r24, r25
    bfe2:	89 83       	std	Y+1, r24	; 0x01

    MemoryWriteBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    bfe4:	43 e0       	ldi	r20, 0x03	; 3
    bfe6:	50 e0       	ldi	r21, 0x00	; 0
    bfe8:	60 e0       	ldi	r22, 0x00	; 0
    bfea:	70 e0       	ldi	r23, 0x00	; 0
    bfec:	c8 01       	movw	r24, r16
    bfee:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    MemoryWriteBlock(&BCC1, UID_BCC1_ADDRESS, ISO14443A_CL_BCC_SIZE);
    bff2:	41 e0       	ldi	r20, 0x01	; 1
    bff4:	50 e0       	ldi	r21, 0x00	; 0
    bff6:	63 e0       	ldi	r22, 0x03	; 3
    bff8:	70 e0       	ldi	r23, 0x00	; 0
    bffa:	ce 01       	movw	r24, r28
    bffc:	02 96       	adiw	r24, 0x02	; 2
    bffe:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    MemoryWriteBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    c002:	44 e0       	ldi	r20, 0x04	; 4
    c004:	50 e0       	ldi	r21, 0x00	; 0
    c006:	64 e0       	ldi	r22, 0x04	; 4
    c008:	70 e0       	ldi	r23, 0x00	; 0
    c00a:	c8 01       	movw	r24, r16
    c00c:	03 96       	adiw	r24, 0x03	; 3
    c00e:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    MemoryWriteBlock(&BCC2, UID_BCC2_ADDRESS, ISO14443A_CL_BCC_SIZE);
    c012:	41 e0       	ldi	r20, 0x01	; 1
    c014:	50 e0       	ldi	r21, 0x00	; 0
    c016:	68 e0       	ldi	r22, 0x08	; 8
    c018:	70 e0       	ldi	r23, 0x00	; 0
    c01a:	ce 01       	movw	r24, r28
    c01c:	01 96       	adiw	r24, 0x01	; 1
    c01e:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
}
    c022:	0f 90       	pop	r0
    c024:	0f 90       	pop	r0
    c026:	df 91       	pop	r29
    c028:	cf 91       	pop	r28
    c02a:	1f 91       	pop	r17
    c02c:	0f 91       	pop	r16
    c02e:	08 95       	ret

0000c030 <isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT>:
 * The relevatn interrupt vector is registered to CODEC_DEMOD_IN_MASK0 (PIN1) via:
 * CODEC_DEMOD_IN_PORT.INT0MASK = CODEC_DEMOD_IN_MASK0;
 * and unregistered writing the INT0MASK to 0
 */
// ISR(CODEC_DEMOD_IN_INT0_VECT)
ISR_SHARED isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT(void) {
    c030:	1f 92       	push	r1
    c032:	0f 92       	push	r0
    c034:	0f b6       	in	r0, 0x3f	; 63
    c036:	0f 92       	push	r0
    c038:	11 24       	eor	r1, r1
    c03a:	08 b6       	in	r0, 0x38	; 56
    c03c:	0f 92       	push	r0
    c03e:	18 be       	out	0x38, r1	; 56
    c040:	0b b6       	in	r0, 0x3b	; 59
    c042:	0f 92       	push	r0
    c044:	1b be       	out	0x3b, r1	; 59
    c046:	8f 93       	push	r24
    c048:	ef 93       	push	r30
    c04a:	ff 93       	push	r31
    /* Start sample timer CODEC_TIMER_SAMPLING (TCD0).
     * Set Counter Channel C (CCC) with relevant bitmask (TC0_CCCIF_bm),
     * the period for clock sampling is specified in StartISO15693Demod.
     */
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    c04c:	e0 e0       	ldi	r30, 0x00	; 0
    c04e:	f9 e0       	ldi	r31, 0x09	; 9
    c050:	80 e4       	ldi	r24, 0x40	; 64
    c052:	84 87       	std	Z+12, r24	; 0x0c
    /* Sets register INTCTRLB to TC_CCCINTLVL_HI_gc = (0x03<<4) to enable compare/capture for high level interrupts on Channel C (CCC) */
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_HI_gc;
    c054:	80 e3       	ldi	r24, 0x30	; 48
    c056:	87 83       	std	Z+7, r24	; 0x07

    /* Disable this interrupt as we've already sensed the relevant pulse and will use our internal clock from now on */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    c058:	10 92 2a 06 	sts	0x062A, r1	; 0x80062a <__TEXT_REGION_LENGTH__+0x70062a>
}
    c05c:	ff 91       	pop	r31
    c05e:	ef 91       	pop	r30
    c060:	8f 91       	pop	r24
    c062:	0f 90       	pop	r0
    c064:	0b be       	out	0x3b, r0	; 59
    c066:	0f 90       	pop	r0
    c068:	08 be       	out	0x38, r0	; 56
    c06a:	0f 90       	pop	r0
    c06c:	0f be       	out	0x3f, r0	; 63
    c06e:	0f 90       	pop	r0
    c070:	1f 90       	pop	r1
    c072:	18 95       	reti

0000c074 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT>:
 *
 * It demodulates bits received from the reader and saves them in CodecBuffer.
 *
 * It disables its own interrupt when receives an EOF (calling ISO15693_EOC) or when it receives garbage
 */
ISR_SHARED isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT(void) {
    c074:	1f 92       	push	r1
    c076:	0f 92       	push	r0
    c078:	0f b6       	in	r0, 0x3f	; 63
    c07a:	0f 92       	push	r0
    c07c:	11 24       	eor	r1, r1
    c07e:	08 b6       	in	r0, 0x38	; 56
    c080:	0f 92       	push	r0
    c082:	18 be       	out	0x38, r1	; 56
    c084:	0b b6       	in	r0, 0x3b	; 59
    c086:	0f 92       	push	r0
    c088:	1b be       	out	0x3b, r1	; 59
    c08a:	2f 93       	push	r18
    c08c:	3f 93       	push	r19
    c08e:	8f 93       	push	r24
    c090:	9f 93       	push	r25
    c092:	ef 93       	push	r30
    c094:	ff 93       	push	r31
    /* Shift demod data */
    SampleRegister = (SampleRegister << 1) | (!(CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK) ? 0x01 : 0x00);
    c096:	93 b1       	in	r25, 0x03	; 3
    c098:	20 91 28 06 	lds	r18, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
    c09c:	26 70       	andi	r18, 0x06	; 6
    c09e:	81 e0       	ldi	r24, 0x01	; 1
    c0a0:	09 f0       	breq	.+2      	; 0xc0a4 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x30>
    c0a2:	80 e0       	ldi	r24, 0x00	; 0
    c0a4:	99 0f       	add	r25, r25
    c0a6:	89 2b       	or	r24, r25
    c0a8:	83 b9       	out	0x03, r24	; 3

    if (++BitSampleCount == 8) {
    c0aa:	86 b1       	in	r24, 0x06	; 6
    c0ac:	97 b1       	in	r25, 0x07	; 7
    c0ae:	01 96       	adiw	r24, 0x01	; 1
    c0b0:	86 b9       	out	0x06, r24	; 6
    c0b2:	97 b9       	out	0x07, r25	; 7
    c0b4:	08 97       	sbiw	r24, 0x08	; 8
    c0b6:	09 f0       	breq	.+2      	; 0xc0ba <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x46>
    c0b8:	c9 c0       	rjmp	.+402    	; 0xc24c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1d8>
        BitSampleCount = 0;
    c0ba:	16 b8       	out	0x06, r1	; 6
    c0bc:	17 b8       	out	0x07, r1	; 7
        switch (DemodState) {
    c0be:	80 91 a7 2e 	lds	r24, 0x2EA7	; 0x802ea7 <DemodState>
    c0c2:	81 30       	cpi	r24, 0x01	; 1
    c0c4:	e9 f0       	breq	.+58     	; 0xc100 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x8c>
    c0c6:	20 f0       	brcs	.+8      	; 0xc0d0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x5c>
    c0c8:	82 30       	cpi	r24, 0x02	; 2
    c0ca:	09 f4       	brne	.+2      	; 0xc0ce <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x5a>
    c0cc:	4e c0       	rjmp	.+156    	; 0xc16a <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xf6>
    c0ce:	be c0       	rjmp	.+380    	; 0xc24c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1d8>
            case DEMOD_SOC_STATE:
                if (SampleRegister == SOC_1_OF_4_CODE) {
    c0d0:	83 b1       	in	r24, 0x03	; 3
    c0d2:	8b 37       	cpi	r24, 0x7B	; 123
    c0d4:	49 f4       	brne	.+18     	; 0xc0e8 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x74>
                    DemodState = DEMOD_1_OUT_OF_4_STATE;
    c0d6:	81 e0       	ldi	r24, 0x01	; 1
    c0d8:	80 93 a7 2e 	sts	0x2EA7, r24	; 0x802ea7 <DemodState>
                    SampleDataCount = 0;
    c0dc:	10 92 9f 2e 	sts	0x2E9F, r1	; 0x802e9f <SampleDataCount>
    c0e0:	10 92 a0 2e 	sts	0x2EA0, r1	; 0x802ea0 <SampleDataCount+0x1>
                    ModulationPauseCount = 0;
    c0e4:	12 b8       	out	0x02, r1	; 2
    c0e6:	b2 c0       	rjmp	.+356    	; 0xc24c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1d8>
                } else if (SampleRegister == SOC_1_OF_256_CODE) {
    c0e8:	83 b1       	in	r24, 0x03	; 3
    c0ea:	8e 37       	cpi	r24, 0x7E	; 126
    c0ec:	09 f0       	breq	.+2      	; 0xc0f0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x7c>
    c0ee:	79 c0       	rjmp	.+242    	; 0xc1e2 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x16e>
                    DemodState = DEMOD_1_OUT_OF_256_STATE;
    c0f0:	82 e0       	ldi	r24, 0x02	; 2
    c0f2:	80 93 a7 2e 	sts	0x2EA7, r24	; 0x802ea7 <DemodState>
                    SampleDataCount = 0;
    c0f6:	10 92 9f 2e 	sts	0x2E9F, r1	; 0x802e9f <SampleDataCount>
    c0fa:	10 92 a0 2e 	sts	0x2EA0, r1	; 0x802ea0 <SampleDataCount+0x1>
    c0fe:	a6 c0       	rjmp	.+332    	; 0xc24c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1d8>
                    CODEC_TIMER_SAMPLING.INTCTRLB = 0;
                }
                break;

            case DEMOD_1_OUT_OF_4_STATE:
                if (SampleRegister == EOC_CODE) {
    c100:	83 b1       	in	r24, 0x03	; 3
    c102:	8f 3d       	cpi	r24, 0xDF	; 223
    c104:	b1 f1       	breq	.+108    	; 0xc172 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xfe>
                    ISO15693_EOC();
                } else {
                    uint8_t SampleData = ~SampleRegister;
    c106:	83 b1       	in	r24, 0x03	; 3
    c108:	80 95       	com	r24
                    if (SampleData == (0x01 << 6)) {
    c10a:	80 34       	cpi	r24, 0x40	; 64
    c10c:	39 f4       	brne	.+14     	; 0xc11c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xa8>
                        /* ^_^^^^^^ -> 00 */
                        ModulationPauseCount++;
    c10e:	82 b1       	in	r24, 0x02	; 2
    c110:	8f 5f       	subi	r24, 0xFF	; 255
    c112:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    c114:	80 b1       	in	r24, 0x00	; 0
    c116:	86 95       	lsr	r24
    c118:	86 95       	lsr	r24
    c11a:	21 c0       	rjmp	.+66     	; 0xc15e <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xea>

                    } else if (SampleData == (0x01 << 4)) {
    c11c:	80 31       	cpi	r24, 0x10	; 16
    c11e:	49 f4       	brne	.+18     	; 0xc132 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xbe>
                        /* ^^^_^^^^ -> 01 */
                        ModulationPauseCount++;
    c120:	82 b1       	in	r24, 0x02	; 2
    c122:	8f 5f       	subi	r24, 0xFF	; 255
    c124:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    c126:	80 b1       	in	r24, 0x00	; 0
    c128:	86 95       	lsr	r24
    c12a:	86 95       	lsr	r24
    c12c:	80 b9       	out	0x00, r24	; 0
                        DataRegister |= 0b01 << 6;
    c12e:	06 9a       	sbi	0x00, 6	; 0
    c130:	17 c0       	rjmp	.+46     	; 0xc160 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xec>

                    } else if (SampleData == (0x01 << 2)) {
    c132:	84 30       	cpi	r24, 0x04	; 4
    c134:	49 f4       	brne	.+18     	; 0xc148 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xd4>
                        /* ^^^^^_^^ -> 10 */
                        ModulationPauseCount++;
    c136:	82 b1       	in	r24, 0x02	; 2
    c138:	8f 5f       	subi	r24, 0xFF	; 255
    c13a:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    c13c:	80 b1       	in	r24, 0x00	; 0
    c13e:	86 95       	lsr	r24
    c140:	86 95       	lsr	r24
    c142:	80 b9       	out	0x00, r24	; 0
                        DataRegister |= 0b10 << 6;
    c144:	07 9a       	sbi	0x00, 7	; 0
    c146:	0c c0       	rjmp	.+24     	; 0xc160 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xec>

                    } else if (SampleData == (0x01 << 0)) {
    c148:	81 30       	cpi	r24, 0x01	; 1
    c14a:	51 f4       	brne	.+20     	; 0xc160 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xec>
                        /* ^^^^^^^_ -> 11 */
                        ModulationPauseCount++;
    c14c:	82 b1       	in	r24, 0x02	; 2
    c14e:	8f 5f       	subi	r24, 0xFF	; 255
    c150:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    c152:	80 b1       	in	r24, 0x00	; 0
    c154:	86 95       	lsr	r24
    c156:	86 95       	lsr	r24
    c158:	80 b9       	out	0x00, r24	; 0
                        DataRegister |= 0b11 << 6;
    c15a:	80 b1       	in	r24, 0x00	; 0
    c15c:	80 6c       	ori	r24, 0xC0	; 192
    c15e:	80 b9       	out	0x00, r24	; 0
                    }

                    if (ModulationPauseCount == 4) {
    c160:	82 b1       	in	r24, 0x02	; 2
    c162:	84 30       	cpi	r24, 0x04	; 4
    c164:	09 f0       	breq	.+2      	; 0xc168 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xf4>
    c166:	72 c0       	rjmp	.+228    	; 0xc24c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1d8>
    c168:	62 c0       	rjmp	.+196    	; 0xc22e <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1ba>
                    }
                }
                break;

            case DEMOD_1_OUT_OF_256_STATE:
                if (SampleRegister == EOC_CODE) {
    c16a:	83 b1       	in	r24, 0x03	; 3
    c16c:	8f 3d       	cpi	r24, 0xDF	; 223
    c16e:	09 f0       	breq	.+2      	; 0xc172 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xfe>
    c170:	40 c0       	rjmp	.+128    	; 0xc1f2 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x17e>
/* This function is called from isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT
 * when we have 8 bits in SampleRegister and they represent an end of frame.
 */
INLINE void ISO15693_EOC(void) {
    /* Set bitrate required by the reader on SOF for our following response */
    BitRate1 = 256 * 4; // 256 * 4 - 1
    c172:	80 e0       	ldi	r24, 0x00	; 0
    c174:	94 e0       	ldi	r25, 0x04	; 4
    c176:	80 93 a3 2e 	sts	0x2EA3, r24	; 0x802ea3 <BitRate1>
    c17a:	90 93 a4 2e 	sts	0x2EA4, r25	; 0x802ea4 <BitRate1+0x1>
    if (CodecBuffer[0] & ISO15693_REQ_DATARATE_HIGH)
    c17e:	80 91 3d 32 	lds	r24, 0x323D	; 0x80323d <CodecBuffer>
    c182:	98 2f       	mov	r25, r24
    c184:	92 70       	andi	r25, 0x02	; 2
    c186:	81 ff       	sbrs	r24, 1
    c188:	06 c0       	rjmp	.+12     	; 0xc196 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x122>
        BitRate1 = 256;
    c18a:	20 e0       	ldi	r18, 0x00	; 0
    c18c:	31 e0       	ldi	r19, 0x01	; 1
    c18e:	20 93 a3 2e 	sts	0x2EA3, r18	; 0x802ea3 <BitRate1>
    c192:	30 93 a4 2e 	sts	0x2EA4, r19	; 0x802ea4 <BitRate1+0x1>

    if (CodecBuffer[0] & ISO15693_REQ_SUBCARRIER_DUAL) {
    c196:	80 ff       	sbrs	r24, 0
    c198:	0b c0       	rjmp	.+22     	; 0xc1b0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x13c>
        BitRate2 = 252 * 4; // 252 * 4 - 3
    c19a:	20 ef       	ldi	r18, 0xF0	; 240
    c19c:	33 e0       	ldi	r19, 0x03	; 3
    c19e:	20 93 a1 2e 	sts	0x2EA1, r18	; 0x802ea1 <BitRate2>
    c1a2:	30 93 a2 2e 	sts	0x2EA2, r19	; 0x802ea2 <BitRate2+0x1>
        if (CodecBuffer[0] & ISO15693_REQ_DATARATE_HIGH)
    c1a6:	99 23       	and	r25, r25
    c1a8:	59 f0       	breq	.+22     	; 0xc1c0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x14c>
            BitRate2 = 252;
    c1aa:	8c ef       	ldi	r24, 0xFC	; 252
    c1ac:	90 e0       	ldi	r25, 0x00	; 0
    c1ae:	04 c0       	rjmp	.+8      	; 0xc1b8 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x144>
    } else {
        BitRate2 = BitRate1;
    c1b0:	80 91 a3 2e 	lds	r24, 0x2EA3	; 0x802ea3 <BitRate1>
    c1b4:	90 91 a4 2e 	lds	r25, 0x2EA4	; 0x802ea4 <BitRate1+0x1>
    c1b8:	80 93 a1 2e 	sts	0x2EA1, r24	; 0x802ea1 <BitRate2>
    c1bc:	90 93 a2 2e 	sts	0x2EA2, r25	; 0x802ea2 <BitRate2+0x1>
    }

    /* Disable event action for CODEC_TIMER_LOADMOD (TCE0) as we're done receiving data */
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_OFF_gc;
    c1c0:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>
    /* Set Counter Channel B (CCB) with relevant bitmask (TC0_CCBIF_bm), the period for clock sampling is specified below */
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_CCBIF_bm; // TODO This might not be needed since commenting it does not break anything
    c1c4:	80 e2       	ldi	r24, 0x20	; 32
    c1c6:	80 93 0c 0a 	sts	0x0A0C, r24	; 0x800a0c <__TEXT_REGION_LENGTH__+0x700a0c>
    /* Sets register INTCTRLB to TC_CCBINTLVL_HI_gc = (0x03<<2) to enable compare/capture for high level interrupts on channel B */
    CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCBINTLVL_HI_gc;
    c1ca:	8c e0       	ldi	r24, 0x0C	; 12
    c1cc:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    /* Set the period for CODEC_TIMER_LOADMOD (TCE0) to Bitrate - 1 because PERBUF is 0-based
     *
     * TODO Why are we using PERBUF instead of PER?
     *      With PERBUF the period register will occur on the next overflow.
     */
    CODEC_TIMER_LOADMOD.PERBUF = BitRate1 - 1;
    c1d0:	80 91 a3 2e 	lds	r24, 0x2EA3	; 0x802ea3 <BitRate1>
    c1d4:	90 91 a4 2e 	lds	r25, 0x2EA4	; 0x802ea4 <BitRate1+0x1>
    c1d8:	01 97       	sbiw	r24, 0x01	; 1
    c1da:	80 93 36 0a 	sts	0x0A36, r24	; 0x800a36 <__TEXT_REGION_LENGTH__+0x700a36>
    c1de:	90 93 37 0a 	sts	0x0A37, r25	; 0x800a37 <__TEXT_REGION_LENGTH__+0x700a37>

    Flags.DemodFinished = 1;
    c1e2:	81 e0       	ldi	r24, 0x01	; 1
    c1e4:	80 93 a9 2e 	sts	0x2EA9, r24	; 0x802ea9 <Flags>
    /* Sets timer off for CODEC_TIMER_SAMPLING (TCD0) disabling clock source */
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    c1e8:	10 92 00 09 	sts	0x0900, r1	; 0x800900 <__TEXT_REGION_LENGTH__+0x700900>
    /* Sets register INTCTRLB to 0 to disable all compare/capture interrupts */
    CODEC_TIMER_SAMPLING.INTCTRLB = 0;
    c1ec:	10 92 07 09 	sts	0x0907, r1	; 0x800907 <__TEXT_REGION_LENGTH__+0x700907>
    c1f0:	2d c0       	rjmp	.+90     	; 0xc24c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1d8>

            case DEMOD_1_OUT_OF_256_STATE:
                if (SampleRegister == EOC_CODE) {
                    ISO15693_EOC();
                } else {
                    uint8_t Position = ((SampleDataCount / 2) % 256) - 1;
    c1f2:	80 91 9f 2e 	lds	r24, 0x2E9F	; 0x802e9f <SampleDataCount>
    c1f6:	90 91 a0 2e 	lds	r25, 0x2EA0	; 0x802ea0 <SampleDataCount+0x1>
    c1fa:	96 95       	lsr	r25
    c1fc:	87 95       	ror	r24
                    uint8_t SampleData = ~SampleRegister;
    c1fe:	23 b1       	in	r18, 0x03	; 3
    c200:	20 95       	com	r18

                    if (SampleData == (0x01 << 6)) {
    c202:	20 34       	cpi	r18, 0x40	; 64
    c204:	11 f4       	brne	.+4      	; 0xc20a <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x196>
                        /* ^_^^^^^^ -> N-3 */
                        DataRegister = Position - 3;
    c206:	84 50       	subi	r24, 0x04	; 4
    c208:	0b c0       	rjmp	.+22     	; 0xc220 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1ac>
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 4)) {
    c20a:	20 31       	cpi	r18, 0x10	; 16
    c20c:	11 f4       	brne	.+4      	; 0xc212 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x19e>
                        /* ^^^_^^^^ -> N-2 */
                        DataRegister = Position - 2;
    c20e:	83 50       	subi	r24, 0x03	; 3
    c210:	07 c0       	rjmp	.+14     	; 0xc220 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1ac>
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 2)) {
    c212:	24 30       	cpi	r18, 0x04	; 4
    c214:	11 f4       	brne	.+4      	; 0xc21a <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1a6>
                        /* ^^^^^_^^ -> N-1 */
                        DataRegister = Position - 1;
    c216:	82 50       	subi	r24, 0x02	; 2
    c218:	03 c0       	rjmp	.+6      	; 0xc220 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1ac>
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 0)) {
    c21a:	21 30       	cpi	r18, 0x01	; 1
    c21c:	29 f4       	brne	.+10     	; 0xc228 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b4>

            case DEMOD_1_OUT_OF_256_STATE:
                if (SampleRegister == EOC_CODE) {
                    ISO15693_EOC();
                } else {
                    uint8_t Position = ((SampleDataCount / 2) % 256) - 1;
    c21e:	81 50       	subi	r24, 0x01	; 1
                        DataRegister = Position - 1;
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 0)) {
                        /* ^^^^^^^_ -> N-0 */
                        DataRegister = Position - 0;
    c220:	80 b9       	out	0x00, r24	; 0
                        ModulationPauseCount++;
    c222:	82 b1       	in	r24, 0x02	; 2
    c224:	8f 5f       	subi	r24, 0xFF	; 255
    c226:	82 b9       	out	0x02, r24	; 2
                    }

                    if (ModulationPauseCount == 1) {
    c228:	82 b1       	in	r24, 0x02	; 2
    c22a:	81 30       	cpi	r24, 0x01	; 1
    c22c:	79 f4       	brne	.+30     	; 0xc24c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1d8>
                        ModulationPauseCount = 0;
    c22e:	12 b8       	out	0x02, r1	; 2
                        *CodecBufferPtr = DataRegister;
    c230:	e8 b1       	in	r30, 0x08	; 8
    c232:	f9 b1       	in	r31, 0x09	; 9
    c234:	80 b1       	in	r24, 0x00	; 0
    c236:	80 83       	st	Z, r24
                        ++CodecBufferPtr;
    c238:	88 b1       	in	r24, 0x08	; 8
    c23a:	99 b1       	in	r25, 0x09	; 9
    c23c:	01 96       	adiw	r24, 0x01	; 1
    c23e:	88 b9       	out	0x08, r24	; 8
    c240:	99 b9       	out	0x09, r25	; 9
                        ++ByteCount;
    c242:	80 91 a5 2e 	lds	r24, 0x2EA5	; 0x802ea5 <ByteCount>
    c246:	8f 5f       	subi	r24, 0xFF	; 255
    c248:	80 93 a5 2e 	sts	0x2EA5, r24	; 0x802ea5 <ByteCount>
                    }
                }
                break;
        }
    }
    SampleDataCount++;
    c24c:	80 91 9f 2e 	lds	r24, 0x2E9F	; 0x802e9f <SampleDataCount>
    c250:	90 91 a0 2e 	lds	r25, 0x2EA0	; 0x802ea0 <SampleDataCount+0x1>
    c254:	01 96       	adiw	r24, 0x01	; 1
    c256:	80 93 9f 2e 	sts	0x2E9F, r24	; 0x802e9f <SampleDataCount>
    c25a:	90 93 a0 2e 	sts	0x2EA0, r25	; 0x802ea0 <SampleDataCount+0x1>
}
    c25e:	ff 91       	pop	r31
    c260:	ef 91       	pop	r30
    c262:	9f 91       	pop	r25
    c264:	8f 91       	pop	r24
    c266:	3f 91       	pop	r19
    c268:	2f 91       	pop	r18
    c26a:	0f 90       	pop	r0
    c26c:	0b be       	out	0x3b, r0	; 59
    c26e:	0f 90       	pop	r0
    c270:	08 be       	out	0x38, r0	; 56
    c272:	0f 90       	pop	r0
    c274:	0f be       	out	0x3f, r0	; 63
    c276:	0f 90       	pop	r0
    c278:	1f 90       	pop	r1
    c27a:	18 95       	reti

0000c27c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT>:
        [LOADMOD_BIT1_DUAL]     = && LOADMOD_BIT1_DUAL_LABEL,
        [LOADMOD_EOF_DUAL]      = && LOADMOD_EOF_DUAL_LABEL,
        [LOADMOD_FINISHED]      = && LOADMOD_FINISHED_LABEL
    };

    if ((StateRegister >= LOADMOD_START_SINGLE) && (StateRegister <= LOADMOD_FINISHED)) {
    c27c:	81 b1       	in	r24, 0x01	; 1
    c27e:	88 23       	and	r24, r24
    c280:	09 f4       	brne	.+2      	; 0xc284 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x8>
    c282:	59 c1       	rjmp	.+690    	; 0xc536 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
    c284:	81 b1       	in	r24, 0x01	; 1
    c286:	8c 30       	cpi	r24, 0x0C	; 12
    c288:	08 f0       	brcs	.+2      	; 0xc28c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x10>
    c28a:	55 c1       	rjmp	.+682    	; 0xc536 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
        goto *JumpTable[StateRegister];
    c28c:	e1 b1       	in	r30, 0x01	; 1
    c28e:	f0 e0       	ldi	r31, 0x00	; 0
    c290:	ee 0f       	add	r30, r30
    c292:	ff 1f       	adc	r31, r31
    c294:	e0 55       	subi	r30, 0x50	; 80
    c296:	fc 4d       	sbci	r31, 0xDC	; 220
    c298:	01 90       	ld	r0, Z+
    c29a:	f0 81       	ld	r31, Z
    c29c:	e0 2d       	mov	r30, r0
    c29e:	19 94       	eijmp
        return;
    }

LOADMOD_START_SINGLE_LABEL:
    /* Application produced data. With this interrupt we are aligned to the bit-grid. */
    ShiftRegister = SOF_PATTERN;
    c2a0:	8d e1       	ldi	r24, 0x1D	; 29
    c2a2:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent = 0;
    c2a6:	14 b8       	out	0x04, r1	; 4
    c2a8:	15 b8       	out	0x05, r1	; 5
    /* Fallthrough */
LOADMOD_SOF_SINGLE_LABEL:
    if (ShiftRegister & 0x80) {
    c2aa:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c2ae:	87 ff       	sbrs	r24, 7
    c2b0:	02 c0       	rjmp	.+4      	; 0xc2b6 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x3a>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    c2b2:	8e 9a       	sbi	0x11, 6	; 17
    c2b4:	01 c0       	rjmp	.+2      	; 0xc2b8 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x3c>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    c2b6:	8e 98       	cbi	0x11, 6	; 17
INLINE void CodecChangeDivider(uint16_t Divider) {
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
}

INLINE void CodecStartSubcarrier(void) {
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    c2b8:	8e e0       	ldi	r24, 0x0E	; 14
    c2ba:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
        CodecSetLoadmodState(false);
    }

    CodecStartSubcarrier();

    ShiftRegister <<= 1;
    c2be:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c2c2:	88 0f       	add	r24, r24
    c2c4:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent++;
    c2c8:	84 b1       	in	r24, 0x04	; 4
    c2ca:	95 b1       	in	r25, 0x05	; 5
    c2cc:	01 96       	adiw	r24, 0x01	; 1
    c2ce:	84 b9       	out	0x04, r24	; 4
    c2d0:	95 b9       	out	0x05, r25	; 5

    if ((BitSent % 8) == 0) {
    c2d2:	84 b1       	in	r24, 0x04	; 4
    c2d4:	95 b1       	in	r25, 0x05	; 5
    c2d6:	87 70       	andi	r24, 0x07	; 7
    c2d8:	99 27       	eor	r25, r25
    c2da:	89 2b       	or	r24, r25
    c2dc:	11 f4       	brne	.+4      	; 0xc2e2 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x66>
        /* Last SOF bit has been put out. Start sending out data */
        StateRegister = LOADMOD_BIT0_SINGLE;
    c2de:	83 e0       	ldi	r24, 0x03	; 3
    c2e0:	82 c0       	rjmp	.+260    	; 0xc3e6 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x16a>
        ShiftRegister = (*CodecBufferPtr++);
    } else {
        StateRegister = LOADMOD_SOF_SINGLE;
    c2e2:	82 e0       	ldi	r24, 0x02	; 2
    c2e4:	1b c1       	rjmp	.+566    	; 0xc51c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    }
    return;

LOADMOD_BIT0_SINGLE_LABEL: //Manchester encoding
    if (ShiftRegister & 0x01) {
    c2e6:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c2ea:	80 ff       	sbrs	r24, 0
    c2ec:	02 c0       	rjmp	.+4      	; 0xc2f2 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x76>

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    c2ee:	8e 98       	cbi	0x11, 6	; 17
    c2f0:	01 c0       	rjmp	.+2      	; 0xc2f4 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x78>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    c2f2:	8e 9a       	sbi	0x11, 6	; 17
    } else {
        /* Activate carrier */
        CodecSetLoadmodState(true);
    }

    StateRegister = LOADMOD_BIT1_SINGLE;
    c2f4:	84 e0       	ldi	r24, 0x04	; 4
    c2f6:	12 c1       	rjmp	.+548    	; 0xc51c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    return;

LOADMOD_BIT1_SINGLE_LABEL: //Manchester encoding
    if (ShiftRegister & 0x01) {
    c2f8:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c2fc:	80 ff       	sbrs	r24, 0
    c2fe:	02 c0       	rjmp	.+4      	; 0xc304 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x88>
    c300:	8e 9a       	sbi	0x11, 6	; 17
    c302:	01 c0       	rjmp	.+2      	; 0xc306 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x8a>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    c304:	8e 98       	cbi	0x11, 6	; 17
        CodecSetLoadmodState(true);
    } else {
        CodecSetLoadmodState(false);
    }

    ShiftRegister >>= 1;
    c306:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c30a:	86 95       	lsr	r24
    c30c:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent++;
    c310:	84 b1       	in	r24, 0x04	; 4
    c312:	95 b1       	in	r25, 0x05	; 5
    c314:	01 96       	adiw	r24, 0x01	; 1
    c316:	84 b9       	out	0x04, r24	; 4
    c318:	95 b9       	out	0x05, r25	; 5

    StateRegister = LOADMOD_BIT0_SINGLE;
    c31a:	83 e0       	ldi	r24, 0x03	; 3
    c31c:	81 b9       	out	0x01, r24	; 1

    if ((BitSent % 8) == 0) {
    c31e:	84 b1       	in	r24, 0x04	; 4
    c320:	95 b1       	in	r25, 0x05	; 5
    c322:	87 70       	andi	r24, 0x07	; 7
    c324:	99 27       	eor	r25, r25
    c326:	89 2b       	or	r24, r25
    c328:	09 f0       	breq	.+2      	; 0xc32c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xb0>
    c32a:	05 c1       	rjmp	.+522    	; 0xc536 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
        /* Byte boundary */
        if (--ByteCount == 0) {
    c32c:	80 91 a5 2e 	lds	r24, 0x2EA5	; 0x802ea5 <ByteCount>
    c330:	81 50       	subi	r24, 0x01	; 1
    c332:	80 93 a5 2e 	sts	0x2EA5, r24	; 0x802ea5 <ByteCount>
    c336:	81 11       	cpse	r24, r1
    c338:	b6 c0       	rjmp	.+364    	; 0xc4a6 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x22a>
            /* No more data left */
            ShiftRegister = EOF_PATTERN;
    c33a:	88 eb       	ldi	r24, 0xB8	; 184
    c33c:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    c340:	18 c0       	rjmp	.+48     	; 0xc372 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xf6>
    }
    return;

LOADMOD_EOF_SINGLE_LABEL: //End of Manchester encoding
    /* Output EOF */
    if (ShiftRegister & 0x80) {
    c342:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c346:	87 ff       	sbrs	r24, 7
    c348:	02 c0       	rjmp	.+4      	; 0xc34e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xd2>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    c34a:	8e 9a       	sbi	0x11, 6	; 17
    c34c:	01 c0       	rjmp	.+2      	; 0xc350 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xd4>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    c34e:	8e 98       	cbi	0x11, 6	; 17
        CodecSetLoadmodState(true);
    } else {
        CodecSetLoadmodState(false);
    }

    ShiftRegister <<= 1;
    c350:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c354:	88 0f       	add	r24, r24
    c356:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent++;
    c35a:	84 b1       	in	r24, 0x04	; 4
    c35c:	95 b1       	in	r25, 0x05	; 5
    c35e:	01 96       	adiw	r24, 0x01	; 1
    c360:	84 b9       	out	0x04, r24	; 4
    c362:	95 b9       	out	0x05, r25	; 5

    if ((BitSent % 8) == 0) {
    c364:	84 b1       	in	r24, 0x04	; 4
    c366:	95 b1       	in	r25, 0x05	; 5
    c368:	87 70       	andi	r24, 0x07	; 7
    c36a:	99 27       	eor	r25, r25
    c36c:	89 2b       	or	r24, r25
    c36e:	09 f4       	brne	.+2      	; 0xc372 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xf6>
    c370:	d2 c0       	rjmp	.+420    	; 0xc516 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x29a>
        /* Last bit has been put out */
        StateRegister = LOADMOD_FINISHED;
    } else {
        StateRegister = LOADMOD_EOF_SINGLE;
    c372:	85 e0       	ldi	r24, 0x05	; 5
    c374:	d3 c0       	rjmp	.+422    	; 0xc51c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    return;

    // -------------------------------------------------------------

LOADMOD_START_DUAL_LABEL:
    ShiftRegister = SOF_PATTERN;
    c376:	8d e1       	ldi	r24, 0x1D	; 29
    c378:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent = 0;
    c37c:	14 b8       	out	0x04, r1	; 4
    c37e:	15 b8       	out	0x05, r1	; 5
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    c380:	8e 9a       	sbi	0x11, 6	; 17
INLINE void CodecChangeDivider(uint16_t Divider) {
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
}

INLINE void CodecStartSubcarrier(void) {
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    c382:	8e e0       	ldi	r24, 0x0E	; 14
    c384:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    CodecSetLoadmodState(true);
    CodecStartSubcarrier();
    // fallthrough
LOADMOD_SOF_DUAL_LABEL:
    if (ShiftRegister & 0x80) {
    c388:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c38c:	87 ff       	sbrs	r24, 7
    c38e:	0b c0       	rjmp	.+22     	; 0xc3a6 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x12a>
        CODEC_SUBCARRIER_TIMER.CTRLB = CODEC_SUBCARRIER_CCEN_OOK | TC_WGMODE_SINGLESLOPE_gc;
    }
}

INLINE void CodecChangeDivider(uint16_t Divider) {
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    c390:	8f e1       	ldi	r24, 0x1F	; 31
    c392:	90 e0       	ldi	r25, 0x00	; 0
    c394:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c398:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
        CodecChangeDivider(SUBCARRIER_1);
        CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    c39c:	80 91 a3 2e 	lds	r24, 0x2EA3	; 0x802ea3 <BitRate1>
    c3a0:	90 91 a4 2e 	lds	r25, 0x2EA4	; 0x802ea4 <BitRate1+0x1>
    c3a4:	0a c0       	rjmp	.+20     	; 0xc3ba <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x13e>
    c3a6:	8b e1       	ldi	r24, 0x1B	; 27
    c3a8:	90 e0       	ldi	r25, 0x00	; 0
    c3aa:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c3ae:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
    } else {
        CodecChangeDivider(SUBCARRIER_2);
        CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    c3b2:	80 91 a1 2e 	lds	r24, 0x2EA1	; 0x802ea1 <BitRate2>
    c3b6:	90 91 a2 2e 	lds	r25, 0x2EA2	; 0x802ea2 <BitRate2+0x1>
    c3ba:	01 97       	sbiw	r24, 0x01	; 1
    c3bc:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    c3c0:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    }

    ShiftRegister <<= 1;
    c3c4:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c3c8:	88 0f       	add	r24, r24
    c3ca:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent++;
    c3ce:	84 b1       	in	r24, 0x04	; 4
    c3d0:	95 b1       	in	r25, 0x05	; 5
    c3d2:	01 96       	adiw	r24, 0x01	; 1
    c3d4:	84 b9       	out	0x04, r24	; 4
    c3d6:	95 b9       	out	0x05, r25	; 5

    if ((BitSent % 8) == 0) {
    c3d8:	84 b1       	in	r24, 0x04	; 4
    c3da:	95 b1       	in	r25, 0x05	; 5
    c3dc:	87 70       	andi	r24, 0x07	; 7
    c3de:	99 27       	eor	r25, r25
    c3e0:	89 2b       	or	r24, r25
    c3e2:	19 f4       	brne	.+6      	; 0xc3ea <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x16e>
        /* Last SOF bit has been put out. Start sending out data */
        StateRegister = LOADMOD_BIT0_DUAL;
    c3e4:	88 e0       	ldi	r24, 0x08	; 8
    c3e6:	81 b9       	out	0x01, r24	; 1
    c3e8:	5e c0       	rjmp	.+188    	; 0xc4a6 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x22a>
        ShiftRegister = (*CodecBufferPtr++);
    } else {
        StateRegister = LOADMOD_SOF_DUAL;
    c3ea:	87 e0       	ldi	r24, 0x07	; 7
    c3ec:	97 c0       	rjmp	.+302    	; 0xc51c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    }
    return;

LOADMOD_BIT0_DUAL_LABEL: //Manchester encoding
    if (ShiftRegister & 0x01) {
    c3ee:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c3f2:	80 ff       	sbrs	r24, 0
    c3f4:	0b c0       	rjmp	.+22     	; 0xc40c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x190>
    c3f6:	8b e1       	ldi	r24, 0x1B	; 27
    c3f8:	90 e0       	ldi	r25, 0x00	; 0
    c3fa:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c3fe:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
        CodecChangeDivider(SUBCARRIER_2);
        CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    c402:	80 91 a1 2e 	lds	r24, 0x2EA1	; 0x802ea1 <BitRate2>
    c406:	90 91 a2 2e 	lds	r25, 0x2EA2	; 0x802ea2 <BitRate2+0x1>
    c40a:	0a c0       	rjmp	.+20     	; 0xc420 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x1a4>
    c40c:	8f e1       	ldi	r24, 0x1F	; 31
    c40e:	90 e0       	ldi	r25, 0x00	; 0
    c410:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c414:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
    } else {
        CodecChangeDivider(SUBCARRIER_1);
        CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    c418:	80 91 a3 2e 	lds	r24, 0x2EA3	; 0x802ea3 <BitRate1>
    c41c:	90 91 a4 2e 	lds	r25, 0x2EA4	; 0x802ea4 <BitRate1+0x1>
    c420:	01 97       	sbiw	r24, 0x01	; 1
    c422:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    c426:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    }

    StateRegister = LOADMOD_BIT1_DUAL;
    c42a:	89 e0       	ldi	r24, 0x09	; 9
    c42c:	77 c0       	rjmp	.+238    	; 0xc51c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    return;

LOADMOD_BIT1_DUAL_LABEL: //Manchester encoding
    if (ShiftRegister & 0x01) {
    c42e:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c432:	80 ff       	sbrs	r24, 0
    c434:	0b c0       	rjmp	.+22     	; 0xc44c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x1d0>
    c436:	8f e1       	ldi	r24, 0x1F	; 31
    c438:	90 e0       	ldi	r25, 0x00	; 0
    c43a:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c43e:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
        /* fc / 32 */
        CodecChangeDivider(SUBCARRIER_1);
        CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    c442:	80 91 a3 2e 	lds	r24, 0x2EA3	; 0x802ea3 <BitRate1>
    c446:	90 91 a4 2e 	lds	r25, 0x2EA4	; 0x802ea4 <BitRate1+0x1>
    c44a:	0a c0       	rjmp	.+20     	; 0xc460 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x1e4>
    c44c:	8b e1       	ldi	r24, 0x1B	; 27
    c44e:	90 e0       	ldi	r25, 0x00	; 0
    c450:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c454:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
    } else {
        /* fc / 28 */
        CodecChangeDivider(SUBCARRIER_2);
        CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    c458:	80 91 a1 2e 	lds	r24, 0x2EA1	; 0x802ea1 <BitRate2>
    c45c:	90 91 a2 2e 	lds	r25, 0x2EA2	; 0x802ea2 <BitRate2+0x1>
    c460:	01 97       	sbiw	r24, 0x01	; 1
    c462:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    c466:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    }

    ShiftRegister >>= 1;
    c46a:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c46e:	86 95       	lsr	r24
    c470:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent++;
    c474:	84 b1       	in	r24, 0x04	; 4
    c476:	95 b1       	in	r25, 0x05	; 5
    c478:	01 96       	adiw	r24, 0x01	; 1
    c47a:	84 b9       	out	0x04, r24	; 4
    c47c:	95 b9       	out	0x05, r25	; 5

    StateRegister = LOADMOD_BIT0_DUAL;
    c47e:	88 e0       	ldi	r24, 0x08	; 8
    c480:	81 b9       	out	0x01, r24	; 1

    if ((BitSent % 8) == 0) {
    c482:	84 b1       	in	r24, 0x04	; 4
    c484:	95 b1       	in	r25, 0x05	; 5
    c486:	87 70       	andi	r24, 0x07	; 7
    c488:	99 27       	eor	r25, r25
    c48a:	89 2b       	or	r24, r25
    c48c:	09 f0       	breq	.+2      	; 0xc490 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x214>
    c48e:	53 c0       	rjmp	.+166    	; 0xc536 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
        /* Byte boundary */
        if (--ByteCount == 0) {
    c490:	80 91 a5 2e 	lds	r24, 0x2EA5	; 0x802ea5 <ByteCount>
    c494:	81 50       	subi	r24, 0x01	; 1
    c496:	80 93 a5 2e 	sts	0x2EA5, r24	; 0x802ea5 <ByteCount>
    c49a:	81 11       	cpse	r24, r1
    c49c:	04 c0       	rjmp	.+8      	; 0xc4a6 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x22a>
            /* No more data left */
            ShiftRegister = EOF_PATTERN;
    c49e:	88 eb       	ldi	r24, 0xB8	; 184
    c4a0:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    c4a4:	3a c0       	rjmp	.+116    	; 0xc51a <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x29e>
            StateRegister = LOADMOD_EOF_DUAL;
        } else {
            ShiftRegister = (*CodecBufferPtr++);
    c4a6:	e8 b1       	in	r30, 0x08	; 8
    c4a8:	f9 b1       	in	r31, 0x09	; 9
    c4aa:	cf 01       	movw	r24, r30
    c4ac:	01 96       	adiw	r24, 0x01	; 1
    c4ae:	88 b9       	out	0x08, r24	; 8
    c4b0:	99 b9       	out	0x09, r25	; 9
    c4b2:	80 81       	ld	r24, Z
    c4b4:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    c4b8:	08 95       	ret
    }
    return;

LOADMOD_EOF_DUAL_LABEL: //End of Manchester encoding
    /* Output EOF */
    if (ShiftRegister & 0x80) {
    c4ba:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c4be:	87 ff       	sbrs	r24, 7
    c4c0:	0b c0       	rjmp	.+22     	; 0xc4d8 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x25c>
    c4c2:	8f e1       	ldi	r24, 0x1F	; 31
    c4c4:	90 e0       	ldi	r25, 0x00	; 0
    c4c6:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c4ca:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
        CodecChangeDivider(SUBCARRIER_1);
        CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    c4ce:	80 91 a3 2e 	lds	r24, 0x2EA3	; 0x802ea3 <BitRate1>
    c4d2:	90 91 a4 2e 	lds	r25, 0x2EA4	; 0x802ea4 <BitRate1+0x1>
    c4d6:	0a c0       	rjmp	.+20     	; 0xc4ec <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x270>
    c4d8:	8b e1       	ldi	r24, 0x1B	; 27
    c4da:	90 e0       	ldi	r25, 0x00	; 0
    c4dc:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c4e0:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
    } else {
        CodecChangeDivider(SUBCARRIER_2);
        CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    c4e4:	80 91 a1 2e 	lds	r24, 0x2EA1	; 0x802ea1 <BitRate2>
    c4e8:	90 91 a2 2e 	lds	r25, 0x2EA2	; 0x802ea2 <BitRate2+0x1>
    c4ec:	01 97       	sbiw	r24, 0x01	; 1
    c4ee:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
    c4f2:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
    }

    ShiftRegister <<= 1;
    c4f6:	80 91 a6 2e 	lds	r24, 0x2EA6	; 0x802ea6 <ShiftRegister>
    c4fa:	88 0f       	add	r24, r24
    c4fc:	80 93 a6 2e 	sts	0x2EA6, r24	; 0x802ea6 <ShiftRegister>
    BitSent++;
    c500:	84 b1       	in	r24, 0x04	; 4
    c502:	95 b1       	in	r25, 0x05	; 5
    c504:	01 96       	adiw	r24, 0x01	; 1
    c506:	84 b9       	out	0x04, r24	; 4
    c508:	95 b9       	out	0x05, r25	; 5

    if ((BitSent % 8) == 0) {
    c50a:	84 b1       	in	r24, 0x04	; 4
    c50c:	95 b1       	in	r25, 0x05	; 5
    c50e:	87 70       	andi	r24, 0x07	; 7
    c510:	99 27       	eor	r25, r25
    c512:	89 2b       	or	r24, r25
    c514:	11 f4       	brne	.+4      	; 0xc51a <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x29e>
        /* Last bit has been put out */
        StateRegister = LOADMOD_FINISHED;
    c516:	8b e0       	ldi	r24, 0x0B	; 11
    c518:	01 c0       	rjmp	.+2      	; 0xc51c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    } else {
        StateRegister = LOADMOD_EOF_DUAL;
    c51a:	8a e0       	ldi	r24, 0x0A	; 10
    c51c:	81 b9       	out	0x01, r24	; 1
    c51e:	08 95       	ret
    }
    return;

LOADMOD_FINISHED_LABEL:
    /* Sets timer off for CODEC_TIMER_LOADMOD (TCE0) disabling clock source as we're done modulating */
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    c520:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    /* Sets register INTCTRLB to 0 to disable all compare/capture interrupts */
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    c524:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider) {
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    c528:	10 92 40 08 	sts	0x0840, r1	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    c52c:	10 92 41 08 	sts	0x0841, r1	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OFF, 0);
    Flags.LoadmodFinished = 1;
    c530:	81 e0       	ldi	r24, 0x01	; 1
    c532:	80 93 aa 2e 	sts	0x2EAA, r24	; 0x802eaa <Flags+0x1>
    c536:	08 95       	ret

0000c538 <StartISO15693Demod>:
#endif /* CONFIG_VICINITY_SUPPORT */

/* This functions resets all global variables used in the codec and enables interrupts to wait for reader data */
void StartISO15693Demod(void) {
    /* Reset global variables to default values */
    CodecBufferPtr = CodecBuffer;
    c538:	8d e3       	ldi	r24, 0x3D	; 61
    c53a:	92 e3       	ldi	r25, 0x32	; 50
    c53c:	88 b9       	out	0x08, r24	; 8
    c53e:	99 b9       	out	0x09, r25	; 9
    Flags.DemodFinished = 0;
    c540:	e9 ea       	ldi	r30, 0xA9	; 169
    c542:	fe e2       	ldi	r31, 0x2E	; 46
    c544:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    c546:	11 82       	std	Z+1, r1	; 0x01
    DemodState = DEMOD_SOC_STATE;
    c548:	10 92 a7 2e 	sts	0x2EA7, r1	; 0x802ea7 <DemodState>
    StateRegister = LOADMOD_WAIT;
    c54c:	11 b8       	out	0x01, r1	; 1
    DataRegister = 0;
    c54e:	10 b8       	out	0x00, r1	; 0
    SampleRegister = 0;
    c550:	13 b8       	out	0x03, r1	; 3
    BitSampleCount = 0;
    c552:	16 b8       	out	0x06, r1	; 6
    c554:	17 b8       	out	0x07, r1	; 7
    SampleDataCount = 0;
    c556:	10 92 9f 2e 	sts	0x2E9F, r1	; 0x802e9f <SampleDataCount>
    c55a:	10 92 a0 2e 	sts	0x2EA0, r1	; 0x802ea0 <SampleDataCount+0x1>
    ModulationPauseCount = 0;
    c55e:	12 b8       	out	0x02, r1	; 2
    ByteCount = 0;
    c560:	10 92 a5 2e 	sts	0x2EA5, r1	; 0x802ea5 <ByteCount>
    ShiftRegister = 0;
    c564:	10 92 a6 2e 	sts	0x2EA6, r1	; 0x802ea6 <ShiftRegister>
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
}

INLINE void CodecSetDemodPower(bool bOnOff) {
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    c568:	a0 e2       	ldi	r26, 0x20	; 32
    c56a:	b6 e0       	ldi	r27, 0x06	; 6
    c56c:	81 e0       	ldi	r24, 0x01	; 1
    c56e:	15 96       	adiw	r26, 0x05	; 5
    c570:	8c 93       	st	X, r24
    c572:	15 97       	sbiw	r26, 0x05	; 5
    /* Activate Power for demodulator */
    CodecSetDemodPower(true);

    /* Configure sampling-timer free running and sync to first modulation-pause. */
    /* Resets the counter to 0 */
    CODEC_TIMER_SAMPLING.CNT = 0;
    c574:	e0 e0       	ldi	r30, 0x00	; 0
    c576:	f9 e0       	ldi	r31, 0x09	; 9
    c578:	10 a2       	std	Z+32, r1	; 0x20
    c57a:	11 a2       	std	Z+33, r1	; 0x21
    /* Set the period for CODEC_TIMER_SAMPLING (TCD0) to ISO15693_SAMPLE_PERIOD - 1 because PER is 0-based */
    CODEC_TIMER_SAMPLING.PER = ISO15693_SAMPLE_PERIOD - 1;
    c57c:	8f e7       	ldi	r24, 0x7F	; 127
    c57e:	90 e0       	ldi	r25, 0x00	; 0
    c580:	86 a3       	std	Z+38, r24	; 0x26
    c582:	97 a3       	std	Z+39, r25	; 0x27
    /* Set Counter Channel C (CCC) register with half bit period - 1. (- 14 to compensate ISR timing overhead) */
    CODEC_TIMER_SAMPLING.CCC = ISO15693_SAMPLE_PERIOD / 2 - 14 - 1;
    c584:	81 e3       	ldi	r24, 0x31	; 49
    c586:	90 e0       	ldi	r25, 0x00	; 0
    c588:	84 a7       	std	Z+44, r24	; 0x2c
    c58a:	95 a7       	std	Z+45, r25	; 0x2d
    /* Set timer for CODEC_TIMER_SAMPLING (TCD0) to ISO15693_SAMPLE_CLK = TC_CLKSEL_DIV2_gc = System Clock / 2
     *
     * TODO Why system clock / 2 and not iso period?
     */
    CODEC_TIMER_SAMPLING.CTRLA = ISO15693_SAMPLE_CLK;
    c58c:	82 e0       	ldi	r24, 0x02	; 2
    c58e:	80 83       	st	Z, r24
    /* Set event action for CODEC_TIMER_SAMPLING (TCD0) to restart and trigger CODEC_TIMER_MODSTART_EVSEL = TC_EVSEL_CH0_gc = Event Channel 0 */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    c590:	98 e8       	ldi	r25, 0x88	; 136
    c592:	93 83       	std	Z+3, r25	; 0x03
    /* Set Counter Channel C (CCC) with relevant bitmask (TC0_CCCIF_bm), the period for clock sampling is specified above */
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    c594:	20 e4       	ldi	r18, 0x40	; 64
    c596:	24 87       	std	Z+12, r18	; 0x0c
    /* Sets register INTCTRLB to TC_CCCINTLVL_OFF_gc = (0x00<<4) to disable compare/capture C interrupts
     *
     * TODO Why turn it off?
     */
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_OFF_gc;
    c598:	17 82       	std	Z+7, r1	; 0x07

    /* Set event action for CODEC_TIMER_LOADMOD (TCE0) to restart and trigger CODEC_TIMER_MODSTART_EVSEL = TC_EVSEL_CH0_gc = Event Channel 0 */
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    c59a:	e0 e0       	ldi	r30, 0x00	; 0
    c59c:	fa e0       	ldi	r31, 0x0A	; 10
    c59e:	93 83       	std	Z+3, r25	; 0x03
    /* Set the period for CODEC_TIMER_LOADMOD (TCE0) to... some magic numbers?
     * Using PER instead of PERBUF breaks it when receiving ISO15693_APP_NO_RESPONSE from Application.
     *
     * TODO What are these numbers?
     */
    CODEC_TIMER_LOADMOD.PERBUF = 4192 + 128 + 128 - 1;
    c5a0:	2f e5       	ldi	r18, 0x5F	; 95
    c5a2:	31 e1       	ldi	r19, 0x11	; 17
    c5a4:	26 ab       	std	Z+54, r18	; 0x36
    c5a6:	37 ab       	std	Z+55, r19	; 0x37
    /* Sets register INTCTRLA to 0 to disable timer error or overflow interrupts */
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    c5a8:	16 82       	std	Z+6, r1	; 0x06
    /* Sets register INTCTRLB to 0 to disable all compare/capture interrupts */
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    c5aa:	17 82       	std	Z+7, r1	; 0x07
    /* Set timer for CODEC_TIMER_SAMPLING (TCD0) to TC_CLKSEL_EVCH6_gc = Event Channel 6 */
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_EVCH6_gc;
    c5ac:	9e e0       	ldi	r25, 0x0E	; 14
    c5ae:	90 83       	st	Z, r25

    /* Start looking out for modulation pause via interrupt. */
    /* Sets register INTFLAGS to PORT_INT0LVL_HI_gc = (0x03<<0) to enable compare/capture for high level interrupts on CODEC_DEMOD_IN_PORT (PORTB) */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT0LVL_HI_gc;
    c5b0:	93 e0       	ldi	r25, 0x03	; 3
    c5b2:	1c 96       	adiw	r26, 0x0c	; 12
    c5b4:	9c 93       	st	X, r25
    c5b6:	1c 97       	sbiw	r26, 0x0c	; 12
    /* Sets INT0MASK to CODEC_DEMOD_IN_MASK0 = PIN1_bm to use it as source for port interrupt 0 */
    CODEC_DEMOD_IN_PORT.INT0MASK = CODEC_DEMOD_IN_MASK0;
    c5b8:	1a 96       	adiw	r26, 0x0a	; 10
    c5ba:	8c 93       	st	X, r24
    c5bc:	08 95       	ret

0000c5be <ISO15693CodecInit>:
}

void ISO15693CodecInit(void) {
    c5be:	cf 93       	push	r28
    c5c0:	df 93       	push	r29
INLINE void CodecInitCommon(void) {
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    c5c2:	e0 e4       	ldi	r30, 0x40	; 64
    c5c4:	f6 e0       	ldi	r31, 0x06	; 6
    c5c6:	12 8a       	std	Z+18, r1	; 0x12
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    c5c8:	84 e0       	ldi	r24, 0x04	; 4
    c5ca:	82 83       	std	Z+2, r24	; 0x02
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    c5cc:	c0 e8       	ldi	r28, 0x80	; 128
    c5ce:	d1 e0       	ldi	r29, 0x01	; 1
    c5d0:	82 e6       	ldi	r24, 0x62	; 98
    c5d2:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    c5d4:	a0 e2       	ldi	r26, 0x20	; 32
    c5d6:	b6 e0       	ldi	r27, 0x06	; 6
    c5d8:	81 e0       	ldi	r24, 0x01	; 1
    c5da:	16 96       	adiw	r26, 0x06	; 6
    c5dc:	8c 93       	st	X, r24
    c5de:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    c5e0:	11 96       	adiw	r26, 0x01	; 1
    c5e2:	8c 93       	st	X, r24
    c5e4:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    c5e6:	96 e0       	ldi	r25, 0x06	; 6
    c5e8:	12 96       	adiw	r26, 0x02	; 2
    c5ea:	9c 93       	st	X, r25
    c5ec:	12 97       	sbiw	r26, 0x02	; 2
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    c5ee:	51 96       	adiw	r26, 0x11	; 17
    c5f0:	8c 93       	st	X, r24
    c5f2:	51 97       	sbiw	r26, 0x11	; 17
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    c5f4:	32 e0       	ldi	r19, 0x02	; 2
    c5f6:	52 96       	adiw	r26, 0x12	; 18
    c5f8:	3c 93       	st	X, r19
    c5fa:	52 97       	sbiw	r26, 0x12	; 18
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    c5fc:	1a 96       	adiw	r26, 0x0a	; 10
    c5fe:	1c 92       	st	X, r1
    c600:	1a 97       	sbiw	r26, 0x0a	; 10
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    c602:	1b 96       	adiw	r26, 0x0b	; 11
    c604:	1c 92       	st	X, r1
    c606:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    c608:	9f e0       	ldi	r25, 0x0F	; 15
    c60a:	19 96       	adiw	r26, 0x09	; 9
    c60c:	9c 93       	st	X, r25
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    c60e:	99 e5       	ldi	r25, 0x59	; 89
    c610:	98 83       	st	Y, r25
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    c612:	2a e5       	ldi	r18, 0x5A	; 90
    c614:	29 83       	std	Y+1, r18	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    c616:	9a 83       	std	Y+2, r25	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    c618:	90 e4       	ldi	r25, 0x40	; 64
    c61a:	91 83       	std	Z+1, r25	; 0x01
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    c61c:	96 83       	std	Z+6, r25	; 0x06
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    c61e:	a0 eb       	ldi	r26, 0xB0	; 176
    c620:	b0 e0       	ldi	r27, 0x00	; 0
    c622:	12 96       	adiw	r26, 0x02	; 2
    c624:	2c 91       	ld	r18, X
    c626:	12 97       	sbiw	r26, 0x02	; 2
    c628:	20 7f       	andi	r18, 0xF0	; 240
    c62a:	12 96       	adiw	r26, 0x02	; 2
    c62c:	2c 93       	st	X, r18
    c62e:	12 97       	sbiw	r26, 0x02	; 2
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    c630:	12 96       	adiw	r26, 0x02	; 2
    c632:	2c 91       	ld	r18, X
    c634:	12 97       	sbiw	r26, 0x02	; 2
    c636:	22 60       	ori	r18, 0x02	; 2
    c638:	12 96       	adiw	r26, 0x02	; 2
    c63a:	2c 93       	st	X, r18

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    c63c:	20 e3       	ldi	r18, 0x30	; 48
    c63e:	21 83       	std	Z+1, r18	; 0x01
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    c640:	26 83       	std	Z+6, r18	; 0x06

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    c642:	90 8b       	std	Z+16, r25	; 0x10
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    c644:	86 83       	std	Z+6, r24	; 0x06
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    c646:	35 83       	std	Z+5, r19	; 0x05
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    c648:	83 e0       	ldi	r24, 0x03	; 3
    c64a:	81 83       	std	Z+1, r24	; 0x01

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    c64c:	e0 e0       	ldi	r30, 0x00	; 0
    c64e:	f8 e0       	ldi	r31, 0x08	; 8
    c650:	83 e1       	ldi	r24, 0x13	; 19
    c652:	81 83       	std	Z+1, r24	; 0x01
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    c654:	21 e0       	ldi	r18, 0x01	; 1
    c656:	30 e0       	ldi	r19, 0x00	; 0
    c658:	26 a3       	std	Z+38, r18	; 0x26
    c65a:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    c65c:	20 a7       	std	Z+40, r18	; 0x28
    c65e:	31 a7       	std	Z+41, r19	; 0x29

    AWEXC.OUTOVEN = 0x00;
    c660:	e0 e8       	ldi	r30, 0x80	; 128
    c662:	f8 e0       	ldi	r31, 0x08	; 8
    c664:	14 86       	std	Z+12, r1	; 0x0c
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    c666:	80 83       	st	Z, r24

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    c668:	e0 e2       	ldi	r30, 0x20	; 32
    c66a:	f3 e0       	ldi	r31, 0x03	; 3
    c66c:	13 82       	std	Z+3, r1	; 0x03
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    c66e:	11 82       	std	Z+1, r1	; 0x01
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    c670:	88 e0       	ldi	r24, 0x08	; 8
    c672:	82 83       	std	Z+2, r24	; 0x02
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    c674:	91 e1       	ldi	r25, 0x11	; 17
    c676:	90 83       	st	Z, r25
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    c678:	a0 91 d9 2f 	lds	r26, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    c67c:	b0 91 da 2f 	lds	r27, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    c680:	1a 96       	adiw	r26, 0x0a	; 10
    c682:	2d 91       	ld	r18, X+
    c684:	3c 91       	ld	r19, X
    c686:	1b 97       	sbiw	r26, 0x0b	; 11
    c688:	20 8f       	std	Z+24, r18	; 0x18
    c68a:	31 8f       	std	Z+25, r19	; 0x19

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    c68c:	e0 e8       	ldi	r30, 0x80	; 128
    c68e:	f3 e0       	ldi	r31, 0x03	; 3
    c690:	9c e3       	ldi	r25, 0x3C	; 60
    c692:	92 83       	std	Z+2, r25	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    c694:	80 83       	st	Z, r24

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    c696:	93 83       	std	Z+3, r25	; 0x03
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    c698:	81 83       	std	Z+1, r24	; 0x01
    CodecInitCommon();

    /* Register isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT function
     * to CODEC_TIMER_SAMPLING (TCD0)'s Counter Channel C (CCC)
     */
    isr_func_TCD0_CCC_vect = &isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT;
    c69a:	8a e3       	ldi	r24, 0x3A	; 58
    c69c:	90 e6       	ldi	r25, 0x60	; 96
    c69e:	80 93 b7 2e 	sts	0x2EB7, r24	; 0x802eb7 <isr_func_TCD0_CCC_vect>
    c6a2:	90 93 b8 2e 	sts	0x2EB8, r25	; 0x802eb8 <isr_func_TCD0_CCC_vect+0x1>
    /* Register isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT function
     * to CODEC_DEMOD_IN_PORT (PORTB) interrupt 0
     */
    isr_func_CODEC_DEMOD_IN_INT0_VECT = &isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT;
    c6a6:	88 e1       	ldi	r24, 0x18	; 24
    c6a8:	90 e6       	ldi	r25, 0x60	; 96
    c6aa:	80 93 b9 2f 	sts	0x2FB9, r24	; 0x802fb9 <isr_func_CODEC_DEMOD_IN_INT0_VECT>
    c6ae:	90 93 ba 2f 	sts	0x2FBA, r25	; 0x802fba <isr_func_CODEC_DEMOD_IN_INT0_VECT+0x1>
    /* Register isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT function
     * to CODEC_TIMER_LOADMOD (TCE0)'s Counter Channel B (CCB)
     */
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT = &isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT;
    c6b2:	8e e3       	ldi	r24, 0x3E	; 62
    c6b4:	91 e6       	ldi	r25, 0x61	; 97
    c6b6:	80 93 b5 2e 	sts	0x2EB5, r24	; 0x802eb5 <isr_func_CODEC_TIMER_LOADMOD_CCB_VECT>
    c6ba:	90 93 b6 2e 	sts	0x2EB6, r25	; 0x802eb6 <isr_func_CODEC_TIMER_LOADMOD_CCB_VECT+0x1>

    StartISO15693Demod();
}
    c6be:	df 91       	pop	r29
    c6c0:	cf 91       	pop	r28
    /* Register isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT function
     * to CODEC_TIMER_LOADMOD (TCE0)'s Counter Channel B (CCB)
     */
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT = &isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT;

    StartISO15693Demod();
    c6c2:	3a cf       	rjmp	.-396    	; 0xc538 <StartISO15693Demod>

0000c6c4 <ISO15693CodecDeInit>:
}

void ISO15693CodecDeInit(void) {
    /* Gracefully shutdown codec */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    c6c4:	a0 e2       	ldi	r26, 0x20	; 32
    c6c6:	b6 e0       	ldi	r27, 0x06	; 6
    c6c8:	1a 96       	adiw	r26, 0x0a	; 10
    c6ca:	1c 92       	st	X, r1
    c6cc:	1a 97       	sbiw	r26, 0x0a	; 10

    /* Reset global variables to default values */
    CodecBufferPtr = CodecBuffer;
    c6ce:	8d e3       	ldi	r24, 0x3D	; 61
    c6d0:	92 e3       	ldi	r25, 0x32	; 50
    c6d2:	88 b9       	out	0x08, r24	; 8
    c6d4:	99 b9       	out	0x09, r25	; 9
    Flags.DemodFinished = 0;
    c6d6:	e9 ea       	ldi	r30, 0xA9	; 169
    c6d8:	fe e2       	ldi	r31, 0x2E	; 46
    c6da:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    c6dc:	11 82       	std	Z+1, r1	; 0x01
    DemodState = DEMOD_SOC_STATE;
    c6de:	10 92 a7 2e 	sts	0x2EA7, r1	; 0x802ea7 <DemodState>
    StateRegister = LOADMOD_WAIT;
    c6e2:	11 b8       	out	0x01, r1	; 1
    DataRegister = 0;
    c6e4:	10 b8       	out	0x00, r1	; 0
    SampleRegister = 0;
    c6e6:	13 b8       	out	0x03, r1	; 3
    BitSampleCount = 0;
    c6e8:	16 b8       	out	0x06, r1	; 6
    c6ea:	17 b8       	out	0x07, r1	; 7
    SampleDataCount = 0;
    c6ec:	10 92 9f 2e 	sts	0x2E9F, r1	; 0x802e9f <SampleDataCount>
    c6f0:	10 92 a0 2e 	sts	0x2EA0, r1	; 0x802ea0 <SampleDataCount+0x1>
    ModulationPauseCount = 0;
    c6f4:	12 b8       	out	0x02, r1	; 2
    ByteCount = 0;
    c6f6:	10 92 a5 2e 	sts	0x2EA5, r1	; 0x802ea5 <ByteCount>
    ShiftRegister = 0;
    c6fa:	10 92 a6 2e 	sts	0x2EA6, r1	; 0x802ea6 <ShiftRegister>

    /* Disable sample timer */
    /* Sets timer off for CODEC_TIMER_SAMPLING (TCD0) disabling clock source */
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    c6fe:	e0 e0       	ldi	r30, 0x00	; 0
    c700:	f9 e0       	ldi	r31, 0x09	; 9
    c702:	10 82       	st	Z, r1
    /* Disable event action for CODEC_TIMER_SAMPLING (TCD0) */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    c704:	13 82       	std	Z+3, r1	; 0x03
    /* Sets register INTCTRLB to TC_CCCINTLVL_OFF_gc = (0x00<<4) to disable compare/capture C interrupts */
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_OFF_gc;
    c706:	17 82       	std	Z+7, r1	; 0x07
    /* Restore Counter Channel C (CCC) interrupt mask (TC0_CCCIF_bm) */
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    c708:	80 e4       	ldi	r24, 0x40	; 64
    c70a:	84 87       	std	Z+12, r24	; 0x0c

    /* Disable load modulation */
    /* Disable event action for CODEC_TIMER_LOADMOD (TCE0) */
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_OFF_gc;
    c70c:	e0 e0       	ldi	r30, 0x00	; 0
    c70e:	fa e0       	ldi	r31, 0x0A	; 10
    c710:	13 82       	std	Z+3, r1	; 0x03
    /* Sets register INTCTRLB to TC_CCBINTLVL_OFF_gc = (0x00<<2) to disable compare/capture B interrupts */
    CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCBINTLVL_OFF_gc;
    c712:	17 82       	std	Z+7, r1	; 0x07
    /* Restore Counter Channel B (CCB) interrupt mask (TC0_CCBIF_bm) */
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_CCBIF_bm;
    c714:	80 e2       	ldi	r24, 0x20	; 32
    c716:	84 87       	std	Z+12, r24	; 0x0c
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider) {
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    c718:	e0 e4       	ldi	r30, 0x40	; 64
    c71a:	f8 e0       	ldi	r31, 0x08	; 8
    c71c:	10 82       	st	Z, r1
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    c71e:	11 82       	std	Z+1, r1	; 0x01

INLINE void CodecSetDemodPower(bool bOnOff) {
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    c720:	81 e0       	ldi	r24, 0x01	; 1
    c722:	16 96       	adiw	r26, 0x06	; 6
    c724:	8c 93       	st	X, r24

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    c726:	8e 98       	cbi	0x11, 6	; 17
    c728:	08 95       	ret

0000c72a <ISO15693CodecTask>:
    CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OFF, 0);
    CodecSetDemodPower(false);
    CodecSetLoadmodState(false);
}

void ISO15693CodecTask(void) {
    c72a:	0f 93       	push	r16
    c72c:	1f 93       	push	r17
    c72e:	cf 93       	push	r28
    if (Flags.DemodFinished) {
    c730:	80 91 a9 2e 	lds	r24, 0x2EA9	; 0x802ea9 <Flags>
    c734:	88 23       	and	r24, r24
    c736:	09 f4       	brne	.+2      	; 0xc73a <ISO15693CodecTask+0x10>
    c738:	7e c0       	rjmp	.+252    	; 0xc836 <ISO15693CodecTask+0x10c>
        Flags.DemodFinished = 0;
    c73a:	10 92 a9 2e 	sts	0x2EA9, r1	; 0x802ea9 <Flags>

        uint16_t DemodByteCount = ByteCount;
    c73e:	40 91 a5 2e 	lds	r20, 0x2EA5	; 0x802ea5 <ByteCount>
    c742:	04 2f       	mov	r16, r20
    c744:	10 e0       	ldi	r17, 0x00	; 0
        uint16_t AppReceivedByteCount = 0;
        bool bDualSubcarrier = false;

        if (DemodByteCount > 0) {
    c746:	01 15       	cp	r16, r1
    c748:	11 05       	cpc	r17, r1
    c74a:	09 f4       	brne	.+2      	; 0xc74e <ISO15693CodecTask+0x24>
    c74c:	6f c0       	rjmp	.+222    	; 0xc82c <ISO15693CodecTask+0x102>
void LogGetModeByName(char *Mode, uint16_t BufferSize);
void LogGetModeList(char *List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void *Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    c74e:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    c752:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    c756:	6d e3       	ldi	r22, 0x3D	; 61
    c758:	72 e3       	ldi	r23, 0x32	; 50
    c75a:	80 e4       	ldi	r24, 0x40	; 64
    c75c:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    c75e:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    c762:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    c766:	87 81       	ldd	r24, Z+7	; 0x07
    c768:	88 30       	cpi	r24, 0x08	; 8
    c76a:	19 f4       	brne	.+6      	; 0xc772 <ISO15693CodecTask+0x48>
        LEDGreenAction = Action;
    c76c:	83 e1       	ldi	r24, 0x13	; 19
    c76e:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    c772:	86 81       	ldd	r24, Z+6	; 0x06
    c774:	88 30       	cpi	r24, 0x08	; 8
    c776:	19 f4       	brne	.+6      	; 0xc77e <ISO15693CodecTask+0x54>
        LEDRedAction = Action;
    c778:	83 e1       	ldi	r24, 0x13	; 19
    c77a:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
    c77e:	c0 91 3d 32 	lds	r28, 0x323D	; 0x80323d <CodecBuffer>
    c782:	c1 70       	andi	r28, 0x01	; 1
    c784:	e0 91 cb 2f 	lds	r30, 0x2FCB	; 0x802fcb <ActiveConfiguration+0xe>
    c788:	f0 91 cc 2f 	lds	r31, 0x2FCC	; 0x802fcc <ActiveConfiguration+0xf>
    c78c:	b8 01       	movw	r22, r16
    c78e:	8d e3       	ldi	r24, 0x3D	; 61
    c790:	92 e3       	ldi	r25, 0x32	; 50
    c792:	19 95       	eicall
    c794:	8c 01       	movw	r16, r24
            }
            AppReceivedByteCount = ApplicationProcess(CodecBuffer, DemodByteCount);
        }

        /* This is only reached when we've received a valid frame */
        if (AppReceivedByteCount != ISO15693_APP_NO_RESPONSE) {
    c796:	00 97       	sbiw	r24, 0x00	; 0
    c798:	09 f4       	brne	.+2      	; 0xc79c <ISO15693CodecTask+0x72>
    c79a:	48 c0       	rjmp	.+144    	; 0xc82c <ISO15693CodecTask+0x102>
    c79c:	e0 91 d6 2f 	lds	r30, 0x2FD6	; 0x802fd6 <CurrentLogFunc>
    c7a0:	f0 91 d7 2f 	lds	r31, 0x2FD7	; 0x802fd7 <CurrentLogFunc+0x1>
    c7a4:	48 2f       	mov	r20, r24
    c7a6:	6d e3       	ldi	r22, 0x3D	; 61
    c7a8:	72 e3       	ldi	r23, 0x32	; 50
    c7aa:	81 e4       	ldi	r24, 0x41	; 65
    c7ac:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    c7ae:	e0 91 d9 2f 	lds	r30, 0x2FD9	; 0x802fd9 <GlobalSettings+0x1>
    c7b2:	f0 91 da 2f 	lds	r31, 0x2FDA	; 0x802fda <GlobalSettings+0x2>
    c7b6:	87 81       	ldd	r24, Z+7	; 0x07
    c7b8:	89 30       	cpi	r24, 0x09	; 9
    c7ba:	19 f4       	brne	.+6      	; 0xc7c2 <ISO15693CodecTask+0x98>
        LEDGreenAction = Action;
    c7bc:	83 e1       	ldi	r24, 0x13	; 19
    c7be:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <LEDGreenAction>
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    c7c2:	86 81       	ldd	r24, Z+6	; 0x06
    c7c4:	89 30       	cpi	r24, 0x09	; 9
    c7c6:	19 f4       	brne	.+6      	; 0xc7ce <ISO15693CodecTask+0xa4>
        LEDRedAction = Action;
    c7c8:	83 e1       	ldi	r24, 0x13	; 19
    c7ca:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <LEDRedAction>
            LogEntry(LOG_INFO_CODEC_TX_DATA, CodecBuffer, AppReceivedByteCount);
            LEDHook(LED_CODEC_TX, LED_PULSE);

            ByteCount = AppReceivedByteCount;
    c7ce:	00 93 a5 2e 	sts	0x2EA5, r16	; 0x802ea5 <ByteCount>
            CodecBufferPtr = CodecBuffer;
    c7d2:	8d e3       	ldi	r24, 0x3D	; 61
    c7d4:	92 e3       	ldi	r25, 0x32	; 50
    c7d6:	88 b9       	out	0x08, r24	; 8
    c7d8:	99 b9       	out	0x09, r25	; 9
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    } else if (ModType == CODEC_SUBCARRIERMOD_OOK) {
        /* Configure subcarrier generation with 50% DC output using OOK */
        CODEC_SUBCARRIER_TIMER.CNT = 0;
    c7da:	10 92 60 08 	sts	0x0860, r1	; 0x800860 <__TEXT_REGION_LENGTH__+0x700860>
    c7de:	10 92 61 08 	sts	0x0861, r1	; 0x800861 <__TEXT_REGION_LENGTH__+0x700861>

            /* Start loadmodulating */
            if (bDualSubcarrier) {
    c7e2:	cc 23       	and	r28, r28
    c7e4:	89 f0       	breq	.+34     	; 0xc808 <ISO15693CodecTask+0xde>
        CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    c7e6:	8b e1       	ldi	r24, 0x1B	; 27
    c7e8:	90 e0       	ldi	r25, 0x00	; 0
    c7ea:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c7ee:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
        CODEC_SUBCARRIER_TIMER.CODEC_SUBCARRIER_CC_OOK = Divider / 2;
    c7f2:	8e e0       	ldi	r24, 0x0E	; 14
    c7f4:	90 e0       	ldi	r25, 0x00	; 0
    c7f6:	80 93 6a 08 	sts	0x086A, r24	; 0x80086a <__TEXT_REGION_LENGTH__+0x70086a>
    c7fa:	90 93 6b 08 	sts	0x086B, r25	; 0x80086b <__TEXT_REGION_LENGTH__+0x70086b>
        CODEC_SUBCARRIER_TIMER.CTRLB = CODEC_SUBCARRIER_CCEN_OOK | TC_WGMODE_SINGLESLOPE_gc;
    c7fe:	83 e2       	ldi	r24, 0x23	; 35
    c800:	80 93 41 08 	sts	0x0841, r24	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
                CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OOK, SUBCARRIER_2);
                StateRegister = LOADMOD_START_DUAL;
    c804:	86 e0       	ldi	r24, 0x06	; 6
    c806:	10 c0       	rjmp	.+32     	; 0xc828 <ISO15693CodecTask+0xfe>
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    } else if (ModType == CODEC_SUBCARRIERMOD_OOK) {
        /* Configure subcarrier generation with 50% DC output using OOK */
        CODEC_SUBCARRIER_TIMER.CNT = 0;
        CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    c808:	8f e1       	ldi	r24, 0x1F	; 31
    c80a:	90 e0       	ldi	r25, 0x00	; 0
    c80c:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
    c810:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
        CODEC_SUBCARRIER_TIMER.CODEC_SUBCARRIER_CC_OOK = Divider / 2;
    c814:	80 e1       	ldi	r24, 0x10	; 16
    c816:	90 e0       	ldi	r25, 0x00	; 0
    c818:	80 93 6a 08 	sts	0x086A, r24	; 0x80086a <__TEXT_REGION_LENGTH__+0x70086a>
    c81c:	90 93 6b 08 	sts	0x086B, r25	; 0x80086b <__TEXT_REGION_LENGTH__+0x70086b>
        CODEC_SUBCARRIER_TIMER.CTRLB = CODEC_SUBCARRIER_CCEN_OOK | TC_WGMODE_SINGLESLOPE_gc;
    c820:	83 e2       	ldi	r24, 0x23	; 35
    c822:	80 93 41 08 	sts	0x0841, r24	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
            } else {
                CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OOK, SUBCARRIER_1);
                StateRegister = LOADMOD_START_SINGLE;
    c826:	81 e0       	ldi	r24, 0x01	; 1
    c828:	81 b9       	out	0x01, r24	; 1
    c82a:	05 c0       	rjmp	.+10     	; 0xc836 <ISO15693CodecTask+0x10c>
            }

        } else {
            /* No data to process. Disable CODEC_TIMER_LOADMOD (TCE0) counter and start listening again */
            /* Sets timer off for CODEC_TIMER_LOADMOD (TCE0) disabling clock source as we're done modulating */
            CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    c82c:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
            /* Sets register INTCTRLB to 0 to disable all compare/capture interrupts */
            CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    c830:	10 92 07 0a 	sts	0x0A07, r1	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>

            StartISO15693Demod();
    c834:	81 de       	rcall	.-766    	; 0xc538 <StartISO15693Demod>
        }
    }

    if (Flags.LoadmodFinished) {
    c836:	80 91 aa 2e 	lds	r24, 0x2EAA	; 0x802eaa <Flags+0x1>
    c83a:	88 23       	and	r24, r24
    c83c:	31 f0       	breq	.+12     	; 0xc84a <ISO15693CodecTask+0x120>
        Flags.LoadmodFinished = 0;
    c83e:	10 92 aa 2e 	sts	0x2EAA, r1	; 0x802eaa <Flags+0x1>
        /* Load modulation has been finished. Stop it and start to listen for incoming data again. */
        StartISO15693Demod();
    }
}
    c842:	cf 91       	pop	r28
    c844:	1f 91       	pop	r17
    }

    if (Flags.LoadmodFinished) {
        Flags.LoadmodFinished = 0;
        /* Load modulation has been finished. Stop it and start to listen for incoming data again. */
        StartISO15693Demod();
    c846:	0f 91       	pop	r16
    c848:	77 ce       	rjmp	.-786    	; 0xc538 <StartISO15693Demod>
    }
}
    c84a:	cf 91       	pop	r28
    c84c:	1f 91       	pop	r17
    c84e:	0f 91       	pop	r16
    c850:	08 95       	ret

0000c852 <VicinityAppInit>:
    c852:	10 92 ac 2e 	sts	0x2EAC, r1	; 0x802eac <State>
    c856:	08 95       	ret

0000c858 <VicinityAppReset>:
void VicinityAppInit(void) {
    State = STATE_READY;
}

void VicinityAppReset(void) {
    State = STATE_READY;
    c858:	10 92 ac 2e 	sts	0x2EAC, r1	; 0x802eac <State>
    c85c:	08 95       	ret

0000c85e <VicinityAppTask>:
    c85e:	08 95       	ret

0000c860 <VicinityAppTick>:

void VicinityAppTask(void) {

}

void VicinityAppTick(void) {
    c860:	08 95       	ret

0000c862 <VicinityAppProcess>:


}

uint16_t VicinityAppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    c862:	ef 92       	push	r14
    c864:	ff 92       	push	r15
    c866:	0f 93       	push	r16
    c868:	1f 93       	push	r17
    c86a:	cf 93       	push	r28
    c86c:	df 93       	push	r29
    c86e:	cd b7       	in	r28, 0x3d	; 61
    c870:	de b7       	in	r29, 0x3e	; 62
    c872:	28 97       	sbiw	r28, 0x08	; 8
    c874:	cd bf       	out	0x3d, r28	; 61
    c876:	de bf       	out	0x3e, r29	; 62
    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
    c878:	64 30       	cpi	r22, 0x04	; 4
    c87a:	71 05       	cpc	r23, r1
    c87c:	18 f4       	brcc	.+6      	; 0xc884 <VicinityAppProcess+0x22>

        } else { // Invalid CRC
            return ISO15693_APP_NO_RESPONSE;
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    c87e:	80 e0       	ldi	r24, 0x00	; 0
    c880:	90 e0       	ldi	r25, 0x00	; 0
    c882:	c9 c0       	rjmp	.+402    	; 0xca16 <VicinityAppProcess+0x1b4>
    c884:	8c 01       	movw	r16, r24

}

uint16_t VicinityAppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
        if (ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE)) {
    c886:	62 50       	subi	r22, 0x02	; 2
    c888:	71 09       	sbc	r23, r1
    c88a:	c8 d4       	rcall	.+2448   	; 0xd21c <ISO15693CheckCRC>
    c88c:	88 23       	and	r24, r24
    c88e:	b9 f3       	breq	.-18     	; 0xc87e <VicinityAppProcess+0x1c>
            // At this point, we have a valid ISO15693 frame
            uint8_t Command = FrameBuf[1];
    c890:	f8 01       	movw	r30, r16
    c892:	f1 80       	ldd	r15, Z+1	; 0x01
            uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
            uint8_t Uid[8];
            MemoryReadBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    c894:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    c898:	50 e0       	ldi	r21, 0x00	; 0
    c89a:	60 e0       	ldi	r22, 0x00	; 0
    c89c:	70 e0       	ldi	r23, 0x00	; 0
    c89e:	ce 01       	movw	r24, r28
    c8a0:	01 96       	adiw	r24, 0x01	; 1
    c8a2:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

            switch (State) {
    c8a6:	80 91 ac 2e 	lds	r24, 0x2EAC	; 0x802eac <State>
    c8aa:	88 23       	and	r24, r24
    c8ac:	21 f0       	breq	.+8      	; 0xc8b6 <VicinityAppProcess+0x54>
    c8ae:	82 30       	cpi	r24, 0x02	; 2
    c8b0:	09 f4       	brne	.+2      	; 0xc8b4 <VicinityAppProcess+0x52>
    c8b2:	6e c0       	rjmp	.+220    	; 0xc990 <VicinityAppProcess+0x12e>
    c8b4:	a5 c0       	rjmp	.+330    	; 0xca00 <VicinityAppProcess+0x19e>
                case STATE_READY:
                    if (Command == ISO15693_CMD_INVENTORY) {
    c8b6:	f1 e0       	ldi	r31, 0x01	; 1
    c8b8:	ff 12       	cpse	r15, r31
    c8ba:	17 c0       	rjmp	.+46     	; 0xc8ea <VicinityAppProcess+0x88>
                        FrameBuf[0] = 0x00; /* Flags */
    c8bc:	f8 01       	movw	r30, r16
    c8be:	10 82       	st	Z, r1
                        FrameBuf[1] = 0x00; /* DSFID */
    c8c0:	11 82       	std	Z+1, r1	; 0x01
    }
}

INLINE
void ISO15693CopyUid(uint8_t *DstUid, uint8_t *SrcUid) {
    DstUid[0] = SrcUid[7];
    c8c2:	88 85       	ldd	r24, Y+8	; 0x08
    c8c4:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[6];
    c8c6:	8f 81       	ldd	r24, Y+7	; 0x07
    c8c8:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[5];
    c8ca:	8e 81       	ldd	r24, Y+6	; 0x06
    c8cc:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[4];
    c8ce:	8d 81       	ldd	r24, Y+5	; 0x05
    c8d0:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[3];
    c8d2:	8c 81       	ldd	r24, Y+4	; 0x04
    c8d4:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[2];
    c8d6:	8b 81       	ldd	r24, Y+3	; 0x03
    c8d8:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[1];
    c8da:	8a 81       	ldd	r24, Y+2	; 0x02
    c8dc:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[0];
    c8de:	89 81       	ldd	r24, Y+1	; 0x01
    c8e0:	81 87       	std	Z+9, r24	; 0x09
                        ISO15693CopyUid(&FrameBuf[2], Uid);
                        ResponseByteCount = 10;
    c8e2:	9a e0       	ldi	r25, 0x0A	; 10
    c8e4:	e9 2e       	mov	r14, r25
    c8e6:	f1 2c       	mov	r15, r1
    c8e8:	8f c0       	rjmp	.+286    	; 0xca08 <VicinityAppProcess+0x1a6>
                    } else if (Command == ISO15693_CMD_STAY_QUIET) {
    c8ea:	f2 e0       	ldi	r31, 0x02	; 2
    c8ec:	ff 12       	cpse	r15, r31
    c8ee:	28 c0       	rjmp	.+80     	; 0xc940 <VicinityAppProcess+0xde>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    c8f0:	f8 01       	movw	r30, r16
    c8f2:	80 81       	ld	r24, Z
    c8f4:	85 ff       	sbrs	r24, 5
    c8f6:	20 c0       	rjmp	.+64     	; 0xc938 <VicinityAppProcess+0xd6>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    c8f8:	92 81       	ldd	r25, Z+2	; 0x02
    c8fa:	88 85       	ldd	r24, Y+8	; 0x08
    c8fc:	98 13       	cpse	r25, r24
    c8fe:	80 c0       	rjmp	.+256    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[1] == Uid2[6])
    c900:	93 81       	ldd	r25, Z+3	; 0x03
    c902:	8f 81       	ldd	r24, Y+7	; 0x07
    c904:	98 13       	cpse	r25, r24
    c906:	7c c0       	rjmp	.+248    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[2] == Uid2[5])
    c908:	94 81       	ldd	r25, Z+4	; 0x04
    c90a:	8e 81       	ldd	r24, Y+6	; 0x06
    c90c:	98 13       	cpse	r25, r24
    c90e:	78 c0       	rjmp	.+240    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[3] == Uid2[4])
    c910:	95 81       	ldd	r25, Z+5	; 0x05
    c912:	8d 81       	ldd	r24, Y+5	; 0x05
    c914:	98 13       	cpse	r25, r24
    c916:	74 c0       	rjmp	.+232    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[4] == Uid2[3])
    c918:	96 81       	ldd	r25, Z+6	; 0x06
    c91a:	8c 81       	ldd	r24, Y+4	; 0x04
    c91c:	98 13       	cpse	r25, r24
    c91e:	70 c0       	rjmp	.+224    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[5] == Uid2[2])
    c920:	97 81       	ldd	r25, Z+7	; 0x07
    c922:	8b 81       	ldd	r24, Y+3	; 0x03
    c924:	98 13       	cpse	r25, r24
    c926:	6c c0       	rjmp	.+216    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[6] == Uid2[1])
    c928:	90 85       	ldd	r25, Z+8	; 0x08
    c92a:	8a 81       	ldd	r24, Y+2	; 0x02
    c92c:	98 13       	cpse	r25, r24
    c92e:	68 c0       	rjmp	.+208    	; 0xca00 <VicinityAppProcess+0x19e>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
    c930:	91 85       	ldd	r25, Z+9	; 0x09
    c932:	89 81       	ldd	r24, Y+1	; 0x01
    c934:	98 13       	cpse	r25, r24
    c936:	64 c0       	rjmp	.+200    	; 0xca00 <VicinityAppProcess+0x19e>
                            State = STATE_QUIET;
    c938:	82 e0       	ldi	r24, 0x02	; 2
    c93a:	80 93 ac 2e 	sts	0x2EAC, r24	; 0x802eac <State>
    c93e:	60 c0       	rjmp	.+192    	; 0xca00 <VicinityAppProcess+0x19e>
                        }
                    } else if (Command == ISO15693_CMD_GET_SYS_INFO) {
    c940:	fb e2       	ldi	r31, 0x2B	; 43
    c942:	ff 12       	cpse	r15, r31
    c944:	5d c0       	rjmp	.+186    	; 0xca00 <VicinityAppProcess+0x19e>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    c946:	f8 01       	movw	r30, r16
    c948:	80 81       	ld	r24, Z
    c94a:	85 ff       	sbrs	r24, 5
    c94c:	b7 cf       	rjmp	.-146    	; 0xc8bc <VicinityAppProcess+0x5a>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    c94e:	92 81       	ldd	r25, Z+2	; 0x02
    c950:	88 85       	ldd	r24, Y+8	; 0x08
    c952:	98 13       	cpse	r25, r24
    c954:	55 c0       	rjmp	.+170    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[1] == Uid2[6])
    c956:	93 81       	ldd	r25, Z+3	; 0x03
    c958:	8f 81       	ldd	r24, Y+7	; 0x07
    c95a:	98 13       	cpse	r25, r24
    c95c:	51 c0       	rjmp	.+162    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[2] == Uid2[5])
    c95e:	94 81       	ldd	r25, Z+4	; 0x04
    c960:	8e 81       	ldd	r24, Y+6	; 0x06
    c962:	98 13       	cpse	r25, r24
    c964:	4d c0       	rjmp	.+154    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[3] == Uid2[4])
    c966:	95 81       	ldd	r25, Z+5	; 0x05
    c968:	8d 81       	ldd	r24, Y+5	; 0x05
    c96a:	98 13       	cpse	r25, r24
    c96c:	49 c0       	rjmp	.+146    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[4] == Uid2[3])
    c96e:	96 81       	ldd	r25, Z+6	; 0x06
    c970:	8c 81       	ldd	r24, Y+4	; 0x04
    c972:	98 13       	cpse	r25, r24
    c974:	45 c0       	rjmp	.+138    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[5] == Uid2[2])
    c976:	97 81       	ldd	r25, Z+7	; 0x07
    c978:	8b 81       	ldd	r24, Y+3	; 0x03
    c97a:	98 13       	cpse	r25, r24
    c97c:	41 c0       	rjmp	.+130    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[6] == Uid2[1])
    c97e:	90 85       	ldd	r25, Z+8	; 0x08
    c980:	8a 81       	ldd	r24, Y+2	; 0x02
    c982:	98 13       	cpse	r25, r24
    c984:	3d c0       	rjmp	.+122    	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[7] == Uid2[0])) {
    c986:	91 85       	ldd	r25, Z+9	; 0x09
    c988:	89 81       	ldd	r24, Y+1	; 0x01
    c98a:	98 13       	cpse	r25, r24
    c98c:	39 c0       	rjmp	.+114    	; 0xca00 <VicinityAppProcess+0x19e>
    c98e:	96 cf       	rjmp	.-212    	; 0xc8bc <VicinityAppProcess+0x5a>
                case STATE_SELECTED:

                    break;

                case STATE_QUIET:
                    if (Command == ISO15693_CMD_RESET_TO_READY) {
    c990:	f6 e2       	ldi	r31, 0x26	; 38
    c992:	ff 12       	cpse	r15, r31
    c994:	35 c0       	rjmp	.+106    	; 0xca00 <VicinityAppProcess+0x19e>
                        MemoryReadBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    c996:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    c99a:	50 e0       	ldi	r21, 0x00	; 0
    c99c:	60 e0       	ldi	r22, 0x00	; 0
    c99e:	70 e0       	ldi	r23, 0x00	; 0
    c9a0:	ce 01       	movw	r24, r28
    c9a2:	01 96       	adiw	r24, 0x01	; 1
    c9a4:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    c9a8:	f8 01       	movw	r30, r16
    c9aa:	80 81       	ld	r24, Z
    c9ac:	85 ff       	sbrs	r24, 5
    c9ae:	20 c0       	rjmp	.+64     	; 0xc9f0 <VicinityAppProcess+0x18e>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    c9b0:	92 81       	ldd	r25, Z+2	; 0x02
    c9b2:	88 85       	ldd	r24, Y+8	; 0x08
    c9b4:	98 13       	cpse	r25, r24
    c9b6:	24 c0       	rjmp	.+72     	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[1] == Uid2[6])
    c9b8:	93 81       	ldd	r25, Z+3	; 0x03
    c9ba:	8f 81       	ldd	r24, Y+7	; 0x07
    c9bc:	98 13       	cpse	r25, r24
    c9be:	20 c0       	rjmp	.+64     	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[2] == Uid2[5])
    c9c0:	94 81       	ldd	r25, Z+4	; 0x04
    c9c2:	8e 81       	ldd	r24, Y+6	; 0x06
    c9c4:	98 13       	cpse	r25, r24
    c9c6:	1c c0       	rjmp	.+56     	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[3] == Uid2[4])
    c9c8:	95 81       	ldd	r25, Z+5	; 0x05
    c9ca:	8d 81       	ldd	r24, Y+5	; 0x05
    c9cc:	98 13       	cpse	r25, r24
    c9ce:	18 c0       	rjmp	.+48     	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[4] == Uid2[3])
    c9d0:	96 81       	ldd	r25, Z+6	; 0x06
    c9d2:	8c 81       	ldd	r24, Y+4	; 0x04
    c9d4:	98 13       	cpse	r25, r24
    c9d6:	14 c0       	rjmp	.+40     	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[5] == Uid2[2])
    c9d8:	97 81       	ldd	r25, Z+7	; 0x07
    c9da:	8b 81       	ldd	r24, Y+3	; 0x03
    c9dc:	98 13       	cpse	r25, r24
    c9de:	10 c0       	rjmp	.+32     	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[6] == Uid2[1])
    c9e0:	90 85       	ldd	r25, Z+8	; 0x08
    c9e2:	8a 81       	ldd	r24, Y+2	; 0x02
    c9e4:	98 13       	cpse	r25, r24
    c9e6:	0c c0       	rjmp	.+24     	; 0xca00 <VicinityAppProcess+0x19e>
            && (Uid1[7] == Uid2[0])) {
    c9e8:	91 85       	ldd	r25, Z+9	; 0x09
    c9ea:	89 81       	ldd	r24, Y+1	; 0x01
    c9ec:	98 13       	cpse	r25, r24
    c9ee:	08 c0       	rjmp	.+16     	; 0xca00 <VicinityAppProcess+0x19e>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
                            FrameBuf[0] = 0;
    c9f0:	f8 01       	movw	r30, r16
    c9f2:	10 82       	st	Z, r1
                            ResponseByteCount = 1;
                            State = STATE_READY;
    c9f4:	10 92 ac 2e 	sts	0x2EAC, r1	; 0x802eac <State>
                case STATE_QUIET:
                    if (Command == ISO15693_CMD_RESET_TO_READY) {
                        MemoryReadBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
                            FrameBuf[0] = 0;
                            ResponseByteCount = 1;
    c9f8:	ee 24       	eor	r14, r14
    c9fa:	e3 94       	inc	r14
    c9fc:	f1 2c       	mov	r15, r1
    c9fe:	04 c0       	rjmp	.+8      	; 0xca08 <VicinityAppProcess+0x1a6>
void VicinityAppTick(void) {


}

uint16_t VicinityAppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    ca00:	e1 2c       	mov	r14, r1
    ca02:	f1 2c       	mov	r15, r1
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
                ResponseByteCount += ISO15693_CRC16_SIZE;
            }

            return ResponseByteCount;
    ca04:	c7 01       	movw	r24, r14
    ca06:	07 c0       	rjmp	.+14     	; 0xca16 <VicinityAppProcess+0x1b4>
                    break;
            }

            if (ResponseByteCount > 0) {
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
    ca08:	b7 01       	movw	r22, r14
    ca0a:	c8 01       	movw	r24, r16
    ca0c:	f7 d3       	rcall	.+2030   	; 0xd1fc <ISO15693AppendCRC>
                ResponseByteCount += ISO15693_CRC16_SIZE;
    ca0e:	f2 e0       	ldi	r31, 0x02	; 2
    ca10:	ef 0e       	add	r14, r31
    ca12:	f1 1c       	adc	r15, r1
    ca14:	f7 cf       	rjmp	.-18     	; 0xca04 <VicinityAppProcess+0x1a2>
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    }

}
    ca16:	28 96       	adiw	r28, 0x08	; 8
    ca18:	cd bf       	out	0x3d, r28	; 61
    ca1a:	de bf       	out	0x3e, r29	; 62
    ca1c:	df 91       	pop	r29
    ca1e:	cf 91       	pop	r28
    ca20:	1f 91       	pop	r17
    ca22:	0f 91       	pop	r16
    ca24:	ff 90       	pop	r15
    ca26:	ef 90       	pop	r14
    ca28:	08 95       	ret

0000ca2a <VicinityGetUid>:

void VicinityGetUid(ConfigurationUidType Uid) {
    MemoryReadBlock(&Uid[0], MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    ca2a:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    ca2e:	50 e0       	ldi	r21, 0x00	; 0
    ca30:	60 e0       	ldi	r22, 0x00	; 0
    ca32:	70 e0       	ldi	r23, 0x00	; 0
    ca34:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

0000ca38 <VicinitySetUid>:
}

void VicinitySetUid(ConfigurationUidType Uid) {
    MemoryWriteBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    ca38:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    ca3c:	50 e0       	ldi	r21, 0x00	; 0
    ca3e:	60 e0       	ldi	r22, 0x00	; 0
    ca40:	70 e0       	ldi	r23, 0x00	; 0
    ca42:	0c 94 15 12 	jmp	0x242a	; 0x242a <MemoryWriteBlock>

0000ca46 <Sl2s2002AppInit>:
    ca46:	10 92 ad 2e 	sts	0x2EAD, r1	; 0x802ead <State>
    ca4a:	08 95       	ret

0000ca4c <Sl2s2002AppReset>:
void Sl2s2002AppInit(void) {
    State = STATE_READY;
}

void Sl2s2002AppReset(void) {
    State = STATE_READY;
    ca4c:	10 92 ad 2e 	sts	0x2EAD, r1	; 0x802ead <State>
    ca50:	08 95       	ret

0000ca52 <Sl2s2002AppTask>:
    ca52:	08 95       	ret

0000ca54 <Sl2s2002AppTick>:

void Sl2s2002AppTask(void) {

}

void Sl2s2002AppTick(void) {
    ca54:	08 95       	ret

0000ca56 <Sl2s2002AppProcess>:


}

uint16_t Sl2s2002AppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    ca56:	6f 92       	push	r6
    ca58:	7f 92       	push	r7
    ca5a:	9f 92       	push	r9
    ca5c:	af 92       	push	r10
    ca5e:	bf 92       	push	r11
    ca60:	cf 92       	push	r12
    ca62:	df 92       	push	r13
    ca64:	ef 92       	push	r14
    ca66:	ff 92       	push	r15
    ca68:	0f 93       	push	r16
    ca6a:	1f 93       	push	r17
    ca6c:	cf 93       	push	r28
    ca6e:	df 93       	push	r29
    ca70:	cd b7       	in	r28, 0x3d	; 61
    ca72:	de b7       	in	r29, 0x3e	; 62
    ca74:	28 97       	sbiw	r28, 0x08	; 8
    ca76:	cd bf       	out	0x3d, r28	; 61
    ca78:	de bf       	out	0x3e, r29	; 62
    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
    ca7a:	64 30       	cpi	r22, 0x04	; 4
    ca7c:	71 05       	cpc	r23, r1
    ca7e:	18 f4       	brcc	.+6      	; 0xca86 <Sl2s2002AppProcess+0x30>

        } else { // Invalid CRC
            return ISO15693_APP_NO_RESPONSE;
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    ca80:	80 e0       	ldi	r24, 0x00	; 0
    ca82:	90 e0       	ldi	r25, 0x00	; 0
    ca84:	d1 c1       	rjmp	.+930    	; 0xce28 <Sl2s2002AppProcess+0x3d2>
    ca86:	8c 01       	movw	r16, r24

}

uint16_t Sl2s2002AppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
        if (ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE)) {
    ca88:	62 50       	subi	r22, 0x02	; 2
    ca8a:	71 09       	sbc	r23, r1
    ca8c:	c7 d3       	rcall	.+1934   	; 0xd21c <ISO15693CheckCRC>
    ca8e:	88 23       	and	r24, r24
    ca90:	b9 f3       	breq	.-18     	; 0xca80 <Sl2s2002AppProcess+0x2a>
            // At this point, we have a valid ISO15693 frame
            uint8_t Command = FrameBuf[1];
    ca92:	f8 01       	movw	r30, r16
    ca94:	f1 80       	ldd	r15, Z+1	; 0x01
            uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
            uint8_t Uid[8];
            MemoryReadBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    ca96:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    ca9a:	50 e0       	ldi	r21, 0x00	; 0
    ca9c:	60 e0       	ldi	r22, 0x00	; 0
    ca9e:	70 e0       	ldi	r23, 0x00	; 0
    caa0:	ce 01       	movw	r24, r28
    caa2:	01 96       	adiw	r24, 0x01	; 1
    caa4:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

            switch (State) {
    caa8:	80 91 ad 2e 	lds	r24, 0x2EAD	; 0x802ead <State>
    caac:	88 23       	and	r24, r24
    caae:	21 f0       	breq	.+8      	; 0xcab8 <Sl2s2002AppProcess+0x62>
    cab0:	82 30       	cpi	r24, 0x02	; 2
    cab2:	09 f4       	brne	.+2      	; 0xcab6 <Sl2s2002AppProcess+0x60>
    cab4:	80 c1       	rjmp	.+768    	; 0xcdb6 <Sl2s2002AppProcess+0x360>
    cab6:	b5 c1       	rjmp	.+874    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                case STATE_READY:
                    if (Command == ISO15693_CMD_INVENTORY) {
    cab8:	f1 e0       	ldi	r31, 0x01	; 1
    caba:	ff 12       	cpse	r15, r31
    cabc:	17 c0       	rjmp	.+46     	; 0xcaec <Sl2s2002AppProcess+0x96>
                        FrameBuf[0] = 0x00; /* Flags */
    cabe:	f8 01       	movw	r30, r16
    cac0:	10 82       	st	Z, r1
                        FrameBuf[1] = 0x00; /* DSFID */
    cac2:	11 82       	std	Z+1, r1	; 0x01
    }
}

INLINE
void ISO15693CopyUid(uint8_t *DstUid, uint8_t *SrcUid) {
    DstUid[0] = SrcUid[7];
    cac4:	88 85       	ldd	r24, Y+8	; 0x08
    cac6:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[6];
    cac8:	8f 81       	ldd	r24, Y+7	; 0x07
    caca:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[5];
    cacc:	8e 81       	ldd	r24, Y+6	; 0x06
    cace:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[4];
    cad0:	8d 81       	ldd	r24, Y+5	; 0x05
    cad2:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[3];
    cad4:	8c 81       	ldd	r24, Y+4	; 0x04
    cad6:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[2];
    cad8:	8b 81       	ldd	r24, Y+3	; 0x03
    cada:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[1];
    cadc:	8a 81       	ldd	r24, Y+2	; 0x02
    cade:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[0];
    cae0:	89 81       	ldd	r24, Y+1	; 0x01
    cae2:	81 87       	std	Z+9, r24	; 0x09
                        ISO15693CopyUid(&FrameBuf[2], Uid);
                        ResponseByteCount = 10;
    cae4:	9a e0       	ldi	r25, 0x0A	; 10
    cae6:	e9 2e       	mov	r14, r25
    cae8:	f1 2c       	mov	r15, r1
    caea:	93 c1       	rjmp	.+806    	; 0xce12 <Sl2s2002AppProcess+0x3bc>
                    } else if (Command == ISO15693_CMD_STAY_QUIET) {
    caec:	f2 e0       	ldi	r31, 0x02	; 2
    caee:	ff 12       	cpse	r15, r31
    caf0:	28 c0       	rjmp	.+80     	; 0xcb42 <Sl2s2002AppProcess+0xec>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    caf2:	f8 01       	movw	r30, r16
    caf4:	80 81       	ld	r24, Z
    caf6:	85 ff       	sbrs	r24, 5
    caf8:	20 c0       	rjmp	.+64     	; 0xcb3a <Sl2s2002AppProcess+0xe4>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    cafa:	92 81       	ldd	r25, Z+2	; 0x02
    cafc:	88 85       	ldd	r24, Y+8	; 0x08
    cafe:	98 13       	cpse	r25, r24
    cb00:	90 c1       	rjmp	.+800    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[1] == Uid2[6])
    cb02:	93 81       	ldd	r25, Z+3	; 0x03
    cb04:	8f 81       	ldd	r24, Y+7	; 0x07
    cb06:	98 13       	cpse	r25, r24
    cb08:	8c c1       	rjmp	.+792    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[2] == Uid2[5])
    cb0a:	94 81       	ldd	r25, Z+4	; 0x04
    cb0c:	8e 81       	ldd	r24, Y+6	; 0x06
    cb0e:	98 13       	cpse	r25, r24
    cb10:	88 c1       	rjmp	.+784    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[3] == Uid2[4])
    cb12:	95 81       	ldd	r25, Z+5	; 0x05
    cb14:	8d 81       	ldd	r24, Y+5	; 0x05
    cb16:	98 13       	cpse	r25, r24
    cb18:	84 c1       	rjmp	.+776    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[4] == Uid2[3])
    cb1a:	96 81       	ldd	r25, Z+6	; 0x06
    cb1c:	8c 81       	ldd	r24, Y+4	; 0x04
    cb1e:	98 13       	cpse	r25, r24
    cb20:	80 c1       	rjmp	.+768    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[5] == Uid2[2])
    cb22:	97 81       	ldd	r25, Z+7	; 0x07
    cb24:	8b 81       	ldd	r24, Y+3	; 0x03
    cb26:	98 13       	cpse	r25, r24
    cb28:	7c c1       	rjmp	.+760    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[6] == Uid2[1])
    cb2a:	90 85       	ldd	r25, Z+8	; 0x08
    cb2c:	8a 81       	ldd	r24, Y+2	; 0x02
    cb2e:	98 13       	cpse	r25, r24
    cb30:	78 c1       	rjmp	.+752    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
    cb32:	91 85       	ldd	r25, Z+9	; 0x09
    cb34:	89 81       	ldd	r24, Y+1	; 0x01
    cb36:	98 13       	cpse	r25, r24
    cb38:	74 c1       	rjmp	.+744    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                            State = STATE_QUIET;
    cb3a:	82 e0       	ldi	r24, 0x02	; 2
    cb3c:	80 93 ad 2e 	sts	0x2EAD, r24	; 0x802ead <State>
    cb40:	70 c1       	rjmp	.+736    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                        }
                    } else if (Command == ISO15693_CMD_GET_SYS_INFO) {
    cb42:	fb e2       	ldi	r31, 0x2B	; 43
    cb44:	ff 12       	cpse	r15, r31
    cb46:	43 c0       	rjmp	.+134    	; 0xcbce <Sl2s2002AppProcess+0x178>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    cb48:	f8 01       	movw	r30, r16
    cb4a:	90 81       	ld	r25, Z
    cb4c:	88 85       	ldd	r24, Y+8	; 0x08
    cb4e:	95 ff       	sbrs	r25, 5
    cb50:	1f c0       	rjmp	.+62     	; 0xcb90 <Sl2s2002AppProcess+0x13a>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    cb52:	92 81       	ldd	r25, Z+2	; 0x02
    cb54:	98 13       	cpse	r25, r24
    cb56:	65 c1       	rjmp	.+714    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[1] == Uid2[6])
    cb58:	23 81       	ldd	r18, Z+3	; 0x03
    cb5a:	9f 81       	ldd	r25, Y+7	; 0x07
    cb5c:	29 13       	cpse	r18, r25
    cb5e:	61 c1       	rjmp	.+706    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[2] == Uid2[5])
    cb60:	24 81       	ldd	r18, Z+4	; 0x04
    cb62:	9e 81       	ldd	r25, Y+6	; 0x06
    cb64:	29 13       	cpse	r18, r25
    cb66:	5d c1       	rjmp	.+698    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[3] == Uid2[4])
    cb68:	25 81       	ldd	r18, Z+5	; 0x05
    cb6a:	9d 81       	ldd	r25, Y+5	; 0x05
    cb6c:	29 13       	cpse	r18, r25
    cb6e:	59 c1       	rjmp	.+690    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[4] == Uid2[3])
    cb70:	26 81       	ldd	r18, Z+6	; 0x06
    cb72:	9c 81       	ldd	r25, Y+4	; 0x04
    cb74:	29 13       	cpse	r18, r25
    cb76:	55 c1       	rjmp	.+682    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[5] == Uid2[2])
    cb78:	27 81       	ldd	r18, Z+7	; 0x07
    cb7a:	9b 81       	ldd	r25, Y+3	; 0x03
    cb7c:	29 13       	cpse	r18, r25
    cb7e:	51 c1       	rjmp	.+674    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[6] == Uid2[1])
    cb80:	20 85       	ldd	r18, Z+8	; 0x08
    cb82:	9a 81       	ldd	r25, Y+2	; 0x02
    cb84:	29 13       	cpse	r18, r25
    cb86:	4d c1       	rjmp	.+666    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[7] == Uid2[0])) {
    cb88:	21 85       	ldd	r18, Z+9	; 0x09
    cb8a:	99 81       	ldd	r25, Y+1	; 0x01
    cb8c:	29 13       	cpse	r18, r25
    cb8e:	49 c1       	rjmp	.+658    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
                            FrameBuf[0] = 0; /* Flags */
    cb90:	f8 01       	movw	r30, r16
    cb92:	10 82       	st	Z, r1
                            FrameBuf[1] = 0x0F; /* InfoFlags */
    cb94:	9f e0       	ldi	r25, 0x0F	; 15
    cb96:	91 83       	std	Z+1, r25	; 0x01
    }
}

INLINE
void ISO15693CopyUid(uint8_t *DstUid, uint8_t *SrcUid) {
    DstUid[0] = SrcUid[7];
    cb98:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[6];
    cb9a:	8f 81       	ldd	r24, Y+7	; 0x07
    cb9c:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[5];
    cb9e:	8e 81       	ldd	r24, Y+6	; 0x06
    cba0:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[4];
    cba2:	8d 81       	ldd	r24, Y+5	; 0x05
    cba4:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[3];
    cba6:	8c 81       	ldd	r24, Y+4	; 0x04
    cba8:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[2];
    cbaa:	8b 81       	ldd	r24, Y+3	; 0x03
    cbac:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[1];
    cbae:	8a 81       	ldd	r24, Y+2	; 0x02
    cbb0:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[0];
    cbb2:	89 81       	ldd	r24, Y+1	; 0x01
    cbb4:	81 87       	std	Z+9, r24	; 0x09
                            ISO15693CopyUid(&FrameBuf[2], Uid);
                            FrameBuf[10] = 0x00;
    cbb6:	12 86       	std	Z+10, r1	; 0x0a
                            FrameBuf[11] = 0xC2;
    cbb8:	82 ec       	ldi	r24, 0xC2	; 194
    cbba:	83 87       	std	Z+11, r24	; 0x0b
                            FrameBuf[12] = 0x03;
    cbbc:	83 e0       	ldi	r24, 0x03	; 3
    cbbe:	84 87       	std	Z+12, r24	; 0x0c
                            FrameBuf[13] = 0x03;
    cbc0:	85 87       	std	Z+13, r24	; 0x0d
                            FrameBuf[14] = 0x01;
    cbc2:	81 e0       	ldi	r24, 0x01	; 1
    cbc4:	86 87       	std	Z+14, r24	; 0x0e
                            ResponseByteCount = 15;
    cbc6:	8f e0       	ldi	r24, 0x0F	; 15
    cbc8:	e8 2e       	mov	r14, r24
    cbca:	f1 2c       	mov	r15, r1
    cbcc:	22 c1       	rjmp	.+580    	; 0xce12 <Sl2s2002AppProcess+0x3bc>
                        }
                    } else if (Command == ISO15693_CMD_READ_SINGLE) {
    cbce:	f0 e2       	ldi	r31, 0x20	; 32
    cbd0:	ff 12       	cpse	r15, r31
    cbd2:	47 c0       	rjmp	.+142    	; 0xcc62 <Sl2s2002AppProcess+0x20c>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    cbd4:	f8 01       	movw	r30, r16
    cbd6:	80 81       	ld	r24, Z
    cbd8:	85 ff       	sbrs	r24, 5
    cbda:	20 c0       	rjmp	.+64     	; 0xcc1c <Sl2s2002AppProcess+0x1c6>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    cbdc:	22 81       	ldd	r18, Z+2	; 0x02
    cbde:	98 85       	ldd	r25, Y+8	; 0x08
    cbe0:	29 13       	cpse	r18, r25
    cbe2:	1f c1       	rjmp	.+574    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[1] == Uid2[6])
    cbe4:	23 81       	ldd	r18, Z+3	; 0x03
    cbe6:	9f 81       	ldd	r25, Y+7	; 0x07
    cbe8:	29 13       	cpse	r18, r25
    cbea:	1b c1       	rjmp	.+566    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[2] == Uid2[5])
    cbec:	24 81       	ldd	r18, Z+4	; 0x04
    cbee:	9e 81       	ldd	r25, Y+6	; 0x06
    cbf0:	29 13       	cpse	r18, r25
    cbf2:	17 c1       	rjmp	.+558    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[3] == Uid2[4])
    cbf4:	25 81       	ldd	r18, Z+5	; 0x05
    cbf6:	9d 81       	ldd	r25, Y+5	; 0x05
    cbf8:	29 13       	cpse	r18, r25
    cbfa:	13 c1       	rjmp	.+550    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[4] == Uid2[3])
    cbfc:	26 81       	ldd	r18, Z+6	; 0x06
    cbfe:	9c 81       	ldd	r25, Y+4	; 0x04
    cc00:	29 13       	cpse	r18, r25
    cc02:	0f c1       	rjmp	.+542    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[5] == Uid2[2])
    cc04:	27 81       	ldd	r18, Z+7	; 0x07
    cc06:	9b 81       	ldd	r25, Y+3	; 0x03
    cc08:	29 13       	cpse	r18, r25
    cc0a:	0b c1       	rjmp	.+534    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[6] == Uid2[1])
    cc0c:	20 85       	ldd	r18, Z+8	; 0x08
    cc0e:	9a 81       	ldd	r25, Y+2	; 0x02
    cc10:	29 13       	cpse	r18, r25
    cc12:	07 c1       	rjmp	.+526    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[7] == Uid2[0])) {
    cc14:	21 85       	ldd	r18, Z+9	; 0x09
    cc16:	99 81       	ldd	r25, Y+1	; 0x01
    cc18:	29 13       	cpse	r18, r25
    cc1a:	03 c1       	rjmp	.+518    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
                            uint8_t PageAddress = FrameBuf[10];
    cc1c:	f8 01       	movw	r30, r16
    cc1e:	62 85       	ldd	r22, Z+10	; 0x0a
    cc20:	70 e0       	ldi	r23, 0x00	; 0
                            if (FrameBuf[0] & ISO15693_REQ_FLAG_OPTION) {
    cc22:	86 ff       	sbrs	r24, 6
    cc24:	10 c0       	rjmp	.+32     	; 0xcc46 <Sl2s2002AppProcess+0x1f0>
                                FrameBuf[0] = 0x00; /* Flags */
    cc26:	10 82       	st	Z, r1
                                FrameBuf[1] = 0x00; /* security dummy to 0 */
    cc28:	11 82       	std	Z+1, r1	; 0x01
                                MemoryReadBlock(FrameBuf + 2, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
    cc2a:	66 0f       	add	r22, r22
    cc2c:	77 1f       	adc	r23, r23
    cc2e:	66 0f       	add	r22, r22
    cc30:	77 1f       	adc	r23, r23
    cc32:	44 e0       	ldi	r20, 0x04	; 4
    cc34:	50 e0       	ldi	r21, 0x00	; 0
    cc36:	c8 01       	movw	r24, r16
    cc38:	02 96       	adiw	r24, 0x02	; 2
    cc3a:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                                ResponseByteCount = 6;
    cc3e:	b6 e0       	ldi	r27, 0x06	; 6
    cc40:	eb 2e       	mov	r14, r27
    cc42:	f1 2c       	mov	r15, r1
    cc44:	e6 c0       	rjmp	.+460    	; 0xce12 <Sl2s2002AppProcess+0x3bc>
                            } else {
                                FrameBuf[0] = 0x00; /* Flags */
    cc46:	11 92       	st	Z+, r1
    cc48:	cf 01       	movw	r24, r30
                                MemoryReadBlock(FrameBuf + 1, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
    cc4a:	66 0f       	add	r22, r22
    cc4c:	77 1f       	adc	r23, r23
    cc4e:	66 0f       	add	r22, r22
    cc50:	77 1f       	adc	r23, r23
    cc52:	44 e0       	ldi	r20, 0x04	; 4
    cc54:	50 e0       	ldi	r21, 0x00	; 0
    cc56:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                                ResponseByteCount = 5;
    cc5a:	f5 e0       	ldi	r31, 0x05	; 5
    cc5c:	ef 2e       	mov	r14, r31
    cc5e:	f1 2c       	mov	r15, r1
    cc60:	d8 c0       	rjmp	.+432    	; 0xce12 <Sl2s2002AppProcess+0x3bc>
                            }
                        }
                    } else if (Command == ISO15693_CMD_READ_MULTIPLE) {
    cc62:	f3 e2       	ldi	r31, 0x23	; 35
    cc64:	ff 12       	cpse	r15, r31
    cc66:	6f c0       	rjmp	.+222    	; 0xcd46 <Sl2s2002AppProcess+0x2f0>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    cc68:	f8 01       	movw	r30, r16
    cc6a:	90 81       	ld	r25, Z
    cc6c:	95 ff       	sbrs	r25, 5
    cc6e:	20 c0       	rjmp	.+64     	; 0xccb0 <Sl2s2002AppProcess+0x25a>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    cc70:	22 81       	ldd	r18, Z+2	; 0x02
    cc72:	88 85       	ldd	r24, Y+8	; 0x08
    cc74:	28 13       	cpse	r18, r24
    cc76:	d5 c0       	rjmp	.+426    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[1] == Uid2[6])
    cc78:	23 81       	ldd	r18, Z+3	; 0x03
    cc7a:	8f 81       	ldd	r24, Y+7	; 0x07
    cc7c:	28 13       	cpse	r18, r24
    cc7e:	d1 c0       	rjmp	.+418    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[2] == Uid2[5])
    cc80:	24 81       	ldd	r18, Z+4	; 0x04
    cc82:	8e 81       	ldd	r24, Y+6	; 0x06
    cc84:	28 13       	cpse	r18, r24
    cc86:	cd c0       	rjmp	.+410    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[3] == Uid2[4])
    cc88:	25 81       	ldd	r18, Z+5	; 0x05
    cc8a:	8d 81       	ldd	r24, Y+5	; 0x05
    cc8c:	28 13       	cpse	r18, r24
    cc8e:	c9 c0       	rjmp	.+402    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[4] == Uid2[3])
    cc90:	26 81       	ldd	r18, Z+6	; 0x06
    cc92:	8c 81       	ldd	r24, Y+4	; 0x04
    cc94:	28 13       	cpse	r18, r24
    cc96:	c5 c0       	rjmp	.+394    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[5] == Uid2[2])
    cc98:	27 81       	ldd	r18, Z+7	; 0x07
    cc9a:	8b 81       	ldd	r24, Y+3	; 0x03
    cc9c:	28 13       	cpse	r18, r24
    cc9e:	c1 c0       	rjmp	.+386    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[6] == Uid2[1])
    cca0:	20 85       	ldd	r18, Z+8	; 0x08
    cca2:	8a 81       	ldd	r24, Y+2	; 0x02
    cca4:	28 13       	cpse	r18, r24
    cca6:	bd c0       	rjmp	.+378    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
    cca8:	21 85       	ldd	r18, Z+9	; 0x09
    ccaa:	89 81       	ldd	r24, Y+1	; 0x01
    ccac:	28 13       	cpse	r18, r24
    ccae:	b9 c0       	rjmp	.+370    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                            uint16_t PageAddress = FrameBuf[10];
    ccb0:	f8 01       	movw	r30, r16
    ccb2:	62 85       	ldd	r22, Z+10	; 0x0a
                            uint16_t PageAddressCount = FrameBuf[11] + 1;
    ccb4:	c3 84       	ldd	r12, Z+11	; 0x0b
    ccb6:	d1 2c       	mov	r13, r1
    ccb8:	ff ef       	ldi	r31, 0xFF	; 255
    ccba:	cf 1a       	sub	r12, r31
    ccbc:	df 0a       	sbc	r13, r31

                            uint8_t *FrameBufPtr = FrameBuf + 1;
    ccbe:	98 01       	movw	r18, r16
    ccc0:	2f 5f       	subi	r18, 0xFF	; 255
    ccc2:	3f 4f       	sbci	r19, 0xFF	; 255
    ccc4:	70 e0       	ldi	r23, 0x00	; 0
                            if (FrameBuf[0] & ISO15693_REQ_FLAG_OPTION) {
    ccc6:	96 ff       	sbrs	r25, 6
    ccc8:	2b c0       	rjmp	.+86     	; 0xcd20 <Sl2s2002AppProcess+0x2ca>
    ccca:	58 01       	movw	r10, r16
    cccc:	7b 01       	movw	r14, r22
    ccce:	ee 0c       	add	r14, r14
    ccd0:	ff 1c       	adc	r15, r15
    ccd2:	ee 0c       	add	r14, r14
    ccd4:	ff 1c       	adc	r15, r15
    ccd6:	61 2c       	mov	r6, r1
    ccd8:	71 2c       	mov	r7, r1
    ccda:	91 2c       	mov	r9, r1
                                uint8_t count;
                                for (count = 0; count < PageAddressCount; count++) {
    ccdc:	89 2d       	mov	r24, r9
    ccde:	90 e0       	ldi	r25, 0x00	; 0
    cce0:	8c 15       	cp	r24, r12
    cce2:	9d 05       	cpc	r25, r13
    cce4:	98 f4       	brcc	.+38     	; 0xcd0c <Sl2s2002AppProcess+0x2b6>
                                    *FrameBufPtr++ = 0; // block security status = unlocked
    cce6:	f5 01       	movw	r30, r10
    cce8:	11 82       	std	Z+1, r1	; 0x01
                                    MemoryReadBlock(FrameBufPtr, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
    ccea:	b7 01       	movw	r22, r14
    ccec:	66 0d       	add	r22, r6
    ccee:	77 1d       	adc	r23, r7
    ccf0:	44 e0       	ldi	r20, 0x04	; 4
    ccf2:	50 e0       	ldi	r21, 0x00	; 0
    ccf4:	c5 01       	movw	r24, r10
    ccf6:	02 96       	adiw	r24, 0x02	; 2
    ccf8:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                            uint16_t PageAddressCount = FrameBuf[11] + 1;

                            uint8_t *FrameBufPtr = FrameBuf + 1;
                            if (FrameBuf[0] & ISO15693_REQ_FLAG_OPTION) {
                                uint8_t count;
                                for (count = 0; count < PageAddressCount; count++) {
    ccfc:	93 94       	inc	r9
    ccfe:	f5 e0       	ldi	r31, 0x05	; 5
    cd00:	af 0e       	add	r10, r31
    cd02:	b1 1c       	adc	r11, r1
    cd04:	84 e0       	ldi	r24, 0x04	; 4
    cd06:	68 0e       	add	r6, r24
    cd08:	71 1c       	adc	r7, r1
    cd0a:	e8 cf       	rjmp	.-48     	; 0xccdc <Sl2s2002AppProcess+0x286>
                                    *FrameBufPtr++ = 0; // block security status = unlocked
                                    MemoryReadBlock(FrameBufPtr, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
                                    FrameBufPtr += BYTES_PER_PAGE;
                                    PageAddress += 1;
                                }
                                ResponseByteCount = 1 + (BYTES_PER_PAGE + 1) * PageAddressCount;
    cd0c:	85 e0       	ldi	r24, 0x05	; 5
    cd0e:	8c 9d       	mul	r24, r12
    cd10:	70 01       	movw	r14, r0
    cd12:	8d 9d       	mul	r24, r13
    cd14:	f0 0c       	add	r15, r0
    cd16:	11 24       	eor	r1, r1
    cd18:	ef ef       	ldi	r30, 0xFF	; 255
    cd1a:	ee 1a       	sub	r14, r30
    cd1c:	fe 0a       	sbc	r15, r30
    cd1e:	10 c0       	rjmp	.+32     	; 0xcd40 <Sl2s2002AppProcess+0x2ea>
                            } else {
                                MemoryReadBlock(FrameBufPtr, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE * PageAddressCount);
    cd20:	76 01       	movw	r14, r12
    cd22:	ee 0c       	add	r14, r14
    cd24:	ff 1c       	adc	r15, r15
    cd26:	ee 0c       	add	r14, r14
    cd28:	ff 1c       	adc	r15, r15
    cd2a:	66 0f       	add	r22, r22
    cd2c:	77 1f       	adc	r23, r23
    cd2e:	66 0f       	add	r22, r22
    cd30:	77 1f       	adc	r23, r23
    cd32:	a7 01       	movw	r20, r14
    cd34:	c9 01       	movw	r24, r18
    cd36:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
                                ResponseByteCount = 1 + BYTES_PER_PAGE * PageAddressCount;
    cd3a:	ff ef       	ldi	r31, 0xFF	; 255
    cd3c:	ef 1a       	sub	r14, r31
    cd3e:	ff 0a       	sbc	r15, r31
                            }
                            FrameBuf[0] = 0; /* Flags */
    cd40:	f8 01       	movw	r30, r16
    cd42:	10 82       	st	Z, r1
    cd44:	66 c0       	rjmp	.+204    	; 0xce12 <Sl2s2002AppProcess+0x3bc>
                        }
                    } else if (Command == ISO15693_CMD_GET_BLOCK_SEC) { // TODO read out block security status
    cd46:	fc e2       	ldi	r31, 0x2C	; 44
    cd48:	ff 12       	cpse	r15, r31
    cd4a:	6b c0       	rjmp	.+214    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    cd4c:	f8 01       	movw	r30, r16
    cd4e:	80 81       	ld	r24, Z
    cd50:	85 ff       	sbrs	r24, 5
    cd52:	20 c0       	rjmp	.+64     	; 0xcd94 <Sl2s2002AppProcess+0x33e>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    cd54:	92 81       	ldd	r25, Z+2	; 0x02
    cd56:	88 85       	ldd	r24, Y+8	; 0x08
    cd58:	98 13       	cpse	r25, r24
    cd5a:	63 c0       	rjmp	.+198    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[1] == Uid2[6])
    cd5c:	93 81       	ldd	r25, Z+3	; 0x03
    cd5e:	8f 81       	ldd	r24, Y+7	; 0x07
    cd60:	98 13       	cpse	r25, r24
    cd62:	5f c0       	rjmp	.+190    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[2] == Uid2[5])
    cd64:	94 81       	ldd	r25, Z+4	; 0x04
    cd66:	8e 81       	ldd	r24, Y+6	; 0x06
    cd68:	98 13       	cpse	r25, r24
    cd6a:	5b c0       	rjmp	.+182    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[3] == Uid2[4])
    cd6c:	95 81       	ldd	r25, Z+5	; 0x05
    cd6e:	8d 81       	ldd	r24, Y+5	; 0x05
    cd70:	98 13       	cpse	r25, r24
    cd72:	57 c0       	rjmp	.+174    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[4] == Uid2[3])
    cd74:	96 81       	ldd	r25, Z+6	; 0x06
    cd76:	8c 81       	ldd	r24, Y+4	; 0x04
    cd78:	98 13       	cpse	r25, r24
    cd7a:	53 c0       	rjmp	.+166    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[5] == Uid2[2])
    cd7c:	97 81       	ldd	r25, Z+7	; 0x07
    cd7e:	8b 81       	ldd	r24, Y+3	; 0x03
    cd80:	98 13       	cpse	r25, r24
    cd82:	4f c0       	rjmp	.+158    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[6] == Uid2[1])
    cd84:	90 85       	ldd	r25, Z+8	; 0x08
    cd86:	8a 81       	ldd	r24, Y+2	; 0x02
    cd88:	98 13       	cpse	r25, r24
    cd8a:	4b c0       	rjmp	.+150    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
    cd8c:	91 85       	ldd	r25, Z+9	; 0x09
    cd8e:	89 81       	ldd	r24, Y+1	; 0x01
    cd90:	98 13       	cpse	r25, r24
    cd92:	47 c0       	rjmp	.+142    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                            //uint8_t PageAddressStart = FrameBuf[10];
                            uint8_t PageAddressCount = FrameBuf[11] + 1;
    cd94:	f8 01       	movw	r30, r16
    cd96:	e3 84       	ldd	r14, Z+11	; 0x0b
    cd98:	e3 94       	inc	r14
                            FrameBuf[0] = 0; /* Flags */
    cd9a:	10 82       	st	Z, r1
    cd9c:	90 2f       	mov	r25, r16
                            for (uint8_t i = 0; i < PageAddressCount; i++) {
    cd9e:	f8 01       	movw	r30, r16
    cda0:	8e 2f       	mov	r24, r30
    cda2:	89 1b       	sub	r24, r25
    cda4:	8e 15       	cp	r24, r14
    cda6:	10 f4       	brcc	.+4      	; 0xcdac <Sl2s2002AppProcess+0x356>
                                FrameBuf[i] = 0x00;
    cda8:	11 92       	st	Z+, r1
    cdaa:	fa cf       	rjmp	.-12     	; 0xcda0 <Sl2s2002AppProcess+0x34a>
                            }
                            ResponseByteCount = 1 + PageAddressCount;
    cdac:	f1 2c       	mov	r15, r1
    cdae:	ff ef       	ldi	r31, 0xFF	; 255
    cdb0:	ef 1a       	sub	r14, r31
    cdb2:	ff 0a       	sbc	r15, r31
    cdb4:	2e c0       	rjmp	.+92     	; 0xce12 <Sl2s2002AppProcess+0x3bc>
                case STATE_SELECTED:

                    break;

                case STATE_QUIET:
                    if (Command == ISO15693_CMD_RESET_TO_READY) {
    cdb6:	86 e2       	ldi	r24, 0x26	; 38
    cdb8:	f8 12       	cpse	r15, r24
    cdba:	33 c0       	rjmp	.+102    	; 0xce22 <Sl2s2002AppProcess+0x3cc>
}


INLINE
bool ISO15693AddressedLegacy(uint8_t *Buffer, uint8_t *MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    cdbc:	f8 01       	movw	r30, r16
    cdbe:	80 81       	ld	r24, Z
    cdc0:	85 ff       	sbrs	r24, 5
    cdc2:	20 c0       	rjmp	.+64     	; 0xce04 <Sl2s2002AppProcess+0x3ae>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    cdc4:	92 81       	ldd	r25, Z+2	; 0x02
    cdc6:	88 85       	ldd	r24, Y+8	; 0x08
    cdc8:	98 13       	cpse	r25, r24
    cdca:	2b c0       	rjmp	.+86     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[1] == Uid2[6])
    cdcc:	93 81       	ldd	r25, Z+3	; 0x03
    cdce:	8f 81       	ldd	r24, Y+7	; 0x07
    cdd0:	98 13       	cpse	r25, r24
    cdd2:	27 c0       	rjmp	.+78     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[2] == Uid2[5])
    cdd4:	94 81       	ldd	r25, Z+4	; 0x04
    cdd6:	8e 81       	ldd	r24, Y+6	; 0x06
    cdd8:	98 13       	cpse	r25, r24
    cdda:	23 c0       	rjmp	.+70     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[3] == Uid2[4])
    cddc:	95 81       	ldd	r25, Z+5	; 0x05
    cdde:	8d 81       	ldd	r24, Y+5	; 0x05
    cde0:	98 13       	cpse	r25, r24
    cde2:	1f c0       	rjmp	.+62     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[4] == Uid2[3])
    cde4:	96 81       	ldd	r25, Z+6	; 0x06
    cde6:	8c 81       	ldd	r24, Y+4	; 0x04
    cde8:	98 13       	cpse	r25, r24
    cdea:	1b c0       	rjmp	.+54     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[5] == Uid2[2])
    cdec:	97 81       	ldd	r25, Z+7	; 0x07
    cdee:	8b 81       	ldd	r24, Y+3	; 0x03
    cdf0:	98 13       	cpse	r25, r24
    cdf2:	17 c0       	rjmp	.+46     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[6] == Uid2[1])
    cdf4:	90 85       	ldd	r25, Z+8	; 0x08
    cdf6:	8a 81       	ldd	r24, Y+2	; 0x02
    cdf8:	98 13       	cpse	r25, r24
    cdfa:	13 c0       	rjmp	.+38     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
            && (Uid1[7] == Uid2[0])) {
    cdfc:	91 85       	ldd	r25, Z+9	; 0x09
    cdfe:	89 81       	ldd	r24, Y+1	; 0x01
    ce00:	98 13       	cpse	r25, r24
    ce02:	0f c0       	rjmp	.+30     	; 0xce22 <Sl2s2002AppProcess+0x3cc>
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
                            FrameBuf[0] = 0;
    ce04:	f8 01       	movw	r30, r16
    ce06:	10 82       	st	Z, r1
                            ResponseByteCount = 1;
                            State = STATE_READY;
    ce08:	10 92 ad 2e 	sts	0x2EAD, r1	; 0x802ead <State>

                case STATE_QUIET:
                    if (Command == ISO15693_CMD_RESET_TO_READY) {
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
                            FrameBuf[0] = 0;
                            ResponseByteCount = 1;
    ce0c:	ee 24       	eor	r14, r14
    ce0e:	e3 94       	inc	r14
    ce10:	f1 2c       	mov	r15, r1
                    break;
            }

            if (ResponseByteCount > 0) {
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
    ce12:	b7 01       	movw	r22, r14
    ce14:	c8 01       	movw	r24, r16
    ce16:	f2 d1       	rcall	.+996    	; 0xd1fc <ISO15693AppendCRC>
                ResponseByteCount += ISO15693_CRC16_SIZE;
    ce18:	f2 e0       	ldi	r31, 0x02	; 2
    ce1a:	ef 0e       	add	r14, r31
    ce1c:	f1 1c       	adc	r15, r1
            }

            return ResponseByteCount;
    ce1e:	c7 01       	movw	r24, r14
    ce20:	03 c0       	rjmp	.+6      	; 0xce28 <Sl2s2002AppProcess+0x3d2>
                    } else if (Command == ISO15693_CMD_GET_BLOCK_SEC) { // TODO read out block security status
                        if (ISO15693AddressedLegacy(FrameBuf, Uid)) {
                            //uint8_t PageAddressStart = FrameBuf[10];
                            uint8_t PageAddressCount = FrameBuf[11] + 1;
                            FrameBuf[0] = 0; /* Flags */
                            for (uint8_t i = 0; i < PageAddressCount; i++) {
    ce22:	e1 2c       	mov	r14, r1
    ce24:	f1 2c       	mov	r15, r1
    ce26:	fb cf       	rjmp	.-10     	; 0xce1e <Sl2s2002AppProcess+0x3c8>
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    }

}
    ce28:	28 96       	adiw	r28, 0x08	; 8
    ce2a:	cd bf       	out	0x3d, r28	; 61
    ce2c:	de bf       	out	0x3e, r29	; 62
    ce2e:	df 91       	pop	r29
    ce30:	cf 91       	pop	r28
    ce32:	1f 91       	pop	r17
    ce34:	0f 91       	pop	r16
    ce36:	ff 90       	pop	r15
    ce38:	ef 90       	pop	r14
    ce3a:	df 90       	pop	r13
    ce3c:	cf 90       	pop	r12
    ce3e:	bf 90       	pop	r11
    ce40:	af 90       	pop	r10
    ce42:	9f 90       	pop	r9
    ce44:	7f 90       	pop	r7
    ce46:	6f 90       	pop	r6
    ce48:	08 95       	ret

0000ce4a <Sl2s2002GetUid>:

void Sl2s2002GetUid(ConfigurationUidType Uid) {
    MemoryReadBlock(&Uid[0], MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    ce4a:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    ce4e:	50 e0       	ldi	r21, 0x00	; 0
    ce50:	60 e0       	ldi	r22, 0x00	; 0
    ce52:	70 e0       	ldi	r23, 0x00	; 0
    ce54:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

0000ce58 <Sl2s2002SetUid>:
}

void Sl2s2002SetUid(ConfigurationUidType Uid) {
    MemoryWriteBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    ce58:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    ce5c:	50 e0       	ldi	r21, 0x00	; 0
    ce5e:	60 e0       	ldi	r22, 0x00	; 0
    ce60:	70 e0       	ldi	r23, 0x00	; 0
    ce62:	0c 94 15 12 	jmp	0x242a	; 0x242a <MemoryWriteBlock>

0000ce66 <TITagitstandardAppInit>:
uint16_t UserLockBits_Mask = 0;     /* Holds lock state of blocks */
uint16_t FactoryLockBits_Mask = 0;  /* Holds lock state of blocks */
CurrentFrame FrameInfo;

void TITagitstandardAppInit(void) {
    State = STATE_READY;
    ce66:	10 92 b2 2e 	sts	0x2EB2, r1	; 0x802eb2 <State>

    FactoryLockBits_Mask |= (1 << 8);   /* Locks block 8... */
    FactoryLockBits_Mask |= (1 << 9);   /* ...and 9, which contains the UID */
    ce6a:	80 91 ae 2e 	lds	r24, 0x2EAE	; 0x802eae <FactoryLockBits_Mask>
    ce6e:	90 91 af 2e 	lds	r25, 0x2EAF	; 0x802eaf <FactoryLockBits_Mask+0x1>
    ce72:	93 60       	ori	r25, 0x03	; 3
    ce74:	80 93 ae 2e 	sts	0x2EAE, r24	; 0x802eae <FactoryLockBits_Mask>
    ce78:	90 93 af 2e 	sts	0x2EAF, r25	; 0x802eaf <FactoryLockBits_Mask+0x1>

    FrameInfo.Flags         = NULL;
    ce7c:	ee e3       	ldi	r30, 0x3E	; 62
    ce7e:	f4 e3       	ldi	r31, 0x34	; 52
    ce80:	10 82       	st	Z, r1
    ce82:	11 82       	std	Z+1, r1	; 0x01
    FrameInfo.Command       = NULL;
    ce84:	12 82       	std	Z+2, r1	; 0x02
    ce86:	13 82       	std	Z+3, r1	; 0x03
    FrameInfo.Parameters    = NULL;
    ce88:	14 82       	std	Z+4, r1	; 0x04
    ce8a:	15 82       	std	Z+5, r1	; 0x05
    FrameInfo.ParamLen      = 0;
    ce8c:	16 82       	std	Z+6, r1	; 0x06
    FrameInfo.Addressed     = false;
    ce8e:	17 82       	std	Z+7, r1	; 0x07
    FrameInfo.Selected      = false;
    ce90:	10 86       	std	Z+8, r1	; 0x08

    MemoryReadBlock(&MyAFI, TITAGIT_MEM_AFI_ADDRESS, 1);
    ce92:	41 e0       	ldi	r20, 0x01	; 1
    ce94:	50 e0       	ldi	r21, 0x00	; 0
    ce96:	68 e2       	ldi	r22, 0x28	; 40
    ce98:	70 e0       	ldi	r23, 0x00	; 0
    ce9a:	8d e3       	ldi	r24, 0x3D	; 61
    ce9c:	94 e3       	ldi	r25, 0x34	; 52
    ce9e:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

0000cea2 <TITagitstandardAppReset>:
}

void TITagitstandardAppReset(void) {
    State = STATE_READY;
    cea2:	10 92 b2 2e 	sts	0x2EB2, r1	; 0x802eb2 <State>

    FrameInfo.Flags         = NULL;
    cea6:	ee e3       	ldi	r30, 0x3E	; 62
    cea8:	f4 e3       	ldi	r31, 0x34	; 52
    ceaa:	10 82       	st	Z, r1
    ceac:	11 82       	std	Z+1, r1	; 0x01
    FrameInfo.Command       = NULL;
    ceae:	12 82       	std	Z+2, r1	; 0x02
    ceb0:	13 82       	std	Z+3, r1	; 0x03
    FrameInfo.Parameters    = NULL;
    ceb2:	14 82       	std	Z+4, r1	; 0x04
    ceb4:	15 82       	std	Z+5, r1	; 0x05
    FrameInfo.ParamLen      = 0;
    ceb6:	16 82       	std	Z+6, r1	; 0x06
    FrameInfo.Addressed     = false;
    ceb8:	17 82       	std	Z+7, r1	; 0x07
    FrameInfo.Selected      = false;
    ceba:	10 86       	std	Z+8, r1	; 0x08
    cebc:	08 95       	ret

0000cebe <TITagitstandardAppTask>:
    cebe:	08 95       	ret

0000cec0 <TITagitstandardAppTick>:

void TITagitstandardAppTask(void) {

}

void TITagitstandardAppTick(void) {
    cec0:	08 95       	ret

0000cec2 <TITagitstandardFlipUid>:
    MemoryWriteBlock(Uid, TITAGIT_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
}

void TITagitstandardFlipUid(ConfigurationUidType Uid) {
    uint8_t tmp, *tail;
    tail = Uid + ActiveConfiguration.UidSize - 1;
    cec2:	e0 91 d3 2f 	lds	r30, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    cec6:	f0 e0       	ldi	r31, 0x00	; 0
    cec8:	31 97       	sbiw	r30, 0x01	; 1
    ceca:	e8 0f       	add	r30, r24
    cecc:	f9 1f       	adc	r31, r25
    cece:	dc 01       	movw	r26, r24
    while (Uid < tail) {
    ced0:	ae 17       	cp	r26, r30
    ced2:	bf 07       	cpc	r27, r31
    ced4:	30 f4       	brcc	.+12     	; 0xcee2 <TITagitstandardFlipUid+0x20>
        tmp = *Uid;
    ced6:	8c 91       	ld	r24, X
        *Uid++ = *tail;
    ced8:	90 81       	ld	r25, Z
    ceda:	9d 93       	st	X+, r25
        *tail-- = tmp;
    cedc:	31 97       	sbiw	r30, 0x01	; 1
    cede:	81 83       	std	Z+1, r24	; 0x01
    cee0:	f7 cf       	rjmp	.-18     	; 0xced0 <TITagitstandardFlipUid+0xe>
    }
}
    cee2:	08 95       	ret

0000cee4 <TITagitstandardGetUid>:
    }

    return ResponseByteCount;
}

void TITagitstandardGetUid(ConfigurationUidType Uid) {
    cee4:	cf 93       	push	r28
    cee6:	df 93       	push	r29
    cee8:	ec 01       	movw	r28, r24
    MemoryReadBlock(&Uid[0], TITAGIT_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    ceea:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    ceee:	50 e0       	ldi	r21, 0x00	; 0
    cef0:	60 e2       	ldi	r22, 0x20	; 32
    cef2:	70 e0       	ldi	r23, 0x00	; 0
    cef4:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

    // Reverse UID after reading it
    TITagitstandardFlipUid(Uid);
    cef8:	ce 01       	movw	r24, r28
}
    cefa:	df 91       	pop	r29
    cefc:	cf 91       	pop	r28

void TITagitstandardGetUid(ConfigurationUidType Uid) {
    MemoryReadBlock(&Uid[0], TITAGIT_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);

    // Reverse UID after reading it
    TITagitstandardFlipUid(Uid);
    cefe:	e1 cf       	rjmp	.-62     	; 0xcec2 <TITagitstandardFlipUid>

0000cf00 <TITagitstandardAppProcess>:

void TITagitstandardAppTick(void) {

}

uint16_t TITagitstandardAppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    cf00:	6f 92       	push	r6
    cf02:	7f 92       	push	r7
    cf04:	8f 92       	push	r8
    cf06:	9f 92       	push	r9
    cf08:	af 92       	push	r10
    cf0a:	bf 92       	push	r11
    cf0c:	cf 92       	push	r12
    cf0e:	df 92       	push	r13
    cf10:	ef 92       	push	r14
    cf12:	0f 93       	push	r16
    cf14:	1f 93       	push	r17
    cf16:	cf 93       	push	r28
    cf18:	df 93       	push	r29
    cf1a:	cd b7       	in	r28, 0x3d	; 61
    cf1c:	de b7       	in	r29, 0x3e	; 62
    cf1e:	6c 01       	movw	r12, r24
    cf20:	3b 01       	movw	r6, r22
        ISO15693AppendCRC(FrameBuf, ResponseByteCount);
        ResponseByteCount += ISO15693_CRC16_SIZE;
    }

    return ResponseByteCount;
}
    cf22:	ad b6       	in	r10, 0x3d	; 61
    cf24:	be b6       	in	r11, 0x3e	; 62

}

uint16_t TITagitstandardAppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t Uid[ActiveConfiguration.UidSize];
    cf26:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    cf2a:	2d b7       	in	r18, 0x3d	; 61
    cf2c:	3e b7       	in	r19, 0x3e	; 62
    cf2e:	28 1b       	sub	r18, r24
    cf30:	31 09       	sbc	r19, r1
    cf32:	2d bf       	out	0x3d, r18	; 61
    cf34:	3e bf       	out	0x3e, r19	; 62
    cf36:	8d b7       	in	r24, 0x3d	; 61
    cf38:	9e b7       	in	r25, 0x3e	; 62
    cf3a:	01 96       	adiw	r24, 0x01	; 1
    cf3c:	4c 01       	movw	r8, r24
    TITagitstandardGetUid(Uid);
    cf3e:	d2 df       	rcall	.-92     	; 0xcee4 <TITagitstandardGetUid>

    if ((FrameBytes < ISO15693_MIN_FRAME_SIZE) || !ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE))
    cf40:	94 e0       	ldi	r25, 0x04	; 4
    cf42:	69 16       	cp	r6, r25
    cf44:	71 04       	cpc	r7, r1
    cf46:	08 f4       	brcc	.+2      	; 0xcf4a <TITagitstandardAppProcess+0x4a>
    cf48:	1a c1       	rjmp	.+564    	; 0xd17e <TITagitstandardAppProcess+0x27e>
    cf4a:	b3 01       	movw	r22, r6
    cf4c:	62 50       	subi	r22, 0x02	; 2
    cf4e:	71 09       	sbc	r23, r1
    cf50:	c6 01       	movw	r24, r12
    cf52:	64 d1       	rcall	.+712    	; 0xd21c <ISO15693CheckCRC>
    cf54:	88 23       	and	r24, r24
    cf56:	09 f4       	brne	.+2      	; 0xcf5a <TITagitstandardAppProcess+0x5a>
    cf58:	12 c1       	rjmp	.+548    	; 0xd17e <TITagitstandardAppProcess+0x27e>
        /* malformed frame */
        return ResponseByteCount;

    if (!ISO15693PrepareFrame(FrameBuf, FrameBytes, &FrameInfo, State == STATE_SELECTED, Uid, MyAFI))
    cf5a:	21 e0       	ldi	r18, 0x01	; 1
    cf5c:	80 91 b2 2e 	lds	r24, 0x2EB2	; 0x802eb2 <State>
    cf60:	81 30       	cpi	r24, 0x01	; 1
    cf62:	09 f0       	breq	.+2      	; 0xcf66 <TITagitstandardAppProcess+0x66>
    cf64:	20 e0       	ldi	r18, 0x00	; 0
    cf66:	e0 90 3d 34 	lds	r14, 0x343D	; 0x80343d <MyAFI>
    cf6a:	84 01       	movw	r16, r8
    cf6c:	4e e3       	ldi	r20, 0x3E	; 62
    cf6e:	54 e3       	ldi	r21, 0x34	; 52
    cf70:	b3 01       	movw	r22, r6
    cf72:	c6 01       	movw	r24, r12
    cf74:	69 d1       	rcall	.+722    	; 0xd248 <ISO15693PrepareFrame>
    cf76:	88 23       	and	r24, r24
    cf78:	09 f4       	brne	.+2      	; 0xcf7c <TITagitstandardAppProcess+0x7c>
    cf7a:	01 c1       	rjmp	.+514    	; 0xd17e <TITagitstandardAppProcess+0x27e>
        return ISO15693_APP_NO_RESPONSE;

    switch (State) {
    cf7c:	80 91 b2 2e 	lds	r24, 0x2EB2	; 0x802eb2 <State>
    cf80:	81 11       	cpse	r24, r1
    cf82:	fd c0       	rjmp	.+506    	; 0xd17e <TITagitstandardAppProcess+0x27e>
        case STATE_READY:
            if (*FrameInfo.Command == ISO15693_CMD_INVENTORY) {
    cf84:	e0 91 40 34 	lds	r30, 0x3440	; 0x803440 <FrameInfo+0x2>
    cf88:	f0 91 41 34 	lds	r31, 0x3441	; 0x803441 <FrameInfo+0x3>
    cf8c:	80 81       	ld	r24, Z
    cf8e:	81 30       	cpi	r24, 0x01	; 1
    cf90:	31 f5       	brne	.+76     	; 0xcfde <TITagitstandardAppProcess+0xde>
                FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    cf92:	f6 01       	movw	r30, r12
    cf94:	10 82       	st	Z, r1
                FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_INVENTORY_DSFID;
    cf96:	11 82       	std	Z+1, r1	; 0x01
    }
}

INLINE
void ISO15693CopyUid(uint8_t *DstUid, uint8_t *SrcUid) {
    DstUid[0] = SrcUid[7];
    cf98:	f4 01       	movw	r30, r8
    cf9a:	87 81       	ldd	r24, Z+7	; 0x07
    cf9c:	f6 01       	movw	r30, r12
    cf9e:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[6];
    cfa0:	f4 01       	movw	r30, r8
    cfa2:	86 81       	ldd	r24, Z+6	; 0x06
    cfa4:	f6 01       	movw	r30, r12
    cfa6:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[5];
    cfa8:	f4 01       	movw	r30, r8
    cfaa:	85 81       	ldd	r24, Z+5	; 0x05
    cfac:	f6 01       	movw	r30, r12
    cfae:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[4];
    cfb0:	f4 01       	movw	r30, r8
    cfb2:	84 81       	ldd	r24, Z+4	; 0x04
    cfb4:	f6 01       	movw	r30, r12
    cfb6:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[3];
    cfb8:	f4 01       	movw	r30, r8
    cfba:	83 81       	ldd	r24, Z+3	; 0x03
    cfbc:	f6 01       	movw	r30, r12
    cfbe:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[2];
    cfc0:	f4 01       	movw	r30, r8
    cfc2:	82 81       	ldd	r24, Z+2	; 0x02
    cfc4:	f6 01       	movw	r30, r12
    cfc6:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[1];
    cfc8:	f4 01       	movw	r30, r8
    cfca:	81 81       	ldd	r24, Z+1	; 0x01
    cfcc:	f6 01       	movw	r30, r12
    cfce:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[0];
    cfd0:	f4 01       	movw	r30, r8
    cfd2:	80 81       	ld	r24, Z
    cfd4:	f6 01       	movw	r30, r12
    cfd6:	81 87       	std	Z+9, r24	; 0x09
                ISO15693CopyUid(&FrameBuf[ISO15693_RES_ADDR_PARAM + 0x01], Uid);
                ResponseByteCount = 10;
    cfd8:	0a e0       	ldi	r16, 0x0A	; 10
    cfda:	10 e0       	ldi	r17, 0x00	; 0
    cfdc:	ca c0       	rjmp	.+404    	; 0xd172 <TITagitstandardAppProcess+0x272>

            } else if (*FrameInfo.Command == ISO15693_CMD_STAY_QUIET && FrameInfo.Addressed) {
    cfde:	82 30       	cpi	r24, 0x02	; 2
    cfe0:	41 f4       	brne	.+16     	; 0xcff2 <TITagitstandardAppProcess+0xf2>
    cfe2:	90 91 45 34 	lds	r25, 0x3445	; 0x803445 <FrameInfo+0x7>
    cfe6:	99 23       	and	r25, r25
    cfe8:	09 f4       	brne	.+2      	; 0xcfec <TITagitstandardAppProcess+0xec>
    cfea:	bd c0       	rjmp	.+378    	; 0xd166 <TITagitstandardAppProcess+0x266>
                State = STATE_QUIET;
    cfec:	80 93 b2 2e 	sts	0x2EB2, r24	; 0x802eb2 <State>
    cff0:	c6 c0       	rjmp	.+396    	; 0xd17e <TITagitstandardAppProcess+0x27e>

            } else if (*FrameInfo.Command == ISO15693_CMD_READ_SINGLE) {
    cff2:	80 32       	cpi	r24, 0x20	; 32
    cff4:	09 f0       	breq	.+2      	; 0xcff8 <TITagitstandardAppProcess+0xf8>
    cff6:	47 c0       	rjmp	.+142    	; 0xd086 <TITagitstandardAppProcess+0x186>
                uint8_t *FramePtr; /* holds the address where block's data will be put */
                uint8_t PageAddress = *FrameInfo.Parameters;

                if (FrameInfo.ParamLen != 1)
    cff8:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    cffc:	81 30       	cpi	r24, 0x01	; 1
    cffe:	09 f0       	breq	.+2      	; 0xd002 <TITagitstandardAppProcess+0x102>
    d000:	be c0       	rjmp	.+380    	; 0xd17e <TITagitstandardAppProcess+0x27e>
            } else if (*FrameInfo.Command == ISO15693_CMD_STAY_QUIET && FrameInfo.Addressed) {
                State = STATE_QUIET;

            } else if (*FrameInfo.Command == ISO15693_CMD_READ_SINGLE) {
                uint8_t *FramePtr; /* holds the address where block's data will be put */
                uint8_t PageAddress = *FrameInfo.Parameters;
    d002:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d006:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d00a:	60 81       	ld	r22, Z

                if (FrameInfo.ParamLen != 1)
                    break; /* malformed: not enough or too much data */

                if (PageAddress >= TITAGIT_NUMBER_OF_SECTORS) { /* the reader is requesting a sector out of bound */
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d00c:	f6 01       	movw	r30, r12
                uint8_t PageAddress = *FrameInfo.Parameters;

                if (FrameInfo.ParamLen != 1)
                    break; /* malformed: not enough or too much data */

                if (PageAddress >= TITAGIT_NUMBER_OF_SECTORS) { /* the reader is requesting a sector out of bound */
    d00e:	6b 30       	cpi	r22, 0x0B	; 11
    d010:	18 f0       	brcs	.+6      	; 0xd018 <TITagitstandardAppProcess+0x118>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d012:	80 83       	st	Z, r24
                    FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_BLK_NOT_AVL; /* real TiTag standard reply with this error */
    d014:	80 e1       	ldi	r24, 0x10	; 16
    d016:	aa c0       	rjmp	.+340    	; 0xd16c <TITagitstandardAppProcess+0x26c>
                    ResponseByteCount = 2;
                    break;
                }

                if (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_OPTION) { /* request with option flag set */
    d018:	80 81       	ld	r24, Z
    d01a:	86 ff       	sbrs	r24, 6
    d01c:	25 c0       	rjmp	.+74     	; 0xd068 <TITagitstandardAppProcess+0x168>
                    if (FactoryLockBits_Mask & (1 << PageAddress)) { /* tests if the n-th bit of the factory bitmask if set to 1 */
    d01e:	81 e0       	ldi	r24, 0x01	; 1
    d020:	90 e0       	ldi	r25, 0x00	; 0
    d022:	06 2e       	mov	r0, r22
    d024:	02 c0       	rjmp	.+4      	; 0xd02a <TITagitstandardAppProcess+0x12a>
    d026:	88 0f       	add	r24, r24
    d028:	99 1f       	adc	r25, r25
    d02a:	0a 94       	dec	r0
    d02c:	e2 f7       	brpl	.-8      	; 0xd026 <TITagitstandardAppProcess+0x126>
    d02e:	20 91 ae 2e 	lds	r18, 0x2EAE	; 0x802eae <FactoryLockBits_Mask>
    d032:	30 91 af 2e 	lds	r19, 0x2EAF	; 0x802eaf <FactoryLockBits_Mask+0x1>
    d036:	28 23       	and	r18, r24
    d038:	39 23       	and	r19, r25
    d03a:	23 2b       	or	r18, r19
    d03c:	11 f0       	breq	.+4      	; 0xd042 <TITagitstandardAppProcess+0x142>
                        FrameBuf[1] = 0x02; /* return bit 1 set as 1 (factory locked) */
    d03e:	82 e0       	ldi	r24, 0x02	; 2
    d040:	0a c0       	rjmp	.+20     	; 0xd056 <TITagitstandardAppProcess+0x156>
                    } else if (UserLockBits_Mask & (1 << PageAddress)) { /* tests if the n-th bit of the user bitmask if set to 1 */
    d042:	20 91 b0 2e 	lds	r18, 0x2EB0	; 0x802eb0 <UserLockBits_Mask>
    d046:	30 91 b1 2e 	lds	r19, 0x2EB1	; 0x802eb1 <UserLockBits_Mask+0x1>
    d04a:	82 23       	and	r24, r18
    d04c:	93 23       	and	r25, r19
    d04e:	89 2b       	or	r24, r25
    d050:	21 f0       	breq	.+8      	; 0xd05a <TITagitstandardAppProcess+0x15a>
                        FrameBuf[1] = 0x01; /* return bit 0 set as 1 (user locked) */
    d052:	81 e0       	ldi	r24, 0x01	; 1
    d054:	f6 01       	movw	r30, r12
    d056:	81 83       	std	Z+1, r24	; 0x01
    d058:	02 c0       	rjmp	.+4      	; 0xd05e <TITagitstandardAppProcess+0x15e>
                    } else
                        FrameBuf[1] = 0x00; /* return lock status 00 (unlocked) */
    d05a:	f6 01       	movw	r30, r12
    d05c:	11 82       	std	Z+1, r1	; 0x01
                    FramePtr = FrameBuf + 2; /* block's data from byte 2 */
    d05e:	c6 01       	movw	r24, r12
    d060:	02 96       	adiw	r24, 0x02	; 2
                    ResponseByteCount = 6;
    d062:	06 e0       	ldi	r16, 0x06	; 6
    d064:	10 e0       	ldi	r17, 0x00	; 0
    d066:	04 c0       	rjmp	.+8      	; 0xd070 <TITagitstandardAppProcess+0x170>
                } else { /* request with option flag not set */
                    FramePtr = FrameBuf + 1; /* block's data from byte 1 */
    d068:	c6 01       	movw	r24, r12
    d06a:	01 96       	adiw	r24, 0x01	; 1
                    ResponseByteCount = 5;
    d06c:	05 e0       	ldi	r16, 0x05	; 5
    d06e:	10 e0       	ldi	r17, 0x00	; 0
                }

                FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    d070:	f6 01       	movw	r30, r12
    d072:	10 82       	st	Z, r1
                MemoryReadBlock(FramePtr, PageAddress * TITAGIT_BYTES_PER_PAGE, TITAGIT_BYTES_PER_PAGE);
    d074:	f4 e0       	ldi	r31, 0x04	; 4
    d076:	6f 9f       	mul	r22, r31
    d078:	b0 01       	movw	r22, r0
    d07a:	11 24       	eor	r1, r1
    d07c:	44 e0       	ldi	r20, 0x04	; 4
    d07e:	50 e0       	ldi	r21, 0x00	; 0
    d080:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    d084:	76 c0       	rjmp	.+236    	; 0xd172 <TITagitstandardAppProcess+0x272>

            } else if (*FrameInfo.Command == ISO15693_CMD_WRITE_SINGLE) {
    d086:	81 32       	cpi	r24, 0x21	; 33
    d088:	c9 f5       	brne	.+114    	; 0xd0fc <TITagitstandardAppProcess+0x1fc>
                uint8_t *Dataptr;
                uint8_t PageAddress = *FrameInfo.Parameters;

                if (FrameInfo.ParamLen != 5)
    d08a:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d08e:	85 30       	cpi	r24, 0x05	; 5
    d090:	09 f0       	breq	.+2      	; 0xd094 <TITagitstandardAppProcess+0x194>
    d092:	75 c0       	rjmp	.+234    	; 0xd17e <TITagitstandardAppProcess+0x27e>
                FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
                MemoryReadBlock(FramePtr, PageAddress * TITAGIT_BYTES_PER_PAGE, TITAGIT_BYTES_PER_PAGE);

            } else if (*FrameInfo.Command == ISO15693_CMD_WRITE_SINGLE) {
                uint8_t *Dataptr;
                uint8_t PageAddress = *FrameInfo.Parameters;
    d094:	80 91 42 34 	lds	r24, 0x3442	; 0x803442 <FrameInfo+0x4>
    d098:	90 91 43 34 	lds	r25, 0x3443	; 0x803443 <FrameInfo+0x5>
    d09c:	fc 01       	movw	r30, r24
    d09e:	60 81       	ld	r22, Z

                if (FrameInfo.ParamLen != 5)
                    break; /* malformed: not enough or too much data */

                if (PageAddress > TITAGIT_NUMBER_OF_SECTORS) {
    d0a0:	6c 30       	cpi	r22, 0x0C	; 12
    d0a2:	28 f0       	brcs	.+10     	; 0xd0ae <TITagitstandardAppProcess+0x1ae>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d0a4:	81 e0       	ldi	r24, 0x01	; 1
    d0a6:	f6 01       	movw	r30, r12
    d0a8:	80 83       	st	Z, r24
                    FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_OPT_NOT_SUPP;
    d0aa:	83 e0       	ldi	r24, 0x03	; 3
    d0ac:	5f c0       	rjmp	.+190    	; 0xd16c <TITagitstandardAppProcess+0x26c>
                    break; /* malformed: trying to write in a non-existing block */
                }

                Dataptr = FrameInfo.Parameters + 1;

                if (FactoryLockBits_Mask & (1 << PageAddress)) {
    d0ae:	21 e0       	ldi	r18, 0x01	; 1
    d0b0:	30 e0       	ldi	r19, 0x00	; 0
    d0b2:	06 2e       	mov	r0, r22
    d0b4:	02 c0       	rjmp	.+4      	; 0xd0ba <TITagitstandardAppProcess+0x1ba>
    d0b6:	22 0f       	add	r18, r18
    d0b8:	33 1f       	adc	r19, r19
    d0ba:	0a 94       	dec	r0
    d0bc:	e2 f7       	brpl	.-8      	; 0xd0b6 <TITagitstandardAppProcess+0x1b6>
    d0be:	40 91 ae 2e 	lds	r20, 0x2EAE	; 0x802eae <FactoryLockBits_Mask>
    d0c2:	50 91 af 2e 	lds	r21, 0x2EAF	; 0x802eaf <FactoryLockBits_Mask+0x1>
    d0c6:	42 23       	and	r20, r18
    d0c8:	53 23       	and	r21, r19
    d0ca:	45 2b       	or	r20, r21
    d0cc:	59 f7       	brne	.-42     	; 0xd0a4 <TITagitstandardAppProcess+0x1a4>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
                    FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_OPT_NOT_SUPP;
                    ResponseByteCount = 2;
                } else if (UserLockBits_Mask & (1 << PageAddress)) {
    d0ce:	40 91 b0 2e 	lds	r20, 0x2EB0	; 0x802eb0 <UserLockBits_Mask>
    d0d2:	50 91 b1 2e 	lds	r21, 0x2EB1	; 0x802eb1 <UserLockBits_Mask+0x1>
    d0d6:	24 23       	and	r18, r20
    d0d8:	35 23       	and	r19, r21
    d0da:	23 2b       	or	r18, r19
    d0dc:	29 f0       	breq	.+10     	; 0xd0e8 <TITagitstandardAppProcess+0x1e8>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d0de:	81 e0       	ldi	r24, 0x01	; 1
    d0e0:	f6 01       	movw	r30, r12
    d0e2:	80 83       	st	Z, r24
                    FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_BLK_CHG_LKD;
    d0e4:	82 e1       	ldi	r24, 0x12	; 18
    d0e6:	42 c0       	rjmp	.+132    	; 0xd16c <TITagitstandardAppProcess+0x26c>
                    ResponseByteCount = 2;
                } else {
                    MemoryWriteBlock(Dataptr, PageAddress * TITAGIT_BYTES_PER_PAGE, TITAGIT_BYTES_PER_PAGE);
    d0e8:	f4 e0       	ldi	r31, 0x04	; 4
    d0ea:	6f 9f       	mul	r22, r31
    d0ec:	b0 01       	movw	r22, r0
    d0ee:	11 24       	eor	r1, r1
    d0f0:	44 e0       	ldi	r20, 0x04	; 4
    d0f2:	50 e0       	ldi	r21, 0x00	; 0
    d0f4:	01 96       	adiw	r24, 0x01	; 1
    d0f6:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    d0fa:	30 c0       	rjmp	.+96     	; 0xd15c <TITagitstandardAppProcess+0x25c>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
                    ResponseByteCount = 1;
                }

            } else if (*FrameInfo.Command == ISO15693_CMD_LOCK_BLOCK) {
    d0fc:	82 32       	cpi	r24, 0x22	; 34
    d0fe:	99 f5       	brne	.+102    	; 0xd166 <TITagitstandardAppProcess+0x266>
                uint8_t PageAddress = *FrameInfo.Parameters;

                if (FrameInfo.ParamLen != 1)
    d100:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d104:	81 30       	cpi	r24, 0x01	; 1
    d106:	d9 f5       	brne	.+118    	; 0xd17e <TITagitstandardAppProcess+0x27e>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
                    ResponseByteCount = 1;
                }

            } else if (*FrameInfo.Command == ISO15693_CMD_LOCK_BLOCK) {
                uint8_t PageAddress = *FrameInfo.Parameters;
    d108:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d10c:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d110:	20 81       	ld	r18, Z

                if (FrameInfo.ParamLen != 1)
                    break; /* malformed: not enough or too much data */

                if (PageAddress > TITAGIT_NUMBER_OF_SECTORS) {
    d112:	2c 30       	cpi	r18, 0x0C	; 12
    d114:	38 f6       	brcc	.-114    	; 0xd0a4 <TITagitstandardAppProcess+0x1a4>
                    FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_OPT_NOT_SUPP;
                    ResponseByteCount = 2;
                    break; /* malformed: trying to lock a non-existing block */
                }

                if ((FactoryLockBits_Mask & (1 << PageAddress)) || (UserLockBits_Mask & (1 << PageAddress))) {
    d116:	81 e0       	ldi	r24, 0x01	; 1
    d118:	90 e0       	ldi	r25, 0x00	; 0
    d11a:	02 c0       	rjmp	.+4      	; 0xd120 <TITagitstandardAppProcess+0x220>
    d11c:	88 0f       	add	r24, r24
    d11e:	99 1f       	adc	r25, r25
    d120:	2a 95       	dec	r18
    d122:	e2 f7       	brpl	.-8      	; 0xd11c <TITagitstandardAppProcess+0x21c>
    d124:	20 91 ae 2e 	lds	r18, 0x2EAE	; 0x802eae <FactoryLockBits_Mask>
    d128:	30 91 af 2e 	lds	r19, 0x2EAF	; 0x802eaf <FactoryLockBits_Mask+0x1>
    d12c:	28 23       	and	r18, r24
    d12e:	39 23       	and	r19, r25
    d130:	23 2b       	or	r18, r19
    d132:	49 f4       	brne	.+18     	; 0xd146 <TITagitstandardAppProcess+0x246>
    d134:	20 91 b0 2e 	lds	r18, 0x2EB0	; 0x802eb0 <UserLockBits_Mask>
    d138:	30 91 b1 2e 	lds	r19, 0x2EB1	; 0x802eb1 <UserLockBits_Mask+0x1>
    d13c:	ac 01       	movw	r20, r24
    d13e:	42 23       	and	r20, r18
    d140:	53 23       	and	r21, r19
    d142:	45 2b       	or	r20, r21
    d144:	29 f0       	breq	.+10     	; 0xd150 <TITagitstandardAppProcess+0x250>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d146:	81 e0       	ldi	r24, 0x01	; 1
    d148:	f6 01       	movw	r30, r12
    d14a:	80 83       	st	Z, r24
                    FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_BLK_ALRD_LKD;
    d14c:	81 e1       	ldi	r24, 0x11	; 17
    d14e:	0e c0       	rjmp	.+28     	; 0xd16c <TITagitstandardAppProcess+0x26c>
                    ResponseByteCount = 2;
                } else {
                    UserLockBits_Mask |= (1 << PageAddress); /*  */
    d150:	82 2b       	or	r24, r18
    d152:	93 2b       	or	r25, r19
    d154:	80 93 b0 2e 	sts	0x2EB0, r24	; 0x802eb0 <UserLockBits_Mask>
    d158:	90 93 b1 2e 	sts	0x2EB1, r25	; 0x802eb1 <UserLockBits_Mask+0x1>
                    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    d15c:	f6 01       	movw	r30, r12
    d15e:	10 82       	st	Z, r1
                    ResponseByteCount = 1;
    d160:	01 e0       	ldi	r16, 0x01	; 1
    d162:	10 e0       	ldi	r17, 0x00	; 0
    d164:	06 c0       	rjmp	.+12     	; 0xd172 <TITagitstandardAppProcess+0x272>
                }

            } else {
                FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d166:	81 e0       	ldi	r24, 0x01	; 1
    d168:	f6 01       	movw	r30, r12
    d16a:	80 83       	st	Z, r24
                FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_NOT_SUPP;
    d16c:	81 83       	std	Z+1, r24	; 0x01
                ResponseByteCount = 2;
    d16e:	02 e0       	ldi	r16, 0x02	; 2
            break;
    }

    if (ResponseByteCount > 0) {
        /* There is data to be sent. Append CRC */
        ISO15693AppendCRC(FrameBuf, ResponseByteCount);
    d170:	10 e0       	ldi	r17, 0x00	; 0
    d172:	b8 01       	movw	r22, r16
    d174:	c6 01       	movw	r24, r12
    d176:	42 d0       	rcall	.+132    	; 0xd1fc <ISO15693AppendCRC>
        ResponseByteCount += ISO15693_CRC16_SIZE;
    d178:	c8 01       	movw	r24, r16
    d17a:	02 96       	adiw	r24, 0x02	; 2
    d17c:	02 c0       	rjmp	.+4      	; 0xd182 <TITagitstandardAppProcess+0x282>
    uint8_t Uid[ActiveConfiguration.UidSize];
    TITagitstandardGetUid(Uid);

    if ((FrameBytes < ISO15693_MIN_FRAME_SIZE) || !ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE))
        /* malformed frame */
        return ResponseByteCount;
    d17e:	80 e0       	ldi	r24, 0x00	; 0
    d180:	90 e0       	ldi	r25, 0x00	; 0
        ISO15693AppendCRC(FrameBuf, ResponseByteCount);
        ResponseByteCount += ISO15693_CRC16_SIZE;
    }

    return ResponseByteCount;
}
    d182:	ad be       	out	0x3d, r10	; 61
    d184:	be be       	out	0x3e, r11	; 62
    d186:	df 91       	pop	r29
    d188:	cf 91       	pop	r28
    d18a:	1f 91       	pop	r17
    d18c:	0f 91       	pop	r16
    d18e:	ef 90       	pop	r14
    d190:	df 90       	pop	r13
    d192:	cf 90       	pop	r12
    d194:	bf 90       	pop	r11
    d196:	af 90       	pop	r10
    d198:	9f 90       	pop	r9
    d19a:	8f 90       	pop	r8
    d19c:	7f 90       	pop	r7
    d19e:	6f 90       	pop	r6
    d1a0:	08 95       	ret

0000d1a2 <TITagitstandardSetUid>:

    // Reverse UID after reading it
    TITagitstandardFlipUid(Uid);
}

void TITagitstandardSetUid(ConfigurationUidType Uid) {
    d1a2:	cf 93       	push	r28
    d1a4:	df 93       	push	r29
    d1a6:	ec 01       	movw	r28, r24
    // Reverse UID before writing it
    TITagitstandardFlipUid(Uid);
    d1a8:	8c de       	rcall	.-744    	; 0xcec2 <TITagitstandardFlipUid>

    MemoryWriteBlock(Uid, TITAGIT_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    d1aa:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    d1ae:	50 e0       	ldi	r21, 0x00	; 0
    d1b0:	60 e2       	ldi	r22, 0x20	; 32
    d1b2:	70 e0       	ldi	r23, 0x00	; 0
    d1b4:	ce 01       	movw	r24, r28
}
    d1b6:	df 91       	pop	r29
    d1b8:	cf 91       	pop	r28

void TITagitstandardSetUid(ConfigurationUidType Uid) {
    // Reverse UID before writing it
    TITagitstandardFlipUid(Uid);

    MemoryWriteBlock(Uid, TITAGIT_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    d1ba:	0c 94 15 12 	jmp	0x242a	; 0x242a <MemoryWriteBlock>

0000d1be <calculateCRC>:
#include "ISO15693-A.h"
#include "../Common.h"
#include <util/crc16.h>

//Refer to ISO/IEC 15693-3:2001 page 41
uint16_t calculateCRC(void *FrameBuf, uint16_t FrameBufSize) {
    d1be:	a8 2f       	mov	r26, r24
    uint16_t reg = ISO15693_CRC16_PRESET;
    uint8_t i, j;

    uint8_t *DataPtr = (uint8_t *)FrameBuf;

    for (i = 0; i < FrameBufSize; i++) {
    d1c0:	fc 01       	movw	r30, r24
#include "../Common.h"
#include <util/crc16.h>

//Refer to ISO/IEC 15693-3:2001 page 41
uint16_t calculateCRC(void *FrameBuf, uint16_t FrameBufSize) {
    uint16_t reg = ISO15693_CRC16_PRESET;
    d1c2:	8f ef       	ldi	r24, 0xFF	; 255
    d1c4:	9f ef       	ldi	r25, 0xFF	; 255
    uint8_t i, j;

    uint8_t *DataPtr = (uint8_t *)FrameBuf;

    for (i = 0; i < FrameBufSize; i++) {
    d1c6:	2e 2f       	mov	r18, r30
    d1c8:	2a 1b       	sub	r18, r26
    d1ca:	30 e0       	ldi	r19, 0x00	; 0
    d1cc:	26 17       	cp	r18, r22
    d1ce:	37 07       	cpc	r19, r23
    d1d0:	90 f4       	brcc	.+36     	; 0xd1f6 <calculateCRC+0x38>
        reg = reg ^ *DataPtr++;
    d1d2:	21 91       	ld	r18, Z+
    d1d4:	82 27       	eor	r24, r18
    d1d6:	28 e0       	ldi	r18, 0x08	; 8
    d1d8:	ac 01       	movw	r20, r24
    d1da:	56 95       	lsr	r21
    d1dc:	47 95       	ror	r20
        for (j = 0; j < 8; j++) {
            if (reg & 0x0001) {
    d1de:	80 ff       	sbrs	r24, 0
    d1e0:	06 c0       	rjmp	.+12     	; 0xd1ee <calculateCRC+0x30>
                reg = (reg >> 1) ^ ISO15693_CRC16_POLYNORMAL;
    d1e2:	ca 01       	movw	r24, r20
    d1e4:	38 e0       	ldi	r19, 0x08	; 8
    d1e6:	83 27       	eor	r24, r19
    d1e8:	34 e8       	ldi	r19, 0x84	; 132
    d1ea:	93 27       	eor	r25, r19
    d1ec:	01 c0       	rjmp	.+2      	; 0xd1f0 <calculateCRC+0x32>
            } else {
                reg = (reg >> 1);
    d1ee:	ca 01       	movw	r24, r20
    d1f0:	21 50       	subi	r18, 0x01	; 1

    uint8_t *DataPtr = (uint8_t *)FrameBuf;

    for (i = 0; i < FrameBufSize; i++) {
        reg = reg ^ *DataPtr++;
        for (j = 0; j < 8; j++) {
    d1f2:	91 f7       	brne	.-28     	; 0xd1d8 <calculateCRC+0x1a>
    d1f4:	e8 cf       	rjmp	.-48     	; 0xd1c6 <calculateCRC+0x8>
            }
        }
    }

    return ~reg;
}
    d1f6:	80 95       	com	r24
    d1f8:	90 95       	com	r25
    d1fa:	08 95       	ret

0000d1fc <ISO15693AppendCRC>:

void ISO15693AppendCRC(uint8_t *FrameBuf, uint16_t FrameBufSize) {
    d1fc:	0f 93       	push	r16
    d1fe:	1f 93       	push	r17
    d200:	cf 93       	push	r28
    d202:	df 93       	push	r29
    d204:	8c 01       	movw	r16, r24
    d206:	eb 01       	movw	r28, r22
    uint16_t crc;

    crc = calculateCRC(FrameBuf, FrameBufSize);
    d208:	da df       	rcall	.-76     	; 0xd1be <calculateCRC>

    uint8_t crcLb = crc & 0xFF;
    uint8_t crcHb = crc >> 8;


    FrameBuf[FrameBufSize] = crcLb;
    d20a:	c0 0f       	add	r28, r16
    d20c:	d1 1f       	adc	r29, r17
    d20e:	88 83       	st	Y, r24
    FrameBuf[FrameBufSize + 1] = crcHb;
    d210:	99 83       	std	Y+1, r25	; 0x01
}
    d212:	df 91       	pop	r29
    d214:	cf 91       	pop	r28
    d216:	1f 91       	pop	r17
    d218:	0f 91       	pop	r16
    d21a:	08 95       	ret

0000d21c <ISO15693CheckCRC>:

bool ISO15693CheckCRC(void *FrameBuf, uint16_t FrameBufSize) {
    d21c:	0f 93       	push	r16
    d21e:	1f 93       	push	r17
    d220:	cf 93       	push	r28
    d222:	df 93       	push	r29
    d224:	8c 01       	movw	r16, r24
    d226:	eb 01       	movw	r28, r22
    uint16_t crc;
    uint8_t *DataPtr = (uint8_t *)FrameBuf;

    crc = calculateCRC(DataPtr, FrameBufSize);
    d228:	ca df       	rcall	.-108    	; 0xd1be <calculateCRC>

    uint8_t crcLb = crc & 0xFF;
    uint8_t crcHb = crc >> 8;

    return (DataPtr[FrameBufSize] == crcLb && DataPtr[FrameBufSize + 1] == crcHb);
    d22a:	c0 0f       	add	r28, r16
    d22c:	d1 1f       	adc	r29, r17
    d22e:	28 81       	ld	r18, Y
    d230:	28 13       	cpse	r18, r24
    d232:	03 c0       	rjmp	.+6      	; 0xd23a <ISO15693CheckCRC+0x1e>
    d234:	81 e0       	ldi	r24, 0x01	; 1
    d236:	29 81       	ldd	r18, Y+1	; 0x01
    d238:	29 13       	cpse	r18, r25
    d23a:	80 e0       	ldi	r24, 0x00	; 0
}
    d23c:	81 70       	andi	r24, 0x01	; 1
    d23e:	df 91       	pop	r29
    d240:	cf 91       	pop	r28
    d242:	1f 91       	pop	r17
    d244:	0f 91       	pop	r16
    d246:	08 95       	ret

0000d248 <ISO15693PrepareFrame>:
 *  - false: Request is not addressed to us
 *           Frame is not valid because it's too short or CRC is wrong
 *
 * Authors: ceres-c & MrMoDDoM
 */
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI) {
    d248:	ef 92       	push	r14
    d24a:	0f 93       	push	r16
    d24c:	1f 93       	push	r17
    d24e:	cf 93       	push	r28
    d250:	df 93       	push	r29
    d252:	dc 01       	movw	r26, r24
    d254:	fa 01       	movw	r30, r20
    d256:	e8 01       	movw	r28, r16
    /* following declarations are not dependent on addressed/unaddressed state */
    FrameStruct -> Flags        = &FrameBuf[ISO15693_ADDR_FLAGS];
    d258:	80 83       	st	Z, r24
    d25a:	91 83       	std	Z+1, r25	; 0x01
    FrameStruct -> Command      = &FrameBuf[ISO15693_REQ_ADDR_CMD];
    d25c:	01 96       	adiw	r24, 0x01	; 1
    d25e:	82 83       	std	Z+2, r24	; 0x02
    d260:	93 83       	std	Z+3, r25	; 0x03

    if (!(FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_INVENTORY)) { /* if inventory flag is not set */
    d262:	8c 91       	ld	r24, X
    d264:	82 fd       	sbrc	r24, 2
    d266:	09 c0       	rjmp	.+18     	; 0xd27a <ISO15693PrepareFrame+0x32>
        FrameStruct -> Addressed = (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_ADDRESS); /* check for addressed flag */
    d268:	85 fb       	bst	r24, 5
    d26a:	88 27       	eor	r24, r24
    d26c:	80 f9       	bld	r24, 0
    d26e:	87 83       	std	Z+7, r24	; 0x07
        FrameStruct -> Selected  = (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_SELECT);  /* check for selected flag */
    d270:	8c 91       	ld	r24, X
    d272:	82 95       	swap	r24
    d274:	81 70       	andi	r24, 0x01	; 1
    d276:	80 87       	std	Z+8, r24	; 0x08
    d278:	02 c0       	rjmp	.+4      	; 0xd27e <ISO15693PrepareFrame+0x36>
    } else { /* otherwise always false */
        FrameStruct -> Addressed = false;
    d27a:	17 82       	std	Z+7, r1	; 0x07
        FrameStruct -> Selected  = false;
    d27c:	10 86       	std	Z+8, r1	; 0x08
    }

    if (FrameStruct -> Addressed)
    d27e:	37 81       	ldd	r19, Z+7	; 0x07
        /* UID sits between CMD and PARAM */
        FrameStruct -> Parameters = &FrameBuf[ISO15693_REQ_ADDR_PARAM + ISO15693_GENERIC_UID_SIZE];
    d280:	cd 01       	movw	r24, r26
    } else { /* otherwise always false */
        FrameStruct -> Addressed = false;
        FrameStruct -> Selected  = false;
    }

    if (FrameStruct -> Addressed)
    d282:	33 23       	and	r19, r19
    d284:	11 f0       	breq	.+4      	; 0xd28a <ISO15693PrepareFrame+0x42>
        /* UID sits between CMD and PARAM */
        FrameStruct -> Parameters = &FrameBuf[ISO15693_REQ_ADDR_PARAM + ISO15693_GENERIC_UID_SIZE];
    d286:	0a 96       	adiw	r24, 0x0a	; 10
    d288:	01 c0       	rjmp	.+2      	; 0xd28c <ISO15693PrepareFrame+0x44>
    else
        FrameStruct -> Parameters = &FrameBuf[ISO15693_REQ_ADDR_PARAM];
    d28a:	02 96       	adiw	r24, 0x02	; 2
    d28c:	84 83       	std	Z+4, r24	; 0x04
    d28e:	95 83       	std	Z+5, r25	; 0x05

    if ((*FrameStruct -> Command) >= 0xA0) {  /* if command is Custom or  Proprietary */
    d290:	11 96       	adiw	r26, 0x01	; 1
    d292:	8c 91       	ld	r24, X
    d294:	11 97       	sbiw	r26, 0x01	; 1
    d296:	80 3a       	cpi	r24, 0xA0	; 160
    d298:	40 f0       	brcs	.+16     	; 0xd2aa <ISO15693PrepareFrame+0x62>
        /* then between CMD and UID is placed another byte which is IC Mfg Code, but we don't need it */
        if (FrameBuf[ISO15693_REQ_ADDR_PARAM] != MyUid[1])
    d29a:	12 96       	adiw	r26, 0x02	; 2
    d29c:	9c 91       	ld	r25, X
    d29e:	12 97       	sbiw	r26, 0x02	; 2
    d2a0:	89 81       	ldd	r24, Y+1	; 0x01
    d2a2:	98 17       	cp	r25, r24
    d2a4:	61 f0       	breq	.+24     	; 0xd2be <ISO15693PrepareFrame+0x76>
            /* if IC Mfg Code is different from our Mfg code (2nd byte of UID), then don't respond */
            return false;
    d2a6:	80 e0       	ldi	r24, 0x00	; 0
    d2a8:	4a c0       	rjmp	.+148    	; 0xd33e <ISO15693PrepareFrame+0xf6>
        FrameStruct -> Parameters += 0x01;
    } else if (((*FrameStruct -> Command) == ISO15693_CMD_INVENTORY) && (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_AFI)) { /* or if it is Inventory with AFI flag set */
    d2aa:	81 30       	cpi	r24, 0x01	; 1
    d2ac:	69 f4       	brne	.+26     	; 0xd2c8 <ISO15693PrepareFrame+0x80>
    d2ae:	8c 91       	ld	r24, X
    d2b0:	84 ff       	sbrs	r24, 4
    d2b2:	0a c0       	rjmp	.+20     	; 0xd2c8 <ISO15693PrepareFrame+0x80>
        /* then between CMD and UID is placed another byte which is requested AFI, but we don't need it */
        if (FrameBuf[ISO15693_REQ_ADDR_PARAM] != MyAFI)
    d2b4:	12 96       	adiw	r26, 0x02	; 2
    d2b6:	8c 91       	ld	r24, X
    d2b8:	12 97       	sbiw	r26, 0x02	; 2
    d2ba:	8e 11       	cpse	r24, r14
    d2bc:	f4 cf       	rjmp	.-24     	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
    if ((*FrameStruct -> Command) >= 0xA0) {  /* if command is Custom or  Proprietary */
        /* then between CMD and UID is placed another byte which is IC Mfg Code, but we don't need it */
        if (FrameBuf[ISO15693_REQ_ADDR_PARAM] != MyUid[1])
            /* if IC Mfg Code is different from our Mfg code (2nd byte of UID), then don't respond */
            return false;
        FrameStruct -> Parameters += 0x01;
    d2be:	84 81       	ldd	r24, Z+4	; 0x04
    d2c0:	95 81       	ldd	r25, Z+5	; 0x05
    d2c2:	01 96       	adiw	r24, 0x01	; 1
    d2c4:	84 83       	std	Z+4, r24	; 0x04
    d2c6:	95 83       	std	Z+5, r25	; 0x05
            /* if requested AFI is different from our current one, then don't respond */
            return false;
        FrameStruct -> Parameters += 0x01;
    }

    FrameStruct -> ParamLen = FrameBuf + (FrameBytes - ISO15693_CRC16_SIZE) - (FrameStruct -> Parameters);
    d2c8:	44 81       	ldd	r20, Z+4	; 0x04
    d2ca:	55 81       	ldd	r21, Z+5	; 0x05
    d2cc:	62 50       	subi	r22, 0x02	; 2
    d2ce:	71 09       	sbc	r23, r1
    d2d0:	a6 0f       	add	r26, r22
    d2d2:	b7 1f       	adc	r27, r23
    d2d4:	a4 1b       	sub	r26, r20
    d2d6:	b5 0b       	sbc	r27, r21
    d2d8:	a6 83       	std	Z+6, r26	; 0x06

    /*                                                  The UID, if present, always sits right befoore the parameters */
    if (FrameStruct -> Addressed && !ISO15693CompareUid(FrameStruct -> Parameters - ISO15693_GENERIC_UID_SIZE, MyUid)) {
    d2da:	33 23       	and	r19, r19
    d2dc:	49 f1       	breq	.+82     	; 0xd330 <ISO15693PrepareFrame+0xe8>
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    d2de:	da 01       	movw	r26, r20
    d2e0:	18 97       	sbiw	r26, 0x08	; 8
    d2e2:	9c 91       	ld	r25, X
    d2e4:	8f 81       	ldd	r24, Y+7	; 0x07
    d2e6:	98 13       	cpse	r25, r24
    d2e8:	de cf       	rjmp	.-68     	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
            && (Uid1[1] == Uid2[6])
    d2ea:	11 96       	adiw	r26, 0x01	; 1
    d2ec:	9c 91       	ld	r25, X
    d2ee:	8e 81       	ldd	r24, Y+6	; 0x06
    d2f0:	98 13       	cpse	r25, r24
    d2f2:	d9 cf       	rjmp	.-78     	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
            && (Uid1[2] == Uid2[5])
    d2f4:	11 96       	adiw	r26, 0x01	; 1
    d2f6:	9c 91       	ld	r25, X
    d2f8:	8d 81       	ldd	r24, Y+5	; 0x05
    d2fa:	98 13       	cpse	r25, r24
    d2fc:	d4 cf       	rjmp	.-88     	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
            && (Uid1[3] == Uid2[4])
    d2fe:	11 96       	adiw	r26, 0x01	; 1
    d300:	9c 91       	ld	r25, X
    d302:	8c 81       	ldd	r24, Y+4	; 0x04
    d304:	98 13       	cpse	r25, r24
    d306:	cf cf       	rjmp	.-98     	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
            && (Uid1[4] == Uid2[3])
    d308:	11 96       	adiw	r26, 0x01	; 1
    d30a:	9c 91       	ld	r25, X
    d30c:	8b 81       	ldd	r24, Y+3	; 0x03
    d30e:	98 13       	cpse	r25, r24
    d310:	ca cf       	rjmp	.-108    	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
            && (Uid1[5] == Uid2[2])
    d312:	11 96       	adiw	r26, 0x01	; 1
    d314:	9c 91       	ld	r25, X
    d316:	8a 81       	ldd	r24, Y+2	; 0x02
    d318:	98 13       	cpse	r25, r24
    d31a:	c5 cf       	rjmp	.-118    	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
            && (Uid1[6] == Uid2[1])
    d31c:	11 96       	adiw	r26, 0x01	; 1
    d31e:	9c 91       	ld	r25, X
    d320:	89 81       	ldd	r24, Y+1	; 0x01
    d322:	98 13       	cpse	r25, r24
    d324:	c0 cf       	rjmp	.-128    	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
            && (Uid1[7] == Uid2[0])) {
    d326:	11 96       	adiw	r26, 0x01	; 1
    d328:	9c 91       	ld	r25, X
    d32a:	88 81       	ld	r24, Y
    d32c:	98 13       	cpse	r25, r24
    d32e:	bb cf       	rjmp	.-138    	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
        /* addressed request but we're not the addressee */
        return false;
    } else if (FrameStruct -> Selected && !IsSelected) {
    d330:	80 85       	ldd	r24, Z+8	; 0x08
    d332:	88 23       	and	r24, r24
    d334:	19 f0       	breq	.+6      	; 0xd33c <ISO15693PrepareFrame+0xf4>
    d336:	21 11       	cpse	r18, r1
    d338:	02 c0       	rjmp	.+4      	; 0xd33e <ISO15693PrepareFrame+0xf6>
    d33a:	b5 cf       	rjmp	.-150    	; 0xd2a6 <ISO15693PrepareFrame+0x5e>
        /* selected request but we're not in selected state */
        return false;
    } else {
        return true;
    d33c:	81 e0       	ldi	r24, 0x01	; 1
    }
}
    d33e:	df 91       	pop	r29
    d340:	cf 91       	pop	r28
    d342:	1f 91       	pop	r17
    d344:	0f 91       	pop	r16
    d346:	ef 90       	pop	r14
    d348:	08 95       	ret

0000d34a <ISO15693AntiColl>:
 * Authors: ceres-c
 *
 * TODO:
 *  - Implement 16 slots mode (still, it seems to work as it is, even for 16 slots mode ._.)
 */
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid) {
    d34a:	ef 92       	push	r14
    d34c:	ff 92       	push	r15
    d34e:	1f 93       	push	r17
    d350:	cf 93       	push	r28
    d352:	df 93       	push	r29
    d354:	cd b7       	in	r28, 0x3d	; 61
    d356:	de b7       	in	r29, 0x3e	; 62
    d358:	28 97       	sbiw	r28, 0x08	; 8
    d35a:	cd bf       	out	0x3d, r28	; 61
    d35c:	de bf       	out	0x3e, r29	; 62
    d35e:	f9 01       	movw	r30, r18
    }
}

INLINE
void ISO15693CopyUid(uint8_t *DstUid, uint8_t *SrcUid) {
    DstUid[0] = SrcUid[7];
    d360:	87 81       	ldd	r24, Z+7	; 0x07
    d362:	89 83       	std	Y+1, r24	; 0x01
    DstUid[1] = SrcUid[6];
    d364:	86 81       	ldd	r24, Z+6	; 0x06
    d366:	8a 83       	std	Y+2, r24	; 0x02
    DstUid[2] = SrcUid[5];
    d368:	85 81       	ldd	r24, Z+5	; 0x05
    d36a:	8b 83       	std	Y+3, r24	; 0x03
    DstUid[3] = SrcUid[4];
    d36c:	84 81       	ldd	r24, Z+4	; 0x04
    d36e:	8c 83       	std	Y+4, r24	; 0x04
    DstUid[4] = SrcUid[3];
    d370:	83 81       	ldd	r24, Z+3	; 0x03
    d372:	8d 83       	std	Y+5, r24	; 0x05
    DstUid[5] = SrcUid[2];
    d374:	82 81       	ldd	r24, Z+2	; 0x02
    d376:	8e 83       	std	Y+6, r24	; 0x06
    DstUid[6] = SrcUid[1];
    d378:	81 81       	ldd	r24, Z+1	; 0x01
    d37a:	8f 83       	std	Y+7, r24	; 0x07
    DstUid[7] = SrcUid[0];
    d37c:	80 81       	ld	r24, Z
    d37e:	88 87       	std	Y+8, r24	; 0x08
    uint8_t CurrentUID[ ISO15693_GENERIC_UID_SIZE ]; /* Holds the UID flipped */
    ISO15693CopyUid(CurrentUID, MyUid);

    uint8_t MaskLenght = *FrameStruct -> Parameters; /* First byte of parameters is mask lenght... */
    d380:	da 01       	movw	r26, r20
    d382:	14 96       	adiw	r26, 0x04	; 4
    d384:	ed 91       	ld	r30, X+
    d386:	fc 91       	ld	r31, X
    d388:	15 97       	sbiw	r26, 0x05	; 5
    d38a:	21 91       	ld	r18, Z+
    uint8_t *MaskValue = FrameStruct -> Parameters + 1; /* ... then the mask itself begins */
    uint8_t BytesNum = MaskLenght / 8; /* Gets the number of full bytes in mask */
    d38c:	82 2f       	mov	r24, r18
    d38e:	86 95       	lsr	r24
    d390:	86 95       	lsr	r24
    d392:	86 95       	lsr	r24
    d394:	ae 01       	movw	r20, r28
    d396:	4f 5f       	subi	r20, 0xFF	; 255
    d398:	5f 4f       	sbci	r21, 0xFF	; 255
    d39a:	7a 01       	movw	r14, r20
    d39c:	af 01       	movw	r20, r30
    uint8_t BitsNum = MaskLenght % 8; /* Gets the number of spare bits */

    uint8_t B; /* B stands for Bytes and will be our reference point (I know, terrible name, I'm sorry) */
    /* Compare the full bytes in mask with UID */
    for (B = 0; B < BytesNum; B++) {
    d39e:	90 e0       	ldi	r25, 0x00	; 0
    d3a0:	b7 01       	movw	r22, r14
    d3a2:	98 17       	cp	r25, r24
    d3a4:	51 f0       	breq	.+20     	; 0xd3ba <ISO15693AntiColl+0x70>
        if (CurrentUID[B] != MaskValue[B])
    d3a6:	d7 01       	movw	r26, r14
    d3a8:	1d 91       	ld	r17, X+
    d3aa:	7d 01       	movw	r14, r26
    d3ac:	da 01       	movw	r26, r20
    d3ae:	3d 91       	ld	r19, X+
    d3b0:	ad 01       	movw	r20, r26
    d3b2:	13 13       	cpse	r17, r19
    d3b4:	18 c0       	rjmp	.+48     	; 0xd3e6 <ISO15693AntiColl+0x9c>
    uint8_t BytesNum = MaskLenght / 8; /* Gets the number of full bytes in mask */
    uint8_t BitsNum = MaskLenght % 8; /* Gets the number of spare bits */

    uint8_t B; /* B stands for Bytes and will be our reference point (I know, terrible name, I'm sorry) */
    /* Compare the full bytes in mask with UID */
    for (B = 0; B < BytesNum; B++) {
    d3b6:	9f 5f       	subi	r25, 0xFF	; 255
    d3b8:	f4 cf       	rjmp	.-24     	; 0xd3a2 <ISO15693AntiColl+0x58>
    }
    /* Once we got here, B points for sure to the last byte of the mask, the one composed of spare bits */

    /* Compare spare bits in mask with bits of UID */
    uint8_t BitsMask = ((1 << BitsNum) - 1); /* (1 << Bits) = 00010000   ->   (1 << Bits) - 1 = 00001111 */
    if ((MaskValue[B] & BitsMask) != (CurrentUID[B] & BitsMask)) {
    d3ba:	89 2f       	mov	r24, r25
    d3bc:	90 e0       	ldi	r25, 0x00	; 0
    d3be:	e8 0f       	add	r30, r24
    d3c0:	f9 1f       	adc	r31, r25
    d3c2:	db 01       	movw	r26, r22
    d3c4:	a8 0f       	add	r26, r24
    d3c6:	b9 1f       	adc	r27, r25
    d3c8:	30 81       	ld	r19, Z
    d3ca:	8c 91       	ld	r24, X
    d3cc:	38 27       	eor	r19, r24
    d3ce:	27 70       	andi	r18, 0x07	; 7
    d3d0:	81 e0       	ldi	r24, 0x01	; 1
    d3d2:	90 e0       	ldi	r25, 0x00	; 0
    d3d4:	01 c0       	rjmp	.+2      	; 0xd3d8 <ISO15693AntiColl+0x8e>
    d3d6:	88 0f       	add	r24, r24
    d3d8:	2a 95       	dec	r18
    d3da:	ea f7       	brpl	.-6      	; 0xd3d6 <ISO15693AntiColl+0x8c>
    d3dc:	81 50       	subi	r24, 0x01	; 1
    d3de:	93 2f       	mov	r25, r19
    d3e0:	98 23       	and	r25, r24
    d3e2:	81 e0       	ldi	r24, 0x01	; 1
    d3e4:	09 f0       	breq	.+2      	; 0xd3e8 <ISO15693AntiColl+0x9e>

    uint8_t B; /* B stands for Bytes and will be our reference point (I know, terrible name, I'm sorry) */
    /* Compare the full bytes in mask with UID */
    for (B = 0; B < BytesNum; B++) {
        if (CurrentUID[B] != MaskValue[B])
            return false; /* UID different */
    d3e6:	80 e0       	ldi	r24, 0x00	; 0
         */
        return false;
    }

    return true;
}
    d3e8:	28 96       	adiw	r28, 0x08	; 8
    d3ea:	cd bf       	out	0x3d, r28	; 61
    d3ec:	de bf       	out	0x3e, r29	; 62
    d3ee:	df 91       	pop	r29
    d3f0:	cf 91       	pop	r28
    d3f2:	1f 91       	pop	r17
    d3f4:	ff 90       	pop	r15
    d3f6:	ef 90       	pop	r14
    d3f8:	08 95       	ret

0000d3fa <EM4233AppInit>:
uint8_t MyAFI; /* This variable holds current tag's AFI (is used in inventory) */

CurrentFrame FrameInfo;

void EM4233AppInit(void) {
    State = STATE_READY;
    d3fa:	10 92 b3 2e 	sts	0x2EB3, r1	; 0x802eb3 <State>

    FrameInfo.Flags         = NULL;
    d3fe:	ee e3       	ldi	r30, 0x3E	; 62
    d400:	f4 e3       	ldi	r31, 0x34	; 52
    d402:	10 82       	st	Z, r1
    d404:	11 82       	std	Z+1, r1	; 0x01
    FrameInfo.Command       = NULL;
    d406:	12 82       	std	Z+2, r1	; 0x02
    d408:	13 82       	std	Z+3, r1	; 0x03
    FrameInfo.Parameters    = NULL;
    d40a:	14 82       	std	Z+4, r1	; 0x04
    d40c:	15 82       	std	Z+5, r1	; 0x05
    FrameInfo.ParamLen      = 0;
    d40e:	16 82       	std	Z+6, r1	; 0x06
    FrameInfo.Addressed     = false;
    d410:	17 82       	std	Z+7, r1	; 0x07
    FrameInfo.Selected      = false;
    d412:	10 86       	std	Z+8, r1	; 0x08
    loggedIn = false;
    d414:	10 92 47 34 	sts	0x3447, r1	; 0x803447 <loggedIn>
    MemoryReadBlock(&MyAFI, EM4233_MEM_AFI_ADDRESS, 1);
    d418:	41 e0       	ldi	r20, 0x01	; 1
    d41a:	50 e0       	ldi	r21, 0x00	; 0
    d41c:	68 ed       	ldi	r22, 0xD8	; 216
    d41e:	70 e0       	ldi	r23, 0x00	; 0
    d420:	8d e3       	ldi	r24, 0x3D	; 61
    d422:	94 e3       	ldi	r25, 0x34	; 52
    d424:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

0000d428 <EM4233AppReset>:

}

void EM4233AppReset(void) {
    State = STATE_READY;
    d428:	10 92 b3 2e 	sts	0x2EB3, r1	; 0x802eb3 <State>

    FrameInfo.Flags         = NULL;
    d42c:	ee e3       	ldi	r30, 0x3E	; 62
    d42e:	f4 e3       	ldi	r31, 0x34	; 52
    d430:	10 82       	st	Z, r1
    d432:	11 82       	std	Z+1, r1	; 0x01
    FrameInfo.Command       = NULL;
    d434:	12 82       	std	Z+2, r1	; 0x02
    d436:	13 82       	std	Z+3, r1	; 0x03
    FrameInfo.Parameters    = NULL;
    d438:	14 82       	std	Z+4, r1	; 0x04
    d43a:	15 82       	std	Z+5, r1	; 0x05
    FrameInfo.ParamLen      = 0;
    d43c:	16 82       	std	Z+6, r1	; 0x06
    FrameInfo.Addressed     = false;
    d43e:	17 82       	std	Z+7, r1	; 0x07
    FrameInfo.Selected      = false;
    d440:	10 86       	std	Z+8, r1	; 0x08
    loggedIn = false;
    d442:	10 92 47 34 	sts	0x3447, r1	; 0x803447 <loggedIn>
    d446:	08 95       	ret

0000d448 <EM4233AppTask>:
    d448:	08 95       	ret

0000d44a <EM4233AppTick>:

void EM4233AppTask(void) {

}

void EM4233AppTick(void) {
    d44a:	08 95       	ret

0000d44c <EM4233_Lock_Block>:

}

uint16_t EM4233_Lock_Block(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d44c:	ff 92       	push	r15
    d44e:	0f 93       	push	r16
    d450:	1f 93       	push	r17
    d452:	cf 93       	push	r28
    d454:	df 93       	push	r29
    d456:	1f 92       	push	r1
    d458:	cd b7       	in	r28, 0x3d	; 61
    d45a:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t BlockAddress = *FrameInfo.Parameters;
    d45c:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d460:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d464:	f0 80       	ld	r15, Z
    uint8_t LockStatus = 0;
    d466:	19 82       	std	Y+1, r1	; 0x01

    MemoryReadBlock(&LockStatus, (EM4233_MEM_LSM_ADDRESS + BlockAddress), 1);
    d468:	0f 2d       	mov	r16, r15
    d46a:	10 e0       	ldi	r17, 0x00	; 0
    d46c:	00 52       	subi	r16, 0x20	; 32
    d46e:	1f 4f       	sbci	r17, 0xFF	; 255
    d470:	41 e0       	ldi	r20, 0x01	; 1
    d472:	50 e0       	ldi	r21, 0x00	; 0
    d474:	b8 01       	movw	r22, r16
    d476:	ce 01       	movw	r24, r28
    d478:	01 96       	adiw	r24, 0x01	; 1
    d47a:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

    if (FrameInfo.ParamLen != 1)
    d47e:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d482:	81 30       	cpi	r24, 0x01	; 1
    d484:	71 f4       	brne	.+28     	; 0xd4a2 <EM4233_Lock_Block+0x56>
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    if (BlockAddress > EM4233_NUMBER_OF_BLCKS) {
    d486:	94 e3       	ldi	r25, 0x34	; 52
    d488:	9f 15       	cp	r25, r15
    d48a:	58 f0       	brcs	.+22     	; 0xd4a2 <EM4233_Lock_Block+0x56>
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
        return ResponseByteCount; /* malformed: trying to lock a non-existing block */
    }


    if (LockStatus > ISO15693_MASK_UNLOCKED) { /* LockStatus 0x00 represent unlocked block, greater values are different kind of locks */
    d48c:	99 81       	ldd	r25, Y+1	; 0x01
    d48e:	91 11       	cpse	r25, r1
    d490:	08 c0       	rjmp	.+16     	; 0xd4a2 <EM4233_Lock_Block+0x56>
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    } else {
        LockStatus |= ISO15693_MASK_USER_LOCK;
    d492:	89 83       	std	Y+1, r24	; 0x01
        MemoryWriteBlock(&LockStatus, (EM4233_MEM_LSM_ADDRESS + BlockAddress), 1); /* write user lock in memory */
    d494:	41 e0       	ldi	r20, 0x01	; 1
    d496:	50 e0       	ldi	r21, 0x00	; 0
    d498:	b8 01       	movw	r22, r16
    d49a:	ce 01       	movw	r24, r28
    d49c:	01 96       	adiw	r24, 0x01	; 1
    d49e:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
        // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    }

    return ResponseByteCount;
}
    d4a2:	80 e0       	ldi	r24, 0x00	; 0
    d4a4:	90 e0       	ldi	r25, 0x00	; 0
    d4a6:	0f 90       	pop	r0
    d4a8:	df 91       	pop	r29
    d4aa:	cf 91       	pop	r28
    d4ac:	1f 91       	pop	r17
    d4ae:	0f 91       	pop	r16
    d4b0:	ff 90       	pop	r15
    d4b2:	08 95       	ret

0000d4b4 <EM4233_Write_Single>:

uint16_t EM4233_Write_Single(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d4b4:	cf 92       	push	r12
    d4b6:	df 92       	push	r13
    d4b8:	ef 92       	push	r14
    d4ba:	ff 92       	push	r15
    d4bc:	0f 93       	push	r16
    d4be:	1f 93       	push	r17
    d4c0:	cf 93       	push	r28
    d4c2:	df 93       	push	r29
    d4c4:	1f 92       	push	r1
    d4c6:	cd b7       	in	r28, 0x3d	; 61
    d4c8:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t BlockAddress = *FrameInfo.Parameters;
    d4ca:	c0 90 42 34 	lds	r12, 0x3442	; 0x803442 <FrameInfo+0x4>
    d4ce:	d0 90 43 34 	lds	r13, 0x3443	; 0x803443 <FrameInfo+0x5>
    d4d2:	f6 01       	movw	r30, r12
    d4d4:	00 81       	ld	r16, Z
    uint8_t *Dataptr = FrameInfo.Parameters + 0x01; /* Data to write begins on 2nd byte of the frame received by the reader */
    uint8_t LockStatus = 0;
    d4d6:	19 82       	std	Y+1, r1	; 0x01

    if (FrameInfo.ParamLen != 5)
    d4d8:	20 91 44 34 	lds	r18, 0x3444	; 0x803444 <FrameInfo+0x6>
    d4dc:	25 30       	cpi	r18, 0x05	; 5
    d4de:	19 f0       	breq	.+6      	; 0xd4e6 <EM4233_Write_Single+0x32>
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */
    d4e0:	80 e0       	ldi	r24, 0x00	; 0
    d4e2:	90 e0       	ldi	r25, 0x00	; 0
    d4e4:	1f c0       	rjmp	.+62     	; 0xd524 <EM4233_Write_Single+0x70>

    if (BlockAddress > EM4233_NUMBER_OF_BLCKS) {
    d4e6:	05 33       	cpi	r16, 0x35	; 53
    d4e8:	d8 f7       	brcc	.-10     	; 0xd4e0 <EM4233_Write_Single+0x2c>
    d4ea:	7c 01       	movw	r14, r24
        // FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_OPT_NOT_SUPP;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
        return ResponseByteCount; /* malformed: trying to write in a non-existing block */
    }

    MemoryReadBlock(&LockStatus, (EM4233_MEM_LSM_ADDRESS + BlockAddress), 1);
    d4ec:	10 e0       	ldi	r17, 0x00	; 0
    d4ee:	b8 01       	movw	r22, r16
    d4f0:	60 52       	subi	r22, 0x20	; 32
    d4f2:	7f 4f       	sbci	r23, 0xFF	; 255
    d4f4:	41 e0       	ldi	r20, 0x01	; 1
    d4f6:	50 e0       	ldi	r21, 0x00	; 0
    d4f8:	ce 01       	movw	r24, r28
    d4fa:	01 96       	adiw	r24, 0x01	; 1
    d4fc:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

    if (LockStatus & ISO15693_MASK_FACTORY_LOCK) {
        // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
        // FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_OPT_NOT_SUPP;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway - probably: no factory lock exists? */
    } else if (LockStatus & ISO15693_MASK_USER_LOCK) {
    d500:	89 81       	ldd	r24, Y+1	; 0x01
    d502:	83 70       	andi	r24, 0x03	; 3
    d504:	69 f7       	brne	.-38     	; 0xd4e0 <EM4233_Write_Single+0x2c>
        // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
        // FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_BLK_CHG_LKD;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    } else {
        MemoryWriteBlock(Dataptr, BlockAddress * EM4233_BYTES_PER_BLCK, EM4233_BYTES_PER_BLCK);
    d506:	b8 01       	movw	r22, r16
    d508:	66 0f       	add	r22, r22
    d50a:	77 1f       	adc	r23, r23
    d50c:	66 0f       	add	r22, r22
    d50e:	77 1f       	adc	r23, r23
    d510:	44 e0       	ldi	r20, 0x04	; 4
    d512:	50 e0       	ldi	r21, 0x00	; 0
    d514:	c6 01       	movw	r24, r12
    d516:	01 96       	adiw	r24, 0x01	; 1
    d518:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
        FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    d51c:	f7 01       	movw	r30, r14
    d51e:	10 82       	st	Z, r1
        ResponseByteCount += 1;
    d520:	81 e0       	ldi	r24, 0x01	; 1
    d522:	90 e0       	ldi	r25, 0x00	; 0
    }

    return ResponseByteCount;
}
    d524:	0f 90       	pop	r0
    d526:	df 91       	pop	r29
    d528:	cf 91       	pop	r28
    d52a:	1f 91       	pop	r17
    d52c:	0f 91       	pop	r16
    d52e:	ff 90       	pop	r15
    d530:	ef 90       	pop	r14
    d532:	df 90       	pop	r13
    d534:	cf 90       	pop	r12
    d536:	08 95       	ret

0000d538 <EM4233_Read_Single>:

uint16_t EM4233_Read_Single(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d538:	cf 92       	push	r12
    d53a:	df 92       	push	r13
    d53c:	ef 92       	push	r14
    d53e:	ff 92       	push	r15
    d540:	0f 93       	push	r16
    d542:	1f 93       	push	r17
    d544:	cf 93       	push	r28
    d546:	df 93       	push	r29
    d548:	1f 92       	push	r1
    d54a:	cd b7       	in	r28, 0x3d	; 61
    d54c:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    d54e:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d552:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d556:	60 81       	ld	r22, Z
    uint8_t LockStatus = 0;
    d558:	19 82       	std	Y+1, r1	; 0x01

    if (FrameInfo.ParamLen != 1)
    d55a:	f0 90 44 34 	lds	r15, 0x3444	; 0x803444 <FrameInfo+0x6>
    d55e:	21 e0       	ldi	r18, 0x01	; 1
    d560:	f2 12       	cpse	r15, r18
    d562:	44 c0       	rjmp	.+136    	; 0xd5ec <EM4233_Read_Single+0xb4>
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    if (BlockAddress >= EM4233_NUMBER_OF_BLCKS) { /* check if the reader is requesting a sector out of bound */
    d564:	64 33       	cpi	r22, 0x34	; 52
    d566:	58 f0       	brcs	.+22     	; 0xd57e <EM4233_Read_Single+0x46>
        if (FrameInfo.Addressed) { /* If the request is addressed */
    d568:	20 91 45 34 	lds	r18, 0x3445	; 0x803445 <FrameInfo+0x7>
    d56c:	22 23       	and	r18, r18
    d56e:	f1 f1       	breq	.+124    	; 0xd5ec <EM4233_Read_Single+0xb4>
            FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d570:	fc 01       	movw	r30, r24
    d572:	f0 82       	st	Z, r15
            FrameBuf[ISO15693_RES_ADDR_PARAM] = 0x0F; /* Magic number from real tag */
    d574:	2f e0       	ldi	r18, 0x0F	; 15
    d576:	21 83       	std	Z+1, r18	; 0x01
            ResponseByteCount += 2; /* Copied this behaviour from real tag, not specified in ISO documents */
    d578:	82 e0       	ldi	r24, 0x02	; 2
    d57a:	90 e0       	ldi	r25, 0x00	; 0
    d57c:	39 c0       	rjmp	.+114    	; 0xd5f0 <EM4233_Read_Single+0xb8>
    d57e:	8c 01       	movw	r16, r24
        return ResponseByteCount; /* If not addressed real tag does not respond */
    }

    FramePtr = 1;

    if (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_OPTION) { /* request with option flag set */
    d580:	fc 01       	movw	r30, r24
    d582:	80 81       	ld	r24, Z
    d584:	c6 2e       	mov	r12, r22
    d586:	d1 2c       	mov	r13, r1
    d588:	86 ff       	sbrs	r24, 6
    d58a:	1b c0       	rjmp	.+54     	; 0xd5c2 <EM4233_Read_Single+0x8a>
        MemoryReadBlock(&LockStatus, (EM4233_MEM_LSM_ADDRESS + BlockAddress), 1);
    d58c:	41 e0       	ldi	r20, 0x01	; 1
    d58e:	50 e0       	ldi	r21, 0x00	; 0
    d590:	b6 01       	movw	r22, r12
    d592:	60 52       	subi	r22, 0x20	; 32
    d594:	7f 4f       	sbci	r23, 0xFF	; 255
    d596:	ce 01       	movw	r24, r28
    d598:	01 96       	adiw	r24, 0x01	; 1
    d59a:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
        if (LockStatus & ISO15693_MASK_FACTORY_LOCK)  { /* tests if the n-th bit of the factory bitmask if set to 1 */
    d59e:	89 81       	ldd	r24, Y+1	; 0x01
    d5a0:	81 ff       	sbrs	r24, 1
    d5a2:	04 c0       	rjmp	.+8      	; 0xd5ac <EM4233_Read_Single+0x74>
            FrameBuf[FramePtr] = ISO15693_MASK_FACTORY_LOCK; /* return bit 1 set as 1 (factory locked) */
    d5a4:	82 e0       	ldi	r24, 0x02	; 2
    d5a6:	f8 01       	movw	r30, r16
    d5a8:	81 83       	std	Z+1, r24	; 0x01
    d5aa:	05 c0       	rjmp	.+10     	; 0xd5b6 <EM4233_Read_Single+0x7e>
        } else if (LockStatus & ISO15693_MASK_USER_LOCK) { /* tests if the n-th bit of the user bitmask if set to 1 */
            FrameBuf[FramePtr] = ISO15693_MASK_USER_LOCK; /* return bit 0 set as 1 (user locked) */
    d5ac:	f8 01       	movw	r30, r16

    if (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_OPTION) { /* request with option flag set */
        MemoryReadBlock(&LockStatus, (EM4233_MEM_LSM_ADDRESS + BlockAddress), 1);
        if (LockStatus & ISO15693_MASK_FACTORY_LOCK)  { /* tests if the n-th bit of the factory bitmask if set to 1 */
            FrameBuf[FramePtr] = ISO15693_MASK_FACTORY_LOCK; /* return bit 1 set as 1 (factory locked) */
        } else if (LockStatus & ISO15693_MASK_USER_LOCK) { /* tests if the n-th bit of the user bitmask if set to 1 */
    d5ae:	80 ff       	sbrs	r24, 0
    d5b0:	06 c0       	rjmp	.+12     	; 0xd5be <EM4233_Read_Single+0x86>
            FrameBuf[FramePtr] = ISO15693_MASK_USER_LOCK; /* return bit 0 set as 1 (user locked) */
    d5b2:	f1 82       	std	Z+1, r15	; 0x01
        } else
            FrameBuf[FramePtr] = ISO15693_MASK_UNLOCKED; /* return lock status 00 (unlocked) */
        FramePtr += 1; /* block's data from byte 2 */
    d5b4:	82 e0       	ldi	r24, 0x02	; 2
        ResponseByteCount += 1;
    d5b6:	ee 24       	eor	r14, r14
    d5b8:	e3 94       	inc	r14
    d5ba:	f1 2c       	mov	r15, r1
    d5bc:	05 c0       	rjmp	.+10     	; 0xd5c8 <EM4233_Read_Single+0x90>
        if (LockStatus & ISO15693_MASK_FACTORY_LOCK)  { /* tests if the n-th bit of the factory bitmask if set to 1 */
            FrameBuf[FramePtr] = ISO15693_MASK_FACTORY_LOCK; /* return bit 1 set as 1 (factory locked) */
        } else if (LockStatus & ISO15693_MASK_USER_LOCK) { /* tests if the n-th bit of the user bitmask if set to 1 */
            FrameBuf[FramePtr] = ISO15693_MASK_USER_LOCK; /* return bit 0 set as 1 (user locked) */
        } else
            FrameBuf[FramePtr] = ISO15693_MASK_UNLOCKED; /* return lock status 00 (unlocked) */
    d5be:	11 82       	std	Z+1, r1	; 0x01
    d5c0:	f9 cf       	rjmp	.-14     	; 0xd5b4 <EM4233_Read_Single+0x7c>
            ResponseByteCount += 2; /* Copied this behaviour from real tag, not specified in ISO documents */
        }
        return ResponseByteCount; /* If not addressed real tag does not respond */
    }

    FramePtr = 1;
    d5c2:	81 e0       	ldi	r24, 0x01	; 1

    return ResponseByteCount;
}

uint16_t EM4233_Read_Single(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    d5c4:	e1 2c       	mov	r14, r1
    d5c6:	f1 2c       	mov	r15, r1
            FrameBuf[FramePtr] = ISO15693_MASK_UNLOCKED; /* return lock status 00 (unlocked) */
        FramePtr += 1; /* block's data from byte 2 */
        ResponseByteCount += 1;
    }

    MemoryReadBlock(&FrameBuf[FramePtr], BlockAddress * EM4233_BYTES_PER_BLCK, EM4233_BYTES_PER_BLCK);
    d5c8:	b6 01       	movw	r22, r12
    d5ca:	66 0f       	add	r22, r22
    d5cc:	77 1f       	adc	r23, r23
    d5ce:	66 0f       	add	r22, r22
    d5d0:	77 1f       	adc	r23, r23
    d5d2:	44 e0       	ldi	r20, 0x04	; 4
    d5d4:	50 e0       	ldi	r21, 0x00	; 0
    d5d6:	98 01       	movw	r18, r16
    d5d8:	28 0f       	add	r18, r24
    d5da:	31 1d       	adc	r19, r1
    d5dc:	c9 01       	movw	r24, r18
    d5de:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    ResponseByteCount += 4;

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    d5e2:	f8 01       	movw	r30, r16
    d5e4:	10 82       	st	Z, r1
    ResponseByteCount += 1;

    return ResponseByteCount;
    d5e6:	c7 01       	movw	r24, r14
    d5e8:	05 96       	adiw	r24, 0x05	; 5
    d5ea:	02 c0       	rjmp	.+4      	; 0xd5f0 <EM4233_Read_Single+0xb8>
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    uint8_t LockStatus = 0;

    if (FrameInfo.ParamLen != 1)
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */
    d5ec:	80 e0       	ldi	r24, 0x00	; 0
    d5ee:	90 e0       	ldi	r25, 0x00	; 0

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;

    return ResponseByteCount;
}
    d5f0:	0f 90       	pop	r0
    d5f2:	df 91       	pop	r29
    d5f4:	cf 91       	pop	r28
    d5f6:	1f 91       	pop	r17
    d5f8:	0f 91       	pop	r16
    d5fa:	ff 90       	pop	r15
    d5fc:	ef 90       	pop	r14
    d5fe:	df 90       	pop	r13
    d600:	cf 90       	pop	r12
    d602:	08 95       	ret

0000d604 <EM4233_Read_Multiple>:

uint16_t EM4233_Read_Multiple(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d604:	3f 92       	push	r3
    d606:	4f 92       	push	r4
    d608:	5f 92       	push	r5
    d60a:	6f 92       	push	r6
    d60c:	7f 92       	push	r7
    d60e:	8f 92       	push	r8
    d610:	9f 92       	push	r9
    d612:	af 92       	push	r10
    d614:	bf 92       	push	r11
    d616:	cf 92       	push	r12
    d618:	df 92       	push	r13
    d61a:	ef 92       	push	r14
    d61c:	ff 92       	push	r15
    d61e:	0f 93       	push	r16
    d620:	1f 93       	push	r17
    d622:	cf 93       	push	r28
    d624:	df 93       	push	r29
    d626:	cd b7       	in	r28, 0x3d	; 61
    d628:	de b7       	in	r29, 0x3e	; 62
    d62a:	8c 01       	movw	r16, r24
    }

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;
    return ResponseByteCount;
}
    d62c:	4d b6       	in	r4, 0x3d	; 61
    d62e:	5e b6       	in	r5, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01; /* according to ISO standard, we have to read 0x08 blocks if we get 0x07 in request */

    if (FrameInfo.ParamLen != 2)
    d630:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d634:	82 30       	cpi	r24, 0x02	; 2
    d636:	09 f0       	breq	.+2      	; 0xd63a <EM4233_Read_Multiple+0x36>
    d638:	a3 c0       	rjmp	.+326    	; 0xd780 <EM4233_Read_Multiple+0x17c>
}

uint16_t EM4233_Read_Multiple(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    d63a:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d63e:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d642:	90 81       	ld	r25, Z
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01; /* according to ISO standard, we have to read 0x08 blocks if we get 0x07 in request */

    if (FrameInfo.ParamLen != 2)
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    if (BlockAddress >= EM4233_NUMBER_OF_BLCKS) { /* the reader is requesting a block out of bound */
    d644:	94 33       	cpi	r25, 0x34	; 52
    d646:	70 f0       	brcs	.+28     	; 0xd664 <EM4233_Read_Multiple+0x60>
        if (FrameInfo.Addressed) { /* If the request is addressed */
    d648:	80 91 45 34 	lds	r24, 0x3445	; 0x803445 <FrameInfo+0x7>
    d64c:	88 23       	and	r24, r24
    d64e:	09 f4       	brne	.+2      	; 0xd652 <EM4233_Read_Multiple+0x4e>
    d650:	97 c0       	rjmp	.+302    	; 0xd780 <EM4233_Read_Multiple+0x17c>
            FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    d652:	81 e0       	ldi	r24, 0x01	; 1
    d654:	d8 01       	movw	r26, r16
    d656:	8c 93       	st	X, r24
            FrameBuf[ISO15693_RES_ADDR_PARAM] = 0x0F; /* Magic number from real tag */
    d658:	8f e0       	ldi	r24, 0x0F	; 15
    d65a:	11 96       	adiw	r26, 0x01	; 1
    d65c:	8c 93       	st	X, r24
            ResponseByteCount += 2; /* Copied this behaviour from real tag, not specified in ISO documents */
    d65e:	82 e0       	ldi	r24, 0x02	; 2
    d660:	90 e0       	ldi	r25, 0x00	; 0
    d662:	90 c0       	rjmp	.+288    	; 0xd784 <EM4233_Read_Multiple+0x180>

uint16_t EM4233_Read_Multiple(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01; /* according to ISO standard, we have to read 0x08 blocks if we get 0x07 in request */
    d664:	81 80       	ldd	r8, Z+1	; 0x01
    d666:	33 24       	eor	r3, r3
    d668:	33 94       	inc	r3
    d66a:	38 0c       	add	r3, r8
            FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
            FrameBuf[ISO15693_RES_ADDR_PARAM] = 0x0F; /* Magic number from real tag */
            ResponseByteCount += 2; /* Copied this behaviour from real tag, not specified in ISO documents */
        }
        return ResponseByteCount; /* If not addressed real tag does not respond */
    } else if ((BlockAddress + BlocksNumber) >= EM4233_NUMBER_OF_BLCKS) { /* last block is out of bound */
    d66c:	c9 2e       	mov	r12, r25
    d66e:	d1 2c       	mov	r13, r1
    d670:	96 01       	movw	r18, r12
    d672:	23 0d       	add	r18, r3
    d674:	31 1d       	adc	r19, r1
    d676:	24 33       	cpi	r18, 0x34	; 52
    d678:	31 05       	cpc	r19, r1
    d67a:	1c f0       	brlt	.+6      	; 0xd682 <EM4233_Read_Multiple+0x7e>
        BlocksNumber = EM4233_NUMBER_OF_BLCKS - BlockAddress; /* we read up to latest block, as real tag does */
    d67c:	84 e3       	ldi	r24, 0x34	; 52
    d67e:	38 2e       	mov	r3, r24
    d680:	39 1a       	sub	r3, r25
    }

    FramePtr = 1; /* start of response data  */

    if ((FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_OPTION) == 0) {   /* blocks' lock status is not requested */
    d682:	f8 01       	movw	r30, r16
    d684:	80 81       	ld	r24, Z
    d686:	83 2c       	mov	r8, r3
    d688:	91 2c       	mov	r9, r1
    d68a:	86 fd       	sbrc	r24, 6
    d68c:	0f c0       	rjmp	.+30     	; 0xd6ac <EM4233_Read_Multiple+0xa8>
        /* read data straight into frame */
        MemoryReadBlock(&FrameBuf[FramePtr], BlockAddress * EM4233_BYTES_PER_BLCK, BlocksNumber * EM4233_BYTES_PER_BLCK);
    d68e:	88 0c       	add	r8, r8
    d690:	99 1c       	adc	r9, r9
    d692:	88 0c       	add	r8, r8
    d694:	99 1c       	adc	r9, r9
    d696:	b6 01       	movw	r22, r12
    d698:	66 0f       	add	r22, r22
    d69a:	77 1f       	adc	r23, r23
    d69c:	66 0f       	add	r22, r22
    d69e:	77 1f       	adc	r23, r23
    d6a0:	a4 01       	movw	r20, r8
    d6a2:	c8 01       	movw	r24, r16
    d6a4:	01 96       	adiw	r24, 0x01	; 1
    d6a6:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    d6aa:	65 c0       	rjmp	.+202    	; 0xd776 <EM4233_Read_Multiple+0x172>
        ResponseByteCount += BlocksNumber * EM4233_BYTES_PER_BLCK;

    } else { /* we have to slice blocks' data with lock statuses */
    d6ac:	6d b6       	in	r6, 0x3d	; 61
    d6ae:	7e b6       	in	r7, 0x3e	; 62
        uint8_t DataBuffer[ BlocksNumber * EM4233_BYTES_PER_BLCK ]; /* a temporary vector with blocks' content */
    d6b0:	a4 01       	movw	r20, r8
    d6b2:	44 0f       	add	r20, r20
    d6b4:	55 1f       	adc	r21, r21
    d6b6:	44 0f       	add	r20, r20
    d6b8:	55 1f       	adc	r21, r21
    d6ba:	8d b7       	in	r24, 0x3d	; 61
    d6bc:	9e b7       	in	r25, 0x3e	; 62
    d6be:	84 1b       	sub	r24, r20
    d6c0:	95 0b       	sbc	r25, r21
    d6c2:	8d bf       	out	0x3d, r24	; 61
    d6c4:	9e bf       	out	0x3e, r25	; 62
    d6c6:	ad b7       	in	r26, 0x3d	; 61
    d6c8:	be b7       	in	r27, 0x3e	; 62
    d6ca:	11 96       	adiw	r26, 0x01	; 1
    d6cc:	7d 01       	movw	r14, r26
        uint8_t LockStatusBuffer[ BlocksNumber ]; /* a temporary vector with blocks' lock status */
    d6ce:	ed b7       	in	r30, 0x3d	; 61
    d6d0:	fe b7       	in	r31, 0x3e	; 62
    d6d2:	e8 19       	sub	r30, r8
    d6d4:	f9 09       	sbc	r31, r9
    d6d6:	ed bf       	out	0x3d, r30	; 61
    d6d8:	fe bf       	out	0x3e, r31	; 62
    d6da:	8d b7       	in	r24, 0x3d	; 61
    d6dc:	9e b7       	in	r25, 0x3e	; 62
    d6de:	01 96       	adiw	r24, 0x01	; 1
    d6e0:	5c 01       	movw	r10, r24

        /* read all at once to reduce timing issues */
        MemoryReadBlock(&DataBuffer, BlockAddress * EM4233_BYTES_PER_BLCK, BlocksNumber * EM4233_BYTES_PER_BLCK);
    d6e2:	b6 01       	movw	r22, r12
    d6e4:	66 0f       	add	r22, r22
    d6e6:	77 1f       	adc	r23, r23
    d6e8:	66 0f       	add	r22, r22
    d6ea:	77 1f       	adc	r23, r23
    d6ec:	cd 01       	movw	r24, r26
    d6ee:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
        MemoryReadBlock(&LockStatusBuffer, EM4233_MEM_LSM_ADDRESS + BlockAddress, BlocksNumber);
    d6f2:	b6 01       	movw	r22, r12
    d6f4:	60 52       	subi	r22, 0x20	; 32
    d6f6:	7f 4f       	sbci	r23, 0xFF	; 255
    d6f8:	a4 01       	movw	r20, r8
    d6fa:	c5 01       	movw	r24, r10
    d6fc:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    d700:	f7 01       	movw	r30, r14

        for (uint8_t block = 0; block < BlocksNumber; block++) { /* we cycle through the blocks */
    d702:	90 e0       	ldi	r25, 0x00	; 0
        return ResponseByteCount; /* If not addressed real tag does not respond */
    } else if ((BlockAddress + BlocksNumber) >= EM4233_NUMBER_OF_BLCKS) { /* last block is out of bound */
        BlocksNumber = EM4233_NUMBER_OF_BLCKS - BlockAddress; /* we read up to latest block, as real tag does */
    }

    FramePtr = 1; /* start of response data  */
    d704:	81 e0       	ldi	r24, 0x01	; 1

        /* read all at once to reduce timing issues */
        MemoryReadBlock(&DataBuffer, BlockAddress * EM4233_BYTES_PER_BLCK, BlocksNumber * EM4233_BYTES_PER_BLCK);
        MemoryReadBlock(&LockStatusBuffer, EM4233_MEM_LSM_ADDRESS + BlockAddress, BlocksNumber);

        for (uint8_t block = 0; block < BlocksNumber; block++) { /* we cycle through the blocks */
    d706:	39 16       	cp	r3, r25
    d708:	81 f1       	breq	.+96     	; 0xd76a <EM4233_Read_Multiple+0x166>

            /* add lock status */
            FrameBuf[FramePtr++] = LockStatusBuffer[block]; /* Byte in dump equals to the byte that has to be sent */
    d70a:	d5 01       	movw	r26, r10
    d70c:	4d 91       	ld	r20, X+
    d70e:	5d 01       	movw	r10, r26
    d710:	98 01       	movw	r18, r16
    d712:	28 0f       	add	r18, r24
    d714:	31 1d       	adc	r19, r1
    d716:	d9 01       	movw	r26, r18
    d718:	4c 93       	st	X, r20
            /* I.E. We store 0x01 to identify user lock, which is the same as what ISO15693 enforce */
            ResponseByteCount += 1;

            /* then copy block's data */
            FrameBuf[FramePtr++] = DataBuffer[block * EM4233_BYTES_PER_BLCK + 0];
    d71a:	21 e0       	ldi	r18, 0x01	; 1
    d71c:	28 0f       	add	r18, r24
    d71e:	a8 01       	movw	r20, r16
    d720:	42 0f       	add	r20, r18
    d722:	51 1d       	adc	r21, r1
    d724:	9a 01       	movw	r18, r20
    d726:	40 81       	ld	r20, Z
    d728:	d9 01       	movw	r26, r18
    d72a:	4c 93       	st	X, r20
            FrameBuf[FramePtr++] = DataBuffer[block * EM4233_BYTES_PER_BLCK + 1];
    d72c:	22 e0       	ldi	r18, 0x02	; 2
    d72e:	28 0f       	add	r18, r24
    d730:	a8 01       	movw	r20, r16
    d732:	42 0f       	add	r20, r18
    d734:	51 1d       	adc	r21, r1
    d736:	9a 01       	movw	r18, r20
    d738:	41 81       	ldd	r20, Z+1	; 0x01
    d73a:	d9 01       	movw	r26, r18
    d73c:	4c 93       	st	X, r20
            FrameBuf[FramePtr++] = DataBuffer[block * EM4233_BYTES_PER_BLCK + 2];
    d73e:	23 e0       	ldi	r18, 0x03	; 3
    d740:	28 0f       	add	r18, r24
    d742:	a8 01       	movw	r20, r16
    d744:	42 0f       	add	r20, r18
    d746:	51 1d       	adc	r21, r1
    d748:	9a 01       	movw	r18, r20
    d74a:	42 81       	ldd	r20, Z+2	; 0x02
    d74c:	d9 01       	movw	r26, r18
    d74e:	4c 93       	st	X, r20
            FrameBuf[FramePtr++] = DataBuffer[block * EM4233_BYTES_PER_BLCK + 3];
    d750:	24 e0       	ldi	r18, 0x04	; 4
    d752:	28 0f       	add	r18, r24
    d754:	a8 01       	movw	r20, r16
    d756:	42 0f       	add	r20, r18
    d758:	51 1d       	adc	r21, r1
    d75a:	9a 01       	movw	r18, r20
    d75c:	8b 5f       	subi	r24, 0xFB	; 251
    d75e:	43 81       	ldd	r20, Z+3	; 0x03
    d760:	d9 01       	movw	r26, r18
    d762:	4c 93       	st	X, r20

        /* read all at once to reduce timing issues */
        MemoryReadBlock(&DataBuffer, BlockAddress * EM4233_BYTES_PER_BLCK, BlocksNumber * EM4233_BYTES_PER_BLCK);
        MemoryReadBlock(&LockStatusBuffer, EM4233_MEM_LSM_ADDRESS + BlockAddress, BlocksNumber);

        for (uint8_t block = 0; block < BlocksNumber; block++) { /* we cycle through the blocks */
    d764:	9f 5f       	subi	r25, 0xFF	; 255
    d766:	34 96       	adiw	r30, 0x04	; 4
    d768:	ce cf       	rjmp	.-100    	; 0xd706 <EM4233_Read_Multiple+0x102>
    d76a:	b5 e0       	ldi	r27, 0x05	; 5
    d76c:	3b 9e       	mul	r3, r27
    d76e:	40 01       	movw	r8, r0
    d770:	11 24       	eor	r1, r1
    d772:	6d be       	out	0x3d, r6	; 61
    d774:	7e be       	out	0x3e, r7	; 62
            FrameBuf[FramePtr++] = DataBuffer[block * EM4233_BYTES_PER_BLCK + 3];
            ResponseByteCount += EM4233_BYTES_PER_BLCK;
        }
    }

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    d776:	f8 01       	movw	r30, r16
    d778:	10 82       	st	Z, r1
    ResponseByteCount += 1;
    return ResponseByteCount;
    d77a:	c4 01       	movw	r24, r8
    d77c:	01 96       	adiw	r24, 0x01	; 1
    d77e:	02 c0       	rjmp	.+4      	; 0xd784 <EM4233_Read_Multiple+0x180>
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01; /* according to ISO standard, we have to read 0x08 blocks if we get 0x07 in request */

    if (FrameInfo.ParamLen != 2)
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */
    d780:	80 e0       	ldi	r24, 0x00	; 0
    d782:	90 e0       	ldi	r25, 0x00	; 0
    }

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;
    return ResponseByteCount;
}
    d784:	4d be       	out	0x3d, r4	; 61
    d786:	5e be       	out	0x3e, r5	; 62
    d788:	df 91       	pop	r29
    d78a:	cf 91       	pop	r28
    d78c:	1f 91       	pop	r17
    d78e:	0f 91       	pop	r16
    d790:	ff 90       	pop	r15
    d792:	ef 90       	pop	r14
    d794:	df 90       	pop	r13
    d796:	cf 90       	pop	r12
    d798:	bf 90       	pop	r11
    d79a:	af 90       	pop	r10
    d79c:	9f 90       	pop	r9
    d79e:	8f 90       	pop	r8
    d7a0:	7f 90       	pop	r7
    d7a2:	6f 90       	pop	r6
    d7a4:	5f 90       	pop	r5
    d7a6:	4f 90       	pop	r4
    d7a8:	3f 90       	pop	r3
    d7aa:	08 95       	ret

0000d7ac <EM4233_Write_AFI>:

uint16_t EM4233_Write_AFI(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d7ac:	cf 93       	push	r28
    d7ae:	df 93       	push	r29
    d7b0:	1f 92       	push	r1
    d7b2:	1f 92       	push	r1
    d7b4:	cd b7       	in	r28, 0x3d	; 61
    d7b6:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t AFI = FrameInfo.Parameters[0];
    d7b8:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d7bc:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d7c0:	80 81       	ld	r24, Z
    d7c2:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t LockStatus = 0;
    d7c4:	19 82       	std	Y+1, r1	; 0x01

    if (FrameInfo.ParamLen != 1)
    d7c6:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d7ca:	81 30       	cpi	r24, 0x01	; 1
    d7cc:	b1 f4       	brne	.+44     	; 0xd7fa <EM4233_Write_AFI+0x4e>
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    MemoryReadBlock(&LockStatus, EM4233_MEM_INF_ADDRESS, 1);
    d7ce:	41 e0       	ldi	r20, 0x01	; 1
    d7d0:	50 e0       	ldi	r21, 0x00	; 0
    d7d2:	6c ed       	ldi	r22, 0xDC	; 220
    d7d4:	70 e0       	ldi	r23, 0x00	; 0
    d7d6:	ce 01       	movw	r24, r28
    d7d8:	01 96       	adiw	r24, 0x01	; 1
    d7da:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

    if (LockStatus & EM4233_MASK_AFI_STATUS) {  /* The AFI is locked */
    d7de:	89 81       	ldd	r24, Y+1	; 0x01
    d7e0:	80 fd       	sbrc	r24, 0
    d7e2:	0b c0       	rjmp	.+22     	; 0xd7fa <EM4233_Write_AFI+0x4e>
        // ResponseByteCount += 2;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
        return ResponseByteCount;
    }

    MemoryWriteBlock(&AFI, EM4233_MEM_AFI_ADDRESS, 1); /* Actually write new AFI */
    d7e4:	41 e0       	ldi	r20, 0x01	; 1
    d7e6:	50 e0       	ldi	r21, 0x00	; 0
    d7e8:	68 ed       	ldi	r22, 0xD8	; 216
    d7ea:	70 e0       	ldi	r23, 0x00	; 0
    d7ec:	ce 01       	movw	r24, r28
    d7ee:	02 96       	adiw	r24, 0x02	; 2
    d7f0:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
    MyAFI = AFI; /* And update global variable */
    d7f4:	8a 81       	ldd	r24, Y+2	; 0x02
    d7f6:	80 93 3d 34 	sts	0x343D, r24	; 0x80343d <MyAFI>

    // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    // ResponseByteCount += 1;
    ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    return ResponseByteCount;
}
    d7fa:	80 e0       	ldi	r24, 0x00	; 0
    d7fc:	90 e0       	ldi	r25, 0x00	; 0
    d7fe:	0f 90       	pop	r0
    d800:	0f 90       	pop	r0
    d802:	df 91       	pop	r29
    d804:	cf 91       	pop	r28
    d806:	08 95       	ret

0000d808 <EM4233_Lock_AFI>:

uint16_t EM4233_Lock_AFI(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d808:	cf 93       	push	r28
    d80a:	df 93       	push	r29
    d80c:	1f 92       	push	r1
    d80e:	cd b7       	in	r28, 0x3d	; 61
    d810:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t LockStatus = 0;
    d812:	19 82       	std	Y+1, r1	; 0x01

    if (FrameInfo.ParamLen != 0)
    d814:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d818:	81 11       	cpse	r24, r1
    d81a:	15 c0       	rjmp	.+42     	; 0xd846 <EM4233_Lock_AFI+0x3e>
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    MemoryReadBlock(&LockStatus, EM4233_MEM_INF_ADDRESS, 1);
    d81c:	41 e0       	ldi	r20, 0x01	; 1
    d81e:	50 e0       	ldi	r21, 0x00	; 0
    d820:	6c ed       	ldi	r22, 0xDC	; 220
    d822:	70 e0       	ldi	r23, 0x00	; 0
    d824:	ce 01       	movw	r24, r28
    d826:	01 96       	adiw	r24, 0x01	; 1
    d828:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

    if (LockStatus & EM4233_MASK_AFI_STATUS) {  /* The AFI is already locked */
    d82c:	89 81       	ldd	r24, Y+1	; 0x01
    d82e:	80 fd       	sbrc	r24, 0
    d830:	0a c0       	rjmp	.+20     	; 0xd846 <EM4233_Lock_AFI+0x3e>
        // ResponseByteCount += 2;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
        return ResponseByteCount;
    }

    LockStatus |= EM4233_MASK_AFI_STATUS;
    d832:	81 60       	ori	r24, 0x01	; 1
    d834:	89 83       	std	Y+1, r24	; 0x01

    MemoryWriteBlock(&LockStatus, EM4233_MEM_INF_ADDRESS, 1); /* Write in info bits AFI lockdown */
    d836:	41 e0       	ldi	r20, 0x01	; 1
    d838:	50 e0       	ldi	r21, 0x00	; 0
    d83a:	6c ed       	ldi	r22, 0xDC	; 220
    d83c:	70 e0       	ldi	r23, 0x00	; 0
    d83e:	ce 01       	movw	r24, r28
    d840:	01 96       	adiw	r24, 0x01	; 1
    d842:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>

    // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    // ResponseByteCount += 1;
    ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    return ResponseByteCount;
}
    d846:	80 e0       	ldi	r24, 0x00	; 0
    d848:	90 e0       	ldi	r25, 0x00	; 0
    d84a:	0f 90       	pop	r0
    d84c:	df 91       	pop	r29
    d84e:	cf 91       	pop	r28
    d850:	08 95       	ret

0000d852 <EM4233_Write_DSFID>:

uint16_t EM4233_Write_DSFID(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d852:	cf 93       	push	r28
    d854:	df 93       	push	r29
    d856:	1f 92       	push	r1
    d858:	1f 92       	push	r1
    d85a:	cd b7       	in	r28, 0x3d	; 61
    d85c:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t DSFID = FrameInfo.Parameters[0];
    d85e:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d862:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d866:	80 81       	ld	r24, Z
    d868:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t LockStatus = 0;
    d86a:	19 82       	std	Y+1, r1	; 0x01

    if (FrameInfo.ParamLen != 1)
    d86c:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d870:	81 30       	cpi	r24, 0x01	; 1
    d872:	99 f4       	brne	.+38     	; 0xd89a <EM4233_Write_DSFID+0x48>
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    MemoryReadBlock(&LockStatus, EM4233_MEM_INF_ADDRESS, 1);
    d874:	41 e0       	ldi	r20, 0x01	; 1
    d876:	50 e0       	ldi	r21, 0x00	; 0
    d878:	6c ed       	ldi	r22, 0xDC	; 220
    d87a:	70 e0       	ldi	r23, 0x00	; 0
    d87c:	ce 01       	movw	r24, r28
    d87e:	01 96       	adiw	r24, 0x01	; 1
    d880:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

    if (LockStatus & EM4233_MASK_DSFID_STATUS) {  /* The DSFID is locked */
    d884:	89 81       	ldd	r24, Y+1	; 0x01
    d886:	81 fd       	sbrc	r24, 1
    d888:	08 c0       	rjmp	.+16     	; 0xd89a <EM4233_Write_DSFID+0x48>
        // ResponseByteCount += 2;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
        return ResponseByteCount;
    }

    MemoryWriteBlock(&DSFID, EM4233_MEM_DSFID_ADDRESS, 1); /* Actually write new DSFID */
    d88a:	41 e0       	ldi	r20, 0x01	; 1
    d88c:	50 e0       	ldi	r21, 0x00	; 0
    d88e:	69 ed       	ldi	r22, 0xD9	; 217
    d890:	70 e0       	ldi	r23, 0x00	; 0
    d892:	ce 01       	movw	r24, r28
    d894:	02 96       	adiw	r24, 0x02	; 2
    d896:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>

    // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    // ResponseByteCount += 1;
    ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    return ResponseByteCount;
}
    d89a:	80 e0       	ldi	r24, 0x00	; 0
    d89c:	90 e0       	ldi	r25, 0x00	; 0
    d89e:	0f 90       	pop	r0
    d8a0:	0f 90       	pop	r0
    d8a2:	df 91       	pop	r29
    d8a4:	cf 91       	pop	r28
    d8a6:	08 95       	ret

0000d8a8 <EM4233_Lock_DSFID>:

uint16_t EM4233_Lock_DSFID(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d8a8:	cf 93       	push	r28
    d8aa:	df 93       	push	r29
    d8ac:	1f 92       	push	r1
    d8ae:	cd b7       	in	r28, 0x3d	; 61
    d8b0:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t LockStatus = 0;
    d8b2:	19 82       	std	Y+1, r1	; 0x01

    if (FrameInfo.ParamLen != 0)
    d8b4:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    d8b8:	81 11       	cpse	r24, r1
    d8ba:	15 c0       	rjmp	.+42     	; 0xd8e6 <EM4233_Lock_DSFID+0x3e>
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    MemoryReadBlock(&LockStatus, EM4233_MEM_INF_ADDRESS, 1);
    d8bc:	41 e0       	ldi	r20, 0x01	; 1
    d8be:	50 e0       	ldi	r21, 0x00	; 0
    d8c0:	6c ed       	ldi	r22, 0xDC	; 220
    d8c2:	70 e0       	ldi	r23, 0x00	; 0
    d8c4:	ce 01       	movw	r24, r28
    d8c6:	01 96       	adiw	r24, 0x01	; 1
    d8c8:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

    if (LockStatus & EM4233_MASK_DSFID_STATUS) {  /* The DSFID is already locked */
    d8cc:	89 81       	ldd	r24, Y+1	; 0x01
    d8ce:	81 fd       	sbrc	r24, 1
    d8d0:	0a c0       	rjmp	.+20     	; 0xd8e6 <EM4233_Lock_DSFID+0x3e>
        // ResponseByteCount += 2;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
        return ResponseByteCount;
    }

    LockStatus |= EM4233_MASK_DSFID_STATUS;
    d8d2:	82 60       	ori	r24, 0x02	; 2
    d8d4:	89 83       	std	Y+1, r24	; 0x01

    MemoryWriteBlock(&LockStatus, EM4233_MEM_INF_ADDRESS, 1); /* Write in info bits DSFID lockdown */
    d8d6:	41 e0       	ldi	r20, 0x01	; 1
    d8d8:	50 e0       	ldi	r21, 0x00	; 0
    d8da:	6c ed       	ldi	r22, 0xDC	; 220
    d8dc:	70 e0       	ldi	r23, 0x00	; 0
    d8de:	ce 01       	movw	r24, r28
    d8e0:	01 96       	adiw	r24, 0x01	; 1
    d8e2:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>

    // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    // ResponseByteCount += 1;
    ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    return ResponseByteCount;
}
    d8e6:	80 e0       	ldi	r24, 0x00	; 0
    d8e8:	90 e0       	ldi	r25, 0x00	; 0
    d8ea:	0f 90       	pop	r0
    d8ec:	df 91       	pop	r29
    d8ee:	cf 91       	pop	r28
    d8f0:	08 95       	ret

0000d8f2 <EM4233_Get_Multi_Block_Sec_Stat>:
    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;
    return ResponseByteCount;
}

uint16_t EM4233_Get_Multi_Block_Sec_Stat(uint8_t *FrameBuf, uint16_t FrameBytes) {
    d8f2:	0f 93       	push	r16
    d8f4:	1f 93       	push	r17
    d8f6:	cf 93       	push	r28
    d8f8:	df 93       	push	r29
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01;

    if (FrameInfo.ParamLen != 2)
    d8fa:	20 91 44 34 	lds	r18, 0x3444	; 0x803444 <FrameInfo+0x6>
    d8fe:	22 30       	cpi	r18, 0x02	; 2
    d900:	01 f5       	brne	.+64     	; 0xd942 <EM4233_Get_Multi_Block_Sec_Stat+0x50>
}

uint16_t EM4233_Get_Multi_Block_Sec_Stat(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    d902:	e0 91 42 34 	lds	r30, 0x3442	; 0x803442 <FrameInfo+0x4>
    d906:	f0 91 43 34 	lds	r31, 0x3443	; 0x803443 <FrameInfo+0x5>
    d90a:	20 81       	ld	r18, Z
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01;

    if (FrameInfo.ParamLen != 2)
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

    if (BlockAddress > EM4233_NUMBER_OF_BLCKS) { /* the reader is requesting a starting block out of bound */
    d90c:	25 33       	cpi	r18, 0x35	; 53
    d90e:	c8 f4       	brcc	.+50     	; 0xd942 <EM4233_Get_Multi_Block_Sec_Stat+0x50>

uint16_t EM4233_Get_Multi_Block_Sec_Stat(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01;
    d910:	c1 81       	ldd	r28, Z+1	; 0x01
    d912:	cf 5f       	subi	r28, 0xFF	; 255
    if (BlockAddress > EM4233_NUMBER_OF_BLCKS) { /* the reader is requesting a starting block out of bound */
        // FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
        // FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_BLK_NOT_AVL;
        ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
        return ResponseByteCount;
    } else if ((BlockAddress + BlocksNumber) >= EM4233_NUMBER_OF_BLCKS) { /* last block is out of bound */
    d914:	62 2f       	mov	r22, r18
    d916:	70 e0       	ldi	r23, 0x00	; 0
    d918:	ab 01       	movw	r20, r22
    d91a:	4c 0f       	add	r20, r28
    d91c:	51 1d       	adc	r21, r1
    d91e:	44 33       	cpi	r20, 0x34	; 52
    d920:	51 05       	cpc	r21, r1
    d922:	14 f0       	brlt	.+4      	; 0xd928 <EM4233_Get_Multi_Block_Sec_Stat+0x36>
        BlocksNumber = EM4233_NUMBER_OF_BLCKS - BlockAddress; /* we read up to latest block, as real tag does */
    d924:	c4 e3       	ldi	r28, 0x34	; 52
    d926:	c2 1b       	sub	r28, r18
    d928:	8c 01       	movw	r16, r24
    }

    FramePtr = 1; /* start of response data  */

    /* read all at once to reduce timing issues */
    MemoryReadBlock(&FrameBuf[FramePtr], EM4233_MEM_LSM_ADDRESS + BlockAddress, BlocksNumber);
    d92a:	d0 e0       	ldi	r29, 0x00	; 0
    d92c:	60 52       	subi	r22, 0x20	; 32
    d92e:	7f 4f       	sbci	r23, 0xFF	; 255
    d930:	ae 01       	movw	r20, r28
    d932:	01 96       	adiw	r24, 0x01	; 1
    d934:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    ResponseByteCount += BlocksNumber;

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    d938:	f8 01       	movw	r30, r16
    d93a:	10 82       	st	Z, r1
    ResponseByteCount += 1;
    return ResponseByteCount;
    d93c:	ce 01       	movw	r24, r28
    d93e:	01 96       	adiw	r24, 0x01	; 1
    d940:	02 c0       	rjmp	.+4      	; 0xd946 <EM4233_Get_Multi_Block_Sec_Stat+0x54>
    uint8_t FramePtr; /* holds the address where block's data will be put */
    uint8_t BlockAddress = FrameInfo.Parameters[0];
    uint8_t BlocksNumber = FrameInfo.Parameters[1] + 0x01;

    if (FrameInfo.ParamLen != 2)
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */
    d942:	80 e0       	ldi	r24, 0x00	; 0
    d944:	90 e0       	ldi	r25, 0x00	; 0
    ResponseByteCount += BlocksNumber;

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;
    return ResponseByteCount;
}
    d946:	df 91       	pop	r29
    d948:	cf 91       	pop	r28
    d94a:	1f 91       	pop	r17
    d94c:	0f 91       	pop	r16
    d94e:	08 95       	ret

0000d950 <EM4233_Select>:

uint16_t EM4233_Select(uint8_t *FrameBuf, uint16_t FrameBytes, uint8_t *Uid) {
    d950:	fc 01       	movw	r30, r24
    d952:	da 01       	movw	r26, r20
bool ISO15693PrepareFrame(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t IsSelected, uint8_t *MyUid, uint8_t MyAFI);
bool ISO15693AntiColl(uint8_t *FrameBuf, uint16_t FrameBytes, CurrentFrame *FrameStruct, uint8_t *MyUid);

INLINE
bool ISO15693CompareUid(uint8_t *Uid1, uint8_t *Uid2) {
    if ((Uid1[0] == Uid2[7])
    d954:	92 81       	ldd	r25, Z+2	; 0x02
    d956:	17 96       	adiw	r26, 0x07	; 7
    d958:	8c 91       	ld	r24, X
    d95a:	17 97       	sbiw	r26, 0x07	; 7
    d95c:	98 13       	cpse	r25, r24
    d95e:	28 c0       	rjmp	.+80     	; 0xd9b0 <EM4233_Select+0x60>
            && (Uid1[1] == Uid2[6])
    d960:	93 81       	ldd	r25, Z+3	; 0x03
    d962:	16 96       	adiw	r26, 0x06	; 6
    d964:	8c 91       	ld	r24, X
    d966:	16 97       	sbiw	r26, 0x06	; 6
    d968:	98 13       	cpse	r25, r24
    d96a:	22 c0       	rjmp	.+68     	; 0xd9b0 <EM4233_Select+0x60>
            && (Uid1[2] == Uid2[5])
    d96c:	94 81       	ldd	r25, Z+4	; 0x04
    d96e:	15 96       	adiw	r26, 0x05	; 5
    d970:	8c 91       	ld	r24, X
    d972:	15 97       	sbiw	r26, 0x05	; 5
    d974:	98 13       	cpse	r25, r24
    d976:	1c c0       	rjmp	.+56     	; 0xd9b0 <EM4233_Select+0x60>
            && (Uid1[3] == Uid2[4])
    d978:	95 81       	ldd	r25, Z+5	; 0x05
    d97a:	14 96       	adiw	r26, 0x04	; 4
    d97c:	8c 91       	ld	r24, X
    d97e:	14 97       	sbiw	r26, 0x04	; 4
    d980:	98 13       	cpse	r25, r24
    d982:	16 c0       	rjmp	.+44     	; 0xd9b0 <EM4233_Select+0x60>
            && (Uid1[4] == Uid2[3])
    d984:	96 81       	ldd	r25, Z+6	; 0x06
    d986:	13 96       	adiw	r26, 0x03	; 3
    d988:	8c 91       	ld	r24, X
    d98a:	13 97       	sbiw	r26, 0x03	; 3
    d98c:	98 13       	cpse	r25, r24
    d98e:	10 c0       	rjmp	.+32     	; 0xd9b0 <EM4233_Select+0x60>
            && (Uid1[5] == Uid2[2])
    d990:	97 81       	ldd	r25, Z+7	; 0x07
    d992:	12 96       	adiw	r26, 0x02	; 2
    d994:	8c 91       	ld	r24, X
    d996:	12 97       	sbiw	r26, 0x02	; 2
    d998:	98 13       	cpse	r25, r24
    d99a:	0a c0       	rjmp	.+20     	; 0xd9b0 <EM4233_Select+0x60>
            && (Uid1[6] == Uid2[1])
    d99c:	90 85       	ldd	r25, Z+8	; 0x08
    d99e:	11 96       	adiw	r26, 0x01	; 1
    d9a0:	8c 91       	ld	r24, X
    d9a2:	11 97       	sbiw	r26, 0x01	; 1
    d9a4:	98 13       	cpse	r25, r24
    d9a6:	04 c0       	rjmp	.+8      	; 0xd9b0 <EM4233_Select+0x60>
            && (Uid1[7] == Uid2[0])) {
    d9a8:	81 e0       	ldi	r24, 0x01	; 1
    d9aa:	21 85       	ldd	r18, Z+9	; 0x09
    d9ac:	9c 91       	ld	r25, X
    d9ae:	29 13       	cpse	r18, r25
        return true;
    } else {
        return false;
    d9b0:	80 e0       	ldi	r24, 0x00	; 0
    }
    */

    bool UidEquals = ISO15693CompareUid(&FrameBuf[ISO15693_REQ_ADDR_PARAM], Uid);

    if (!(FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_ADDRESS) ||
    d9b2:	90 81       	ld	r25, Z
    d9b4:	95 ff       	sbrs	r25, 5
    d9b6:	12 c0       	rjmp	.+36     	; 0xd9dc <EM4233_Select+0x8c>
    d9b8:	94 fd       	sbrc	r25, 4
    d9ba:	10 c0       	rjmp	.+32     	; 0xd9dc <EM4233_Select+0x8c>
            (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_SELECT)
       ) {
        /* tag should remain silent if Select is performed without address flag or with select flag */
        return ISO15693_APP_NO_RESPONSE;
    } else if (!UidEquals) {
    d9bc:	81 11       	cpse	r24, r1
    d9be:	03 c0       	rjmp	.+6      	; 0xd9c6 <EM4233_Select+0x76>
        /* tag should remain silent and reset if Select is performed against another UID,
         * whether our the tag is selected or not
         */
        State = STATE_READY;
    d9c0:	10 92 b3 2e 	sts	0x2EB3, r1	; 0x802eb3 <State>
    d9c4:	0b c0       	rjmp	.+22     	; 0xd9dc <EM4233_Select+0x8c>
        return ISO15693_APP_NO_RESPONSE;
    } else if (State != STATE_SELECTED && UidEquals) {
    d9c6:	80 91 b3 2e 	lds	r24, 0x2EB3	; 0x802eb3 <State>
    d9ca:	81 30       	cpi	r24, 0x01	; 1
    d9cc:	c9 f3       	breq	.-14     	; 0xd9c0 <EM4233_Select+0x70>
        State = STATE_SELECTED;
    d9ce:	81 e0       	ldi	r24, 0x01	; 1
    d9d0:	80 93 b3 2e 	sts	0x2EB3, r24	; 0x802eb3 <State>
        FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    d9d4:	10 82       	st	Z, r1
        ResponseByteCount += 1;
        return ResponseByteCount;
    d9d6:	81 e0       	ldi	r24, 0x01	; 1
    d9d8:	90 e0       	ldi	r25, 0x00	; 0
    d9da:	08 95       	ret

    if (!(FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_ADDRESS) ||
            (FrameBuf[ISO15693_ADDR_FLAGS] & ISO15693_REQ_FLAG_SELECT)
       ) {
        /* tag should remain silent if Select is performed without address flag or with select flag */
        return ISO15693_APP_NO_RESPONSE;
    d9dc:	80 e0       	ldi	r24, 0x00	; 0
    d9de:	90 e0       	ldi	r25, 0x00	; 0
    }

    /* This should never happen (TM), I've added it to shut the compiler up */
    State = STATE_READY;
    return ISO15693_APP_NO_RESPONSE;
}
    d9e0:	08 95       	ret

0000d9e2 <EM4233_Reset_To_Ready>:
        FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_GENERIC;
        ResponseByteCount += 2;
        return ResponseByteCount;
    }
    */
    FrameInfo.Flags         = NULL;
    d9e2:	ee e3       	ldi	r30, 0x3E	; 62
    d9e4:	f4 e3       	ldi	r31, 0x34	; 52
    d9e6:	10 82       	st	Z, r1
    d9e8:	11 82       	std	Z+1, r1	; 0x01
    FrameInfo.Command       = NULL;
    d9ea:	12 82       	std	Z+2, r1	; 0x02
    d9ec:	13 82       	std	Z+3, r1	; 0x03
    FrameInfo.Parameters    = NULL;
    d9ee:	14 82       	std	Z+4, r1	; 0x04
    d9f0:	15 82       	std	Z+5, r1	; 0x05
    FrameInfo.ParamLen      = 0;
    d9f2:	16 82       	std	Z+6, r1	; 0x06
    FrameInfo.Addressed     = false;
    d9f4:	17 82       	std	Z+7, r1	; 0x07
    FrameInfo.Selected      = false;
    d9f6:	10 86       	std	Z+8, r1	; 0x08

    State = STATE_READY;
    d9f8:	10 92 b3 2e 	sts	0x2EB3, r1	; 0x802eb3 <State>

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    d9fc:	fc 01       	movw	r30, r24
    d9fe:	10 82       	st	Z, r1
    ResponseByteCount += 1;
    return ResponseByteCount;
}
    da00:	81 e0       	ldi	r24, 0x01	; 1
    da02:	90 e0       	ldi	r25, 0x00	; 0
    da04:	08 95       	ret

0000da06 <EM4233_Login>:

uint16_t EM4233_Login(uint8_t *FrameBuf, uint16_t FrameBytes) {
    da06:	ff 92       	push	r15
    da08:	0f 93       	push	r16
    da0a:	1f 93       	push	r17
    da0c:	cf 93       	push	r28
    da0e:	df 93       	push	r29
    da10:	00 d0       	rcall	.+0      	; 0xda12 <EM4233_Login+0xc>
    da12:	1f 92       	push	r1
    da14:	cd b7       	in	r28, 0x3d	; 61
    da16:	de b7       	in	r29, 0x3e	; 62
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t Password[4] = { 0 };
    da18:	19 82       	std	Y+1, r1	; 0x01
    da1a:	1a 82       	std	Y+2, r1	; 0x02
    da1c:	1b 82       	std	Y+3, r1	; 0x03
    da1e:	1c 82       	std	Y+4, r1	; 0x04

    if (FrameInfo.ParamLen != 4 || !FrameInfo.Addressed || !(FrameInfo.Selected && State == STATE_SELECTED))
    da20:	20 91 44 34 	lds	r18, 0x3444	; 0x803444 <FrameInfo+0x6>
    da24:	24 30       	cpi	r18, 0x04	; 4
    da26:	49 f5       	brne	.+82     	; 0xda7a <EM4233_Login+0x74>
    da28:	20 91 45 34 	lds	r18, 0x3445	; 0x803445 <FrameInfo+0x7>
    da2c:	22 23       	and	r18, r18
    da2e:	29 f1       	breq	.+74     	; 0xda7a <EM4233_Login+0x74>
    da30:	20 91 46 34 	lds	r18, 0x3446	; 0x803446 <FrameInfo+0x8>
    da34:	22 23       	and	r18, r18
    da36:	09 f1       	breq	.+66     	; 0xda7a <EM4233_Login+0x74>
    da38:	f0 90 b3 2e 	lds	r15, 0x2EB3	; 0x802eb3 <State>
    da3c:	21 e0       	ldi	r18, 0x01	; 1
    da3e:	f2 12       	cpse	r15, r18
    da40:	1c c0       	rjmp	.+56     	; 0xda7a <EM4233_Login+0x74>
    da42:	8c 01       	movw	r16, r24
        /* Malformed: not enough or too much data. Also this command only works in addressed mode */
        return ISO15693_APP_NO_RESPONSE;

    MemoryReadBlock(&Password, EM4233_MEM_PSW_ADDRESS, 4);
    da44:	44 e0       	ldi	r20, 0x04	; 4
    da46:	50 e0       	ldi	r21, 0x00	; 0
    da48:	64 e1       	ldi	r22, 0x14	; 20
    da4a:	71 e0       	ldi	r23, 0x01	; 1
    da4c:	ce 01       	movw	r24, r28
    da4e:	01 96       	adiw	r24, 0x01	; 1
    da50:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>

#ifdef EM4233_LOGIN_YES_CARD
    /* Accept any password from reader as correct one */
    loggedIn = true;
    da54:	f0 92 47 34 	sts	0x3447, r15	; 0x803447 <loggedIn>

    MemoryWriteBlock(FrameInfo.Parameters, EM4233_MEM_PSW_ADDRESS, 4); /* Store password in memory for retrival */
    da58:	44 e0       	ldi	r20, 0x04	; 4
    da5a:	50 e0       	ldi	r21, 0x00	; 0
    da5c:	64 e1       	ldi	r22, 0x14	; 20
    da5e:	71 e0       	ldi	r23, 0x01	; 1
    da60:	80 91 42 34 	lds	r24, 0x3442	; 0x803442 <FrameInfo+0x4>
    da64:	90 91 43 34 	lds	r25, 0x3443	; 0x803443 <FrameInfo+0x5>
    da68:	0e 94 15 12 	call	0x242a	; 0x242a <MemoryWriteBlock>
        return ResponseByteCount;
    }

#endif

    loggedIn = true;
    da6c:	f0 92 47 34 	sts	0x3447, r15	; 0x803447 <loggedIn>

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    da70:	f8 01       	movw	r30, r16
    da72:	10 82       	st	Z, r1
    ResponseByteCount += 1;
    return ResponseByteCount;
    da74:	81 e0       	ldi	r24, 0x01	; 1
    da76:	90 e0       	ldi	r25, 0x00	; 0
    da78:	02 c0       	rjmp	.+4      	; 0xda7e <EM4233_Login+0x78>
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t Password[4] = { 0 };

    if (FrameInfo.ParamLen != 4 || !FrameInfo.Addressed || !(FrameInfo.Selected && State == STATE_SELECTED))
        /* Malformed: not enough or too much data. Also this command only works in addressed mode */
        return ISO15693_APP_NO_RESPONSE;
    da7a:	80 e0       	ldi	r24, 0x00	; 0
    da7c:	90 e0       	ldi	r25, 0x00	; 0
    loggedIn = true;

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;
    return ResponseByteCount;
}
    da7e:	24 96       	adiw	r28, 0x04	; 4
    da80:	cd bf       	out	0x3d, r28	; 61
    da82:	de bf       	out	0x3e, r29	; 62
    da84:	df 91       	pop	r29
    da86:	cf 91       	pop	r28
    da88:	1f 91       	pop	r17
    da8a:	0f 91       	pop	r16
    da8c:	ff 90       	pop	r15
    da8e:	08 95       	ret

0000da90 <EM4233_Auth1>:

uint16_t EM4233_Auth1(uint8_t *FrameBuf, uint16_t FrameBytes) {
    da90:	fc 01       	movw	r30, r24
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    // uint8_t KeyNo = *FrameInfo.Parameters; /* Right now this parameter is unused, but it will be useful */

    if (FrameInfo.ParamLen != 1) /* Malformed: not enough or too much data */
    da92:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    da96:	81 30       	cpi	r24, 0x01	; 1
    da98:	59 f4       	brne	.+22     	; 0xdab0 <EM4233_Auth1+0x20>
        return ISO15693_APP_NO_RESPONSE;

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    da9a:	10 82       	st	Z, r1
#ifdef EM4233_LOGIN_YES_CARD
    /* Will be useful for testing purposes, probably removed in final version */
    FrameBuf[ISO15693_ADDR_FLAGS + 1] = 0x00;
    da9c:	11 82       	std	Z+1, r1	; 0x01
    FrameBuf[ISO15693_ADDR_FLAGS + 2] = 0x00;
    da9e:	12 82       	std	Z+2, r1	; 0x02
    FrameBuf[ISO15693_ADDR_FLAGS + 3] = 0x00;
    daa0:	13 82       	std	Z+3, r1	; 0x03
    FrameBuf[ISO15693_ADDR_FLAGS + 4] = 0x00;
    daa2:	14 82       	std	Z+4, r1	; 0x04
    FrameBuf[ISO15693_ADDR_FLAGS + 5] = 0x00;
    daa4:	15 82       	std	Z+5, r1	; 0x05
    FrameBuf[ISO15693_ADDR_FLAGS + 6] = 0x00;
    daa6:	16 82       	std	Z+6, r1	; 0x06
    FrameBuf[ISO15693_ADDR_FLAGS + 7] = 0x00;
    daa8:	17 82       	std	Z+7, r1	; 0x07
#else
    /* Respond like a real tag */
    RandomGetBuffer(FrameBuf + 0x01, 7); /* Random number A1 in EM Marin definitions */
#endif
    ResponseByteCount += 8;
    return ResponseByteCount;
    daaa:	88 e0       	ldi	r24, 0x08	; 8
    daac:	90 e0       	ldi	r25, 0x00	; 0
    daae:	08 95       	ret
uint16_t EM4233_Auth1(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    // uint8_t KeyNo = *FrameInfo.Parameters; /* Right now this parameter is unused, but it will be useful */

    if (FrameInfo.ParamLen != 1) /* Malformed: not enough or too much data */
        return ISO15693_APP_NO_RESPONSE;
    dab0:	80 e0       	ldi	r24, 0x00	; 0
    dab2:	90 e0       	ldi	r25, 0x00	; 0
    /* Respond like a real tag */
    RandomGetBuffer(FrameBuf + 0x01, 7); /* Random number A1 in EM Marin definitions */
#endif
    ResponseByteCount += 8;
    return ResponseByteCount;
}
    dab4:	08 95       	ret

0000dab6 <EM4233_Auth2>:
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    // uint8_t A2 = FrameInfo.Parameters;
    // uint8_t f = FrameInfo.Parameters + 0x08;
    // uint8_t g[3] = { 0 }; /* Names according to EM Marin definitions */

    if (FrameInfo.ParamLen != 11) /* Malformed: not enough or too much data */
    dab6:	20 91 44 34 	lds	r18, 0x3444	; 0x803444 <FrameInfo+0x6>
    daba:	2b 30       	cpi	r18, 0x0B	; 11
    dabc:	49 f4       	brne	.+18     	; 0xdad0 <EM4233_Auth2+0x1a>
        return ISO15693_APP_NO_RESPONSE;
    // else if (!fFunc()) /* Actual f implementation to check if the f bytes we received are correct */
    //     return ISO15693_APP_NO_RESPONSE;


    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    dabe:	fc 01       	movw	r30, r24
    dac0:	11 92       	st	Z+, r1
    RandomGetBuffer(FrameBuf + 0x01, 3); /* This should be replaced with actual gFunc() implementation */
    dac2:	63 e0       	ldi	r22, 0x03	; 3
    dac4:	cf 01       	movw	r24, r30
    dac6:	0e 94 18 11 	call	0x2230	; 0x2230 <RandomGetBuffer>
    ResponseByteCount += 4;
    return ResponseByteCount;
    daca:	84 e0       	ldi	r24, 0x04	; 4
    dacc:	90 e0       	ldi	r25, 0x00	; 0
    dace:	08 95       	ret
    // uint8_t A2 = FrameInfo.Parameters;
    // uint8_t f = FrameInfo.Parameters + 0x08;
    // uint8_t g[3] = { 0 }; /* Names according to EM Marin definitions */

    if (FrameInfo.ParamLen != 11) /* Malformed: not enough or too much data */
        return ISO15693_APP_NO_RESPONSE;
    dad0:	80 e0       	ldi	r24, 0x00	; 0
    dad2:	90 e0       	ldi	r25, 0x00	; 0

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    RandomGetBuffer(FrameBuf + 0x01, 3); /* This should be replaced with actual gFunc() implementation */
    ResponseByteCount += 4;
    return ResponseByteCount;
}
    dad4:	08 95       	ret

0000dad6 <EM4233GetUid>:

    return ResponseByteCount;
}

void EM4233GetUid(ConfigurationUidType Uid) {
    MemoryReadBlock(&Uid[0], EM4233_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    dad6:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    dada:	50 e0       	ldi	r21, 0x00	; 0
    dadc:	60 ed       	ldi	r22, 0xD0	; 208
    dade:	70 e0       	ldi	r23, 0x00	; 0
    dae0:	0c 94 c7 11 	jmp	0x238e	; 0x238e <MemoryReadBlock>

0000dae4 <EM4233_Get_SysInfo>:
    // ResponseByteCount += 1;
    ResponseByteCount = ISO15693_APP_NO_RESPONSE; /* real tag does not respond anyway */
    return ResponseByteCount;
}

uint8_t EM4233_Get_SysInfo(uint8_t *FrameBuf, uint16_t FrameBytes) {
    dae4:	cf 92       	push	r12
    dae6:	df 92       	push	r13
    dae8:	ef 92       	push	r14
    daea:	ff 92       	push	r15
    daec:	0f 93       	push	r16
    daee:	1f 93       	push	r17
    daf0:	cf 93       	push	r28
    daf2:	df 93       	push	r29
    daf4:	cd b7       	in	r28, 0x3d	; 61
    daf6:	de b7       	in	r29, 0x3e	; 62
    daf8:	8c 01       	movw	r16, r24
    }

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;
    return ResponseByteCount;
}
    dafa:	cd b6       	in	r12, 0x3d	; 61
    dafc:	de b6       	in	r13, 0x3e	; 62

uint8_t EM4233_Get_SysInfo(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */

    if (FrameInfo.ParamLen != 0)
    dafe:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    db02:	81 11       	cpse	r24, r1
    db04:	4a c0       	rjmp	.+148    	; 0xdb9a <EM4233_Get_SysInfo+0xb6>
        return ResponseByteCount;
    }
    */

    /* System info flags */
    FrameBuf[FramePtr] = EM4233_SYSINFO_BYTE; /* check EM4233SLIC datasheet for this */
    db06:	8f e0       	ldi	r24, 0x0F	; 15
    db08:	f8 01       	movw	r30, r16
    db0a:	81 83       	std	Z+1, r24	; 0x01
    FramePtr += 1;             /* Move forward the buffer data pointer */
    ResponseByteCount += 1;    /* Increment the response count */

    /* Then append UID */
    uint8_t Uid[ActiveConfiguration.UidSize];
    db0c:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    db10:	2d b7       	in	r18, 0x3d	; 61
    db12:	3e b7       	in	r19, 0x3e	; 62
    db14:	28 1b       	sub	r18, r24
    db16:	31 09       	sbc	r19, r1
    db18:	2d bf       	out	0x3d, r18	; 61
    db1a:	3e bf       	out	0x3e, r19	; 62
    db1c:	8d b7       	in	r24, 0x3d	; 61
    db1e:	9e b7       	in	r25, 0x3e	; 62
    db20:	01 96       	adiw	r24, 0x01	; 1
    db22:	7c 01       	movw	r14, r24
    EM4233GetUid(Uid);
    db24:	d8 df       	rcall	.-80     	; 0xdad6 <EM4233GetUid>
    }
}

INLINE
void ISO15693CopyUid(uint8_t *DstUid, uint8_t *SrcUid) {
    DstUid[0] = SrcUid[7];
    db26:	f7 01       	movw	r30, r14
    db28:	87 81       	ldd	r24, Z+7	; 0x07
    db2a:	f8 01       	movw	r30, r16
    db2c:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[6];
    db2e:	f7 01       	movw	r30, r14
    db30:	86 81       	ldd	r24, Z+6	; 0x06
    db32:	f8 01       	movw	r30, r16
    db34:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[5];
    db36:	f7 01       	movw	r30, r14
    db38:	85 81       	ldd	r24, Z+5	; 0x05
    db3a:	f8 01       	movw	r30, r16
    db3c:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[4];
    db3e:	f7 01       	movw	r30, r14
    db40:	84 81       	ldd	r24, Z+4	; 0x04
    db42:	f8 01       	movw	r30, r16
    db44:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[3];
    db46:	f7 01       	movw	r30, r14
    db48:	83 81       	ldd	r24, Z+3	; 0x03
    db4a:	f8 01       	movw	r30, r16
    db4c:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[2];
    db4e:	f7 01       	movw	r30, r14
    db50:	82 81       	ldd	r24, Z+2	; 0x02
    db52:	f8 01       	movw	r30, r16
    db54:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[1];
    db56:	f7 01       	movw	r30, r14
    db58:	81 81       	ldd	r24, Z+1	; 0x01
    db5a:	f8 01       	movw	r30, r16
    db5c:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[0];
    db5e:	f7 01       	movw	r30, r14
    db60:	80 81       	ld	r24, Z
    db62:	f8 01       	movw	r30, r16
    db64:	81 87       	std	Z+9, r24	; 0x09
    FramePtr += ISO15693_GENERIC_UID_SIZE;             /* Move forward the buffer data pointer */
    ResponseByteCount += ISO15693_GENERIC_UID_SIZE;    /* Increment the response count */

    /* Append DSFID */
    if (EM4233_SYSINFO_BYTE & (1 << 0)) {
        MemoryReadBlock(&FrameBuf[FramePtr], EM4233_MEM_DSFID_ADDRESS, 1);
    db66:	41 e0       	ldi	r20, 0x01	; 1
    db68:	50 e0       	ldi	r21, 0x00	; 0
    db6a:	69 ed       	ldi	r22, 0xD9	; 217
    db6c:	70 e0       	ldi	r23, 0x00	; 0
    db6e:	c8 01       	movw	r24, r16
    db70:	0a 96       	adiw	r24, 0x0a	; 10
    db72:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
        ResponseByteCount += 1;    /* Increment the response count */
    }

    /* Append AFI */
    if (EM4233_SYSINFO_BYTE & (1 << 1)) {
        MemoryReadBlock(&FrameBuf[FramePtr], EM4233_MEM_AFI_ADDRESS, 1);
    db76:	41 e0       	ldi	r20, 0x01	; 1
    db78:	50 e0       	ldi	r21, 0x00	; 0
    db7a:	68 ed       	ldi	r22, 0xD8	; 216
    db7c:	70 e0       	ldi	r23, 0x00	; 0
    db7e:	c8 01       	movw	r24, r16
    db80:	0b 96       	adiw	r24, 0x0b	; 11
    db82:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
        ResponseByteCount += 1;    /* Increment the response count */
    }

    /* Append VICC memory size */
    if (EM4233_SYSINFO_BYTE & (1 << 2)) {
        FrameBuf[FramePtr] = EM4233_NUMBER_OF_BLCKS - 0x01;
    db86:	83 e3       	ldi	r24, 0x33	; 51
    db88:	f8 01       	movw	r30, r16
    db8a:	84 87       	std	Z+12, r24	; 0x0c
        FramePtr += 1;             /* Move forward the buffer data pointer */
        ResponseByteCount += 1;    /* Increment the response count */

        FrameBuf[FramePtr] = EM4233_BYTES_PER_BLCK - 0x01;
    db8c:	83 e0       	ldi	r24, 0x03	; 3
    db8e:	85 87       	std	Z+13, r24	; 0x0d
        ResponseByteCount += 1;    /* Increment the response count */
    }

    /* Append IC reference */
    if (EM4233_SYSINFO_BYTE & (1 << 3)) {
        FrameBuf[FramePtr] = EM4233_IC_REFERENCE;
    db90:	82 e0       	ldi	r24, 0x02	; 2
    db92:	86 87       	std	Z+14, r24	; 0x0e
        FramePtr += 1;             /* Move forward the buffer data pointer */
        ResponseByteCount += 1;    /* Increment the response count */
    }

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    db94:	10 82       	st	Z, r1
    ResponseByteCount += 1;
    return ResponseByteCount;
    db96:	8f e0       	ldi	r24, 0x0F	; 15
    db98:	01 c0       	rjmp	.+2      	; 0xdb9c <EM4233_Get_SysInfo+0xb8>
uint8_t EM4233_Get_SysInfo(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t FramePtr; /* holds the address where block's data will be put */

    if (FrameInfo.ParamLen != 0)
        return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */
    db9a:	80 e0       	ldi	r24, 0x00	; 0
    }

    FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR; /* flags */
    ResponseByteCount += 1;
    return ResponseByteCount;
}
    db9c:	cd be       	out	0x3d, r12	; 61
    db9e:	de be       	out	0x3e, r13	; 62
    dba0:	df 91       	pop	r29
    dba2:	cf 91       	pop	r28
    dba4:	1f 91       	pop	r17
    dba6:	0f 91       	pop	r16
    dba8:	ff 90       	pop	r15
    dbaa:	ef 90       	pop	r14
    dbac:	df 90       	pop	r13
    dbae:	cf 90       	pop	r12
    dbb0:	08 95       	ret

0000dbb2 <EM4233AppProcess>:
    RandomGetBuffer(FrameBuf + 0x01, 3); /* This should be replaced with actual gFunc() implementation */
    ResponseByteCount += 4;
    return ResponseByteCount;
}

uint16_t EM4233AppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    dbb2:	6f 92       	push	r6
    dbb4:	7f 92       	push	r7
    dbb6:	8f 92       	push	r8
    dbb8:	9f 92       	push	r9
    dbba:	af 92       	push	r10
    dbbc:	bf 92       	push	r11
    dbbe:	cf 92       	push	r12
    dbc0:	df 92       	push	r13
    dbc2:	ef 92       	push	r14
    dbc4:	0f 93       	push	r16
    dbc6:	1f 93       	push	r17
    dbc8:	cf 93       	push	r28
    dbca:	df 93       	push	r29
    dbcc:	cd b7       	in	r28, 0x3d	; 61
    dbce:	de b7       	in	r29, 0x3e	; 62
    dbd0:	6c 01       	movw	r12, r24
    dbd2:	5b 01       	movw	r10, r22
        ISO15693AppendCRC(FrameBuf, ResponseByteCount);
        ResponseByteCount += ISO15693_CRC16_SIZE;
    }

    return ResponseByteCount;
}
    dbd4:	6d b6       	in	r6, 0x3d	; 61
    dbd6:	7e b6       	in	r7, 0x3e	; 62
    return ResponseByteCount;
}

uint16_t EM4233AppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t Uid[ActiveConfiguration.UidSize];
    dbd8:	80 91 d3 2f 	lds	r24, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    dbdc:	2d b7       	in	r18, 0x3d	; 61
    dbde:	3e b7       	in	r19, 0x3e	; 62
    dbe0:	28 1b       	sub	r18, r24
    dbe2:	31 09       	sbc	r19, r1
    dbe4:	2d bf       	out	0x3d, r18	; 61
    dbe6:	3e bf       	out	0x3e, r19	; 62
    dbe8:	8d b7       	in	r24, 0x3d	; 61
    dbea:	9e b7       	in	r25, 0x3e	; 62
    dbec:	01 96       	adiw	r24, 0x01	; 1
    dbee:	4c 01       	movw	r8, r24
    EM4233GetUid(Uid);
    dbf0:	72 df       	rcall	.-284    	; 0xdad6 <EM4233GetUid>

    if ((FrameBytes < ISO15693_MIN_FRAME_SIZE) || !ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE))
    dbf2:	94 e0       	ldi	r25, 0x04	; 4
    dbf4:	a9 16       	cp	r10, r25
    dbf6:	b1 04       	cpc	r11, r1
    dbf8:	18 f4       	brcc	.+6      	; 0xdc00 <EM4233AppProcess+0x4e>
        /* malformed frame */
        return ResponseByteCount;
    dbfa:	80 e0       	ldi	r24, 0x00	; 0
    dbfc:	90 e0       	ldi	r25, 0x00	; 0
    dbfe:	e6 c0       	rjmp	.+460    	; 0xddcc <EM4233AppProcess+0x21a>
uint16_t EM4233AppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    uint8_t Uid[ActiveConfiguration.UidSize];
    EM4233GetUid(Uid);

    if ((FrameBytes < ISO15693_MIN_FRAME_SIZE) || !ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE))
    dc00:	b5 01       	movw	r22, r10
    dc02:	62 50       	subi	r22, 0x02	; 2
    dc04:	71 09       	sbc	r23, r1
    dc06:	c6 01       	movw	r24, r12
    dc08:	09 db       	rcall	.-2542   	; 0xd21c <ISO15693CheckCRC>
    dc0a:	88 23       	and	r24, r24
    dc0c:	b1 f3       	breq	.-20     	; 0xdbfa <EM4233AppProcess+0x48>
        /* malformed frame */
        return ResponseByteCount;

    if (FrameBuf[ISO15693_REQ_ADDR_CMD] == ISO15693_CMD_SELECT) {
    dc0e:	f6 01       	movw	r30, r12
    dc10:	81 81       	ldd	r24, Z+1	; 0x01
    dc12:	85 32       	cpi	r24, 0x25	; 37
    dc14:	31 f4       	brne	.+12     	; 0xdc22 <EM4233AppProcess+0x70>
        /* Select has its own path before PrepareFrame because we have to change the variable State
         * from Select to Ready if "Select" cmd is addressed to another tag.
         * It felt weird to add this kind of check in ISO15693PrepareFrame, which should not
         * interfere with tag specific variables, such as State in this case.
         */
        ResponseByteCount = EM4233_Select(FrameBuf, FrameBytes, Uid);
    dc16:	a4 01       	movw	r20, r8
    dc18:	b5 01       	movw	r22, r10
    dc1a:	c6 01       	movw	r24, r12
    dc1c:	99 de       	rcall	.-718    	; 0xd950 <EM4233_Select>
    dc1e:	8c 01       	movw	r16, r24
    dc20:	12 c0       	rjmp	.+36     	; 0xdc46 <EM4233AppProcess+0x94>
    } else if (!ISO15693PrepareFrame(FrameBuf, FrameBytes, &FrameInfo, State == STATE_SELECTED, Uid, MyAFI))
    dc22:	21 e0       	ldi	r18, 0x01	; 1
    dc24:	80 91 b3 2e 	lds	r24, 0x2EB3	; 0x802eb3 <State>
    dc28:	81 30       	cpi	r24, 0x01	; 1
    dc2a:	09 f0       	breq	.+2      	; 0xdc2e <EM4233AppProcess+0x7c>
    dc2c:	20 e0       	ldi	r18, 0x00	; 0
    dc2e:	e0 90 3d 34 	lds	r14, 0x343D	; 0x80343d <MyAFI>
    dc32:	84 01       	movw	r16, r8
    dc34:	4e e3       	ldi	r20, 0x3E	; 62
    dc36:	54 e3       	ldi	r21, 0x34	; 52
    dc38:	b5 01       	movw	r22, r10
    dc3a:	c6 01       	movw	r24, r12
    dc3c:	05 db       	rcall	.-2550   	; 0xd248 <ISO15693PrepareFrame>
    dc3e:	88 23       	and	r24, r24
    dc40:	e1 f2       	breq	.-72     	; 0xdbfa <EM4233AppProcess+0x48>
    ResponseByteCount += 4;
    return ResponseByteCount;
}

uint16_t EM4233AppProcess(uint8_t *FrameBuf, uint16_t FrameBytes) {
    uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
    dc42:	00 e0       	ldi	r16, 0x00	; 0
    dc44:	10 e0       	ldi	r17, 0x00	; 0
         */
        ResponseByteCount = EM4233_Select(FrameBuf, FrameBytes, Uid);
    } else if (!ISO15693PrepareFrame(FrameBuf, FrameBytes, &FrameInfo, State == STATE_SELECTED, Uid, MyAFI))
        return ISO15693_APP_NO_RESPONSE;

    if (State == STATE_READY || State == STATE_SELECTED) {
    dc46:	80 91 b3 2e 	lds	r24, 0x2EB3	; 0x802eb3 <State>
    dc4a:	82 30       	cpi	r24, 0x02	; 2
    dc4c:	08 f0       	brcs	.+2      	; 0xdc50 <EM4233AppProcess+0x9e>
    dc4e:	ac c0       	rjmp	.+344    	; 0xdda8 <EM4233AppProcess+0x1f6>

        if (*FrameInfo.Command == ISO15693_CMD_INVENTORY) {
    dc50:	e0 91 40 34 	lds	r30, 0x3440	; 0x803440 <FrameInfo+0x2>
    dc54:	f0 91 41 34 	lds	r31, 0x3441	; 0x803441 <FrameInfo+0x3>
    dc58:	80 81       	ld	r24, Z
    dc5a:	81 30       	cpi	r24, 0x01	; 1
    dc5c:	c9 f5       	brne	.+114    	; 0xdcd0 <EM4233AppProcess+0x11e>
            if (FrameInfo.ParamLen == 0)
    dc5e:	80 91 44 34 	lds	r24, 0x3444	; 0x803444 <FrameInfo+0x6>
    dc62:	88 23       	and	r24, r24
    dc64:	51 f2       	breq	.-108    	; 0xdbfa <EM4233AppProcess+0x48>
                return ISO15693_APP_NO_RESPONSE; /* malformed: not enough or too much data */

            if (ISO15693AntiColl(FrameBuf, FrameBytes, &FrameInfo, Uid)) {
    dc66:	94 01       	movw	r18, r8
    dc68:	4e e3       	ldi	r20, 0x3E	; 62
    dc6a:	54 e3       	ldi	r21, 0x34	; 52
    dc6c:	b5 01       	movw	r22, r10
    dc6e:	c6 01       	movw	r24, r12
    dc70:	6c db       	rcall	.-2344   	; 0xd34a <ISO15693AntiColl>
    dc72:	88 23       	and	r24, r24
    dc74:	09 f4       	brne	.+2      	; 0xdc78 <EM4233AppProcess+0xc6>
    dc76:	a1 c0       	rjmp	.+322    	; 0xddba <EM4233AppProcess+0x208>
                FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_NO_ERROR;
    dc78:	f6 01       	movw	r30, r12
    dc7a:	11 92       	st	Z+, r1
    dc7c:	cf 01       	movw	r24, r30
                MemoryReadBlock(&FrameBuf[ISO15693_RES_ADDR_PARAM], EM4233_MEM_DSFID_ADDRESS, 1);
    dc7e:	41 e0       	ldi	r20, 0x01	; 1
    dc80:	50 e0       	ldi	r21, 0x00	; 0
    dc82:	69 ed       	ldi	r22, 0xD9	; 217
    dc84:	70 e0       	ldi	r23, 0x00	; 0
    dc86:	0e 94 c7 11 	call	0x238e	; 0x238e <MemoryReadBlock>
    }
}

INLINE
void ISO15693CopyUid(uint8_t *DstUid, uint8_t *SrcUid) {
    DstUid[0] = SrcUid[7];
    dc8a:	f4 01       	movw	r30, r8
    dc8c:	87 81       	ldd	r24, Z+7	; 0x07
    dc8e:	f6 01       	movw	r30, r12
    dc90:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[6];
    dc92:	f4 01       	movw	r30, r8
    dc94:	86 81       	ldd	r24, Z+6	; 0x06
    dc96:	f6 01       	movw	r30, r12
    dc98:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[5];
    dc9a:	f4 01       	movw	r30, r8
    dc9c:	85 81       	ldd	r24, Z+5	; 0x05
    dc9e:	f6 01       	movw	r30, r12
    dca0:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[4];
    dca2:	f4 01       	movw	r30, r8
    dca4:	84 81       	ldd	r24, Z+4	; 0x04
    dca6:	f6 01       	movw	r30, r12
    dca8:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[3];
    dcaa:	f4 01       	movw	r30, r8
    dcac:	83 81       	ldd	r24, Z+3	; 0x03
    dcae:	f6 01       	movw	r30, r12
    dcb0:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[2];
    dcb2:	f4 01       	movw	r30, r8
    dcb4:	82 81       	ldd	r24, Z+2	; 0x02
    dcb6:	f6 01       	movw	r30, r12
    dcb8:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[1];
    dcba:	f4 01       	movw	r30, r8
    dcbc:	81 81       	ldd	r24, Z+1	; 0x01
    dcbe:	f6 01       	movw	r30, r12
    dcc0:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[0];
    dcc2:	f4 01       	movw	r30, r8
    dcc4:	80 81       	ld	r24, Z
    dcc6:	f6 01       	movw	r30, r12
    dcc8:	81 87       	std	Z+9, r24	; 0x09
                ISO15693CopyUid(&FrameBuf[ISO15693_RES_ADDR_PARAM + 0x01], Uid);
                ResponseByteCount += 10;
    dcca:	06 5f       	subi	r16, 0xF6	; 246
    dccc:	1f 4f       	sbci	r17, 0xFF	; 255
    dcce:	75 c0       	rjmp	.+234    	; 0xddba <EM4233AppProcess+0x208>
            }

        } else if ((*FrameInfo.Command == ISO15693_CMD_STAY_QUIET) && FrameInfo.Addressed) {
    dcd0:	82 30       	cpi	r24, 0x02	; 2
    dcd2:	41 f4       	brne	.+16     	; 0xdce4 <EM4233AppProcess+0x132>
    dcd4:	90 91 45 34 	lds	r25, 0x3445	; 0x803445 <FrameInfo+0x7>
    dcd8:	99 23       	and	r25, r25
    dcda:	09 f4       	brne	.+2      	; 0xdcde <EM4233AppProcess+0x12c>
    dcdc:	5a c0       	rjmp	.+180    	; 0xdd92 <EM4233AppProcess+0x1e0>
            State = STATE_QUIET;
    dcde:	80 93 b3 2e 	sts	0x2EB3, r24	; 0x802eb3 <State>

        } else if (*FrameInfo.Command == ISO15693_CMD_READ_SINGLE) {
    dce2:	6b c0       	rjmp	.+214    	; 0xddba <EM4233AppProcess+0x208>
    dce4:	80 32       	cpi	r24, 0x20	; 32
            ResponseByteCount = EM4233_Read_Single(FrameBuf, FrameBytes);
    dce6:	21 f4       	brne	.+8      	; 0xdcf0 <EM4233AppProcess+0x13e>
    dce8:	b5 01       	movw	r22, r10
    dcea:	c6 01       	movw	r24, r12
    dcec:	25 dc       	rcall	.-1974   	; 0xd538 <EM4233_Read_Single>

        } else if (*FrameInfo.Command == ISO15693_CMD_WRITE_SINGLE) {
    dcee:	05 c0       	rjmp	.+10     	; 0xdcfa <EM4233AppProcess+0x148>
    dcf0:	81 32       	cpi	r24, 0x21	; 33
            ResponseByteCount = EM4233_Write_Single(FrameBuf, FrameBytes);
    dcf2:	29 f4       	brne	.+10     	; 0xdcfe <EM4233AppProcess+0x14c>
    dcf4:	b5 01       	movw	r22, r10
    dcf6:	c6 01       	movw	r24, r12
    dcf8:	dd db       	rcall	.-2118   	; 0xd4b4 <EM4233_Write_Single>
    dcfa:	8c 01       	movw	r16, r24

        } else if (*FrameInfo.Command == ISO15693_CMD_LOCK_BLOCK) {
    dcfc:	5e c0       	rjmp	.+188    	; 0xddba <EM4233AppProcess+0x208>
    dcfe:	82 32       	cpi	r24, 0x22	; 34
            ResponseByteCount = EM4233_Lock_Block(FrameBuf, FrameBytes);
    dd00:	21 f4       	brne	.+8      	; 0xdd0a <EM4233AppProcess+0x158>
    dd02:	b5 01       	movw	r22, r10
    dd04:	c6 01       	movw	r24, r12
    dd06:	a2 db       	rcall	.-2236   	; 0xd44c <EM4233_Lock_Block>

        } else if (*FrameInfo.Command == ISO15693_CMD_READ_MULTIPLE) {
    dd08:	f8 cf       	rjmp	.-16     	; 0xdcfa <EM4233AppProcess+0x148>
    dd0a:	83 32       	cpi	r24, 0x23	; 35
            ResponseByteCount = EM4233_Read_Multiple(FrameBuf, FrameBytes);
    dd0c:	21 f4       	brne	.+8      	; 0xdd16 <EM4233AppProcess+0x164>
    dd0e:	b5 01       	movw	r22, r10
    dd10:	c6 01       	movw	r24, r12
    dd12:	78 dc       	rcall	.-1808   	; 0xd604 <EM4233_Read_Multiple>

        } else if (*FrameInfo.Command == ISO15693_CMD_WRITE_AFI) {
    dd14:	f2 cf       	rjmp	.-28     	; 0xdcfa <EM4233AppProcess+0x148>
            ResponseByteCount = EM4233_Write_AFI(FrameBuf, FrameBytes);
    dd16:	87 32       	cpi	r24, 0x27	; 39
    dd18:	21 f4       	brne	.+8      	; 0xdd22 <EM4233AppProcess+0x170>
    dd1a:	b5 01       	movw	r22, r10
    dd1c:	c6 01       	movw	r24, r12
    dd1e:	46 dd       	rcall	.-1396   	; 0xd7ac <EM4233_Write_AFI>

        } else if (*FrameInfo.Command == ISO15693_CMD_LOCK_AFI) {
    dd20:	ec cf       	rjmp	.-40     	; 0xdcfa <EM4233AppProcess+0x148>
            ResponseByteCount = EM4233_Lock_AFI(FrameBuf, FrameBytes);
    dd22:	88 32       	cpi	r24, 0x28	; 40
    dd24:	21 f4       	brne	.+8      	; 0xdd2e <EM4233AppProcess+0x17c>
    dd26:	b5 01       	movw	r22, r10
    dd28:	c6 01       	movw	r24, r12

        } else if (*FrameInfo.Command == ISO15693_CMD_WRITE_DSFID) {
    dd2a:	6e dd       	rcall	.-1316   	; 0xd808 <EM4233_Lock_AFI>
    dd2c:	e6 cf       	rjmp	.-52     	; 0xdcfa <EM4233AppProcess+0x148>
            ResponseByteCount = EM4233_Write_DSFID(FrameBuf, FrameBytes);
    dd2e:	89 32       	cpi	r24, 0x29	; 41
    dd30:	21 f4       	brne	.+8      	; 0xdd3a <EM4233AppProcess+0x188>
    dd32:	b5 01       	movw	r22, r10
    dd34:	c6 01       	movw	r24, r12

        } else if (*FrameInfo.Command == ISO15693_CMD_LOCK_DSFID) {
    dd36:	8d dd       	rcall	.-1254   	; 0xd852 <EM4233_Write_DSFID>
    dd38:	e0 cf       	rjmp	.-64     	; 0xdcfa <EM4233AppProcess+0x148>
            ResponseByteCount = EM4233_Lock_DSFID(FrameBuf, FrameBytes);
    dd3a:	8a 32       	cpi	r24, 0x2A	; 42
    dd3c:	21 f4       	brne	.+8      	; 0xdd46 <EM4233AppProcess+0x194>
    dd3e:	b5 01       	movw	r22, r10
    dd40:	c6 01       	movw	r24, r12

        } else if (*FrameInfo.Command == ISO15693_CMD_GET_SYS_INFO) {
    dd42:	b2 dd       	rcall	.-1180   	; 0xd8a8 <EM4233_Lock_DSFID>
    dd44:	da cf       	rjmp	.-76     	; 0xdcfa <EM4233AppProcess+0x148>
            ResponseByteCount = EM4233_Get_SysInfo(FrameBuf, FrameBytes);
    dd46:	8b 32       	cpi	r24, 0x2B	; 43
    dd48:	31 f4       	brne	.+12     	; 0xdd56 <EM4233AppProcess+0x1a4>
    dd4a:	b5 01       	movw	r22, r10
    dd4c:	c6 01       	movw	r24, r12
    dd4e:	ca de       	rcall	.-620    	; 0xdae4 <EM4233_Get_SysInfo>
    dd50:	08 2f       	mov	r16, r24

        } else if (*FrameInfo.Command == ISO15693_CMD_GET_BLOCK_SEC) {
    dd52:	10 e0       	ldi	r17, 0x00	; 0
    dd54:	32 c0       	rjmp	.+100    	; 0xddba <EM4233AppProcess+0x208>
            ResponseByteCount = EM4233_Get_Multi_Block_Sec_Stat(FrameBuf, FrameBytes);
    dd56:	8c 32       	cpi	r24, 0x2C	; 44
    dd58:	21 f4       	brne	.+8      	; 0xdd62 <EM4233AppProcess+0x1b0>
    dd5a:	b5 01       	movw	r22, r10
    dd5c:	c6 01       	movw	r24, r12

        } else if (*FrameInfo.Command == ISO15693_CMD_RESET_TO_READY) {
    dd5e:	c9 dd       	rcall	.-1134   	; 0xd8f2 <EM4233_Get_Multi_Block_Sec_Stat>
            ResponseByteCount = EM4233_Reset_To_Ready(FrameBuf, FrameBytes);
    dd60:	cc cf       	rjmp	.-104    	; 0xdcfa <EM4233AppProcess+0x148>
    dd62:	86 32       	cpi	r24, 0x26	; 38
    dd64:	21 f4       	brne	.+8      	; 0xdd6e <EM4233AppProcess+0x1bc>
    dd66:	b5 01       	movw	r22, r10
    dd68:	c6 01       	movw	r24, r12

        } else if (*FrameInfo.Command == EM4233_CMD_LOGIN) {
    dd6a:	3b de       	rcall	.-906    	; 0xd9e2 <EM4233_Reset_To_Ready>
            ResponseByteCount = EM4233_Login(FrameBuf, FrameBytes);
    dd6c:	c6 cf       	rjmp	.-116    	; 0xdcfa <EM4233AppProcess+0x148>
    dd6e:	84 3e       	cpi	r24, 0xE4	; 228
    dd70:	21 f4       	brne	.+8      	; 0xdd7a <EM4233AppProcess+0x1c8>
    dd72:	b5 01       	movw	r22, r10
    dd74:	c6 01       	movw	r24, r12

        } else if (*FrameInfo.Command == EM4233_CMD_AUTH1) {
    dd76:	47 de       	rcall	.-882    	; 0xda06 <EM4233_Login>
    dd78:	c0 cf       	rjmp	.-128    	; 0xdcfa <EM4233AppProcess+0x148>
            ResponseByteCount = EM4233_Auth1(FrameBuf, FrameBytes);
    dd7a:	80 3e       	cpi	r24, 0xE0	; 224
    dd7c:	21 f4       	brne	.+8      	; 0xdd86 <EM4233AppProcess+0x1d4>
    dd7e:	b5 01       	movw	r22, r10
    dd80:	c6 01       	movw	r24, r12
    dd82:	86 de       	rcall	.-756    	; 0xda90 <EM4233_Auth1>

        } else if (*FrameInfo.Command == EM4233_CMD_AUTH2) {
    dd84:	ba cf       	rjmp	.-140    	; 0xdcfa <EM4233AppProcess+0x148>
    dd86:	81 3e       	cpi	r24, 0xE1	; 225
            ResponseByteCount = EM4233_Auth2(FrameBuf, FrameBytes);
    dd88:	21 f4       	brne	.+8      	; 0xdd92 <EM4233AppProcess+0x1e0>
    dd8a:	b5 01       	movw	r22, r10
    dd8c:	c6 01       	movw	r24, r12
    dd8e:	93 de       	rcall	.-730    	; 0xdab6 <EM4233_Auth2>
    dd90:	b4 cf       	rjmp	.-152    	; 0xdcfa <EM4233AppProcess+0x148>

        } else {
            if (FrameInfo.Addressed) {
    dd92:	80 91 45 34 	lds	r24, 0x3445	; 0x803445 <FrameInfo+0x7>
    dd96:	88 23       	and	r24, r24
    dd98:	81 f0       	breq	.+32     	; 0xddba <EM4233AppProcess+0x208>
                FrameBuf[ISO15693_ADDR_FLAGS] = ISO15693_RES_FLAG_ERROR;
    dd9a:	81 e0       	ldi	r24, 0x01	; 1
    dd9c:	f6 01       	movw	r30, r12
    dd9e:	80 83       	st	Z, r24
                FrameBuf[ISO15693_RES_ADDR_PARAM] = ISO15693_RES_ERR_NOT_SUPP;
                ResponseByteCount = 2;
    dda0:	81 83       	std	Z+1, r24	; 0x01
    dda2:	02 e0       	ldi	r16, 0x02	; 2
    dda4:	10 e0       	ldi	r17, 0x00	; 0
            } /* EM4233 respond with error flag only to addressed commands */
        }

    } else if (State == STATE_QUIET) {
    dda6:	0d c0       	rjmp	.+26     	; 0xddc2 <EM4233AppProcess+0x210>
    dda8:	82 30       	cpi	r24, 0x02	; 2
        if (*FrameInfo.Command == ISO15693_CMD_RESET_TO_READY) {
    ddaa:	39 f4       	brne	.+14     	; 0xddba <EM4233AppProcess+0x208>
    ddac:	e0 91 40 34 	lds	r30, 0x3440	; 0x803440 <FrameInfo+0x2>
    ddb0:	f0 91 41 34 	lds	r31, 0x3441	; 0x803441 <FrameInfo+0x3>
    ddb4:	80 81       	ld	r24, Z
    ddb6:	86 32       	cpi	r24, 0x26	; 38
            ResponseByteCount = EM4233_Reset_To_Ready(FrameBuf, FrameBytes);
        }
    }

    if (ResponseByteCount > 0) {
    ddb8:	b1 f2       	breq	.-84     	; 0xdd66 <EM4233AppProcess+0x1b4>
    ddba:	01 15       	cp	r16, r1
    ddbc:	11 05       	cpc	r17, r1
    ddbe:	09 f4       	brne	.+2      	; 0xddc2 <EM4233AppProcess+0x210>
        /* There is data to send. Append CRC */
        ISO15693AppendCRC(FrameBuf, ResponseByteCount);
    ddc0:	1c cf       	rjmp	.-456    	; 0xdbfa <EM4233AppProcess+0x48>
    ddc2:	b8 01       	movw	r22, r16
    ddc4:	c6 01       	movw	r24, r12
    ddc6:	1a da       	rcall	.-3020   	; 0xd1fc <ISO15693AppendCRC>
        ResponseByteCount += ISO15693_CRC16_SIZE;
    ddc8:	c8 01       	movw	r24, r16
    ddca:	02 96       	adiw	r24, 0x02	; 2
    }

    return ResponseByteCount;
}
    ddcc:	6d be       	out	0x3d, r6	; 61
    ddce:	7e be       	out	0x3e, r7	; 62
    ddd0:	df 91       	pop	r29
    ddd2:	cf 91       	pop	r28
    ddd4:	1f 91       	pop	r17
    ddd6:	0f 91       	pop	r16
    ddd8:	ef 90       	pop	r14
    ddda:	df 90       	pop	r13
    dddc:	cf 90       	pop	r12
    ddde:	bf 90       	pop	r11
    dde0:	af 90       	pop	r10
    dde2:	9f 90       	pop	r9
    dde4:	8f 90       	pop	r8
    dde6:	7f 90       	pop	r7
    dde8:	6f 90       	pop	r6
    ddea:	08 95       	ret

0000ddec <EM4233SetUid>:
void EM4233GetUid(ConfigurationUidType Uid) {
    MemoryReadBlock(&Uid[0], EM4233_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
}

void EM4233SetUid(ConfigurationUidType Uid) {
    MemoryWriteBlock(Uid, EM4233_MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    ddec:	40 91 d3 2f 	lds	r20, 0x2FD3	; 0x802fd3 <ActiveConfiguration+0x16>
    ddf0:	50 e0       	ldi	r21, 0x00	; 0
    ddf2:	60 ed       	ldi	r22, 0xD0	; 208
    ddf4:	70 e0       	ldi	r23, 0x00	; 0
    ddf6:	0c 94 15 12 	jmp	0x242a	; 0x242a <MemoryWriteBlock>

0000ddfa <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    ddfa:	0f 93       	push	r16
    ddfc:	1f 93       	push	r17
    ddfe:	cf 93       	push	r28
    de00:	df 93       	push	r29
    de02:	cd b7       	in	r28, 0x3d	; 61
    de04:	de b7       	in	r29, 0x3e	; 62
    de06:	ea 97       	sbiw	r28, 0x3a	; 58
    de08:	cd bf       	out	0x3d, r28	; 61
    de0a:	de bf       	out	0x3e, r29	; 62
    de0c:	0d e4       	ldi	r16, 0x4D	; 77
    de0e:	14 e3       	ldi	r17, 0x34	; 52
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    de10:	95 d2       	rcall	.+1322   	; 0xe33c <Endpoint_Read_8>
    de12:	f8 01       	movw	r30, r16
    de14:	81 93       	st	Z+, r24
    de16:	8f 01       	movw	r16, r30
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    de18:	f4 e3       	ldi	r31, 0x34	; 52
    de1a:	05 35       	cpi	r16, 0x55	; 85
    de1c:	1f 07       	cpc	r17, r31
    de1e:	c1 f7       	brne	.-16     	; 0xde10 <USB_Device_ProcessControlRequest+0x16>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    de20:	0e 94 87 1c 	call	0x390e	; 0x390e <EVENT_USB_Device_ControlRequest>

	if (Endpoint_IsSETUPReceived())
    de24:	06 d3       	rcall	.+1548   	; 0xe432 <Endpoint_IsSETUPReceived>
    de26:	88 23       	and	r24, r24
    de28:	09 f4       	brne	.+2      	; 0xde2c <USB_Device_ProcessControlRequest+0x32>
    de2a:	fa c0       	rjmp	.+500    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    de2c:	80 91 4d 34 	lds	r24, 0x344D	; 0x80344d <USB_ControlRequest>

		switch (USB_ControlRequest.bRequest)
    de30:	90 91 4e 34 	lds	r25, 0x344E	; 0x80344e <USB_ControlRequest+0x1>
    de34:	95 30       	cpi	r25, 0x05	; 5
    de36:	09 f4       	brne	.+2      	; 0xde3a <USB_Device_ProcessControlRequest+0x40>
    de38:	6f c0       	rjmp	.+222    	; 0xdf18 <USB_Device_ProcessControlRequest+0x11e>
    de3a:	30 f4       	brcc	.+12     	; 0xde48 <USB_Device_ProcessControlRequest+0x4e>
    de3c:	91 30       	cpi	r25, 0x01	; 1
    de3e:	69 f1       	breq	.+90     	; 0xde9a <USB_Device_ProcessControlRequest+0xa0>
    de40:	68 f0       	brcs	.+26     	; 0xde5c <USB_Device_ProcessControlRequest+0x62>
    de42:	93 30       	cpi	r25, 0x03	; 3
    de44:	51 f1       	breq	.+84     	; 0xde9a <USB_Device_ProcessControlRequest+0xa0>
    de46:	ec c0       	rjmp	.+472    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    de48:	98 30       	cpi	r25, 0x08	; 8
    de4a:	09 f4       	brne	.+2      	; 0xde4e <USB_Device_ProcessControlRequest+0x54>
    de4c:	c2 c0       	rjmp	.+388    	; 0xdfd2 <USB_Device_ProcessControlRequest+0x1d8>
    de4e:	99 30       	cpi	r25, 0x09	; 9
    de50:	09 f4       	brne	.+2      	; 0xde54 <USB_Device_ProcessControlRequest+0x5a>
    de52:	c8 c0       	rjmp	.+400    	; 0xdfe4 <USB_Device_ProcessControlRequest+0x1ea>
    de54:	96 30       	cpi	r25, 0x06	; 6
    de56:	09 f0       	breq	.+2      	; 0xde5a <USB_Device_ProcessControlRequest+0x60>
    de58:	e3 c0       	rjmp	.+454    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    de5a:	72 c0       	rjmp	.+228    	; 0xdf40 <USB_Device_ProcessControlRequest+0x146>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    de5c:	80 38       	cpi	r24, 0x80	; 128
    de5e:	91 f0       	breq	.+36     	; 0xde84 <USB_Device_ProcessControlRequest+0x8a>
    de60:	82 38       	cpi	r24, 0x82	; 130
    de62:	09 f0       	breq	.+2      	; 0xde66 <USB_Device_ProcessControlRequest+0x6c>
    de64:	dd c0       	rjmp	.+442    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    de66:	80 91 51 34 	lds	r24, 0x3451	; 0x803451 <USB_ControlRequest+0x4>
    de6a:	8f 70       	andi	r24, 0x0F	; 15
    de6c:	87 d2       	rcall	.+1294   	; 0xe37c <Endpoint_SelectEndpoint>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    de6e:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    de72:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    de76:	11 81       	ldd	r17, Z+1	; 0x01

			CurrentStatus = Endpoint_IsStalled();
    de78:	12 fb       	bst	r17, 2
    de7a:	11 27       	eor	r17, r17

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    de7c:	10 f9       	bld	r17, 0
    de7e:	80 e0       	ldi	r24, 0x00	; 0
    de80:	7d d2       	rcall	.+1274   	; 0xe37c <Endpoint_SelectEndpoint>
    de82:	06 c0       	rjmp	.+12     	; 0xde90 <USB_Device_ProcessControlRequest+0x96>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    de84:	10 91 49 34 	lds	r17, 0x3449	; 0x803449 <USB_Device_CurrentlySelfPowered>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    de88:	80 91 4a 34 	lds	r24, 0x344A	; 0x80344a <USB_Device_RemoteWakeupEnabled>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    de8c:	81 11       	cpse	r24, r1
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
    de8e:	12 60       	ori	r17, 0x02	; 2
    de90:	ea d2       	rcall	.+1492   	; 0xe466 <Endpoint_ClearSETUP>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    de92:	81 2f       	mov	r24, r17
    de94:	63 d2       	rcall	.+1222   	; 0xe35c <Endpoint_Write_8>
    de96:	80 e0       	ldi	r24, 0x00	; 0
				Endpoint_Write_8(Data >> 8);
    de98:	a1 c0       	rjmp	.+322    	; 0xdfdc <USB_Device_ProcessControlRequest+0x1e2>
    de9a:	28 2f       	mov	r18, r24
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    de9c:	2d 7f       	andi	r18, 0xFD	; 253
    de9e:	09 f0       	breq	.+2      	; 0xdea2 <USB_Device_ProcessControlRequest+0xa8>
    dea0:	bf c0       	rjmp	.+382    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    dea2:	88 23       	and	r24, r24
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    dea4:	19 f0       	breq	.+6      	; 0xdeac <USB_Device_ProcessControlRequest+0xb2>
    dea6:	82 30       	cpi	r24, 0x02	; 2
    dea8:	61 f0       	breq	.+24     	; 0xdec2 <USB_Device_ProcessControlRequest+0xc8>
    deaa:	ba c0       	rjmp	.+372    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    deac:	80 91 4f 34 	lds	r24, 0x344F	; 0x80344f <USB_ControlRequest+0x2>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    deb0:	81 30       	cpi	r24, 0x01	; 1
    deb2:	09 f0       	breq	.+2      	; 0xdeb6 <USB_Device_ProcessControlRequest+0xbc>
    deb4:	b5 c0       	rjmp	.+362    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    deb6:	93 30       	cpi	r25, 0x03	; 3
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    deb8:	09 f0       	breq	.+2      	; 0xdebc <USB_Device_ProcessControlRequest+0xc2>
    deba:	80 e0       	ldi	r24, 0x00	; 0
    debc:	80 93 4a 34 	sts	0x344A, r24	; 0x80344a <USB_Device_RemoteWakeupEnabled>
    dec0:	27 c0       	rjmp	.+78     	; 0xdf10 <USB_Device_ProcessControlRequest+0x116>
    dec2:	80 91 4f 34 	lds	r24, 0x344F	; 0x80344f <USB_ControlRequest+0x2>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    dec6:	81 11       	cpse	r24, r1
    dec8:	23 c0       	rjmp	.+70     	; 0xdf10 <USB_Device_ProcessControlRequest+0x116>
    deca:	e0 91 51 34 	lds	r30, 0x3451	; 0x803451 <USB_ControlRequest+0x4>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    dece:	1e 2f       	mov	r17, r30
    ded0:	1f 70       	andi	r17, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    ded2:	09 f4       	brne	.+2      	; 0xded6 <USB_Device_ProcessControlRequest+0xdc>
    ded4:	a5 c0       	rjmp	.+330    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
    ded6:	81 2f       	mov	r24, r17
    ded8:	51 d2       	rcall	.+1186   	; 0xe37c <Endpoint_SelectEndpoint>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    deda:	80 91 4e 34 	lds	r24, 0x344E	; 0x80344e <USB_ControlRequest+0x1>
    dede:	83 30       	cpi	r24, 0x03	; 3
    dee0:	11 f4       	brne	.+4      	; 0xdee6 <USB_Device_ProcessControlRequest+0xec>
					{
						Endpoint_StallTransaction();
    dee2:	ed d2       	rcall	.+1498   	; 0xe4be <Endpoint_StallTransaction>
    dee4:	15 c0       	rjmp	.+42     	; 0xdf10 <USB_Device_ProcessControlRequest+0x116>
    dee6:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
    deea:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    deee:	81 81       	ldd	r24, Z+1	; 0x01
    def0:	8b 7f       	andi	r24, 0xFB	; 251
    def2:	81 83       	std	Z+1, r24	; 0x01
    def4:	24 e8       	ldi	r18, 0x84	; 132
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
    def6:	12 9f       	mul	r17, r18
    def8:	f0 01       	movw	r30, r0
    defa:	11 24       	eor	r1, r1
    defc:	e5 56       	subi	r30, 0x65	; 101
    defe:	fb 4c       	sbci	r31, 0xCB	; 203
    df00:	10 82       	st	Z, r1
    df02:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
    df06:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    df0a:	80 81       	ld	r24, Z
    df0c:	8e 7f       	andi	r24, 0xFE	; 254
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    df0e:	80 83       	st	Z, r24
    df10:	80 e0       	ldi	r24, 0x00	; 0

	Endpoint_ClearSETUP();
    df12:	34 d2       	rcall	.+1128   	; 0xe37c <Endpoint_SelectEndpoint>
    df14:	a8 d2       	rcall	.+1360   	; 0xe466 <Endpoint_ClearSETUP>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    df16:	64 c0       	rjmp	.+200    	; 0xdfe0 <USB_Device_ProcessControlRequest+0x1e6>
    df18:	81 11       	cpse	r24, r1
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    df1a:	82 c0       	rjmp	.+260    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    df1c:	10 91 4f 34 	lds	r17, 0x344F	; 0x80344f <USB_ControlRequest+0x2>

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
    df20:	1f 77       	andi	r17, 0x7F	; 127
    df22:	a1 d2       	rcall	.+1346   	; 0xe466 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    df24:	8f d3       	rcall	.+1822   	; 0xe644 <Endpoint_ClearStatusStage>
    df26:	5f d2       	rcall	.+1214   	; 0xe3e6 <Endpoint_IsINReady>

	while (!(Endpoint_IsINReady()));
    df28:	88 23       	and	r24, r24
    df2a:	e9 f3       	breq	.-6      	; 0xdf26 <USB_Device_ProcessControlRequest+0x12c>
    df2c:	10 93 c3 04 	sts	0x04C3, r17	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7004c3>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    df30:	11 11       	cpse	r17, r1
    df32:	02 c0       	rjmp	.+4      	; 0xdf38 <USB_Device_ProcessControlRequest+0x13e>

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    df34:	82 e0       	ldi	r24, 0x02	; 2
    df36:	01 c0       	rjmp	.+2      	; 0xdf3a <USB_Device_ProcessControlRequest+0x140>
    df38:	83 e0       	ldi	r24, 0x03	; 3
    df3a:	80 93 4c 34 	sts	0x344C, r24	; 0x80344c <USB_DeviceState>
    df3e:	70 c0       	rjmp	.+224    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    df40:	80 58       	subi	r24, 0x80	; 128
    df42:	82 30       	cpi	r24, 0x02	; 2
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    df44:	08 f0       	brcs	.+2      	; 0xdf48 <USB_Device_ProcessControlRequest+0x14e>
    df46:	6c c0       	rjmp	.+216    	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    df48:	80 91 4f 34 	lds	r24, 0x344F	; 0x80344f <USB_ControlRequest+0x2>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    df4c:	90 91 50 34 	lds	r25, 0x3450	; 0x803450 <USB_ControlRequest+0x3>
    df50:	8c 3d       	cpi	r24, 0xDC	; 220
    df52:	e3 e0       	ldi	r30, 0x03	; 3
    df54:	9e 07       	cpc	r25, r30
    df56:	61 f5       	brne	.+88     	; 0xdfb0 <USB_Device_ProcessControlRequest+0x1b6>
    df58:	83 e0       	ldi	r24, 0x03	; 3
    df5a:	8a 83       	std	Y+2, r24	; 0x02
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    df5c:	8a e3       	ldi	r24, 0x3A	; 58
    df5e:	89 83       	std	Y+1, r24	; 0x01
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    df60:	4f b7       	in	r20, 0x3f	; 63
    df62:	f8 94       	cli
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    df64:	de 01       	movw	r26, r28
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    df66:	13 96       	adiw	r26, 0x03	; 3
				#endif

				GCC_MEMORY_BARRIER();
    df68:	20 e0       	ldi	r18, 0x00	; 0
    df6a:	38 e0       	ldi	r19, 0x08	; 8
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    df6c:	52 e0       	ldi	r21, 0x02	; 2
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    df6e:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
    df72:	e3 2f       	mov	r30, r19
    df74:	f0 e0       	ldi	r31, 0x00	; 0
					SerialByte = pgm_read_byte(SigReadAddress);
    df76:	e4 91       	lpm	r30, Z
    df78:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
					NVM.CMD    = 0;
    df7c:	20 ff       	sbrs	r18, 0
    df7e:	03 c0       	rjmp	.+6      	; 0xdf86 <USB_Device_ProcessControlRequest+0x18c>

					if (SerialCharNum & 0x01)
    df80:	e2 95       	swap	r30
    df82:	ef 70       	andi	r30, 0x0F	; 15
					{
						SerialByte >>= 4;
    df84:	3f 5f       	subi	r19, 0xFF	; 255
    df86:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    df88:	8e 2f       	mov	r24, r30
					}

					SerialByte &= 0x0F;
    df8a:	90 e0       	ldi	r25, 0x00	; 0
    df8c:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    df8e:	10 f0       	brcs	.+4      	; 0xdf94 <USB_Device_ProcessControlRequest+0x19a>
    df90:	c7 96       	adiw	r24, 0x37	; 55
    df92:	01 c0       	rjmp	.+2      	; 0xdf96 <USB_Device_ProcessControlRequest+0x19c>
    df94:	c0 96       	adiw	r24, 0x30	; 48
    df96:	8d 93       	st	X+, r24
    df98:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    df9a:	2f 5f       	subi	r18, 0xFF	; 255
    df9c:	2c 31       	cpi	r18, 0x1C	; 28
    df9e:	39 f7       	brne	.-50     	; 0xdf6e <USB_Device_ProcessControlRequest+0x174>
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    dfa0:	4f bf       	out	0x3f, r20	; 63

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
    dfa2:	61 d2       	rcall	.+1218   	; 0xe466 <Endpoint_ClearSETUP>
    dfa4:	6a e3       	ldi	r22, 0x3A	; 58

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    dfa6:	70 e0       	ldi	r23, 0x00	; 0
    dfa8:	ce 01       	movw	r24, r28
    dfaa:	01 96       	adiw	r24, 0x01	; 1
    dfac:	a5 d0       	rcall	.+330    	; 0xe0f8 <Endpoint_Write_Control_Stream_LE>
    dfae:	0f c0       	rjmp	.+30     	; 0xdfce <USB_Device_ProcessControlRequest+0x1d4>
    dfb0:	ae 01       	movw	r20, r28
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    dfb2:	4f 5f       	subi	r20, 0xFF	; 255
    dfb4:	5f 4f       	sbci	r21, 0xFF	; 255
    dfb6:	60 91 51 34 	lds	r22, 0x3451	; 0x803451 <USB_ControlRequest+0x4>
    dfba:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <CALLBACK_USB_GetDescriptor>
    dfbe:	8c 01       	movw	r16, r24
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
    dfc0:	89 2b       	or	r24, r25
    dfc2:	71 f1       	breq	.+92     	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    dfc4:	50 d2       	rcall	.+1184   	; 0xe466 <Endpoint_ClearSETUP>
    dfc6:	b8 01       	movw	r22, r16
    dfc8:	89 81       	ldd	r24, Y+1	; 0x01
    dfca:	9a 81       	ldd	r25, Y+2	; 0x02
    dfcc:	11 d1       	rcall	.+546    	; 0xe1f0 <Endpoint_Write_Control_PStream_LE>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
    dfce:	a7 d1       	rcall	.+846    	; 0xe31e <Endpoint_ClearOUT>
    dfd0:	27 c0       	rjmp	.+78     	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    dfd2:	80 38       	cpi	r24, 0x80	; 128
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    dfd4:	29 f5       	brne	.+74     	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
    dfd6:	47 d2       	rcall	.+1166   	; 0xe466 <Endpoint_ClearSETUP>
    dfd8:	80 91 48 34 	lds	r24, 0x3448	; 0x803448 <USB_Device_ConfigurationNumber>

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    dfdc:	bf d1       	rcall	.+894    	; 0xe35c <Endpoint_Write_8>
    dfde:	86 d1       	rcall	.+780    	; 0xe2ec <Endpoint_ClearIN>
	Endpoint_ClearIN();
    dfe0:	31 d3       	rcall	.+1634   	; 0xe644 <Endpoint_ClearStatusStage>
    dfe2:	1e c0       	rjmp	.+60     	; 0xe020 <USB_Device_ProcessControlRequest+0x226>

	Endpoint_ClearStatusStage();
    dfe4:	81 11       	cpse	r24, r1
    dfe6:	1c c0       	rjmp	.+56     	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    dfe8:	80 91 4f 34 	lds	r24, 0x344F	; 0x80344f <USB_ControlRequest+0x2>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    dfec:	90 91 50 34 	lds	r25, 0x3450	; 0x803450 <USB_ControlRequest+0x3>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    dff0:	99 27       	eor	r25, r25
    dff2:	02 97       	sbiw	r24, 0x02	; 2
    dff4:	ac f4       	brge	.+42     	; 0xe020 <USB_Device_ProcessControlRequest+0x226>
    dff6:	37 d2       	rcall	.+1134   	; 0xe466 <Endpoint_ClearSETUP>
    dff8:	80 91 4f 34 	lds	r24, 0x344F	; 0x80344f <USB_ControlRequest+0x2>
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
    dffc:	80 93 48 34 	sts	0x3448, r24	; 0x803448 <USB_Device_ConfigurationNumber>

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    e000:	21 d3       	rcall	.+1602   	; 0xe644 <Endpoint_ClearStatusStage>

	Endpoint_ClearStatusStage();
    e002:	80 91 48 34 	lds	r24, 0x3448	; 0x803448 <USB_Device_ConfigurationNumber>

	if (USB_Device_ConfigurationNumber)
    e006:	81 11       	cpse	r24, r1
    e008:	06 c0       	rjmp	.+12     	; 0xe016 <USB_Device_ProcessControlRequest+0x21c>
    e00a:	80 91 c3 04 	lds	r24, 0x04C3	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7004c3>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    e00e:	81 11       	cpse	r24, r1
    e010:	02 c0       	rjmp	.+4      	; 0xe016 <USB_Device_ProcessControlRequest+0x21c>
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    e012:	81 e0       	ldi	r24, 0x01	; 1
    e014:	01 c0       	rjmp	.+2      	; 0xe018 <USB_Device_ProcessControlRequest+0x21e>
    e016:	84 e0       	ldi	r24, 0x04	; 4
    e018:	80 93 4c 34 	sts	0x344C, r24	; 0x80344c <USB_DeviceState>
    e01c:	0e 94 83 1c 	call	0x3906	; 0x3906 <EVENT_USB_Device_ConfigurationChanged>

	EVENT_USB_Device_ConfigurationChanged();
    e020:	08 d2       	rcall	.+1040   	; 0xe432 <Endpoint_IsSETUPReceived>
    e022:	88 23       	and	r24, r24
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    e024:	11 f0       	breq	.+4      	; 0xe02a <USB_Device_ProcessControlRequest+0x230>
    e026:	1f d2       	rcall	.+1086   	; 0xe466 <Endpoint_ClearSETUP>
    e028:	4a d2       	rcall	.+1172   	; 0xe4be <Endpoint_StallTransaction>
    e02a:	ea 96       	adiw	r28, 0x3a	; 58
	{
		Endpoint_ClearSETUP();
    e02c:	cd bf       	out	0x3d, r28	; 61
    e02e:	de bf       	out	0x3e, r29	; 62
		Endpoint_StallTransaction();
    e030:	df 91       	pop	r29
    e032:	cf 91       	pop	r28
	}
}
    e034:	1f 91       	pop	r17
    e036:	0f 91       	pop	r16
    e038:	08 95       	ret

0000e03a <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    e03a:	08 95       	ret

0000e03c <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    e03c:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    e03e:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>
    e042:	88 23       	and	r24, r24
    e044:	51 f0       	breq	.+20     	; 0xe05a <USB_USBTask+0x1e>
			 *  \return Index of the currently selected endpoint.
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				return USB_Endpoint_SelectedEndpoint;
    e046:	c0 91 59 34 	lds	r28, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
	  return;

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    e04a:	80 e0       	ldi	r24, 0x00	; 0
    e04c:	97 d1       	rcall	.+814    	; 0xe37c <Endpoint_SelectEndpoint>

	if (Endpoint_IsSETUPReceived())
    e04e:	f1 d1       	rcall	.+994    	; 0xe432 <Endpoint_IsSETUPReceived>
    e050:	81 11       	cpse	r24, r1
	  USB_Device_ProcessControlRequest();
    e052:	d3 de       	rcall	.-602    	; 0xddfa <USB_Device_ProcessControlRequest>

	Endpoint_SelectEndpoint(PrevEndpoint);
    e054:	8c 2f       	mov	r24, r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    e056:	cf 91       	pop	r28
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
	  USB_Device_ProcessControlRequest();

	Endpoint_SelectEndpoint(PrevEndpoint);
    e058:	91 c1       	rjmp	.+802    	; 0xe37c <Endpoint_SelectEndpoint>
    e05a:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    e05c:	08 95       	ret

0000e05e <Endpoint_Write_Stream_LE>:
    e05e:	cf 92       	push	r12
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    e060:	df 92       	push	r13
    e062:	ef 92       	push	r14
    e064:	ff 92       	push	r15
    e066:	0f 93       	push	r16
    e068:	1f 93       	push	r17
    e06a:	cf 93       	push	r28
    e06c:	df 93       	push	r29
    e06e:	ec 01       	movw	r28, r24
    e070:	8b 01       	movw	r16, r22
    e072:	7a 01       	movw	r14, r20
    e074:	fd d2       	rcall	.+1530   	; 0xe670 <Endpoint_WaitUntilReady>
    e076:	81 11       	cpse	r24, r1
    e078:	36 c0       	rjmp	.+108    	; 0xe0e6 <Endpoint_Write_Stream_LE+0x88>
    e07a:	e1 14       	cp	r14, r1
    e07c:	f1 04       	cpc	r15, r1
    e07e:	39 f0       	breq	.+14     	; 0xe08e <Endpoint_Write_Stream_LE+0x30>
    e080:	f7 01       	movw	r30, r14
    e082:	80 81       	ld	r24, Z
    e084:	91 81       	ldd	r25, Z+1	; 0x01
    e086:	08 1b       	sub	r16, r24
    e088:	19 0b       	sbc	r17, r25
    e08a:	c8 0f       	add	r28, r24
    e08c:	d9 1f       	adc	r29, r25
    e08e:	c1 2c       	mov	r12, r1
    e090:	d1 2c       	mov	r13, r1
    e092:	01 15       	cp	r16, r1
    e094:	11 05       	cpc	r17, r1
    e096:	31 f1       	breq	.+76     	; 0xe0e4 <Endpoint_Write_Stream_LE+0x86>
    e098:	80 91 55 34 	lds	r24, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e09c:	90 91 56 34 	lds	r25, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e0a0:	fc 01       	movw	r30, r24
    e0a2:	ef 5b       	subi	r30, 0xBF	; 191
    e0a4:	ff 4f       	sbci	r31, 0xFF	; 255
    e0a6:	20 81       	ld	r18, Z
    e0a8:	31 97       	sbiw	r30, 0x01	; 1
    e0aa:	80 81       	ld	r24, Z
    e0ac:	28 17       	cp	r18, r24
    e0ae:	90 f0       	brcs	.+36     	; 0xe0d4 <Endpoint_Write_Stream_LE+0x76>
    e0b0:	1d d1       	rcall	.+570    	; 0xe2ec <Endpoint_ClearIN>
    e0b2:	c4 df       	rcall	.-120    	; 0xe03c <USB_USBTask>
    e0b4:	e1 14       	cp	r14, r1
    e0b6:	f1 04       	cpc	r15, r1
    e0b8:	49 f0       	breq	.+18     	; 0xe0cc <Endpoint_Write_Stream_LE+0x6e>
    e0ba:	f7 01       	movw	r30, r14
    e0bc:	80 81       	ld	r24, Z
    e0be:	91 81       	ldd	r25, Z+1	; 0x01
    e0c0:	c8 0e       	add	r12, r24
    e0c2:	d9 1e       	adc	r13, r25
    e0c4:	c0 82       	st	Z, r12
    e0c6:	d1 82       	std	Z+1, r13	; 0x01
    e0c8:	85 e0       	ldi	r24, 0x05	; 5
    e0ca:	0d c0       	rjmp	.+26     	; 0xe0e6 <Endpoint_Write_Stream_LE+0x88>
    e0cc:	d1 d2       	rcall	.+1442   	; 0xe670 <Endpoint_WaitUntilReady>
    e0ce:	88 23       	and	r24, r24
    e0d0:	01 f3       	breq	.-64     	; 0xe092 <Endpoint_Write_Stream_LE+0x34>
    e0d2:	09 c0       	rjmp	.+18     	; 0xe0e6 <Endpoint_Write_Stream_LE+0x88>
    e0d4:	89 91       	ld	r24, Y+
    e0d6:	42 d1       	rcall	.+644    	; 0xe35c <Endpoint_Write_8>
    e0d8:	01 50       	subi	r16, 0x01	; 1
    e0da:	11 09       	sbc	r17, r1
    e0dc:	ff ef       	ldi	r31, 0xFF	; 255
    e0de:	cf 1a       	sub	r12, r31
    e0e0:	df 0a       	sbc	r13, r31
    e0e2:	d7 cf       	rjmp	.-82     	; 0xe092 <Endpoint_Write_Stream_LE+0x34>
    e0e4:	80 e0       	ldi	r24, 0x00	; 0
    e0e6:	df 91       	pop	r29
    e0e8:	cf 91       	pop	r28
    e0ea:	1f 91       	pop	r17
    e0ec:	0f 91       	pop	r16
    e0ee:	ff 90       	pop	r15
    e0f0:	ef 90       	pop	r14
    e0f2:	df 90       	pop	r13
    e0f4:	cf 90       	pop	r12
    e0f6:	08 95       	ret

0000e0f8 <Endpoint_Write_Control_Stream_LE>:
    e0f8:	df 92       	push	r13
    e0fa:	ef 92       	push	r14
    e0fc:	ff 92       	push	r15
    e0fe:	0f 93       	push	r16
    e100:	1f 93       	push	r17
    e102:	cf 93       	push	r28
    e104:	df 93       	push	r29
    e106:	d8 2f       	mov	r29, r24
    e108:	c9 2f       	mov	r28, r25
    e10a:	8b 01       	movw	r16, r22
    e10c:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e110:	80 68       	ori	r24, 0x80	; 128
    e112:	34 d1       	rcall	.+616    	; 0xe37c <Endpoint_SelectEndpoint>
    e114:	80 91 53 34 	lds	r24, 0x3453	; 0x803453 <USB_ControlRequest+0x6>
    e118:	90 91 54 34 	lds	r25, 0x3454	; 0x803454 <USB_ControlRequest+0x7>
    e11c:	80 17       	cp	r24, r16
    e11e:	91 07       	cpc	r25, r17
    e120:	28 f0       	brcs	.+10     	; 0xe12c <Endpoint_Write_Control_Stream_LE+0x34>
    e122:	01 15       	cp	r16, r1
    e124:	11 05       	cpc	r17, r1
    e126:	19 f4       	brne	.+6      	; 0xe12e <Endpoint_Write_Control_Stream_LE+0x36>
    e128:	e1 d0       	rcall	.+450    	; 0xe2ec <Endpoint_ClearIN>
    e12a:	01 c0       	rjmp	.+2      	; 0xe12e <Endpoint_Write_Control_Stream_LE+0x36>
    e12c:	8c 01       	movw	r16, r24
    e12e:	ed 2e       	mov	r14, r29
    e130:	fc 2e       	mov	r15, r28
    e132:	d1 2c       	mov	r13, r1
    e134:	01 15       	cp	r16, r1
    e136:	11 05       	cpc	r17, r1
    e138:	09 f4       	brne	.+2      	; 0xe13c <Endpoint_Write_Control_Stream_LE+0x44>
    e13a:	40 c0       	rjmp	.+128    	; 0xe1bc <Endpoint_Write_Control_Stream_LE+0xc4>
    e13c:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>
    e140:	81 11       	cpse	r24, r1
    e142:	02 c0       	rjmp	.+4      	; 0xe148 <Endpoint_Write_Control_Stream_LE+0x50>
    e144:	82 e0       	ldi	r24, 0x02	; 2
    e146:	4c c0       	rjmp	.+152    	; 0xe1e0 <Endpoint_Write_Control_Stream_LE+0xe8>
    e148:	85 30       	cpi	r24, 0x05	; 5
    e14a:	11 f4       	brne	.+4      	; 0xe150 <Endpoint_Write_Control_Stream_LE+0x58>
    e14c:	83 e0       	ldi	r24, 0x03	; 3
    e14e:	48 c0       	rjmp	.+144    	; 0xe1e0 <Endpoint_Write_Control_Stream_LE+0xe8>
    e150:	70 d1       	rcall	.+736    	; 0xe432 <Endpoint_IsSETUPReceived>
    e152:	88 23       	and	r24, r24
    e154:	11 f0       	breq	.+4      	; 0xe15a <Endpoint_Write_Control_Stream_LE+0x62>
    e156:	81 e0       	ldi	r24, 0x01	; 1
    e158:	43 c0       	rjmp	.+134    	; 0xe1e0 <Endpoint_Write_Control_Stream_LE+0xe8>
    e15a:	51 d1       	rcall	.+674    	; 0xe3fe <Endpoint_IsOUTReceived>
    e15c:	81 11       	cpse	r24, r1
    e15e:	3c c0       	rjmp	.+120    	; 0xe1d8 <Endpoint_Write_Control_Stream_LE+0xe0>
    e160:	42 d1       	rcall	.+644    	; 0xe3e6 <Endpoint_IsINReady>
    e162:	88 23       	and	r24, r24
    e164:	39 f3       	breq	.-50     	; 0xe134 <Endpoint_Write_Control_Stream_LE+0x3c>
    e166:	20 91 59 34 	lds	r18, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e16a:	80 91 55 34 	lds	r24, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e16e:	90 91 56 34 	lds	r25, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e172:	fc 01       	movw	r30, r24
    e174:	27 ff       	sbrs	r18, 7
    e176:	05 c0       	rjmp	.+10     	; 0xe182 <Endpoint_Write_Control_Stream_LE+0x8a>
    e178:	ef 5b       	subi	r30, 0xBF	; 191
    e17a:	ff 4f       	sbci	r31, 0xFF	; 255
    e17c:	c0 81       	ld	r28, Z
    e17e:	d0 e0       	ldi	r29, 0x00	; 0
    e180:	13 c0       	rjmp	.+38     	; 0xe1a8 <Endpoint_Write_Control_Stream_LE+0xb0>
    e182:	e0 5c       	subi	r30, 0xC0	; 192
    e184:	ff 4f       	sbci	r31, 0xFF	; 255
    e186:	c0 81       	ld	r28, Z
    e188:	31 96       	adiw	r30, 0x01	; 1
    e18a:	80 81       	ld	r24, Z
    e18c:	d0 e0       	ldi	r29, 0x00	; 0
    e18e:	c8 1b       	sub	r28, r24
    e190:	d1 09       	sbc	r29, r1
    e192:	0a c0       	rjmp	.+20     	; 0xe1a8 <Endpoint_Write_Control_Stream_LE+0xb0>
    e194:	c8 30       	cpi	r28, 0x08	; 8
    e196:	d1 05       	cpc	r29, r1
    e198:	50 f4       	brcc	.+20     	; 0xe1ae <Endpoint_Write_Control_Stream_LE+0xb6>
    e19a:	f7 01       	movw	r30, r14
    e19c:	81 91       	ld	r24, Z+
    e19e:	7f 01       	movw	r14, r30
    e1a0:	dd d0       	rcall	.+442    	; 0xe35c <Endpoint_Write_8>
    e1a2:	01 50       	subi	r16, 0x01	; 1
    e1a4:	11 09       	sbc	r17, r1
    e1a6:	21 96       	adiw	r28, 0x01	; 1
    e1a8:	01 15       	cp	r16, r1
    e1aa:	11 05       	cpc	r17, r1
    e1ac:	99 f7       	brne	.-26     	; 0xe194 <Endpoint_Write_Control_Stream_LE+0x9c>
    e1ae:	dd 24       	eor	r13, r13
    e1b0:	d3 94       	inc	r13
    e1b2:	28 97       	sbiw	r28, 0x08	; 8
    e1b4:	09 f0       	breq	.+2      	; 0xe1b8 <Endpoint_Write_Control_Stream_LE+0xc0>
    e1b6:	d1 2c       	mov	r13, r1
    e1b8:	99 d0       	rcall	.+306    	; 0xe2ec <Endpoint_ClearIN>
    e1ba:	bc cf       	rjmp	.-136    	; 0xe134 <Endpoint_Write_Control_Stream_LE+0x3c>
    e1bc:	d1 10       	cpse	r13, r1
    e1be:	be cf       	rjmp	.-132    	; 0xe13c <Endpoint_Write_Control_Stream_LE+0x44>
    e1c0:	0b c0       	rjmp	.+22     	; 0xe1d8 <Endpoint_Write_Control_Stream_LE+0xe0>
    e1c2:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>
    e1c6:	88 23       	and	r24, r24
    e1c8:	09 f4       	brne	.+2      	; 0xe1cc <Endpoint_Write_Control_Stream_LE+0xd4>
    e1ca:	bc cf       	rjmp	.-136    	; 0xe144 <Endpoint_Write_Control_Stream_LE+0x4c>
    e1cc:	85 30       	cpi	r24, 0x05	; 5
    e1ce:	09 f4       	brne	.+2      	; 0xe1d2 <Endpoint_Write_Control_Stream_LE+0xda>
    e1d0:	bd cf       	rjmp	.-134    	; 0xe14c <Endpoint_Write_Control_Stream_LE+0x54>
    e1d2:	2f d1       	rcall	.+606    	; 0xe432 <Endpoint_IsSETUPReceived>
    e1d4:	81 11       	cpse	r24, r1
    e1d6:	bf cf       	rjmp	.-130    	; 0xe156 <Endpoint_Write_Control_Stream_LE+0x5e>
    e1d8:	12 d1       	rcall	.+548    	; 0xe3fe <Endpoint_IsOUTReceived>
    e1da:	88 23       	and	r24, r24
    e1dc:	91 f3       	breq	.-28     	; 0xe1c2 <Endpoint_Write_Control_Stream_LE+0xca>
    e1de:	80 e0       	ldi	r24, 0x00	; 0
    e1e0:	df 91       	pop	r29
    e1e2:	cf 91       	pop	r28
    e1e4:	1f 91       	pop	r17
    e1e6:	0f 91       	pop	r16
    e1e8:	ff 90       	pop	r15
    e1ea:	ef 90       	pop	r14
    e1ec:	df 90       	pop	r13
    e1ee:	08 95       	ret

0000e1f0 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    e1f0:	df 92       	push	r13
    e1f2:	ef 92       	push	r14
    e1f4:	ff 92       	push	r15
    e1f6:	0f 93       	push	r16
    e1f8:	1f 93       	push	r17
    e1fa:	cf 93       	push	r28
    e1fc:	df 93       	push	r29
    e1fe:	d8 2f       	mov	r29, r24
    e200:	c9 2f       	mov	r28, r25
    e202:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    e204:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e208:	80 68       	ori	r24, 0x80	; 128
    e20a:	b8 d0       	rcall	.+368    	; 0xe37c <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
    e20c:	80 91 53 34 	lds	r24, 0x3453	; 0x803453 <USB_ControlRequest+0x6>
    e210:	90 91 54 34 	lds	r25, 0x3454	; 0x803454 <USB_ControlRequest+0x7>
    e214:	80 17       	cp	r24, r16
    e216:	91 07       	cpc	r25, r17
    e218:	28 f0       	brcs	.+10     	; 0xe224 <Endpoint_Write_Control_PStream_LE+0x34>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    e21a:	01 15       	cp	r16, r1
    e21c:	11 05       	cpc	r17, r1
	  Endpoint_ClearIN();
    e21e:	19 f4       	brne	.+6      	; 0xe226 <Endpoint_Write_Control_PStream_LE+0x36>
    e220:	65 d0       	rcall	.+202    	; 0xe2ec <Endpoint_ClearIN>
    e222:	01 c0       	rjmp	.+2      	; 0xe226 <Endpoint_Write_Control_PStream_LE+0x36>
    e224:	8c 01       	movw	r16, r24
    e226:	ed 2e       	mov	r14, r29
    e228:	fc 2e       	mov	r15, r28
    e22a:	d1 2c       	mov	r13, r1

	while (Length || LastPacketFull)
    e22c:	01 15       	cp	r16, r1
    e22e:	11 05       	cpc	r17, r1
    e230:	09 f4       	brne	.+2      	; 0xe234 <Endpoint_Write_Control_PStream_LE+0x44>
    e232:	42 c0       	rjmp	.+132    	; 0xe2b8 <Endpoint_Write_Control_PStream_LE+0xc8>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    e234:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    e238:	81 11       	cpse	r24, r1
    e23a:	02 c0       	rjmp	.+4      	; 0xe240 <Endpoint_Write_Control_PStream_LE+0x50>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    e23c:	82 e0       	ldi	r24, 0x02	; 2
    e23e:	4e c0       	rjmp	.+156    	; 0xe2dc <Endpoint_Write_Control_PStream_LE+0xec>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    e240:	85 30       	cpi	r24, 0x05	; 5
    e242:	11 f4       	brne	.+4      	; 0xe248 <Endpoint_Write_Control_PStream_LE+0x58>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    e244:	83 e0       	ldi	r24, 0x03	; 3
		else if (Endpoint_IsSETUPReceived())
    e246:	4a c0       	rjmp	.+148    	; 0xe2dc <Endpoint_Write_Control_PStream_LE+0xec>
    e248:	f4 d0       	rcall	.+488    	; 0xe432 <Endpoint_IsSETUPReceived>
    e24a:	88 23       	and	r24, r24
		  return ENDPOINT_RWCSTREAM_HostAborted;
    e24c:	11 f0       	breq	.+4      	; 0xe252 <Endpoint_Write_Control_PStream_LE+0x62>
    e24e:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsOUTReceived())
    e250:	45 c0       	rjmp	.+138    	; 0xe2dc <Endpoint_Write_Control_PStream_LE+0xec>
    e252:	d5 d0       	rcall	.+426    	; 0xe3fe <Endpoint_IsOUTReceived>
    e254:	81 11       	cpse	r24, r1
		  break;

		if (Endpoint_IsINReady())
    e256:	3e c0       	rjmp	.+124    	; 0xe2d4 <Endpoint_Write_Control_PStream_LE+0xe4>
    e258:	c6 d0       	rcall	.+396    	; 0xe3e6 <Endpoint_IsINReady>
    e25a:	88 23       	and	r24, r24
    e25c:	39 f3       	breq	.-50     	; 0xe22c <Endpoint_Write_Control_PStream_LE+0x3c>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    e25e:	20 91 59 34 	lds	r18, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e262:	80 91 55 34 	lds	r24, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e266:	90 91 56 34 	lds	r25, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
				  return USB_Endpoint_SelectedFIFO->Position;
    e26a:	fc 01       	movw	r30, r24
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    e26c:	27 ff       	sbrs	r18, 7
    e26e:	05 c0       	rjmp	.+10     	; 0xe27a <Endpoint_Write_Control_PStream_LE+0x8a>
				  return USB_Endpoint_SelectedFIFO->Position;
    e270:	ef 5b       	subi	r30, 0xBF	; 191
    e272:	ff 4f       	sbci	r31, 0xFF	; 255
    e274:	c0 81       	ld	r28, Z
    e276:	d0 e0       	ldi	r29, 0x00	; 0
    e278:	15 c0       	rjmp	.+42     	; 0xe2a4 <Endpoint_Write_Control_PStream_LE+0xb4>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    e27a:	e0 5c       	subi	r30, 0xC0	; 192
    e27c:	ff 4f       	sbci	r31, 0xFF	; 255
    e27e:	c0 81       	ld	r28, Z
    e280:	31 96       	adiw	r30, 0x01	; 1
    e282:	80 81       	ld	r24, Z
    e284:	d0 e0       	ldi	r29, 0x00	; 0
    e286:	c8 1b       	sub	r28, r24
    e288:	d1 09       	sbc	r29, r1
    e28a:	0c c0       	rjmp	.+24     	; 0xe2a4 <Endpoint_Write_Control_PStream_LE+0xb4>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    e28c:	c8 30       	cpi	r28, 0x08	; 8
    e28e:	d1 05       	cpc	r29, r1
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    e290:	60 f4       	brcc	.+24     	; 0xe2aa <Endpoint_Write_Control_PStream_LE+0xba>
    e292:	f7 01       	movw	r30, r14
    e294:	84 91       	lpm	r24, Z
    e296:	62 d0       	rcall	.+196    	; 0xe35c <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    e298:	ff ef       	ldi	r31, 0xFF	; 255
    e29a:	ef 1a       	sub	r14, r31
    e29c:	ff 0a       	sbc	r15, r31
				Length--;
    e29e:	01 50       	subi	r16, 0x01	; 1
    e2a0:	11 09       	sbc	r17, r1
				BytesInEndpoint++;
    e2a2:	21 96       	adiw	r28, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    e2a4:	01 15       	cp	r16, r1
    e2a6:	11 05       	cpc	r17, r1
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    e2a8:	89 f7       	brne	.-30     	; 0xe28c <Endpoint_Write_Control_PStream_LE+0x9c>
    e2aa:	dd 24       	eor	r13, r13
    e2ac:	d3 94       	inc	r13
    e2ae:	28 97       	sbiw	r28, 0x08	; 8
    e2b0:	09 f0       	breq	.+2      	; 0xe2b4 <Endpoint_Write_Control_PStream_LE+0xc4>
			Endpoint_ClearIN();
    e2b2:	d1 2c       	mov	r13, r1
    e2b4:	1b d0       	rcall	.+54     	; 0xe2ec <Endpoint_ClearIN>
    e2b6:	ba cf       	rjmp	.-140    	; 0xe22c <Endpoint_Write_Control_PStream_LE+0x3c>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    e2b8:	d1 10       	cpse	r13, r1
    e2ba:	bc cf       	rjmp	.-136    	; 0xe234 <Endpoint_Write_Control_PStream_LE+0x44>
    e2bc:	0b c0       	rjmp	.+22     	; 0xe2d4 <Endpoint_Write_Control_PStream_LE+0xe4>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    e2be:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    e2c2:	88 23       	and	r24, r24
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    e2c4:	09 f4       	brne	.+2      	; 0xe2c8 <Endpoint_Write_Control_PStream_LE+0xd8>
    e2c6:	ba cf       	rjmp	.-140    	; 0xe23c <Endpoint_Write_Control_PStream_LE+0x4c>
    e2c8:	85 30       	cpi	r24, 0x05	; 5
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    e2ca:	09 f4       	brne	.+2      	; 0xe2ce <Endpoint_Write_Control_PStream_LE+0xde>
    e2cc:	bb cf       	rjmp	.-138    	; 0xe244 <Endpoint_Write_Control_PStream_LE+0x54>
    e2ce:	b1 d0       	rcall	.+354    	; 0xe432 <Endpoint_IsSETUPReceived>
    e2d0:	81 11       	cpse	r24, r1
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    e2d2:	bd cf       	rjmp	.-134    	; 0xe24e <Endpoint_Write_Control_PStream_LE+0x5e>
    e2d4:	94 d0       	rcall	.+296    	; 0xe3fe <Endpoint_IsOUTReceived>
    e2d6:	88 23       	and	r24, r24
    e2d8:	91 f3       	breq	.-28     	; 0xe2be <Endpoint_Write_Control_PStream_LE+0xce>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    e2da:	80 e0       	ldi	r24, 0x00	; 0
}
    e2dc:	df 91       	pop	r29
    e2de:	cf 91       	pop	r28
    e2e0:	1f 91       	pop	r17
    e2e2:	0f 91       	pop	r16
    e2e4:	ff 90       	pop	r15
    e2e6:	ef 90       	pop	r14
    e2e8:	df 90       	pop	r13
    e2ea:	08 95       	ret

0000e2ec <Endpoint_ClearIN>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_ClearIN(void)
{
	USB_Endpoint_SelectedHandle->CNT     = USB_Endpoint_SelectedFIFO->Position;
    e2ec:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e2f0:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e2f4:	a0 91 55 34 	lds	r26, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e2f8:	b0 91 56 34 	lds	r27, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e2fc:	af 5b       	subi	r26, 0xBF	; 191
    e2fe:	bf 4f       	sbci	r27, 0xFF	; 255
    e300:	8c 91       	ld	r24, X
    e302:	90 e0       	ldi	r25, 0x00	; 0
    e304:	82 83       	std	Z+2, r24	; 0x02
    e306:	93 83       	std	Z+3, r25	; 0x03
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    e308:	80 81       	ld	r24, Z
    e30a:	8d 79       	andi	r24, 0x9D	; 157
    e30c:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    e30e:	e0 91 55 34 	lds	r30, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e312:	f0 91 56 34 	lds	r31, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e316:	ef 5b       	subi	r30, 0xBF	; 191
    e318:	ff 4f       	sbci	r31, 0xFF	; 255
    e31a:	10 82       	st	Z, r1
    e31c:	08 95       	ret

0000e31e <Endpoint_ClearOUT>:
}

void Endpoint_ClearOUT(void)
{
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    e31e:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e322:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e326:	80 81       	ld	r24, Z
    e328:	8d 79       	andi	r24, 0x9D	; 157
    e32a:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    e32c:	e0 91 55 34 	lds	r30, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e330:	f0 91 56 34 	lds	r31, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e334:	ef 5b       	subi	r30, 0xBF	; 191
    e336:	ff 4f       	sbci	r31, 0xFF	; 255
    e338:	10 82       	st	Z, r1
    e33a:	08 95       	ret

0000e33c <Endpoint_Read_8>:
	}
}

uint8_t Endpoint_Read_8(void)
{
	return USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++];
    e33c:	80 91 55 34 	lds	r24, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e340:	90 91 56 34 	lds	r25, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e344:	fc 01       	movw	r30, r24
    e346:	ef 5b       	subi	r30, 0xBF	; 191
    e348:	ff 4f       	sbci	r31, 0xFF	; 255
    e34a:	20 81       	ld	r18, Z
    e34c:	31 e0       	ldi	r19, 0x01	; 1
    e34e:	32 0f       	add	r19, r18
    e350:	30 83       	st	Z, r19
    e352:	fc 01       	movw	r30, r24
    e354:	e2 0f       	add	r30, r18
    e356:	f1 1d       	adc	r31, r1
    e358:	80 81       	ld	r24, Z
}
    e35a:	08 95       	ret

0000e35c <Endpoint_Write_8>:

void Endpoint_Write_8(const uint8_t Data)
{
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
    e35c:	20 91 55 34 	lds	r18, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e360:	30 91 56 34 	lds	r19, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e364:	f9 01       	movw	r30, r18
    e366:	ef 5b       	subi	r30, 0xBF	; 191
    e368:	ff 4f       	sbci	r31, 0xFF	; 255
    e36a:	90 81       	ld	r25, Z
    e36c:	41 e0       	ldi	r20, 0x01	; 1
    e36e:	49 0f       	add	r20, r25
    e370:	40 83       	st	Z, r20
    e372:	f9 01       	movw	r30, r18
    e374:	e9 0f       	add	r30, r25
    e376:	f1 1d       	adc	r31, r1
    e378:	80 83       	st	Z, r24
    e37a:	08 95       	ret

0000e37c <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
    e37c:	80 93 59 34 	sts	0x3459, r24	; 0x803459 <USB_Endpoint_SelectedEndpoint>

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
    e380:	48 2f       	mov	r20, r24
    e382:	4f 70       	andi	r20, 0x0F	; 15
    e384:	50 e0       	ldi	r21, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
    e386:	60 91 c6 04 	lds	r22, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7004c6>
    e38a:	70 91 c7 04 	lds	r23, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7004c7>
    e38e:	9a 01       	movw	r18, r20
    e390:	94 e0       	ldi	r25, 0x04	; 4
    e392:	22 0f       	add	r18, r18
    e394:	33 1f       	adc	r19, r19
    e396:	9a 95       	dec	r25
    e398:	e1 f7       	brne	.-8      	; 0xe392 <Endpoint_SelectEndpoint+0x16>

	if (Address & ENDPOINT_DIR_IN)
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    e39a:	e4 e8       	ldi	r30, 0x84	; 132
	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;

	if (Address & ENDPOINT_DIR_IN)
    e39c:	87 ff       	sbrs	r24, 7
    e39e:	11 c0       	rjmp	.+34     	; 0xe3c2 <Endpoint_SelectEndpoint+0x46>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    e3a0:	e4 9f       	mul	r30, r20
    e3a2:	c0 01       	movw	r24, r0
    e3a4:	e5 9f       	mul	r30, r21
    e3a6:	90 0d       	add	r25, r0
    e3a8:	11 24       	eor	r1, r1
    e3aa:	84 56       	subi	r24, 0x64	; 100
    e3ac:	9b 4c       	sbci	r25, 0xCB	; 203
    e3ae:	80 93 55 34 	sts	0x3455, r24	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e3b2:	90 93 56 34 	sts	0x3456, r25	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
    e3b6:	c9 01       	movw	r24, r18
    e3b8:	08 96       	adiw	r24, 0x08	; 8
    e3ba:	9b 01       	movw	r18, r22
    e3bc:	28 0f       	add	r18, r24
    e3be:	39 1f       	adc	r19, r25
    e3c0:	0d c0       	rjmp	.+26     	; 0xe3dc <Endpoint_SelectEndpoint+0x60>
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
    e3c2:	e4 9f       	mul	r30, r20
    e3c4:	c0 01       	movw	r24, r0
    e3c6:	e5 9f       	mul	r30, r21
    e3c8:	90 0d       	add	r25, r0
    e3ca:	11 24       	eor	r1, r1
    e3cc:	86 5a       	subi	r24, 0xA6	; 166
    e3ce:	9b 4c       	sbci	r25, 0xCB	; 203
    e3d0:	80 93 55 34 	sts	0x3455, r24	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e3d4:	90 93 56 34 	sts	0x3456, r25	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
    e3d8:	26 0f       	add	r18, r22
    e3da:	37 1f       	adc	r19, r23
    e3dc:	20 93 57 34 	sts	0x3457, r18	; 0x803457 <USB_Endpoint_SelectedHandle>
    e3e0:	30 93 58 34 	sts	0x3458, r19	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e3e4:	08 95       	ret

0000e3e6 <Endpoint_IsINReady>:
volatile USB_EP_t*        USB_Endpoint_SelectedHandle;
volatile Endpoint_FIFO_t* USB_Endpoint_SelectedFIFO;

bool Endpoint_IsINReady(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    e3e6:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e3ea:	80 68       	ori	r24, 0x80	; 128
    e3ec:	c7 df       	rcall	.-114    	; 0xe37c <Endpoint_SelectEndpoint>

	return ((USB_Endpoint_SelectedHandle->STATUS & USB_EP_BUSNACK0_bm) ? true : false);
    e3ee:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e3f2:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e3f6:	80 81       	ld	r24, Z
}
    e3f8:	86 95       	lsr	r24
    e3fa:	81 70       	andi	r24, 0x01	; 1
    e3fc:	08 95       	ret

0000e3fe <Endpoint_IsOUTReceived>:

bool Endpoint_IsOUTReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    e3fe:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e402:	8f 77       	andi	r24, 0x7F	; 127
    e404:	bb df       	rcall	.-138    	; 0xe37c <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_TRNCOMPL0_bm)
    e406:	a0 91 57 34 	lds	r26, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e40a:	b0 91 58 34 	lds	r27, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e40e:	8c 91       	ld	r24, X
    e410:	85 ff       	sbrs	r24, 5
    e412:	0d c0       	rjmp	.+26     	; 0xe42e <Endpoint_IsOUTReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    e414:	e0 91 55 34 	lds	r30, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e418:	f0 91 56 34 	lds	r31, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e41c:	12 96       	adiw	r26, 0x02	; 2
    e41e:	8d 91       	ld	r24, X+
    e420:	9c 91       	ld	r25, X
    e422:	13 97       	sbiw	r26, 0x03	; 3
    e424:	e0 5c       	subi	r30, 0xC0	; 192
    e426:	ff 4f       	sbci	r31, 0xFF	; 255
    e428:	80 83       	st	Z, r24
		return true;
    e42a:	81 e0       	ldi	r24, 0x01	; 1
    e42c:	08 95       	ret
	}

	return false;
    e42e:	80 e0       	ldi	r24, 0x00	; 0
}
    e430:	08 95       	ret

0000e432 <Endpoint_IsSETUPReceived>:

bool Endpoint_IsSETUPReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    e432:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e436:	8f 77       	andi	r24, 0x7F	; 127
    e438:	a1 df       	rcall	.-190    	; 0xe37c <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_SETUP_bm)
    e43a:	a0 91 57 34 	lds	r26, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e43e:	b0 91 58 34 	lds	r27, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e442:	8c 91       	ld	r24, X
    e444:	84 ff       	sbrs	r24, 4
    e446:	0d c0       	rjmp	.+26     	; 0xe462 <Endpoint_IsSETUPReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    e448:	e0 91 55 34 	lds	r30, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e44c:	f0 91 56 34 	lds	r31, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e450:	12 96       	adiw	r26, 0x02	; 2
    e452:	8d 91       	ld	r24, X+
    e454:	9c 91       	ld	r25, X
    e456:	13 97       	sbiw	r26, 0x03	; 3
    e458:	e0 5c       	subi	r30, 0xC0	; 192
    e45a:	ff 4f       	sbci	r31, 0xFF	; 255
    e45c:	80 83       	st	Z, r24
		return true;
    e45e:	81 e0       	ldi	r24, 0x01	; 1
    e460:	08 95       	ret
	}

	return false;
    e462:	80 e0       	ldi	r24, 0x00	; 0
}
    e464:	08 95       	ret

0000e466 <Endpoint_ClearSETUP>:

void Endpoint_ClearSETUP(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    e466:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e46a:	8f 77       	andi	r24, 0x7F	; 127
    e46c:	87 df       	rcall	.-242    	; 0xe37c <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_SETUP_bm | USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    e46e:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e472:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e476:	80 81       	ld	r24, Z
    e478:	8d 78       	andi	r24, 0x8D	; 141
    e47a:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    e47c:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e480:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e484:	80 81       	ld	r24, Z
    e486:	81 60       	ori	r24, 0x01	; 1
    e488:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    e48a:	e0 91 55 34 	lds	r30, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e48e:	f0 91 56 34 	lds	r31, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e492:	ef 5b       	subi	r30, 0xBF	; 191
    e494:	ff 4f       	sbci	r31, 0xFF	; 255
    e496:	10 82       	st	Z, r1

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    e498:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e49c:	80 68       	ori	r24, 0x80	; 128
    e49e:	6e df       	rcall	.-292    	; 0xe37c <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    e4a0:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e4a4:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e4a8:	80 81       	ld	r24, Z
    e4aa:	81 60       	ori	r24, 0x01	; 1
    e4ac:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    e4ae:	e0 91 55 34 	lds	r30, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e4b2:	f0 91 56 34 	lds	r31, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e4b6:	ef 5b       	subi	r30, 0xBF	; 191
    e4b8:	ff 4f       	sbci	r31, 0xFF	; 255
    e4ba:	10 82       	st	Z, r1
    e4bc:	08 95       	ret

0000e4be <Endpoint_StallTransaction>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_StallTransaction(void)
{
	USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    e4be:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e4c2:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e4c6:	81 81       	ldd	r24, Z+1	; 0x01
    e4c8:	84 60       	ori	r24, 0x04	; 4
    e4ca:	81 83       	std	Z+1, r24	; 0x01

	if ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_TYPE_gm) == USB_EP_TYPE_CONTROL_gc)
    e4cc:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e4d0:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e4d4:	81 81       	ldd	r24, Z+1	; 0x01
    e4d6:	80 7c       	andi	r24, 0xC0	; 192
    e4d8:	80 34       	cpi	r24, 0x40	; 64
    e4da:	59 f4       	brne	.+22     	; 0xe4f2 <Endpoint_StallTransaction+0x34>
	{
		Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint ^ ENDPOINT_DIR_IN);
    e4dc:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    e4e0:	80 58       	subi	r24, 0x80	; 128
    e4e2:	4c df       	rcall	.-360    	; 0xe37c <Endpoint_SelectEndpoint>
		USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    e4e4:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e4e8:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e4ec:	81 81       	ldd	r24, Z+1	; 0x01
    e4ee:	84 60       	ori	r24, 0x04	; 4
    e4f0:	81 83       	std	Z+1, r24	; 0x01
    e4f2:	08 95       	ret

0000e4f4 <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
    e4f4:	1f 93       	push	r17
    e4f6:	cf 93       	push	r28
    e4f8:	df 93       	push	r29
    e4fa:	c8 2f       	mov	r28, r24
    e4fc:	16 2f       	mov	r17, r22
    e4fe:	d4 2f       	mov	r29, r20
	Endpoint_SelectEndpoint(Address);
    e500:	3d df       	rcall	.-390    	; 0xe37c <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
    e502:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e506:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e50a:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    e50c:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e510:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e514:	8c 2f       	mov	r24, r28
    e516:	88 1f       	adc	r24, r24
    e518:	88 27       	eor	r24, r24
    e51a:	88 1f       	adc	r24, r24
    e51c:	88 0f       	add	r24, r24
    e51e:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    e520:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e524:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e528:	11 83       	std	Z+1, r17	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    e52a:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e52e:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e532:	12 82       	std	Z+2, r1	; 0x02
    e534:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    e536:	20 91 55 34 	lds	r18, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e53a:	30 91 56 34 	lds	r19, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e53e:	24 83       	std	Z+4, r18	; 0x04
    e540:	35 83       	std	Z+5, r19	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    e542:	cc 0f       	add	r28, r28
    e544:	cc 0b       	sbc	r28, r28
    e546:	cd 23       	and	r28, r29
    e548:	f9 01       	movw	r30, r18
    e54a:	e0 5c       	subi	r30, 0xC0	; 192
    e54c:	ff 4f       	sbci	r31, 0xFF	; 255
    e54e:	c0 83       	st	Z, r28
	USB_Endpoint_SelectedFIFO->Position  = 0;
    e550:	31 96       	adiw	r30, 0x01	; 1
    e552:	10 82       	st	Z, r1

	return true;
}
    e554:	81 e0       	ldi	r24, 0x01	; 1
    e556:	df 91       	pop	r29
    e558:	cf 91       	pop	r28
    e55a:	1f 91       	pop	r17
    e55c:	08 95       	ret

0000e55e <Endpoint_ConfigureEndpointTable>:
	}
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    e55e:	cf 92       	push	r12
    e560:	df 92       	push	r13
    e562:	ef 92       	push	r14
    e564:	ff 92       	push	r15
    e566:	0f 93       	push	r16
    e568:	1f 93       	push	r17
    e56a:	cf 93       	push	r28
    e56c:	df 93       	push	r29
    e56e:	c6 2e       	mov	r12, r22
    e570:	8c 01       	movw	r16, r24
	for (uint8_t i = 0; i < Entries; i++)
    e572:	d1 2c       	mov	r13, r1
    e574:	dc 14       	cp	r13, r12
    e576:	09 f4       	brne	.+2      	; 0xe57a <Endpoint_ConfigureEndpointTable+0x1c>
    e578:	3f c0       	rjmp	.+126    	; 0xe5f8 <Endpoint_ConfigureEndpointTable+0x9a>
	{
		if (!(Table[i].Address))
    e57a:	f8 01       	movw	r30, r16
    e57c:	d0 81       	ld	r29, Z
    e57e:	d1 11       	cpse	r29, r1
    e580:	04 c0       	rjmp	.+8      	; 0xe58a <Endpoint_ConfigureEndpointTable+0x2c>
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    e582:	d3 94       	inc	r13
    e584:	0b 5f       	subi	r16, 0xFB	; 251
    e586:	1f 4f       	sbci	r17, 0xFF	; 255
    e588:	f5 cf       	rjmp	.-22     	; 0xe574 <Endpoint_ConfigureEndpointTable+0x16>
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    e58a:	f8 01       	movw	r30, r16
    e58c:	e1 80       	ldd	r14, Z+1	; 0x01
    e58e:	f2 80       	ldd	r15, Z+2	; 0x02
    e590:	93 81       	ldd	r25, Z+3	; 0x03
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    e592:	84 81       	ldd	r24, Z+4	; 0x04
    e594:	82 30       	cpi	r24, 0x02	; 2
    e596:	10 f4       	brcc	.+4      	; 0xe59c <Endpoint_ConfigureEndpointTable+0x3e>
    e598:	88 e0       	ldi	r24, 0x08	; 8
    e59a:	01 c0       	rjmp	.+2      	; 0xe59e <Endpoint_ConfigureEndpointTable+0x40>
    e59c:	88 e1       	ldi	r24, 0x18	; 24
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    e59e:	28 e0       	ldi	r18, 0x08	; 8
    e5a0:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    e5a2:	c0 e0       	ldi	r28, 0x00	; 0
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    e5a4:	2e 15       	cp	r18, r14
    e5a6:	3f 05       	cpc	r19, r15
    e5a8:	20 f4       	brcc	.+8      	; 0xe5b2 <Endpoint_ConfigureEndpointTable+0x54>
				{
					MaskVal++;
    e5aa:	cf 5f       	subi	r28, 0xFF	; 255
					CheckBytes <<= 1;
    e5ac:	22 0f       	add	r18, r18
    e5ae:	33 1f       	adc	r19, r19
    e5b0:	f9 cf       	rjmp	.-14     	; 0xe5a4 <Endpoint_ConfigureEndpointTable+0x46>
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    e5b2:	c8 2b       	or	r28, r24

				if ((Address & ENDPOINT_EPNUM_MASK) >= ENDPOINT_TOTAL_ENDPOINTS)
    e5b4:	8d 2f       	mov	r24, r29
    e5b6:	8f 70       	andi	r24, 0x0F	; 15
    e5b8:	86 30       	cpi	r24, 0x06	; 6
    e5ba:	10 f0       	brcs	.+4      	; 0xe5c0 <Endpoint_ConfigureEndpointTable+0x62>
		{
			return false;
    e5bc:	80 e0       	ldi	r24, 0x00	; 0
    e5be:	1d c0       	rjmp	.+58     	; 0xe5fa <Endpoint_ConfigureEndpointTable+0x9c>
				  return false;

				// TODO - Fix once limitations are lifted
				EPConfigMask &= ~USB_EP_PINGPONG_bm;
    e5c0:	cf 7e       	andi	r28, 0xEF	; 239
				if (Size > 64)
    e5c2:	f1 e4       	ldi	r31, 0x41	; 65
    e5c4:	ef 16       	cp	r14, r31
    e5c6:	f1 04       	cpc	r15, r1
    e5c8:	c8 f7       	brcc	.-14     	; 0xe5bc <Endpoint_ConfigureEndpointTable+0x5e>
				  return false;

				switch (Type)
    e5ca:	99 23       	and	r25, r25
    e5cc:	21 f0       	breq	.+8      	; 0xe5d6 <Endpoint_ConfigureEndpointTable+0x78>
    e5ce:	91 30       	cpi	r25, 0x01	; 1
    e5d0:	21 f4       	brne	.+8      	; 0xe5da <Endpoint_ConfigureEndpointTable+0x7c>
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
    e5d2:	c0 6c       	ori	r28, 0xC0	; 192
    e5d4:	0a c0       	rjmp	.+20     	; 0xe5ea <Endpoint_ConfigureEndpointTable+0x8c>
				  return false;

				switch (Type)
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
    e5d6:	c0 64       	ori	r28, 0x40	; 64
    e5d8:	03 c0       	rjmp	.+6      	; 0xe5e0 <Endpoint_ConfigureEndpointTable+0x82>
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
						break;
					default:
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
    e5da:	c0 68       	ori	r28, 0x80	; 128
						break;
				}

				if (Type == EP_TYPE_CONTROL)
    e5dc:	91 11       	cpse	r25, r1
    e5de:	05 c0       	rjmp	.+10     	; 0xe5ea <Endpoint_ConfigureEndpointTable+0x8c>
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    e5e0:	4e 2d       	mov	r20, r14
    e5e2:	6c 2f       	mov	r22, r28
    e5e4:	80 e8       	ldi	r24, 0x80	; 128
    e5e6:	8d 0f       	add	r24, r29
    e5e8:	85 df       	rcall	.-246    	; 0xe4f4 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    e5ea:	4e 2d       	mov	r20, r14
    e5ec:	6c 2f       	mov	r22, r28
    e5ee:	8d 2f       	mov	r24, r29
    e5f0:	81 df       	rcall	.-254    	; 0xe4f4 <Endpoint_ConfigureEndpoint_PRV>
	for (uint8_t i = 0; i < Entries; i++)
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    e5f2:	81 11       	cpse	r24, r1
    e5f4:	c6 cf       	rjmp	.-116    	; 0xe582 <Endpoint_ConfigureEndpointTable+0x24>
    e5f6:	e2 cf       	rjmp	.-60     	; 0xe5bc <Endpoint_ConfigureEndpointTable+0x5e>
		{
			return false;
		}
	}

	return true;
    e5f8:	81 e0       	ldi	r24, 0x01	; 1
}
    e5fa:	df 91       	pop	r29
    e5fc:	cf 91       	pop	r28
    e5fe:	1f 91       	pop	r17
    e600:	0f 91       	pop	r16
    e602:	ff 90       	pop	r15
    e604:	ef 90       	pop	r14
    e606:	df 90       	pop	r13
    e608:	cf 90       	pop	r12
    e60a:	08 95       	ret

0000e60c <Endpoint_ClearEndpoints>:

	return true;
}

void Endpoint_ClearEndpoints(void)
{
    e60c:	80 e0       	ldi	r24, 0x00	; 0
    e60e:	90 e0       	ldi	r25, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    e610:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7004c6>
    e614:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7004c7>
    e618:	9c 01       	movw	r18, r24
    e61a:	44 e0       	ldi	r20, 0x04	; 4
    e61c:	22 0f       	add	r18, r18
    e61e:	33 1f       	adc	r19, r19
    e620:	4a 95       	dec	r20
    e622:	e1 f7       	brne	.-8      	; 0xe61c <Endpoint_ClearEndpoints+0x10>
    e624:	e2 0f       	add	r30, r18
    e626:	f3 1f       	adc	r31, r19
    e628:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    e62a:	40 91 c6 04 	lds	r20, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7004c6>
    e62e:	50 91 c7 04 	lds	r21, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7004c7>
    e632:	fa 01       	movw	r30, r20
    e634:	e2 0f       	add	r30, r18
    e636:	f3 1f       	adc	r31, r19
    e638:	11 82       	std	Z+1, r1	; 0x01
    e63a:	01 96       	adiw	r24, 0x01	; 1
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    e63c:	86 30       	cpi	r24, 0x06	; 6
    e63e:	91 05       	cpc	r25, r1
    e640:	39 f7       	brne	.-50     	; 0xe610 <Endpoint_ClearEndpoints+0x4>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    e642:	08 95       	ret

0000e644 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    e644:	80 91 4d 34 	lds	r24, 0x344D	; 0x80344d <USB_ControlRequest>
    e648:	87 ff       	sbrs	r24, 7
    e64a:	0d c0       	rjmp	.+26     	; 0xe666 <Endpoint_ClearStatusStage+0x22>
	{
		while (!(Endpoint_IsOUTReceived()))
    e64c:	d8 de       	rcall	.-592    	; 0xe3fe <Endpoint_IsOUTReceived>
    e64e:	81 11       	cpse	r24, r1
    e650:	05 c0       	rjmp	.+10     	; 0xe65c <Endpoint_ClearStatusStage+0x18>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    e652:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>
    e656:	81 11       	cpse	r24, r1
    e658:	f9 cf       	rjmp	.-14     	; 0xe64c <Endpoint_ClearStatusStage+0x8>
			  return;
		}

		Endpoint_ClearOUT();
    e65a:	09 c0       	rjmp	.+18     	; 0xe66e <Endpoint_ClearStatusStage+0x2a>
    e65c:	60 ce       	rjmp	.-832    	; 0xe31e <Endpoint_ClearOUT>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    e65e:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>
    e662:	88 23       	and	r24, r24

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    e664:	21 f0       	breq	.+8      	; 0xe66e <Endpoint_ClearStatusStage+0x2a>
    e666:	bf de       	rcall	.-642    	; 0xe3e6 <Endpoint_IsINReady>
    e668:	88 23       	and	r24, r24
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearIN();
    e66a:	c9 f3       	breq	.-14     	; 0xe65e <Endpoint_ClearStatusStage+0x1a>
    e66c:	3f ce       	rjmp	.-898    	; 0xe2ec <Endpoint_ClearIN>
    e66e:	08 95       	ret

0000e670 <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    e670:	0f 93       	push	r16
    e672:	1f 93       	push	r17
    e674:	cf 93       	push	r28
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return ((USB_EndpointTable_t*)USB.EPPTR)->FrameNum;
    e676:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7004c6>
    e67a:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7004c7>
    e67e:	e0 5a       	subi	r30, 0xA0	; 160
    e680:	ff 4f       	sbci	r31, 0xFF	; 255
    e682:	00 81       	ld	r16, Z
    e684:	11 81       	ldd	r17, Z+1	; 0x01
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    e686:	c4 e6       	ldi	r28, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN);
    e688:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    e68c:	87 ff       	sbrs	r24, 7
    e68e:	0a c0       	rjmp	.+20     	; 0xe6a4 <Endpoint_WaitUntilReady+0x34>
		{
			if (Endpoint_IsINReady())
    e690:	aa de       	rcall	.-684    	; 0xe3e6 <Endpoint_IsINReady>
    e692:	81 11       	cpse	r24, r1
    e694:	05 c0       	rjmp	.+10     	; 0xe6a0 <Endpoint_WaitUntilReady+0x30>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    e696:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    e69a:	81 11       	cpse	r24, r1
    e69c:	05 c0       	rjmp	.+10     	; 0xe6a8 <Endpoint_WaitUntilReady+0x38>
    e69e:	22 c0       	rjmp	.+68     	; 0xe6e4 <Endpoint_WaitUntilReady+0x74>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    e6a0:	80 e0       	ldi	r24, 0x00	; 0
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    e6a2:	25 c0       	rjmp	.+74     	; 0xe6ee <Endpoint_WaitUntilReady+0x7e>
    e6a4:	ac de       	rcall	.-680    	; 0xe3fe <Endpoint_IsOUTReceived>
    e6a6:	f5 cf       	rjmp	.-22     	; 0xe692 <Endpoint_WaitUntilReady+0x22>

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    e6a8:	85 30       	cpi	r24, 0x05	; 5
    e6aa:	f1 f0       	breq	.+60     	; 0xe6e8 <Endpoint_WaitUntilReady+0x78>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    e6ac:	e0 91 57 34 	lds	r30, 0x3457	; 0x803457 <USB_Endpoint_SelectedHandle>
    e6b0:	f0 91 58 34 	lds	r31, 0x3458	; 0x803458 <USB_Endpoint_SelectedHandle+0x1>
    e6b4:	81 81       	ldd	r24, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    e6b6:	82 fd       	sbrc	r24, 2
    e6b8:	19 c0       	rjmp	.+50     	; 0xe6ec <Endpoint_WaitUntilReady+0x7c>
    e6ba:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7004c6>
    e6be:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7004c7>
    e6c2:	e0 5a       	subi	r30, 0xA0	; 160
    e6c4:	ff 4f       	sbci	r31, 0xFF	; 255
    e6c6:	80 81       	ld	r24, Z
    e6c8:	91 81       	ldd	r25, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    e6ca:	08 17       	cp	r16, r24
    e6cc:	19 07       	cpc	r17, r25
    e6ce:	11 f4       	brne	.+4      	; 0xe6d4 <Endpoint_WaitUntilReady+0x64>
    e6d0:	8c 01       	movw	r16, r24
    e6d2:	da cf       	rjmp	.-76     	; 0xe688 <Endpoint_WaitUntilReady+0x18>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    e6d4:	2f ef       	ldi	r18, 0xFF	; 255
    e6d6:	2c 0f       	add	r18, r28
    e6d8:	cc 23       	and	r28, r28
    e6da:	11 f0       	breq	.+4      	; 0xe6e0 <Endpoint_WaitUntilReady+0x70>
    e6dc:	c2 2f       	mov	r28, r18
    e6de:	f8 cf       	rjmp	.-16     	; 0xe6d0 <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_Timeout;
    e6e0:	84 e0       	ldi	r24, 0x04	; 4
    e6e2:	05 c0       	rjmp	.+10     	; 0xe6ee <Endpoint_WaitUntilReady+0x7e>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    e6e4:	82 e0       	ldi	r24, 0x02	; 2
    e6e6:	03 c0       	rjmp	.+6      	; 0xe6ee <Endpoint_WaitUntilReady+0x7e>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    e6e8:	83 e0       	ldi	r24, 0x03	; 3
    e6ea:	01 c0       	rjmp	.+2      	; 0xe6ee <Endpoint_WaitUntilReady+0x7e>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    e6ec:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    e6ee:	cf 91       	pop	r28
    e6f0:	1f 91       	pop	r17
    e6f2:	0f 91       	pop	r16
    e6f4:	08 95       	ret

0000e6f6 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    e6f6:	63 d0       	rcall	.+198    	; 0xe7be <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    e6f8:	69 d0       	rcall	.+210    	; 0xe7cc <USB_INT_ClearAllInterrupts>
    e6fa:	e0 ec       	ldi	r30, 0xC0	; 192
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				USB.CTRLB &= ~USB_ATTACH_bm;
    e6fc:	f4 e0       	ldi	r31, 0x04	; 4
    e6fe:	81 81       	ldd	r24, Z+1	; 0x01
    e700:	8e 7f       	andi	r24, 0xFE	; 254
    e702:	81 83       	std	Z+1, r24	; 0x01
    e704:	80 81       	ld	r24, Z
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    e706:	8f 77       	andi	r24, 0x7F	; 127
    e708:	80 83       	st	Z, r24
    e70a:	10 92 4b 34 	sts	0x344B, r1	; 0x80344b <USB_IsInitialized>

	USB_Detach();
	USB_Controller_Disable();

	USB_IsInitialized = false;
    e70e:	08 95       	ret

0000e710 <USB_ResetInterface>:
    e710:	cf 93       	push	r28
}

void USB_ResetInterface(void)
{
    e712:	df 93       	push	r29
	{
		DividerIndex++;
		PrescalerNeeded >>= 1;
	}

	CLK.USBCTRL = (DividerIndex - 1) << CLK_USBPSDIV_gp;
    e714:	e0 e4       	ldi	r30, 0x40	; 64
    e716:	f0 e0       	ldi	r31, 0x00	; 0
    e718:	14 82       	std	Z+4, r1	; 0x04

	if (USB_Options & USB_OPT_PLLCLKSRC)
	  CLK.USBCTRL |= (CLK_USBSRC_PLL_gc   | CLK_USBSEN_bm);
	else
	  CLK.USBCTRL |= (CLK_USBSRC_RC32M_gc | CLK_USBSEN_bm);
    e71a:	84 81       	ldd	r24, Z+4	; 0x04
    e71c:	83 60       	ori	r24, 0x03	; 3
    e71e:	84 83       	std	Z+4, r24	; 0x04

	USB_Device_SetDeviceAddress(0);

	USB_INT_DisableAllInterrupts();
    e720:	4e d0       	rcall	.+156    	; 0xe7be <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    e722:	54 d0       	rcall	.+168    	; 0xe7cc <USB_INT_ClearAllInterrupts>
    e724:	c0 ec       	ldi	r28, 0xC0	; 192
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    e726:	d4 e0       	ldi	r29, 0x04	; 4
    e728:	88 81       	ld	r24, Y
    e72a:	8f 77       	andi	r24, 0x7F	; 127
    e72c:	88 83       	st	Y, r24
    e72e:	88 81       	ld	r24, Y
				USB.CTRLA |=  USB_ENABLE_bm;
    e730:	80 68       	ori	r24, 0x80	; 128
    e732:	88 83       	st	Y, r24
    e734:	10 92 4c 34 	sts	0x344C, r1	; 0x80344c <USB_DeviceState>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    e738:	10 92 48 34 	sts	0x3448, r1	; 0x803448 <USB_Device_ConfigurationNumber>
	USB_Device_ConfigurationNumber  = 0;
    e73c:	10 92 4a 34 	sts	0x344A, r1	; 0x80344a <USB_Device_RemoteWakeupEnabled>

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    e740:	10 92 49 34 	sts	0x3449, r1	; 0x803449 <USB_Device_CurrentlySelfPowered>
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    e744:	88 81       	ld	r24, Y
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				USB.CTRLA |=  USB_SPEED_bm;
    e746:	80 64       	ori	r24, 0x40	; 64
    e748:	88 83       	st	Y, r24
    e74a:	48 e0       	ldi	r20, 0x08	; 8
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    e74c:	68 e4       	ldi	r22, 0x48	; 72
    e74e:	80 e8       	ldi	r24, 0x80	; 128
    e750:	d1 de       	rcall	.-606    	; 0xe4f4 <Endpoint_ConfigureEndpoint_PRV>
    e752:	48 e0       	ldi	r20, 0x08	; 8

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    e754:	68 e4       	ldi	r22, 0x48	; 72
    e756:	80 e0       	ldi	r24, 0x00	; 0
    e758:	cd de       	rcall	.-614    	; 0xe4f4 <Endpoint_ConfigureEndpoint_PRV>
    e75a:	88 85       	ldd	r24, Y+8	; 0x08
			static inline void USB_INT_Enable(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						USB.INTCTRLA |= USB_BUSEVIE_bm;
    e75c:	80 64       	ori	r24, 0x40	; 64
    e75e:	88 87       	std	Y+8, r24	; 0x08
    e760:	89 81       	ldd	r24, Y+1	; 0x01
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				USB.CTRLB |= USB_ATTACH_bm;
    e762:	81 60       	ori	r24, 0x01	; 1
    e764:	89 83       	std	Y+1, r24	; 0x01
    e766:	df 91       	pop	r29
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_Controller_Reset();
	USB_Init_Device();
}
    e768:	cf 91       	pop	r28
    e76a:	08 95       	ret

0000e76c <USB_Init>:
    e76c:	cf 93       	push	r28

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    e76e:	df 93       	push	r29
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    e770:	3f b7       	in	r19, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    e772:	f8 94       	cli
	#endif

	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    e774:	c0 ec       	ldi	r28, 0xC0	; 192
    e776:	d1 e0       	ldi	r29, 0x01	; 1
    e778:	22 e0       	ldi	r18, 0x02	; 2
    e77a:	2a 87       	std	Y+10, r18	; 0x0a
	USB.CAL0 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL0));
    e77c:	ea e1       	ldi	r30, 0x1A	; 26
    e77e:	f0 e0       	ldi	r31, 0x00	; 0
    e780:	e4 91       	lpm	r30, Z
    e782:	a0 ec       	ldi	r26, 0xC0	; 192
    e784:	b4 e0       	ldi	r27, 0x04	; 4
    e786:	da 96       	adiw	r26, 0x3a	; 58
    e788:	ec 93       	st	X, r30
    e78a:	da 97       	sbiw	r26, 0x3a	; 58
	USB.CAL1 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL1));
    e78c:	eb e1       	ldi	r30, 0x1B	; 27
    e78e:	f0 e0       	ldi	r31, 0x00	; 0
    e790:	e4 91       	lpm	r30, Z
    e792:	db 96       	adiw	r26, 0x3b	; 59
    e794:	ec 93       	st	X, r30
    e796:	db 97       	sbiw	r26, 0x3b	; 59
	NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    e798:	1a 86       	std	Y+10, r1	; 0x0a

	/* Ugly workaround to ensure an aligned table, since __BIGGEST_ALIGNMENT__ == 1 for the 8-bit AVR-GCC toolchain */
	USB.EPPTR = ((intptr_t)&USB_EndpointTable[1] & ~(1 << 0));
    e79a:	83 e7       	ldi	r24, 0x73	; 115
    e79c:	97 e3       	ldi	r25, 0x37	; 55
    e79e:	8e 7f       	andi	r24, 0xFE	; 254
    e7a0:	16 96       	adiw	r26, 0x06	; 6
    e7a2:	8d 93       	st	X+, r24
    e7a4:	9c 93       	st	X, r25
    e7a6:	17 97       	sbiw	r26, 0x07	; 7
	USB.CTRLA = (USB_STFRNUM_bm | ((ENDPOINT_TOTAL_ENDPOINTS - 1) << USB_MAXEP_gp));
    e7a8:	85 e1       	ldi	r24, 0x15	; 21
    e7aa:	8c 93       	st	X, r24

	if ((USB_Options & USB_OPT_BUSEVENT_PRIHIGH) == USB_OPT_BUSEVENT_PRIHIGH)
	  USB.INTCTRLA = (3 << USB_INTLVL_gp);
	else if ((USB_Options & USB_OPT_BUSEVENT_PRIMED) == USB_OPT_BUSEVENT_PRIMED)
	  USB.INTCTRLA = (2 << USB_INTLVL_gp);
    e7ac:	18 96       	adiw	r26, 0x08	; 8
    e7ae:	2c 93       	st	X, r18
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    e7b0:	3f bf       	out	0x3f, r19	; 63

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;
    e7b2:	81 e0       	ldi	r24, 0x01	; 1
    e7b4:	80 93 4b 34 	sts	0x344B, r24	; 0x80344b <USB_IsInitialized>

	USB_ResetInterface();
}
    e7b8:	df 91       	pop	r29
    e7ba:	cf 91       	pop	r28
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;

	USB_ResetInterface();
    e7bc:	a9 cf       	rjmp	.-174    	; 0xe710 <USB_ResetInterface>

0000e7be <USB_INT_DisableAllInterrupts>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	USB.INTCTRLA    &= USB_INTLVL_gm;
    e7be:	e0 ec       	ldi	r30, 0xC0	; 192
    e7c0:	f4 e0       	ldi	r31, 0x04	; 4
    e7c2:	80 85       	ldd	r24, Z+8	; 0x08
    e7c4:	83 70       	andi	r24, 0x03	; 3
    e7c6:	80 87       	std	Z+8, r24	; 0x08
	USB.INTCTRLB     = 0;
    e7c8:	11 86       	std	Z+9, r1	; 0x09
    e7ca:	08 95       	ret

0000e7cc <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	USB.INTFLAGSACLR = 0xFF;
    e7cc:	e0 ec       	ldi	r30, 0xC0	; 192
    e7ce:	f4 e0       	ldi	r31, 0x04	; 4
    e7d0:	8f ef       	ldi	r24, 0xFF	; 255
    e7d2:	82 87       	std	Z+10, r24	; 0x0a
	USB.INTFLAGSBCLR = 0xFF;
    e7d4:	84 87       	std	Z+12, r24	; 0x0c
    e7d6:	08 95       	ret

0000e7d8 <__vector_125>:
}

ISR(USB_BUSEVENT_vect)
{
    e7d8:	1f 92       	push	r1
    e7da:	0f 92       	push	r0
    e7dc:	0f b6       	in	r0, 0x3f	; 63
    e7de:	0f 92       	push	r0
    e7e0:	11 24       	eor	r1, r1
    e7e2:	08 b6       	in	r0, 0x38	; 56
    e7e4:	0f 92       	push	r0
    e7e6:	18 be       	out	0x38, r1	; 56
    e7e8:	09 b6       	in	r0, 0x39	; 57
    e7ea:	0f 92       	push	r0
    e7ec:	19 be       	out	0x39, r1	; 57
    e7ee:	0b b6       	in	r0, 0x3b	; 59
    e7f0:	0f 92       	push	r0
    e7f2:	1b be       	out	0x3b, r1	; 59
    e7f4:	2f 93       	push	r18
    e7f6:	3f 93       	push	r19
    e7f8:	4f 93       	push	r20
    e7fa:	5f 93       	push	r21
    e7fc:	6f 93       	push	r22
    e7fe:	7f 93       	push	r23
    e800:	8f 93       	push	r24
    e802:	9f 93       	push	r25
    e804:	af 93       	push	r26
    e806:	bf 93       	push	r27
    e808:	ef 93       	push	r30
    e80a:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    e80c:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    e810:	87 ff       	sbrs	r24, 7
    e812:	08 c0       	rjmp	.+16     	; 0xe824 <__vector_125+0x4c>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    e814:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <__TEXT_REGION_LENGTH__+0x7004c8>
    e818:	87 ff       	sbrs	r24, 7
    e81a:	04 c0       	rjmp	.+8      	; 0xe824 <__vector_125+0x4c>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    e81c:	80 e8       	ldi	r24, 0x80	; 128
    e81e:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    e822:	0b dc       	rcall	.-2026   	; 0xe03a <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    e824:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    e828:	86 ff       	sbrs	r24, 6
    e82a:	07 c0       	rjmp	.+14     	; 0xe83a <__vector_125+0x62>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    e82c:	80 e4       	ldi	r24, 0x40	; 64
    e82e:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    e832:	10 92 4c 34 	sts	0x344C, r1	; 0x80344c <USB_DeviceState>
		EVENT_USB_Device_Disconnect();
    e836:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    e83a:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    e83e:	85 ff       	sbrs	r24, 5
    e840:	14 c0       	rjmp	.+40     	; 0xe86a <__vector_125+0x92>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    e842:	80 e2       	ldi	r24, 0x20	; 32
    e844:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    e848:	80 91 48 34 	lds	r24, 0x3448	; 0x803448 <USB_Device_ConfigurationNumber>
    e84c:	88 23       	and	r24, r24
    e84e:	11 f0       	breq	.+4      	; 0xe854 <__vector_125+0x7c>
		  USB_DeviceState = DEVICE_STATE_Configured;
    e850:	84 e0       	ldi	r24, 0x04	; 4
    e852:	07 c0       	rjmp	.+14     	; 0xe862 <__vector_125+0x8a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    e854:	80 91 c3 04 	lds	r24, 0x04C3	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7004c3>
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    e858:	81 11       	cpse	r24, r1
    e85a:	02 c0       	rjmp	.+4      	; 0xe860 <__vector_125+0x88>
    e85c:	81 e0       	ldi	r24, 0x01	; 1
    e85e:	01 c0       	rjmp	.+2      	; 0xe862 <__vector_125+0x8a>
    e860:	83 e0       	ldi	r24, 0x03	; 3
    e862:	80 93 4c 34 	sts	0x344C, r24	; 0x80344c <USB_DeviceState>

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    e866:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    e86a:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    e86e:	84 ff       	sbrs	r24, 4
    e870:	14 c0       	rjmp	.+40     	; 0xe89a <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    e872:	80 e1       	ldi	r24, 0x10	; 16
    e874:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7004ca>
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    e878:	82 e0       	ldi	r24, 0x02	; 2
    e87a:	80 93 4c 34 	sts	0x344C, r24	; 0x80344c <USB_DeviceState>
		USB_Device_ConfigurationNumber = 0;
    e87e:	10 92 48 34 	sts	0x3448, r1	; 0x803448 <USB_Device_ConfigurationNumber>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    e882:	10 92 c3 04 	sts	0x04C3, r1	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7004c3>

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
    e886:	c2 de       	rcall	.-636    	; 0xe60c <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    e888:	48 e0       	ldi	r20, 0x08	; 8
    e88a:	68 e4       	ldi	r22, 0x48	; 72
    e88c:	80 e8       	ldi	r24, 0x80	; 128
    e88e:	32 de       	rcall	.-924    	; 0xe4f4 <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    e890:	48 e0       	ldi	r20, 0x08	; 8
    e892:	68 e4       	ldi	r22, 0x48	; 72
    e894:	80 e0       	ldi	r24, 0x00	; 0
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    e896:	2e de       	rcall	.-932    	; 0xe4f4 <Endpoint_ConfigureEndpoint_PRV>
    e898:	d0 db       	rcall	.-2144   	; 0xe03a <USB_Event_Stub>
	}
}
    e89a:	ff 91       	pop	r31
    e89c:	ef 91       	pop	r30
    e89e:	bf 91       	pop	r27
    e8a0:	af 91       	pop	r26
    e8a2:	9f 91       	pop	r25
    e8a4:	8f 91       	pop	r24
    e8a6:	7f 91       	pop	r23
    e8a8:	6f 91       	pop	r22
    e8aa:	5f 91       	pop	r21
    e8ac:	4f 91       	pop	r20
    e8ae:	3f 91       	pop	r19
    e8b0:	2f 91       	pop	r18
    e8b2:	0f 90       	pop	r0
    e8b4:	0b be       	out	0x3b, r0	; 59
    e8b6:	0f 90       	pop	r0
    e8b8:	09 be       	out	0x39, r0	; 57
    e8ba:	0f 90       	pop	r0
    e8bc:	08 be       	out	0x38, r0	; 56
    e8be:	0f 90       	pop	r0
    e8c0:	0f be       	out	0x3f, r0	; 63
    e8c2:	0f 90       	pop	r0
    e8c4:	1f 90       	pop	r1
    e8c6:	18 95       	reti

0000e8c8 <CDC_Device_ConfigureEndpoints>:

void CDC_Device_CreateBlockingStream(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                                     FILE* const Stream)
{
	*Stream = (FILE)FDEV_SETUP_STREAM(CDC_Device_putchar, CDC_Device_getchar_Blocking, _FDEV_SETUP_RW);
	fdev_set_udata(Stream, CDCInterfaceInfo);
    e8c8:	cf 93       	push	r28
    e8ca:	df 93       	push	r29
    e8cc:	ec 01       	movw	r28, r24
    e8ce:	fc 01       	movw	r30, r24
    e8d0:	70 96       	adiw	r30, 0x10	; 16
    e8d2:	8b e0       	ldi	r24, 0x0B	; 11
    e8d4:	df 01       	movw	r26, r30
    e8d6:	1d 92       	st	X+, r1
    e8d8:	8a 95       	dec	r24
    e8da:	e9 f7       	brne	.-6      	; 0xe8d6 <CDC_Device_ConfigureEndpoints+0xe>
    e8dc:	82 e0       	ldi	r24, 0x02	; 2
    e8de:	8c 83       	std	Y+4, r24	; 0x04
    e8e0:	89 87       	std	Y+9, r24	; 0x09
    e8e2:	83 e0       	ldi	r24, 0x03	; 3
    e8e4:	8e 87       	std	Y+14, r24	; 0x0e
    e8e6:	61 e0       	ldi	r22, 0x01	; 1
    e8e8:	ce 01       	movw	r24, r28
    e8ea:	01 96       	adiw	r24, 0x01	; 1
    e8ec:	38 de       	rcall	.-912    	; 0xe55e <Endpoint_ConfigureEndpointTable>
    e8ee:	88 23       	and	r24, r24
    e8f0:	61 f0       	breq	.+24     	; 0xe90a <CDC_Device_ConfigureEndpoints+0x42>
    e8f2:	61 e0       	ldi	r22, 0x01	; 1
    e8f4:	ce 01       	movw	r24, r28
    e8f6:	06 96       	adiw	r24, 0x06	; 6
    e8f8:	32 de       	rcall	.-924    	; 0xe55e <Endpoint_ConfigureEndpointTable>
    e8fa:	88 23       	and	r24, r24
    e8fc:	31 f0       	breq	.+12     	; 0xe90a <CDC_Device_ConfigureEndpoints+0x42>
    e8fe:	61 e0       	ldi	r22, 0x01	; 1
    e900:	ce 01       	movw	r24, r28
    e902:	0b 96       	adiw	r24, 0x0b	; 11
    e904:	df 91       	pop	r29
    e906:	cf 91       	pop	r28
    e908:	2a ce       	rjmp	.-940    	; 0xe55e <Endpoint_ConfigureEndpointTable>
    e90a:	80 e0       	ldi	r24, 0x00	; 0
    e90c:	df 91       	pop	r29
    e90e:	cf 91       	pop	r28
    e910:	08 95       	ret

0000e912 <CDC_Device_SendString>:
    e912:	0f 93       	push	r16
    e914:	1f 93       	push	r17
    e916:	cf 93       	push	r28
    e918:	df 93       	push	r29
    e91a:	20 91 4c 34 	lds	r18, 0x344C	; 0x80344c <USB_DeviceState>
    e91e:	24 30       	cpi	r18, 0x04	; 4
    e920:	e1 f4       	brne	.+56     	; 0xe95a <CDC_Device_SendString+0x48>
    e922:	fc 01       	movw	r30, r24
    e924:	04 89       	ldd	r16, Z+20	; 0x14
    e926:	15 89       	ldd	r17, Z+21	; 0x15
    e928:	26 89       	ldd	r18, Z+22	; 0x16
    e92a:	37 89       	ldd	r19, Z+23	; 0x17
    e92c:	01 2b       	or	r16, r17
    e92e:	02 2b       	or	r16, r18
    e930:	03 2b       	or	r16, r19
    e932:	99 f0       	breq	.+38     	; 0xe95a <CDC_Device_SendString+0x48>
    e934:	eb 01       	movw	r28, r22
    e936:	81 81       	ldd	r24, Z+1	; 0x01
    e938:	21 dd       	rcall	.-1470   	; 0xe37c <Endpoint_SelectEndpoint>
    e93a:	fe 01       	movw	r30, r28
    e93c:	01 90       	ld	r0, Z+
    e93e:	00 20       	and	r0, r0
    e940:	e9 f7       	brne	.-6      	; 0xe93c <CDC_Device_SendString+0x2a>
    e942:	31 97       	sbiw	r30, 0x01	; 1
    e944:	bf 01       	movw	r22, r30
    e946:	6c 1b       	sub	r22, r28
    e948:	7d 0b       	sbc	r23, r29
    e94a:	40 e0       	ldi	r20, 0x00	; 0
    e94c:	50 e0       	ldi	r21, 0x00	; 0
    e94e:	ce 01       	movw	r24, r28
    e950:	df 91       	pop	r29
    e952:	cf 91       	pop	r28
    e954:	1f 91       	pop	r17
    e956:	0f 91       	pop	r16
    e958:	82 cb       	rjmp	.-2300   	; 0xe05e <Endpoint_Write_Stream_LE>
    e95a:	82 e0       	ldi	r24, 0x02	; 2
    e95c:	df 91       	pop	r29
    e95e:	cf 91       	pop	r28
    e960:	1f 91       	pop	r17
    e962:	0f 91       	pop	r16
    e964:	08 95       	ret

0000e966 <CDC_Device_SendData>:
    e966:	0f 93       	push	r16
    e968:	1f 93       	push	r17
    e96a:	cf 93       	push	r28
    e96c:	df 93       	push	r29
    e96e:	20 91 4c 34 	lds	r18, 0x344C	; 0x80344c <USB_DeviceState>
    e972:	24 30       	cpi	r18, 0x04	; 4
    e974:	b1 f4       	brne	.+44     	; 0xe9a2 <CDC_Device_SendData+0x3c>
    e976:	fc 01       	movw	r30, r24
    e978:	04 89       	ldd	r16, Z+20	; 0x14
    e97a:	15 89       	ldd	r17, Z+21	; 0x15
    e97c:	26 89       	ldd	r18, Z+22	; 0x16
    e97e:	37 89       	ldd	r19, Z+23	; 0x17
    e980:	01 2b       	or	r16, r17
    e982:	02 2b       	or	r16, r18
    e984:	03 2b       	or	r16, r19
    e986:	69 f0       	breq	.+26     	; 0xe9a2 <CDC_Device_SendData+0x3c>
    e988:	8a 01       	movw	r16, r20
    e98a:	eb 01       	movw	r28, r22
    e98c:	81 81       	ldd	r24, Z+1	; 0x01
    e98e:	f6 dc       	rcall	.-1556   	; 0xe37c <Endpoint_SelectEndpoint>
    e990:	40 e0       	ldi	r20, 0x00	; 0
    e992:	50 e0       	ldi	r21, 0x00	; 0
    e994:	b8 01       	movw	r22, r16
    e996:	ce 01       	movw	r24, r28
    e998:	df 91       	pop	r29
    e99a:	cf 91       	pop	r28
    e99c:	1f 91       	pop	r17
    e99e:	0f 91       	pop	r16
    e9a0:	5e cb       	rjmp	.-2372   	; 0xe05e <Endpoint_Write_Stream_LE>
    e9a2:	82 e0       	ldi	r24, 0x02	; 2
    e9a4:	df 91       	pop	r29
    e9a6:	cf 91       	pop	r28
    e9a8:	1f 91       	pop	r17
    e9aa:	0f 91       	pop	r16
    e9ac:	08 95       	ret

0000e9ae <CDC_Device_SendByte>:
    e9ae:	0f 93       	push	r16
    e9b0:	1f 93       	push	r17
    e9b2:	cf 93       	push	r28
    e9b4:	20 91 4c 34 	lds	r18, 0x344C	; 0x80344c <USB_DeviceState>
    e9b8:	24 30       	cpi	r18, 0x04	; 4
    e9ba:	09 f5       	brne	.+66     	; 0xe9fe <CDC_Device_SendByte+0x50>
    e9bc:	fc 01       	movw	r30, r24
    e9be:	04 89       	ldd	r16, Z+20	; 0x14
    e9c0:	15 89       	ldd	r17, Z+21	; 0x15
    e9c2:	26 89       	ldd	r18, Z+22	; 0x16
    e9c4:	37 89       	ldd	r19, Z+23	; 0x17
    e9c6:	01 2b       	or	r16, r17
    e9c8:	02 2b       	or	r16, r18
    e9ca:	03 2b       	or	r16, r19
    e9cc:	c1 f0       	breq	.+48     	; 0xe9fe <CDC_Device_SendByte+0x50>
    e9ce:	c6 2f       	mov	r28, r22
    e9d0:	81 81       	ldd	r24, Z+1	; 0x01
    e9d2:	d4 dc       	rcall	.-1624   	; 0xe37c <Endpoint_SelectEndpoint>
    e9d4:	80 91 55 34 	lds	r24, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    e9d8:	90 91 56 34 	lds	r25, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    e9dc:	fc 01       	movw	r30, r24
    e9de:	ef 5b       	subi	r30, 0xBF	; 191
    e9e0:	ff 4f       	sbci	r31, 0xFF	; 255
    e9e2:	20 81       	ld	r18, Z
    e9e4:	31 97       	sbiw	r30, 0x01	; 1
    e9e6:	80 81       	ld	r24, Z
    e9e8:	28 17       	cp	r18, r24
    e9ea:	20 f4       	brcc	.+8      	; 0xe9f4 <CDC_Device_SendByte+0x46>
    e9ec:	8c 2f       	mov	r24, r28
    e9ee:	b6 dc       	rcall	.-1684   	; 0xe35c <Endpoint_Write_8>
    e9f0:	80 e0       	ldi	r24, 0x00	; 0
    e9f2:	06 c0       	rjmp	.+12     	; 0xea00 <CDC_Device_SendByte+0x52>
    e9f4:	7b dc       	rcall	.-1802   	; 0xe2ec <Endpoint_ClearIN>
    e9f6:	3c de       	rcall	.-904    	; 0xe670 <Endpoint_WaitUntilReady>
    e9f8:	88 23       	and	r24, r24
    e9fa:	c1 f3       	breq	.-16     	; 0xe9ec <CDC_Device_SendByte+0x3e>
    e9fc:	01 c0       	rjmp	.+2      	; 0xea00 <CDC_Device_SendByte+0x52>
    e9fe:	82 e0       	ldi	r24, 0x02	; 2
    ea00:	cf 91       	pop	r28
    ea02:	1f 91       	pop	r17
    ea04:	0f 91       	pop	r16
    ea06:	08 95       	ret

0000ea08 <CDC_Device_Flush>:
    ea08:	cf 93       	push	r28
    ea0a:	df 93       	push	r29
    ea0c:	20 91 4c 34 	lds	r18, 0x344C	; 0x80344c <USB_DeviceState>
    ea10:	24 30       	cpi	r18, 0x04	; 4
    ea12:	91 f5       	brne	.+100    	; 0xea78 <CDC_Device_Flush+0x70>
    ea14:	fc 01       	movw	r30, r24
    ea16:	44 89       	ldd	r20, Z+20	; 0x14
    ea18:	55 89       	ldd	r21, Z+21	; 0x15
    ea1a:	66 89       	ldd	r22, Z+22	; 0x16
    ea1c:	77 89       	ldd	r23, Z+23	; 0x17
    ea1e:	45 2b       	or	r20, r21
    ea20:	46 2b       	or	r20, r22
    ea22:	47 2b       	or	r20, r23
    ea24:	49 f1       	breq	.+82     	; 0xea78 <CDC_Device_Flush+0x70>
    ea26:	81 81       	ldd	r24, Z+1	; 0x01
    ea28:	a9 dc       	rcall	.-1710   	; 0xe37c <Endpoint_SelectEndpoint>
    ea2a:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    ea2e:	20 91 55 34 	lds	r18, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    ea32:	30 91 56 34 	lds	r19, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    ea36:	f9 01       	movw	r30, r18
    ea38:	87 ff       	sbrs	r24, 7
    ea3a:	05 c0       	rjmp	.+10     	; 0xea46 <CDC_Device_Flush+0x3e>
    ea3c:	ef 5b       	subi	r30, 0xBF	; 191
    ea3e:	ff 4f       	sbci	r31, 0xFF	; 255
    ea40:	80 81       	ld	r24, Z
    ea42:	90 e0       	ldi	r25, 0x00	; 0
    ea44:	08 c0       	rjmp	.+16     	; 0xea56 <CDC_Device_Flush+0x4e>
    ea46:	e0 5c       	subi	r30, 0xC0	; 192
    ea48:	ff 4f       	sbci	r31, 0xFF	; 255
    ea4a:	80 81       	ld	r24, Z
    ea4c:	31 96       	adiw	r30, 0x01	; 1
    ea4e:	40 81       	ld	r20, Z
    ea50:	90 e0       	ldi	r25, 0x00	; 0
    ea52:	84 1b       	sub	r24, r20
    ea54:	91 09       	sbc	r25, r1
    ea56:	89 2b       	or	r24, r25
    ea58:	69 f0       	breq	.+26     	; 0xea74 <CDC_Device_Flush+0x6c>
    ea5a:	f9 01       	movw	r30, r18
    ea5c:	ef 5b       	subi	r30, 0xBF	; 191
    ea5e:	ff 4f       	sbci	r31, 0xFF	; 255
    ea60:	d0 81       	ld	r29, Z
    ea62:	31 97       	sbiw	r30, 0x01	; 1
    ea64:	c0 81       	ld	r28, Z
    ea66:	42 dc       	rcall	.-1916   	; 0xe2ec <Endpoint_ClearIN>
    ea68:	dc 17       	cp	r29, r28
    ea6a:	20 f0       	brcs	.+8      	; 0xea74 <CDC_Device_Flush+0x6c>
    ea6c:	01 de       	rcall	.-1022   	; 0xe670 <Endpoint_WaitUntilReady>
    ea6e:	81 11       	cpse	r24, r1
    ea70:	04 c0       	rjmp	.+8      	; 0xea7a <CDC_Device_Flush+0x72>
    ea72:	3c dc       	rcall	.-1928   	; 0xe2ec <Endpoint_ClearIN>
    ea74:	80 e0       	ldi	r24, 0x00	; 0
    ea76:	01 c0       	rjmp	.+2      	; 0xea7a <CDC_Device_Flush+0x72>
    ea78:	82 e0       	ldi	r24, 0x02	; 2
    ea7a:	df 91       	pop	r29
    ea7c:	cf 91       	pop	r28
    ea7e:	08 95       	ret

0000ea80 <CDC_Device_USBTask>:
    ea80:	cf 93       	push	r28
    ea82:	df 93       	push	r29
    ea84:	20 91 4c 34 	lds	r18, 0x344C	; 0x80344c <USB_DeviceState>
    ea88:	24 30       	cpi	r18, 0x04	; 4
    ea8a:	99 f4       	brne	.+38     	; 0xeab2 <CDC_Device_USBTask+0x32>
    ea8c:	fc 01       	movw	r30, r24
    ea8e:	44 89       	ldd	r20, Z+20	; 0x14
    ea90:	55 89       	ldd	r21, Z+21	; 0x15
    ea92:	66 89       	ldd	r22, Z+22	; 0x16
    ea94:	77 89       	ldd	r23, Z+23	; 0x17
    ea96:	45 2b       	or	r20, r21
    ea98:	46 2b       	or	r20, r22
    ea9a:	47 2b       	or	r20, r23
    ea9c:	51 f0       	breq	.+20     	; 0xeab2 <CDC_Device_USBTask+0x32>
    ea9e:	ec 01       	movw	r28, r24
    eaa0:	81 81       	ldd	r24, Z+1	; 0x01
    eaa2:	6c dc       	rcall	.-1832   	; 0xe37c <Endpoint_SelectEndpoint>
    eaa4:	a0 dc       	rcall	.-1728   	; 0xe3e6 <Endpoint_IsINReady>
    eaa6:	88 23       	and	r24, r24
    eaa8:	21 f0       	breq	.+8      	; 0xeab2 <CDC_Device_USBTask+0x32>
    eaaa:	ce 01       	movw	r24, r28
    eaac:	df 91       	pop	r29
    eaae:	cf 91       	pop	r28
    eab0:	ab cf       	rjmp	.-170    	; 0xea08 <CDC_Device_Flush>
    eab2:	df 91       	pop	r29
    eab4:	cf 91       	pop	r28
    eab6:	08 95       	ret

0000eab8 <CDC_Device_ReceiveByte>:
    eab8:	cf 93       	push	r28
    eaba:	df 93       	push	r29
    eabc:	20 91 4c 34 	lds	r18, 0x344C	; 0x80344c <USB_DeviceState>
    eac0:	24 30       	cpi	r18, 0x04	; 4
    eac2:	19 f0       	breq	.+6      	; 0xeaca <CDC_Device_ReceiveByte+0x12>
    eac4:	8f ef       	ldi	r24, 0xFF	; 255
    eac6:	9f ef       	ldi	r25, 0xFF	; 255
    eac8:	46 c0       	rjmp	.+140    	; 0xeb56 <CDC_Device_ReceiveByte+0x9e>
    eaca:	fc 01       	movw	r30, r24
    eacc:	44 89       	ldd	r20, Z+20	; 0x14
    eace:	55 89       	ldd	r21, Z+21	; 0x15
    ead0:	66 89       	ldd	r22, Z+22	; 0x16
    ead2:	77 89       	ldd	r23, Z+23	; 0x17
    ead4:	45 2b       	or	r20, r21
    ead6:	46 2b       	or	r20, r22
    ead8:	47 2b       	or	r20, r23
    eada:	a1 f3       	breq	.-24     	; 0xeac4 <CDC_Device_ReceiveByte+0xc>
    eadc:	86 81       	ldd	r24, Z+6	; 0x06
    eade:	4e dc       	rcall	.-1892   	; 0xe37c <Endpoint_SelectEndpoint>
    eae0:	8e dc       	rcall	.-1764   	; 0xe3fe <Endpoint_IsOUTReceived>
    eae2:	88 23       	and	r24, r24
    eae4:	79 f3       	breq	.-34     	; 0xeac4 <CDC_Device_ReceiveByte+0xc>
    eae6:	80 91 59 34 	lds	r24, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    eaea:	20 91 55 34 	lds	r18, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    eaee:	30 91 56 34 	lds	r19, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    eaf2:	f9 01       	movw	r30, r18
    eaf4:	87 ff       	sbrs	r24, 7
    eaf6:	05 c0       	rjmp	.+10     	; 0xeb02 <CDC_Device_ReceiveByte+0x4a>
    eaf8:	ef 5b       	subi	r30, 0xBF	; 191
    eafa:	ff 4f       	sbci	r31, 0xFF	; 255
    eafc:	80 81       	ld	r24, Z
    eafe:	90 e0       	ldi	r25, 0x00	; 0
    eb00:	08 c0       	rjmp	.+16     	; 0xeb12 <CDC_Device_ReceiveByte+0x5a>
    eb02:	e0 5c       	subi	r30, 0xC0	; 192
    eb04:	ff 4f       	sbci	r31, 0xFF	; 255
    eb06:	80 81       	ld	r24, Z
    eb08:	31 96       	adiw	r30, 0x01	; 1
    eb0a:	20 81       	ld	r18, Z
    eb0c:	90 e0       	ldi	r25, 0x00	; 0
    eb0e:	82 1b       	sub	r24, r18
    eb10:	91 09       	sbc	r25, r1
    eb12:	89 2b       	or	r24, r25
    eb14:	21 f0       	breq	.+8      	; 0xeb1e <CDC_Device_ReceiveByte+0x66>
    eb16:	12 dc       	rcall	.-2012   	; 0xe33c <Endpoint_Read_8>
    eb18:	c8 2f       	mov	r28, r24
    eb1a:	d0 e0       	ldi	r29, 0x00	; 0
    eb1c:	02 c0       	rjmp	.+4      	; 0xeb22 <CDC_Device_ReceiveByte+0x6a>
    eb1e:	cf ef       	ldi	r28, 0xFF	; 255
    eb20:	df ef       	ldi	r29, 0xFF	; 255
    eb22:	20 91 59 34 	lds	r18, 0x3459	; 0x803459 <USB_Endpoint_SelectedEndpoint>
    eb26:	80 91 55 34 	lds	r24, 0x3455	; 0x803455 <USB_Endpoint_SelectedFIFO>
    eb2a:	90 91 56 34 	lds	r25, 0x3456	; 0x803456 <USB_Endpoint_SelectedFIFO+0x1>
    eb2e:	fc 01       	movw	r30, r24
    eb30:	27 ff       	sbrs	r18, 7
    eb32:	05 c0       	rjmp	.+10     	; 0xeb3e <CDC_Device_ReceiveByte+0x86>
    eb34:	ef 5b       	subi	r30, 0xBF	; 191
    eb36:	ff 4f       	sbci	r31, 0xFF	; 255
    eb38:	20 81       	ld	r18, Z
    eb3a:	30 e0       	ldi	r19, 0x00	; 0
    eb3c:	08 c0       	rjmp	.+16     	; 0xeb4e <CDC_Device_ReceiveByte+0x96>
    eb3e:	e0 5c       	subi	r30, 0xC0	; 192
    eb40:	ff 4f       	sbci	r31, 0xFF	; 255
    eb42:	20 81       	ld	r18, Z
    eb44:	31 96       	adiw	r30, 0x01	; 1
    eb46:	80 81       	ld	r24, Z
    eb48:	30 e0       	ldi	r19, 0x00	; 0
    eb4a:	28 1b       	sub	r18, r24
    eb4c:	31 09       	sbc	r19, r1
    eb4e:	23 2b       	or	r18, r19
    eb50:	09 f4       	brne	.+2      	; 0xeb54 <CDC_Device_ReceiveByte+0x9c>
    eb52:	e5 db       	rcall	.-2102   	; 0xe31e <Endpoint_ClearOUT>
    eb54:	ce 01       	movw	r24, r28
    eb56:	df 91       	pop	r29
    eb58:	cf 91       	pop	r28
    eb5a:	08 95       	ret

0000eb5c <CDC_Device_Event_Stub>:
	return ReceivedByte;
}
#endif

void CDC_Device_Event_Stub(void)
{
    eb5c:	08 95       	ret

0000eb5e <CDC_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_CDC_DRIVER
#define  __INCLUDE_FROM_CDC_DEVICE_C
#include "CDCClassDevice.h"

void CDC_Device_ProcessControlRequest(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    eb5e:	ff 92       	push	r15
    eb60:	0f 93       	push	r16
    eb62:	1f 93       	push	r17
    eb64:	cf 93       	push	r28
    eb66:	df 93       	push	r29
    eb68:	ec 01       	movw	r28, r24
	if (!(Endpoint_IsSETUPReceived()))
    eb6a:	63 dc       	rcall	.-1850   	; 0xe432 <Endpoint_IsSETUPReceived>
    eb6c:	88 23       	and	r24, r24
    eb6e:	09 f4       	brne	.+2      	; 0xeb72 <CDC_Device_ProcessControlRequest+0x14>
    eb70:	8e c0       	rjmp	.+284    	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
	  return;

	if (USB_ControlRequest.wIndex != CDCInterfaceInfo->Config.ControlInterfaceNumber)
    eb72:	88 81       	ld	r24, Y
    eb74:	90 e0       	ldi	r25, 0x00	; 0
    eb76:	20 91 51 34 	lds	r18, 0x3451	; 0x803451 <USB_ControlRequest+0x4>
    eb7a:	30 91 52 34 	lds	r19, 0x3452	; 0x803452 <USB_ControlRequest+0x5>
    eb7e:	28 17       	cp	r18, r24
    eb80:	39 07       	cpc	r19, r25
    eb82:	09 f0       	breq	.+2      	; 0xeb86 <CDC_Device_ProcessControlRequest+0x28>
    eb84:	84 c0       	rjmp	.+264    	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
	  return;

	switch (USB_ControlRequest.bRequest)
    eb86:	80 91 4e 34 	lds	r24, 0x344E	; 0x80344e <USB_ControlRequest+0x1>
    eb8a:	81 32       	cpi	r24, 0x21	; 33
    eb8c:	59 f0       	breq	.+22     	; 0xeba4 <CDC_Device_ProcessControlRequest+0x46>
    eb8e:	18 f4       	brcc	.+6      	; 0xeb96 <CDC_Device_ProcessControlRequest+0x38>
    eb90:	80 32       	cpi	r24, 0x20	; 32
    eb92:	49 f1       	breq	.+82     	; 0xebe6 <CDC_Device_ProcessControlRequest+0x88>
    eb94:	7c c0       	rjmp	.+248    	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
    eb96:	82 32       	cpi	r24, 0x22	; 34
    eb98:	09 f4       	brne	.+2      	; 0xeb9c <CDC_Device_ProcessControlRequest+0x3e>
    eb9a:	57 c0       	rjmp	.+174    	; 0xec4a <CDC_Device_ProcessControlRequest+0xec>
    eb9c:	83 32       	cpi	r24, 0x23	; 35
    eb9e:	09 f4       	brne	.+2      	; 0xeba2 <CDC_Device_ProcessControlRequest+0x44>
    eba0:	67 c0       	rjmp	.+206    	; 0xec70 <CDC_Device_ProcessControlRequest+0x112>
    eba2:	75 c0       	rjmp	.+234    	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    eba4:	80 91 4d 34 	lds	r24, 0x344D	; 0x80344d <USB_ControlRequest>
    eba8:	81 3a       	cpi	r24, 0xA1	; 161
    ebaa:	09 f0       	breq	.+2      	; 0xebae <CDC_Device_ProcessControlRequest+0x50>
			{
				Endpoint_ClearSETUP();
    ebac:	70 c0       	rjmp	.+224    	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>

				while (!(Endpoint_IsINReady()));
    ebae:	5b dc       	rcall	.-1866   	; 0xe466 <Endpoint_ClearSETUP>
    ebb0:	1a dc       	rcall	.-1996   	; 0xe3e6 <Endpoint_IsINReady>
    ebb2:	88 23       	and	r24, r24
    ebb4:	e9 f3       	breq	.-6      	; 0xebb0 <CDC_Device_ProcessControlRequest+0x52>

				Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
    ebb6:	8c 89       	ldd	r24, Y+20	; 0x14
    ebb8:	fd 88       	ldd	r15, Y+21	; 0x15
    ebba:	0e 89       	ldd	r16, Y+22	; 0x16
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_32_LE(const uint32_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_32_LE(const uint32_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    ebbc:	1f 89       	ldd	r17, Y+23	; 0x17
				Endpoint_Write_8(Data >> 8);
    ebbe:	ce db       	rcall	.-2148   	; 0xe35c <Endpoint_Write_8>
    ebc0:	8f 2d       	mov	r24, r15
				Endpoint_Write_8(Data >> 16);
    ebc2:	cc db       	rcall	.-2152   	; 0xe35c <Endpoint_Write_8>
    ebc4:	80 2f       	mov	r24, r16
				Endpoint_Write_8(Data >> 24);
    ebc6:	ca db       	rcall	.-2156   	; 0xe35c <Endpoint_Write_8>
    ebc8:	81 2f       	mov	r24, r17
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
    ebca:	c8 db       	rcall	.-2160   	; 0xe35c <Endpoint_Write_8>
    ebcc:	88 8d       	ldd	r24, Y+24	; 0x18
    ebce:	c6 db       	rcall	.-2164   	; 0xe35c <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
    ebd0:	89 8d       	ldd	r24, Y+25	; 0x19
    ebd2:	c4 db       	rcall	.-2168   	; 0xe35c <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
    ebd4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    ebd6:	c2 db       	rcall	.-2172   	; 0xe35c <Endpoint_Write_8>
    ebd8:	89 db       	rcall	.-2286   	; 0xe2ec <Endpoint_ClearIN>

				Endpoint_ClearIN();
    ebda:	df 91       	pop	r29
    ebdc:	cf 91       	pop	r28
				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
			}

			break;
	}
}
    ebde:	1f 91       	pop	r17
    ebe0:	0f 91       	pop	r16
    ebe2:	ff 90       	pop	r15
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);

				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    ebe4:	2f cd       	rjmp	.-1442   	; 0xe644 <Endpoint_ClearStatusStage>
    ebe6:	80 91 4d 34 	lds	r24, 0x344D	; 0x80344d <USB_ControlRequest>
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    ebea:	81 32       	cpi	r24, 0x21	; 33
    ebec:	09 f0       	breq	.+2      	; 0xebf0 <CDC_Device_ProcessControlRequest+0x92>
    ebee:	4f c0       	rjmp	.+158    	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
			{
				Endpoint_ClearSETUP();
    ebf0:	3a dc       	rcall	.-1932   	; 0xe466 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsOUTReceived()))
    ebf2:	05 dc       	rcall	.-2038   	; 0xe3fe <Endpoint_IsOUTReceived>
    ebf4:	81 11       	cpse	r24, r1
    ebf6:	05 c0       	rjmp	.+10     	; 0xec02 <CDC_Device_ProcessControlRequest+0xa4>
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    ebf8:	80 91 4c 34 	lds	r24, 0x344C	; 0x80344c <USB_DeviceState>
    ebfc:	81 11       	cpse	r24, r1
    ebfe:	f9 cf       	rjmp	.-14     	; 0xebf2 <CDC_Device_ProcessControlRequest+0x94>
    ec00:	46 c0       	rjmp	.+140    	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
			 *  \return Next four bytes in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
    ec02:	9c db       	rcall	.-2248   	; 0xe33c <Endpoint_Read_8>
    ec04:	f8 2e       	mov	r15, r24
    ec06:	9a db       	rcall	.-2252   	; 0xe33c <Endpoint_Read_8>
				uint32_t Byte1 = Endpoint_Read_8();
    ec08:	18 2f       	mov	r17, r24
    ec0a:	98 db       	rcall	.-2256   	; 0xe33c <Endpoint_Read_8>
    ec0c:	08 2f       	mov	r16, r24
				uint32_t Byte2 = Endpoint_Read_8();
    ec0e:	96 db       	rcall	.-2260   	; 0xe33c <Endpoint_Read_8>
    ec10:	40 2f       	mov	r20, r16
				uint32_t Byte3 = Endpoint_Read_8();
    ec12:	50 e0       	ldi	r21, 0x00	; 0
					  return;
				}

				CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
    ec14:	60 e0       	ldi	r22, 0x00	; 0
    ec16:	70 e0       	ldi	r23, 0x00	; 0
    ec18:	ba 01       	movw	r22, r20
    ec1a:	55 27       	eor	r21, r21
    ec1c:	44 27       	eor	r20, r20
    ec1e:	78 2b       	or	r23, r24
    ec20:	4f 29       	or	r20, r15
    ec22:	51 2b       	or	r21, r17
    ec24:	4c 8b       	std	Y+20, r20	; 0x14
    ec26:	5d 8b       	std	Y+21, r21	; 0x15
				CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
    ec28:	6e 8b       	std	Y+22, r22	; 0x16
    ec2a:	7f 8b       	std	Y+23, r23	; 0x17
				CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
    ec2c:	87 db       	rcall	.-2290   	; 0xe33c <Endpoint_Read_8>
    ec2e:	88 8f       	std	Y+24, r24	; 0x18
    ec30:	85 db       	rcall	.-2294   	; 0xe33c <Endpoint_Read_8>
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
    ec32:	89 8f       	std	Y+25, r24	; 0x19
    ec34:	83 db       	rcall	.-2298   	; 0xe33c <Endpoint_Read_8>
    ec36:	8a 8f       	std	Y+26, r24	; 0x1a

				Endpoint_ClearOUT();
    ec38:	72 db       	rcall	.-2332   	; 0xe31e <Endpoint_ClearOUT>
    ec3a:	04 dd       	rcall	.-1528   	; 0xe644 <Endpoint_ClearStatusStage>
				Endpoint_ClearStatusStage();
    ec3c:	ce 01       	movw	r24, r28
    ec3e:	df 91       	pop	r29

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    ec40:	cf 91       	pop	r28
				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
			}

			break;
	}
}
    ec42:	1f 91       	pop	r17
    ec44:	0f 91       	pop	r16
    ec46:	ff 90       	pop	r15
    ec48:	89 cf       	rjmp	.-238    	; 0xeb5c <CDC_Device_Event_Stub>
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();

				Endpoint_ClearOUT();
				Endpoint_ClearStatusStage();

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    ec4a:	80 91 4d 34 	lds	r24, 0x344D	; 0x80344d <USB_ControlRequest>
			}

			break;
		case CDC_REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    ec4e:	81 32       	cpi	r24, 0x21	; 33
    ec50:	f1 f4       	brne	.+60     	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
			{
				Endpoint_ClearSETUP();
    ec52:	09 dc       	rcall	.-2030   	; 0xe466 <Endpoint_ClearSETUP>
    ec54:	f7 dc       	rcall	.-1554   	; 0xe644 <Endpoint_ClearStatusStage>
				Endpoint_ClearStatusStage();
    ec56:	80 91 4f 34 	lds	r24, 0x344F	; 0x80344f <USB_ControlRequest+0x2>

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
    ec5a:	90 91 50 34 	lds	r25, 0x3450	; 0x803450 <USB_ControlRequest+0x3>
    ec5e:	88 8b       	std	Y+16, r24	; 0x10
    ec60:	99 8b       	std	Y+17, r25	; 0x11
    ec62:	ce 01       	movw	r24, r28

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    ec64:	df 91       	pop	r29
				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
			}

			break;
	}
}
    ec66:	cf 91       	pop	r28
    ec68:	1f 91       	pop	r17
    ec6a:	0f 91       	pop	r16
    ec6c:	ff 90       	pop	r15
    ec6e:	76 cf       	rjmp	.-276    	; 0xeb5c <CDC_Device_Event_Stub>
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    ec70:	80 91 4d 34 	lds	r24, 0x344D	; 0x80344d <USB_ControlRequest>
			}

			break;
		case CDC_REQ_SendBreak:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    ec74:	81 32       	cpi	r24, 0x21	; 33
    ec76:	59 f4       	brne	.+22     	; 0xec8e <CDC_Device_ProcessControlRequest+0x130>
    ec78:	f6 db       	rcall	.-2068   	; 0xe466 <Endpoint_ClearSETUP>
    ec7a:	e4 dc       	rcall	.-1592   	; 0xe644 <Endpoint_ClearStatusStage>
			{
				Endpoint_ClearSETUP();
    ec7c:	60 91 4f 34 	lds	r22, 0x344F	; 0x80344f <USB_ControlRequest+0x2>
				Endpoint_ClearStatusStage();
    ec80:	ce 01       	movw	r24, r28
    ec82:	df 91       	pop	r29

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    ec84:	cf 91       	pop	r28
    ec86:	1f 91       	pop	r17
    ec88:	0f 91       	pop	r16
			}

			break;
	}
}
    ec8a:	ff 90       	pop	r15
    ec8c:	67 cf       	rjmp	.-306    	; 0xeb5c <CDC_Device_Event_Stub>
    ec8e:	df 91       	pop	r29
    ec90:	cf 91       	pop	r28
    ec92:	1f 91       	pop	r17
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    ec94:	0f 91       	pop	r16
    ec96:	ff 90       	pop	r15
			}

			break;
	}
}
    ec98:	08 95       	ret

0000ec9a <ceil>:
    ec9a:	56 d1       	rcall	.+684    	; 0xef48 <__fp_trunc>
    ec9c:	80 f0       	brcs	.+32     	; 0xecbe <ceil+0x24>
    ec9e:	9f 37       	cpi	r25, 0x7F	; 127
    eca0:	40 f4       	brcc	.+16     	; 0xecb2 <ceil+0x18>
    eca2:	91 11       	cpse	r25, r1
    eca4:	0e f4       	brtc	.+2      	; 0xeca8 <ceil+0xe>
    eca6:	68 c1       	rjmp	.+720    	; 0xef78 <__fp_szero>
    eca8:	60 e0       	ldi	r22, 0x00	; 0
    ecaa:	70 e0       	ldi	r23, 0x00	; 0
    ecac:	80 e8       	ldi	r24, 0x80	; 128
    ecae:	9f e3       	ldi	r25, 0x3F	; 63
    ecb0:	08 95       	ret
    ecb2:	26 f0       	brts	.+8      	; 0xecbc <ceil+0x22>
    ecb4:	1b 16       	cp	r1, r27
    ecb6:	61 1d       	adc	r22, r1
    ecb8:	71 1d       	adc	r23, r1
    ecba:	81 1d       	adc	r24, r1
    ecbc:	d8 c0       	rjmp	.+432    	; 0xee6e <__fp_mintl>
    ecbe:	f2 c0       	rjmp	.+484    	; 0xeea4 <__fp_mpack>

0000ecc0 <__divsf3>:
    ecc0:	0c d0       	rcall	.+24     	; 0xecda <__divsf3x>
    ecc2:	0f c1       	rjmp	.+542    	; 0xeee2 <__fp_round>
    ecc4:	07 d1       	rcall	.+526    	; 0xeed4 <__fp_pscB>
    ecc6:	40 f0       	brcs	.+16     	; 0xecd8 <__divsf3+0x18>
    ecc8:	fe d0       	rcall	.+508    	; 0xeec6 <__fp_pscA>
    ecca:	30 f0       	brcs	.+12     	; 0xecd8 <__divsf3+0x18>
    eccc:	21 f4       	brne	.+8      	; 0xecd6 <__divsf3+0x16>
    ecce:	5f 3f       	cpi	r21, 0xFF	; 255
    ecd0:	19 f0       	breq	.+6      	; 0xecd8 <__divsf3+0x18>
    ecd2:	c7 c0       	rjmp	.+398    	; 0xee62 <__fp_inf>
    ecd4:	51 11       	cpse	r21, r1
    ecd6:	50 c1       	rjmp	.+672    	; 0xef78 <__fp_szero>
    ecd8:	f3 c0       	rjmp	.+486    	; 0xeec0 <__fp_nan>

0000ecda <__divsf3x>:
    ecda:	14 d1       	rcall	.+552    	; 0xef04 <__fp_split3>
    ecdc:	98 f3       	brcs	.-26     	; 0xecc4 <__divsf3+0x4>

0000ecde <__divsf3_pse>:
    ecde:	99 23       	and	r25, r25
    ece0:	c9 f3       	breq	.-14     	; 0xecd4 <__divsf3+0x14>
    ece2:	55 23       	and	r21, r21
    ece4:	b1 f3       	breq	.-20     	; 0xecd2 <__divsf3+0x12>
    ece6:	95 1b       	sub	r25, r21
    ece8:	55 0b       	sbc	r21, r21
    ecea:	bb 27       	eor	r27, r27
    ecec:	aa 27       	eor	r26, r26
    ecee:	62 17       	cp	r22, r18
    ecf0:	73 07       	cpc	r23, r19
    ecf2:	84 07       	cpc	r24, r20
    ecf4:	38 f0       	brcs	.+14     	; 0xed04 <__divsf3_pse+0x26>
    ecf6:	9f 5f       	subi	r25, 0xFF	; 255
    ecf8:	5f 4f       	sbci	r21, 0xFF	; 255
    ecfa:	22 0f       	add	r18, r18
    ecfc:	33 1f       	adc	r19, r19
    ecfe:	44 1f       	adc	r20, r20
    ed00:	aa 1f       	adc	r26, r26
    ed02:	a9 f3       	breq	.-22     	; 0xecee <__divsf3_pse+0x10>
    ed04:	33 d0       	rcall	.+102    	; 0xed6c <__divsf3_pse+0x8e>
    ed06:	0e 2e       	mov	r0, r30
    ed08:	3a f0       	brmi	.+14     	; 0xed18 <__divsf3_pse+0x3a>
    ed0a:	e0 e8       	ldi	r30, 0x80	; 128
    ed0c:	30 d0       	rcall	.+96     	; 0xed6e <__divsf3_pse+0x90>
    ed0e:	91 50       	subi	r25, 0x01	; 1
    ed10:	50 40       	sbci	r21, 0x00	; 0
    ed12:	e6 95       	lsr	r30
    ed14:	00 1c       	adc	r0, r0
    ed16:	ca f7       	brpl	.-14     	; 0xed0a <__divsf3_pse+0x2c>
    ed18:	29 d0       	rcall	.+82     	; 0xed6c <__divsf3_pse+0x8e>
    ed1a:	fe 2f       	mov	r31, r30
    ed1c:	27 d0       	rcall	.+78     	; 0xed6c <__divsf3_pse+0x8e>
    ed1e:	66 0f       	add	r22, r22
    ed20:	77 1f       	adc	r23, r23
    ed22:	88 1f       	adc	r24, r24
    ed24:	bb 1f       	adc	r27, r27
    ed26:	26 17       	cp	r18, r22
    ed28:	37 07       	cpc	r19, r23
    ed2a:	48 07       	cpc	r20, r24
    ed2c:	ab 07       	cpc	r26, r27
    ed2e:	b0 e8       	ldi	r27, 0x80	; 128
    ed30:	09 f0       	breq	.+2      	; 0xed34 <__divsf3_pse+0x56>
    ed32:	bb 0b       	sbc	r27, r27
    ed34:	80 2d       	mov	r24, r0
    ed36:	bf 01       	movw	r22, r30
    ed38:	ff 27       	eor	r31, r31
    ed3a:	93 58       	subi	r25, 0x83	; 131
    ed3c:	5f 4f       	sbci	r21, 0xFF	; 255
    ed3e:	2a f0       	brmi	.+10     	; 0xed4a <__divsf3_pse+0x6c>
    ed40:	9e 3f       	cpi	r25, 0xFE	; 254
    ed42:	51 05       	cpc	r21, r1
    ed44:	68 f0       	brcs	.+26     	; 0xed60 <__divsf3_pse+0x82>
    ed46:	8d c0       	rjmp	.+282    	; 0xee62 <__fp_inf>
    ed48:	17 c1       	rjmp	.+558    	; 0xef78 <__fp_szero>
    ed4a:	5f 3f       	cpi	r21, 0xFF	; 255
    ed4c:	ec f3       	brlt	.-6      	; 0xed48 <__divsf3_pse+0x6a>
    ed4e:	98 3e       	cpi	r25, 0xE8	; 232
    ed50:	dc f3       	brlt	.-10     	; 0xed48 <__divsf3_pse+0x6a>
    ed52:	86 95       	lsr	r24
    ed54:	77 95       	ror	r23
    ed56:	67 95       	ror	r22
    ed58:	b7 95       	ror	r27
    ed5a:	f7 95       	ror	r31
    ed5c:	9f 5f       	subi	r25, 0xFF	; 255
    ed5e:	c9 f7       	brne	.-14     	; 0xed52 <__divsf3_pse+0x74>
    ed60:	88 0f       	add	r24, r24
    ed62:	91 1d       	adc	r25, r1
    ed64:	96 95       	lsr	r25
    ed66:	87 95       	ror	r24
    ed68:	97 f9       	bld	r25, 7
    ed6a:	08 95       	ret
    ed6c:	e1 e0       	ldi	r30, 0x01	; 1
    ed6e:	66 0f       	add	r22, r22
    ed70:	77 1f       	adc	r23, r23
    ed72:	88 1f       	adc	r24, r24
    ed74:	bb 1f       	adc	r27, r27
    ed76:	62 17       	cp	r22, r18
    ed78:	73 07       	cpc	r23, r19
    ed7a:	84 07       	cpc	r24, r20
    ed7c:	ba 07       	cpc	r27, r26
    ed7e:	20 f0       	brcs	.+8      	; 0xed88 <__divsf3_pse+0xaa>
    ed80:	62 1b       	sub	r22, r18
    ed82:	73 0b       	sbc	r23, r19
    ed84:	84 0b       	sbc	r24, r20
    ed86:	ba 0b       	sbc	r27, r26
    ed88:	ee 1f       	adc	r30, r30
    ed8a:	88 f7       	brcc	.-30     	; 0xed6e <__divsf3_pse+0x90>
    ed8c:	e0 95       	com	r30
    ed8e:	08 95       	ret

0000ed90 <__fixunssfsi>:
    ed90:	c1 d0       	rcall	.+386    	; 0xef14 <__fp_splitA>
    ed92:	88 f0       	brcs	.+34     	; 0xedb6 <__fixunssfsi+0x26>
    ed94:	9f 57       	subi	r25, 0x7F	; 127
    ed96:	90 f0       	brcs	.+36     	; 0xedbc <__fixunssfsi+0x2c>
    ed98:	b9 2f       	mov	r27, r25
    ed9a:	99 27       	eor	r25, r25
    ed9c:	b7 51       	subi	r27, 0x17	; 23
    ed9e:	a0 f0       	brcs	.+40     	; 0xedc8 <__fixunssfsi+0x38>
    eda0:	d1 f0       	breq	.+52     	; 0xedd6 <__fixunssfsi+0x46>
    eda2:	66 0f       	add	r22, r22
    eda4:	77 1f       	adc	r23, r23
    eda6:	88 1f       	adc	r24, r24
    eda8:	99 1f       	adc	r25, r25
    edaa:	1a f0       	brmi	.+6      	; 0xedb2 <__fixunssfsi+0x22>
    edac:	ba 95       	dec	r27
    edae:	c9 f7       	brne	.-14     	; 0xeda2 <__fixunssfsi+0x12>
    edb0:	12 c0       	rjmp	.+36     	; 0xedd6 <__fixunssfsi+0x46>
    edb2:	b1 30       	cpi	r27, 0x01	; 1
    edb4:	81 f0       	breq	.+32     	; 0xedd6 <__fixunssfsi+0x46>
    edb6:	df d0       	rcall	.+446    	; 0xef76 <__fp_zero>
    edb8:	b1 e0       	ldi	r27, 0x01	; 1
    edba:	08 95       	ret
    edbc:	dc c0       	rjmp	.+440    	; 0xef76 <__fp_zero>
    edbe:	67 2f       	mov	r22, r23
    edc0:	78 2f       	mov	r23, r24
    edc2:	88 27       	eor	r24, r24
    edc4:	b8 5f       	subi	r27, 0xF8	; 248
    edc6:	39 f0       	breq	.+14     	; 0xedd6 <__fixunssfsi+0x46>
    edc8:	b9 3f       	cpi	r27, 0xF9	; 249
    edca:	cc f3       	brlt	.-14     	; 0xedbe <__fixunssfsi+0x2e>
    edcc:	86 95       	lsr	r24
    edce:	77 95       	ror	r23
    edd0:	67 95       	ror	r22
    edd2:	b3 95       	inc	r27
    edd4:	d9 f7       	brne	.-10     	; 0xedcc <__fixunssfsi+0x3c>
    edd6:	3e f4       	brtc	.+14     	; 0xede6 <__fixunssfsi+0x56>
    edd8:	90 95       	com	r25
    edda:	80 95       	com	r24
    eddc:	70 95       	com	r23
    edde:	61 95       	neg	r22
    ede0:	7f 4f       	sbci	r23, 0xFF	; 255
    ede2:	8f 4f       	sbci	r24, 0xFF	; 255
    ede4:	9f 4f       	sbci	r25, 0xFF	; 255
    ede6:	08 95       	ret

0000ede8 <__floatunsisf>:
    ede8:	e8 94       	clt
    edea:	09 c0       	rjmp	.+18     	; 0xedfe <__floatsisf+0x12>

0000edec <__floatsisf>:
    edec:	97 fb       	bst	r25, 7
    edee:	3e f4       	brtc	.+14     	; 0xedfe <__floatsisf+0x12>
    edf0:	90 95       	com	r25
    edf2:	80 95       	com	r24
    edf4:	70 95       	com	r23
    edf6:	61 95       	neg	r22
    edf8:	7f 4f       	sbci	r23, 0xFF	; 255
    edfa:	8f 4f       	sbci	r24, 0xFF	; 255
    edfc:	9f 4f       	sbci	r25, 0xFF	; 255
    edfe:	99 23       	and	r25, r25
    ee00:	a9 f0       	breq	.+42     	; 0xee2c <__floatsisf+0x40>
    ee02:	f9 2f       	mov	r31, r25
    ee04:	96 e9       	ldi	r25, 0x96	; 150
    ee06:	bb 27       	eor	r27, r27
    ee08:	93 95       	inc	r25
    ee0a:	f6 95       	lsr	r31
    ee0c:	87 95       	ror	r24
    ee0e:	77 95       	ror	r23
    ee10:	67 95       	ror	r22
    ee12:	b7 95       	ror	r27
    ee14:	f1 11       	cpse	r31, r1
    ee16:	f8 cf       	rjmp	.-16     	; 0xee08 <__floatsisf+0x1c>
    ee18:	fa f4       	brpl	.+62     	; 0xee58 <__floatsisf+0x6c>
    ee1a:	bb 0f       	add	r27, r27
    ee1c:	11 f4       	brne	.+4      	; 0xee22 <__floatsisf+0x36>
    ee1e:	60 ff       	sbrs	r22, 0
    ee20:	1b c0       	rjmp	.+54     	; 0xee58 <__floatsisf+0x6c>
    ee22:	6f 5f       	subi	r22, 0xFF	; 255
    ee24:	7f 4f       	sbci	r23, 0xFF	; 255
    ee26:	8f 4f       	sbci	r24, 0xFF	; 255
    ee28:	9f 4f       	sbci	r25, 0xFF	; 255
    ee2a:	16 c0       	rjmp	.+44     	; 0xee58 <__floatsisf+0x6c>
    ee2c:	88 23       	and	r24, r24
    ee2e:	11 f0       	breq	.+4      	; 0xee34 <__floatsisf+0x48>
    ee30:	96 e9       	ldi	r25, 0x96	; 150
    ee32:	11 c0       	rjmp	.+34     	; 0xee56 <__floatsisf+0x6a>
    ee34:	77 23       	and	r23, r23
    ee36:	21 f0       	breq	.+8      	; 0xee40 <__floatsisf+0x54>
    ee38:	9e e8       	ldi	r25, 0x8E	; 142
    ee3a:	87 2f       	mov	r24, r23
    ee3c:	76 2f       	mov	r23, r22
    ee3e:	05 c0       	rjmp	.+10     	; 0xee4a <__floatsisf+0x5e>
    ee40:	66 23       	and	r22, r22
    ee42:	71 f0       	breq	.+28     	; 0xee60 <__floatsisf+0x74>
    ee44:	96 e8       	ldi	r25, 0x86	; 134
    ee46:	86 2f       	mov	r24, r22
    ee48:	70 e0       	ldi	r23, 0x00	; 0
    ee4a:	60 e0       	ldi	r22, 0x00	; 0
    ee4c:	2a f0       	brmi	.+10     	; 0xee58 <__floatsisf+0x6c>
    ee4e:	9a 95       	dec	r25
    ee50:	66 0f       	add	r22, r22
    ee52:	77 1f       	adc	r23, r23
    ee54:	88 1f       	adc	r24, r24
    ee56:	da f7       	brpl	.-10     	; 0xee4e <__floatsisf+0x62>
    ee58:	88 0f       	add	r24, r24
    ee5a:	96 95       	lsr	r25
    ee5c:	87 95       	ror	r24
    ee5e:	97 f9       	bld	r25, 7
    ee60:	08 95       	ret

0000ee62 <__fp_inf>:
    ee62:	97 f9       	bld	r25, 7
    ee64:	9f 67       	ori	r25, 0x7F	; 127
    ee66:	80 e8       	ldi	r24, 0x80	; 128
    ee68:	70 e0       	ldi	r23, 0x00	; 0
    ee6a:	60 e0       	ldi	r22, 0x00	; 0
    ee6c:	08 95       	ret

0000ee6e <__fp_mintl>:
    ee6e:	88 23       	and	r24, r24
    ee70:	71 f4       	brne	.+28     	; 0xee8e <__fp_mintl+0x20>
    ee72:	77 23       	and	r23, r23
    ee74:	21 f0       	breq	.+8      	; 0xee7e <__fp_mintl+0x10>
    ee76:	98 50       	subi	r25, 0x08	; 8
    ee78:	87 2b       	or	r24, r23
    ee7a:	76 2f       	mov	r23, r22
    ee7c:	07 c0       	rjmp	.+14     	; 0xee8c <__fp_mintl+0x1e>
    ee7e:	66 23       	and	r22, r22
    ee80:	11 f4       	brne	.+4      	; 0xee86 <__fp_mintl+0x18>
    ee82:	99 27       	eor	r25, r25
    ee84:	0d c0       	rjmp	.+26     	; 0xeea0 <__fp_mintl+0x32>
    ee86:	90 51       	subi	r25, 0x10	; 16
    ee88:	86 2b       	or	r24, r22
    ee8a:	70 e0       	ldi	r23, 0x00	; 0
    ee8c:	60 e0       	ldi	r22, 0x00	; 0
    ee8e:	2a f0       	brmi	.+10     	; 0xee9a <__fp_mintl+0x2c>
    ee90:	9a 95       	dec	r25
    ee92:	66 0f       	add	r22, r22
    ee94:	77 1f       	adc	r23, r23
    ee96:	88 1f       	adc	r24, r24
    ee98:	da f7       	brpl	.-10     	; 0xee90 <__fp_mintl+0x22>
    ee9a:	88 0f       	add	r24, r24
    ee9c:	96 95       	lsr	r25
    ee9e:	87 95       	ror	r24
    eea0:	97 f9       	bld	r25, 7
    eea2:	08 95       	ret

0000eea4 <__fp_mpack>:
    eea4:	9f 3f       	cpi	r25, 0xFF	; 255
    eea6:	31 f0       	breq	.+12     	; 0xeeb4 <__fp_mpack_finite+0xc>

0000eea8 <__fp_mpack_finite>:
    eea8:	91 50       	subi	r25, 0x01	; 1
    eeaa:	20 f4       	brcc	.+8      	; 0xeeb4 <__fp_mpack_finite+0xc>
    eeac:	87 95       	ror	r24
    eeae:	77 95       	ror	r23
    eeb0:	67 95       	ror	r22
    eeb2:	b7 95       	ror	r27
    eeb4:	88 0f       	add	r24, r24
    eeb6:	91 1d       	adc	r25, r1
    eeb8:	96 95       	lsr	r25
    eeba:	87 95       	ror	r24
    eebc:	97 f9       	bld	r25, 7
    eebe:	08 95       	ret

0000eec0 <__fp_nan>:
    eec0:	9f ef       	ldi	r25, 0xFF	; 255
    eec2:	80 ec       	ldi	r24, 0xC0	; 192
    eec4:	08 95       	ret

0000eec6 <__fp_pscA>:
    eec6:	00 24       	eor	r0, r0
    eec8:	0a 94       	dec	r0
    eeca:	16 16       	cp	r1, r22
    eecc:	17 06       	cpc	r1, r23
    eece:	18 06       	cpc	r1, r24
    eed0:	09 06       	cpc	r0, r25
    eed2:	08 95       	ret

0000eed4 <__fp_pscB>:
    eed4:	00 24       	eor	r0, r0
    eed6:	0a 94       	dec	r0
    eed8:	12 16       	cp	r1, r18
    eeda:	13 06       	cpc	r1, r19
    eedc:	14 06       	cpc	r1, r20
    eede:	05 06       	cpc	r0, r21
    eee0:	08 95       	ret

0000eee2 <__fp_round>:
    eee2:	09 2e       	mov	r0, r25
    eee4:	03 94       	inc	r0
    eee6:	00 0c       	add	r0, r0
    eee8:	11 f4       	brne	.+4      	; 0xeeee <__fp_round+0xc>
    eeea:	88 23       	and	r24, r24
    eeec:	52 f0       	brmi	.+20     	; 0xef02 <__fp_round+0x20>
    eeee:	bb 0f       	add	r27, r27
    eef0:	40 f4       	brcc	.+16     	; 0xef02 <__fp_round+0x20>
    eef2:	bf 2b       	or	r27, r31
    eef4:	11 f4       	brne	.+4      	; 0xeefa <__fp_round+0x18>
    eef6:	60 ff       	sbrs	r22, 0
    eef8:	04 c0       	rjmp	.+8      	; 0xef02 <__fp_round+0x20>
    eefa:	6f 5f       	subi	r22, 0xFF	; 255
    eefc:	7f 4f       	sbci	r23, 0xFF	; 255
    eefe:	8f 4f       	sbci	r24, 0xFF	; 255
    ef00:	9f 4f       	sbci	r25, 0xFF	; 255
    ef02:	08 95       	ret

0000ef04 <__fp_split3>:
    ef04:	57 fd       	sbrc	r21, 7
    ef06:	90 58       	subi	r25, 0x80	; 128
    ef08:	44 0f       	add	r20, r20
    ef0a:	55 1f       	adc	r21, r21
    ef0c:	59 f0       	breq	.+22     	; 0xef24 <__fp_splitA+0x10>
    ef0e:	5f 3f       	cpi	r21, 0xFF	; 255
    ef10:	71 f0       	breq	.+28     	; 0xef2e <__fp_splitA+0x1a>
    ef12:	47 95       	ror	r20

0000ef14 <__fp_splitA>:
    ef14:	88 0f       	add	r24, r24
    ef16:	97 fb       	bst	r25, 7
    ef18:	99 1f       	adc	r25, r25
    ef1a:	61 f0       	breq	.+24     	; 0xef34 <__fp_splitA+0x20>
    ef1c:	9f 3f       	cpi	r25, 0xFF	; 255
    ef1e:	79 f0       	breq	.+30     	; 0xef3e <__fp_splitA+0x2a>
    ef20:	87 95       	ror	r24
    ef22:	08 95       	ret
    ef24:	12 16       	cp	r1, r18
    ef26:	13 06       	cpc	r1, r19
    ef28:	14 06       	cpc	r1, r20
    ef2a:	55 1f       	adc	r21, r21
    ef2c:	f2 cf       	rjmp	.-28     	; 0xef12 <__fp_split3+0xe>
    ef2e:	46 95       	lsr	r20
    ef30:	f1 df       	rcall	.-30     	; 0xef14 <__fp_splitA>
    ef32:	08 c0       	rjmp	.+16     	; 0xef44 <__fp_splitA+0x30>
    ef34:	16 16       	cp	r1, r22
    ef36:	17 06       	cpc	r1, r23
    ef38:	18 06       	cpc	r1, r24
    ef3a:	99 1f       	adc	r25, r25
    ef3c:	f1 cf       	rjmp	.-30     	; 0xef20 <__fp_splitA+0xc>
    ef3e:	86 95       	lsr	r24
    ef40:	71 05       	cpc	r23, r1
    ef42:	61 05       	cpc	r22, r1
    ef44:	08 94       	sec
    ef46:	08 95       	ret

0000ef48 <__fp_trunc>:
    ef48:	e5 df       	rcall	.-54     	; 0xef14 <__fp_splitA>
    ef4a:	a0 f0       	brcs	.+40     	; 0xef74 <__fp_trunc+0x2c>
    ef4c:	be e7       	ldi	r27, 0x7E	; 126
    ef4e:	b9 17       	cp	r27, r25
    ef50:	88 f4       	brcc	.+34     	; 0xef74 <__fp_trunc+0x2c>
    ef52:	bb 27       	eor	r27, r27
    ef54:	9f 38       	cpi	r25, 0x8F	; 143
    ef56:	60 f4       	brcc	.+24     	; 0xef70 <__fp_trunc+0x28>
    ef58:	16 16       	cp	r1, r22
    ef5a:	b1 1d       	adc	r27, r1
    ef5c:	67 2f       	mov	r22, r23
    ef5e:	78 2f       	mov	r23, r24
    ef60:	88 27       	eor	r24, r24
    ef62:	98 5f       	subi	r25, 0xF8	; 248
    ef64:	f7 cf       	rjmp	.-18     	; 0xef54 <__fp_trunc+0xc>
    ef66:	86 95       	lsr	r24
    ef68:	77 95       	ror	r23
    ef6a:	67 95       	ror	r22
    ef6c:	b1 1d       	adc	r27, r1
    ef6e:	93 95       	inc	r25
    ef70:	96 39       	cpi	r25, 0x96	; 150
    ef72:	c8 f3       	brcs	.-14     	; 0xef66 <__fp_trunc+0x1e>
    ef74:	08 95       	ret

0000ef76 <__fp_zero>:
    ef76:	e8 94       	clt

0000ef78 <__fp_szero>:
    ef78:	bb 27       	eor	r27, r27
    ef7a:	66 27       	eor	r22, r22
    ef7c:	77 27       	eor	r23, r23
    ef7e:	cb 01       	movw	r24, r22
    ef80:	97 f9       	bld	r25, 7
    ef82:	08 95       	ret

0000ef84 <__gesf2>:
    ef84:	03 d0       	rcall	.+6      	; 0xef8c <__fp_cmp>
    ef86:	08 f4       	brcc	.+2      	; 0xef8a <__gesf2+0x6>
    ef88:	8f ef       	ldi	r24, 0xFF	; 255
    ef8a:	08 95       	ret

0000ef8c <__fp_cmp>:
    ef8c:	99 0f       	add	r25, r25
    ef8e:	00 08       	sbc	r0, r0
    ef90:	55 0f       	add	r21, r21
    ef92:	aa 0b       	sbc	r26, r26
    ef94:	e0 e8       	ldi	r30, 0x80	; 128
    ef96:	fe ef       	ldi	r31, 0xFE	; 254
    ef98:	16 16       	cp	r1, r22
    ef9a:	17 06       	cpc	r1, r23
    ef9c:	e8 07       	cpc	r30, r24
    ef9e:	f9 07       	cpc	r31, r25
    efa0:	c0 f0       	brcs	.+48     	; 0xefd2 <__fp_cmp+0x46>
    efa2:	12 16       	cp	r1, r18
    efa4:	13 06       	cpc	r1, r19
    efa6:	e4 07       	cpc	r30, r20
    efa8:	f5 07       	cpc	r31, r21
    efaa:	98 f0       	brcs	.+38     	; 0xefd2 <__fp_cmp+0x46>
    efac:	62 1b       	sub	r22, r18
    efae:	73 0b       	sbc	r23, r19
    efb0:	84 0b       	sbc	r24, r20
    efb2:	95 0b       	sbc	r25, r21
    efb4:	39 f4       	brne	.+14     	; 0xefc4 <__fp_cmp+0x38>
    efb6:	0a 26       	eor	r0, r26
    efb8:	61 f0       	breq	.+24     	; 0xefd2 <__fp_cmp+0x46>
    efba:	23 2b       	or	r18, r19
    efbc:	24 2b       	or	r18, r20
    efbe:	25 2b       	or	r18, r21
    efc0:	21 f4       	brne	.+8      	; 0xefca <__fp_cmp+0x3e>
    efc2:	08 95       	ret
    efc4:	0a 26       	eor	r0, r26
    efc6:	09 f4       	brne	.+2      	; 0xefca <__fp_cmp+0x3e>
    efc8:	a1 40       	sbci	r26, 0x01	; 1
    efca:	a6 95       	lsr	r26
    efcc:	8f ef       	ldi	r24, 0xFF	; 255
    efce:	81 1d       	adc	r24, r1
    efd0:	81 1d       	adc	r24, r1
    efd2:	08 95       	ret

0000efd4 <__udivmodhi4>:
    efd4:	aa 1b       	sub	r26, r26
    efd6:	bb 1b       	sub	r27, r27
    efd8:	51 e1       	ldi	r21, 0x11	; 17
    efda:	07 c0       	rjmp	.+14     	; 0xefea <__udivmodhi4_ep>

0000efdc <__udivmodhi4_loop>:
    efdc:	aa 1f       	adc	r26, r26
    efde:	bb 1f       	adc	r27, r27
    efe0:	a6 17       	cp	r26, r22
    efe2:	b7 07       	cpc	r27, r23
    efe4:	10 f0       	brcs	.+4      	; 0xefea <__udivmodhi4_ep>
    efe6:	a6 1b       	sub	r26, r22
    efe8:	b7 0b       	sbc	r27, r23

0000efea <__udivmodhi4_ep>:
    efea:	88 1f       	adc	r24, r24
    efec:	99 1f       	adc	r25, r25
    efee:	5a 95       	dec	r21
    eff0:	a9 f7       	brne	.-22     	; 0xefdc <__udivmodhi4_loop>
    eff2:	80 95       	com	r24
    eff4:	90 95       	com	r25
    eff6:	bc 01       	movw	r22, r24
    eff8:	cd 01       	movw	r24, r26
    effa:	08 95       	ret

0000effc <__mulshisi3>:
    effc:	b7 ff       	sbrs	r27, 7
    effe:	04 c0       	rjmp	.+8      	; 0xf008 <__muluhisi3>

0000f000 <__mulohisi3>:
    f000:	03 d0       	rcall	.+6      	; 0xf008 <__muluhisi3>
    f002:	82 1b       	sub	r24, r18
    f004:	93 0b       	sbc	r25, r19
    f006:	08 95       	ret

0000f008 <__muluhisi3>:
    f008:	09 d0       	rcall	.+18     	; 0xf01c <__umulhisi3>
    f00a:	a5 9f       	mul	r26, r21
    f00c:	90 0d       	add	r25, r0
    f00e:	b4 9f       	mul	r27, r20
    f010:	90 0d       	add	r25, r0
    f012:	a4 9f       	mul	r26, r20
    f014:	80 0d       	add	r24, r0
    f016:	91 1d       	adc	r25, r1
    f018:	11 24       	eor	r1, r1
    f01a:	08 95       	ret

0000f01c <__umulhisi3>:
    f01c:	a2 9f       	mul	r26, r18
    f01e:	b0 01       	movw	r22, r0
    f020:	b3 9f       	mul	r27, r19
    f022:	c0 01       	movw	r24, r0
    f024:	a3 9f       	mul	r26, r19
    f026:	70 0d       	add	r23, r0
    f028:	81 1d       	adc	r24, r1
    f02a:	11 24       	eor	r1, r1
    f02c:	91 1d       	adc	r25, r1
    f02e:	b2 9f       	mul	r27, r18
    f030:	70 0d       	add	r23, r0
    f032:	81 1d       	adc	r24, r1
    f034:	11 24       	eor	r1, r1
    f036:	91 1d       	adc	r25, r1
    f038:	08 95       	ret

0000f03a <do_rand>:
    f03a:	8f 92       	push	r8
    f03c:	9f 92       	push	r9
    f03e:	af 92       	push	r10
    f040:	bf 92       	push	r11
    f042:	cf 92       	push	r12
    f044:	df 92       	push	r13
    f046:	ef 92       	push	r14
    f048:	ff 92       	push	r15
    f04a:	cf 93       	push	r28
    f04c:	df 93       	push	r29
    f04e:	ec 01       	movw	r28, r24
    f050:	68 81       	ld	r22, Y
    f052:	79 81       	ldd	r23, Y+1	; 0x01
    f054:	8a 81       	ldd	r24, Y+2	; 0x02
    f056:	9b 81       	ldd	r25, Y+3	; 0x03
    f058:	61 15       	cp	r22, r1
    f05a:	71 05       	cpc	r23, r1
    f05c:	81 05       	cpc	r24, r1
    f05e:	91 05       	cpc	r25, r1
    f060:	21 f4       	brne	.+8      	; 0xf06a <do_rand+0x30>
    f062:	64 e2       	ldi	r22, 0x24	; 36
    f064:	79 ed       	ldi	r23, 0xD9	; 217
    f066:	8b e5       	ldi	r24, 0x5B	; 91
    f068:	97 e0       	ldi	r25, 0x07	; 7
    f06a:	2d e1       	ldi	r18, 0x1D	; 29
    f06c:	33 ef       	ldi	r19, 0xF3	; 243
    f06e:	41 e0       	ldi	r20, 0x01	; 1
    f070:	50 e0       	ldi	r21, 0x00	; 0
    f072:	37 d7       	rcall	.+3694   	; 0xfee2 <__divmodsi4>
    f074:	49 01       	movw	r8, r18
    f076:	5a 01       	movw	r10, r20
    f078:	9b 01       	movw	r18, r22
    f07a:	ac 01       	movw	r20, r24
    f07c:	a7 ea       	ldi	r26, 0xA7	; 167
    f07e:	b1 e4       	ldi	r27, 0x41	; 65
    f080:	c3 df       	rcall	.-122    	; 0xf008 <__muluhisi3>
    f082:	6b 01       	movw	r12, r22
    f084:	7c 01       	movw	r14, r24
    f086:	ac ee       	ldi	r26, 0xEC	; 236
    f088:	b4 ef       	ldi	r27, 0xF4	; 244
    f08a:	a5 01       	movw	r20, r10
    f08c:	94 01       	movw	r18, r8
    f08e:	b8 df       	rcall	.-144    	; 0xf000 <__mulohisi3>
    f090:	dc 01       	movw	r26, r24
    f092:	cb 01       	movw	r24, r22
    f094:	8c 0d       	add	r24, r12
    f096:	9d 1d       	adc	r25, r13
    f098:	ae 1d       	adc	r26, r14
    f09a:	bf 1d       	adc	r27, r15
    f09c:	b7 ff       	sbrs	r27, 7
    f09e:	03 c0       	rjmp	.+6      	; 0xf0a6 <do_rand+0x6c>
    f0a0:	01 97       	sbiw	r24, 0x01	; 1
    f0a2:	a1 09       	sbc	r26, r1
    f0a4:	b0 48       	sbci	r27, 0x80	; 128
    f0a6:	88 83       	st	Y, r24
    f0a8:	99 83       	std	Y+1, r25	; 0x01
    f0aa:	aa 83       	std	Y+2, r26	; 0x02
    f0ac:	bb 83       	std	Y+3, r27	; 0x03
    f0ae:	9f 77       	andi	r25, 0x7F	; 127
    f0b0:	df 91       	pop	r29
    f0b2:	cf 91       	pop	r28
    f0b4:	ff 90       	pop	r15
    f0b6:	ef 90       	pop	r14
    f0b8:	df 90       	pop	r13
    f0ba:	cf 90       	pop	r12
    f0bc:	bf 90       	pop	r11
    f0be:	af 90       	pop	r10
    f0c0:	9f 90       	pop	r9
    f0c2:	8f 90       	pop	r8
    f0c4:	08 95       	ret

0000f0c6 <rand_r>:
    f0c6:	b9 cf       	rjmp	.-142    	; 0xf03a <do_rand>

0000f0c8 <rand>:
    f0c8:	82 e2       	ldi	r24, 0x22	; 34
    f0ca:	90 e2       	ldi	r25, 0x20	; 32
    f0cc:	b6 cf       	rjmp	.-148    	; 0xf03a <do_rand>

0000f0ce <srand>:
    f0ce:	a0 e0       	ldi	r26, 0x00	; 0
    f0d0:	b0 e0       	ldi	r27, 0x00	; 0
    f0d2:	80 93 22 20 	sts	0x2022, r24	; 0x802022 <next>
    f0d6:	90 93 23 20 	sts	0x2023, r25	; 0x802023 <next+0x1>
    f0da:	a0 93 24 20 	sts	0x2024, r26	; 0x802024 <next+0x2>
    f0de:	b0 93 25 20 	sts	0x2025, r27	; 0x802025 <next+0x3>
    f0e2:	08 95       	ret

0000f0e4 <memcpy_P>:
    f0e4:	fb 01       	movw	r30, r22
    f0e6:	dc 01       	movw	r26, r24
    f0e8:	02 c0       	rjmp	.+4      	; 0xf0ee <memcpy_P+0xa>
    f0ea:	05 90       	lpm	r0, Z+
    f0ec:	0d 92       	st	X+, r0
    f0ee:	41 50       	subi	r20, 0x01	; 1
    f0f0:	50 40       	sbci	r21, 0x00	; 0
    f0f2:	d8 f7       	brcc	.-10     	; 0xf0ea <memcpy_P+0x6>
    f0f4:	08 95       	ret

0000f0f6 <strcmp_P>:
    f0f6:	fb 01       	movw	r30, r22
    f0f8:	dc 01       	movw	r26, r24
    f0fa:	8d 91       	ld	r24, X+
    f0fc:	05 90       	lpm	r0, Z+
    f0fe:	80 19       	sub	r24, r0
    f100:	01 10       	cpse	r0, r1
    f102:	d9 f3       	breq	.-10     	; 0xf0fa <strcmp_P+0x4>
    f104:	99 0b       	sbc	r25, r25
    f106:	08 95       	ret

0000f108 <strncpy_P>:
    f108:	fb 01       	movw	r30, r22
    f10a:	dc 01       	movw	r26, r24
    f10c:	41 50       	subi	r20, 0x01	; 1
    f10e:	50 40       	sbci	r21, 0x00	; 0
    f110:	48 f0       	brcs	.+18     	; 0xf124 <strncpy_P+0x1c>
    f112:	05 90       	lpm	r0, Z+
    f114:	0d 92       	st	X+, r0
    f116:	00 20       	and	r0, r0
    f118:	c9 f7       	brne	.-14     	; 0xf10c <strncpy_P+0x4>
    f11a:	01 c0       	rjmp	.+2      	; 0xf11e <strncpy_P+0x16>
    f11c:	1d 92       	st	X+, r1
    f11e:	41 50       	subi	r20, 0x01	; 1
    f120:	50 40       	sbci	r21, 0x00	; 0
    f122:	e0 f7       	brcc	.-8      	; 0xf11c <strncpy_P+0x14>
    f124:	08 95       	ret

0000f126 <memcmp>:
    f126:	fb 01       	movw	r30, r22
    f128:	dc 01       	movw	r26, r24
    f12a:	04 c0       	rjmp	.+8      	; 0xf134 <memcmp+0xe>
    f12c:	8d 91       	ld	r24, X+
    f12e:	01 90       	ld	r0, Z+
    f130:	80 19       	sub	r24, r0
    f132:	21 f4       	brne	.+8      	; 0xf13c <memcmp+0x16>
    f134:	41 50       	subi	r20, 0x01	; 1
    f136:	50 40       	sbci	r21, 0x00	; 0
    f138:	c8 f7       	brcc	.-14     	; 0xf12c <memcmp+0x6>
    f13a:	88 1b       	sub	r24, r24
    f13c:	99 0b       	sbc	r25, r25
    f13e:	08 95       	ret

0000f140 <memcpy>:
    f140:	fb 01       	movw	r30, r22
    f142:	dc 01       	movw	r26, r24
    f144:	02 c0       	rjmp	.+4      	; 0xf14a <memcpy+0xa>
    f146:	01 90       	ld	r0, Z+
    f148:	0d 92       	st	X+, r0
    f14a:	41 50       	subi	r20, 0x01	; 1
    f14c:	50 40       	sbci	r21, 0x00	; 0
    f14e:	d8 f7       	brcc	.-10     	; 0xf146 <memcpy+0x6>
    f150:	08 95       	ret

0000f152 <memmove>:
    f152:	68 17       	cp	r22, r24
    f154:	79 07       	cpc	r23, r25
    f156:	68 f4       	brcc	.+26     	; 0xf172 <memmove+0x20>
    f158:	fb 01       	movw	r30, r22
    f15a:	dc 01       	movw	r26, r24
    f15c:	e4 0f       	add	r30, r20
    f15e:	f5 1f       	adc	r31, r21
    f160:	a4 0f       	add	r26, r20
    f162:	b5 1f       	adc	r27, r21
    f164:	02 c0       	rjmp	.+4      	; 0xf16a <memmove+0x18>
    f166:	02 90       	ld	r0, -Z
    f168:	0e 92       	st	-X, r0
    f16a:	41 50       	subi	r20, 0x01	; 1
    f16c:	50 40       	sbci	r21, 0x00	; 0
    f16e:	d8 f7       	brcc	.-10     	; 0xf166 <memmove+0x14>
    f170:	08 95       	ret
    f172:	e6 cf       	rjmp	.-52     	; 0xf140 <memcpy>

0000f174 <memset>:
    f174:	dc 01       	movw	r26, r24
    f176:	01 c0       	rjmp	.+2      	; 0xf17a <memset+0x6>
    f178:	6d 93       	st	X+, r22
    f17a:	41 50       	subi	r20, 0x01	; 1
    f17c:	50 40       	sbci	r21, 0x00	; 0
    f17e:	e0 f7       	brcc	.-8      	; 0xf178 <memset+0x4>
    f180:	08 95       	ret

0000f182 <strchr>:
    f182:	fc 01       	movw	r30, r24
    f184:	81 91       	ld	r24, Z+
    f186:	86 17       	cp	r24, r22
    f188:	21 f0       	breq	.+8      	; 0xf192 <strchr+0x10>
    f18a:	88 23       	and	r24, r24
    f18c:	d9 f7       	brne	.-10     	; 0xf184 <strchr+0x2>
    f18e:	99 27       	eor	r25, r25
    f190:	08 95       	ret
    f192:	31 97       	sbiw	r30, 0x01	; 1
    f194:	cf 01       	movw	r24, r30
    f196:	08 95       	ret

0000f198 <strcpy>:
    f198:	fb 01       	movw	r30, r22
    f19a:	dc 01       	movw	r26, r24
    f19c:	01 90       	ld	r0, Z+
    f19e:	0d 92       	st	X+, r0
    f1a0:	00 20       	and	r0, r0
    f1a2:	e1 f7       	brne	.-8      	; 0xf19c <strcpy+0x4>
    f1a4:	08 95       	ret

0000f1a6 <snprintf>:
    f1a6:	0f 93       	push	r16
    f1a8:	1f 93       	push	r17
    f1aa:	cf 93       	push	r28
    f1ac:	df 93       	push	r29
    f1ae:	cd b7       	in	r28, 0x3d	; 61
    f1b0:	de b7       	in	r29, 0x3e	; 62
    f1b2:	2e 97       	sbiw	r28, 0x0e	; 14
    f1b4:	cd bf       	out	0x3d, r28	; 61
    f1b6:	de bf       	out	0x3e, r29	; 62
    f1b8:	0e 89       	ldd	r16, Y+22	; 0x16
    f1ba:	1f 89       	ldd	r17, Y+23	; 0x17
    f1bc:	88 8d       	ldd	r24, Y+24	; 0x18
    f1be:	99 8d       	ldd	r25, Y+25	; 0x19
    f1c0:	26 e0       	ldi	r18, 0x06	; 6
    f1c2:	2c 83       	std	Y+4, r18	; 0x04
    f1c4:	09 83       	std	Y+1, r16	; 0x01
    f1c6:	1a 83       	std	Y+2, r17	; 0x02
    f1c8:	97 ff       	sbrs	r25, 7
    f1ca:	02 c0       	rjmp	.+4      	; 0xf1d0 <snprintf+0x2a>
    f1cc:	80 e0       	ldi	r24, 0x00	; 0
    f1ce:	90 e8       	ldi	r25, 0x80	; 128
    f1d0:	01 97       	sbiw	r24, 0x01	; 1
    f1d2:	8d 83       	std	Y+5, r24	; 0x05
    f1d4:	9e 83       	std	Y+6, r25	; 0x06
    f1d6:	ae 01       	movw	r20, r28
    f1d8:	44 5e       	subi	r20, 0xE4	; 228
    f1da:	5f 4f       	sbci	r21, 0xFF	; 255
    f1dc:	6a 8d       	ldd	r22, Y+26	; 0x1a
    f1de:	7b 8d       	ldd	r23, Y+27	; 0x1b
    f1e0:	ce 01       	movw	r24, r28
    f1e2:	01 96       	adiw	r24, 0x01	; 1
    f1e4:	67 d0       	rcall	.+206    	; 0xf2b4 <vfprintf>
    f1e6:	4d 81       	ldd	r20, Y+5	; 0x05
    f1e8:	5e 81       	ldd	r21, Y+6	; 0x06
    f1ea:	57 fd       	sbrc	r21, 7
    f1ec:	0a c0       	rjmp	.+20     	; 0xf202 <snprintf+0x5c>
    f1ee:	2f 81       	ldd	r18, Y+7	; 0x07
    f1f0:	38 85       	ldd	r19, Y+8	; 0x08
    f1f2:	42 17       	cp	r20, r18
    f1f4:	53 07       	cpc	r21, r19
    f1f6:	0c f4       	brge	.+2      	; 0xf1fa <snprintf+0x54>
    f1f8:	9a 01       	movw	r18, r20
    f1fa:	f8 01       	movw	r30, r16
    f1fc:	e2 0f       	add	r30, r18
    f1fe:	f3 1f       	adc	r31, r19
    f200:	10 82       	st	Z, r1
    f202:	2e 96       	adiw	r28, 0x0e	; 14
    f204:	cd bf       	out	0x3d, r28	; 61
    f206:	de bf       	out	0x3e, r29	; 62
    f208:	df 91       	pop	r29
    f20a:	cf 91       	pop	r28
    f20c:	1f 91       	pop	r17
    f20e:	0f 91       	pop	r16
    f210:	08 95       	ret

0000f212 <snprintf_P>:
    f212:	0f 93       	push	r16
    f214:	1f 93       	push	r17
    f216:	cf 93       	push	r28
    f218:	df 93       	push	r29
    f21a:	cd b7       	in	r28, 0x3d	; 61
    f21c:	de b7       	in	r29, 0x3e	; 62
    f21e:	2e 97       	sbiw	r28, 0x0e	; 14
    f220:	cd bf       	out	0x3d, r28	; 61
    f222:	de bf       	out	0x3e, r29	; 62
    f224:	0e 89       	ldd	r16, Y+22	; 0x16
    f226:	1f 89       	ldd	r17, Y+23	; 0x17
    f228:	88 8d       	ldd	r24, Y+24	; 0x18
    f22a:	99 8d       	ldd	r25, Y+25	; 0x19
    f22c:	2e e0       	ldi	r18, 0x0E	; 14
    f22e:	2c 83       	std	Y+4, r18	; 0x04
    f230:	09 83       	std	Y+1, r16	; 0x01
    f232:	1a 83       	std	Y+2, r17	; 0x02
    f234:	97 ff       	sbrs	r25, 7
    f236:	02 c0       	rjmp	.+4      	; 0xf23c <snprintf_P+0x2a>
    f238:	80 e0       	ldi	r24, 0x00	; 0
    f23a:	90 e8       	ldi	r25, 0x80	; 128
    f23c:	01 97       	sbiw	r24, 0x01	; 1
    f23e:	8d 83       	std	Y+5, r24	; 0x05
    f240:	9e 83       	std	Y+6, r25	; 0x06
    f242:	ae 01       	movw	r20, r28
    f244:	44 5e       	subi	r20, 0xE4	; 228
    f246:	5f 4f       	sbci	r21, 0xFF	; 255
    f248:	6a 8d       	ldd	r22, Y+26	; 0x1a
    f24a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    f24c:	ce 01       	movw	r24, r28
    f24e:	01 96       	adiw	r24, 0x01	; 1
    f250:	31 d0       	rcall	.+98     	; 0xf2b4 <vfprintf>
    f252:	4d 81       	ldd	r20, Y+5	; 0x05
    f254:	5e 81       	ldd	r21, Y+6	; 0x06
    f256:	57 fd       	sbrc	r21, 7
    f258:	0a c0       	rjmp	.+20     	; 0xf26e <snprintf_P+0x5c>
    f25a:	2f 81       	ldd	r18, Y+7	; 0x07
    f25c:	38 85       	ldd	r19, Y+8	; 0x08
    f25e:	42 17       	cp	r20, r18
    f260:	53 07       	cpc	r21, r19
    f262:	0c f4       	brge	.+2      	; 0xf266 <snprintf_P+0x54>
    f264:	9a 01       	movw	r18, r20
    f266:	f8 01       	movw	r30, r16
    f268:	e2 0f       	add	r30, r18
    f26a:	f3 1f       	adc	r31, r19
    f26c:	10 82       	st	Z, r1
    f26e:	2e 96       	adiw	r28, 0x0e	; 14
    f270:	cd bf       	out	0x3d, r28	; 61
    f272:	de bf       	out	0x3e, r29	; 62
    f274:	df 91       	pop	r29
    f276:	cf 91       	pop	r28
    f278:	1f 91       	pop	r17
    f27a:	0f 91       	pop	r16
    f27c:	08 95       	ret

0000f27e <sscanf_P>:
    f27e:	cf 93       	push	r28
    f280:	df 93       	push	r29
    f282:	cd b7       	in	r28, 0x3d	; 61
    f284:	de b7       	in	r29, 0x3e	; 62
    f286:	2e 97       	sbiw	r28, 0x0e	; 14
    f288:	cd bf       	out	0x3d, r28	; 61
    f28a:	de bf       	out	0x3e, r29	; 62
    f28c:	8d e0       	ldi	r24, 0x0D	; 13
    f28e:	8c 83       	std	Y+4, r24	; 0x04
    f290:	8c 89       	ldd	r24, Y+20	; 0x14
    f292:	9d 89       	ldd	r25, Y+21	; 0x15
    f294:	89 83       	std	Y+1, r24	; 0x01
    f296:	9a 83       	std	Y+2, r25	; 0x02
    f298:	ae 01       	movw	r20, r28
    f29a:	48 5e       	subi	r20, 0xE8	; 232
    f29c:	5f 4f       	sbci	r21, 0xFF	; 255
    f29e:	6e 89       	ldd	r22, Y+22	; 0x16
    f2a0:	7f 89       	ldd	r23, Y+23	; 0x17
    f2a2:	ce 01       	movw	r24, r28
    f2a4:	01 96       	adiw	r24, 0x01	; 1
    f2a6:	a9 d3       	rcall	.+1874   	; 0xf9fa <vfscanf>
    f2a8:	2e 96       	adiw	r28, 0x0e	; 14
    f2aa:	cd bf       	out	0x3d, r28	; 61
    f2ac:	de bf       	out	0x3e, r29	; 62
    f2ae:	df 91       	pop	r29
    f2b0:	cf 91       	pop	r28
    f2b2:	08 95       	ret

0000f2b4 <vfprintf>:
    f2b4:	2f 92       	push	r2
    f2b6:	3f 92       	push	r3
    f2b8:	4f 92       	push	r4
    f2ba:	5f 92       	push	r5
    f2bc:	6f 92       	push	r6
    f2be:	7f 92       	push	r7
    f2c0:	8f 92       	push	r8
    f2c2:	9f 92       	push	r9
    f2c4:	af 92       	push	r10
    f2c6:	bf 92       	push	r11
    f2c8:	cf 92       	push	r12
    f2ca:	df 92       	push	r13
    f2cc:	ef 92       	push	r14
    f2ce:	ff 92       	push	r15
    f2d0:	0f 93       	push	r16
    f2d2:	1f 93       	push	r17
    f2d4:	cf 93       	push	r28
    f2d6:	df 93       	push	r29
    f2d8:	cd b7       	in	r28, 0x3d	; 61
    f2da:	de b7       	in	r29, 0x3e	; 62
    f2dc:	2b 97       	sbiw	r28, 0x0b	; 11
    f2de:	cd bf       	out	0x3d, r28	; 61
    f2e0:	de bf       	out	0x3e, r29	; 62
    f2e2:	6c 01       	movw	r12, r24
    f2e4:	7b 01       	movw	r14, r22
    f2e6:	8a 01       	movw	r16, r20
    f2e8:	fc 01       	movw	r30, r24
    f2ea:	16 82       	std	Z+6, r1	; 0x06
    f2ec:	17 82       	std	Z+7, r1	; 0x07
    f2ee:	83 81       	ldd	r24, Z+3	; 0x03
    f2f0:	81 ff       	sbrs	r24, 1
    f2f2:	bf c1       	rjmp	.+894    	; 0xf672 <vfprintf+0x3be>
    f2f4:	ce 01       	movw	r24, r28
    f2f6:	01 96       	adiw	r24, 0x01	; 1
    f2f8:	3c 01       	movw	r6, r24
    f2fa:	f6 01       	movw	r30, r12
    f2fc:	93 81       	ldd	r25, Z+3	; 0x03
    f2fe:	f7 01       	movw	r30, r14
    f300:	93 fd       	sbrc	r25, 3
    f302:	85 91       	lpm	r24, Z+
    f304:	93 ff       	sbrs	r25, 3
    f306:	81 91       	ld	r24, Z+
    f308:	7f 01       	movw	r14, r30
    f30a:	88 23       	and	r24, r24
    f30c:	09 f4       	brne	.+2      	; 0xf310 <vfprintf+0x5c>
    f30e:	ad c1       	rjmp	.+858    	; 0xf66a <vfprintf+0x3b6>
    f310:	85 32       	cpi	r24, 0x25	; 37
    f312:	39 f4       	brne	.+14     	; 0xf322 <vfprintf+0x6e>
    f314:	93 fd       	sbrc	r25, 3
    f316:	85 91       	lpm	r24, Z+
    f318:	93 ff       	sbrs	r25, 3
    f31a:	81 91       	ld	r24, Z+
    f31c:	7f 01       	movw	r14, r30
    f31e:	85 32       	cpi	r24, 0x25	; 37
    f320:	21 f4       	brne	.+8      	; 0xf32a <vfprintf+0x76>
    f322:	b6 01       	movw	r22, r12
    f324:	90 e0       	ldi	r25, 0x00	; 0
    f326:	e7 d4       	rcall	.+2510   	; 0xfcf6 <fputc>
    f328:	e8 cf       	rjmp	.-48     	; 0xf2fa <vfprintf+0x46>
    f32a:	91 2c       	mov	r9, r1
    f32c:	21 2c       	mov	r2, r1
    f32e:	31 2c       	mov	r3, r1
    f330:	ff e1       	ldi	r31, 0x1F	; 31
    f332:	f3 15       	cp	r31, r3
    f334:	d8 f0       	brcs	.+54     	; 0xf36c <vfprintf+0xb8>
    f336:	8b 32       	cpi	r24, 0x2B	; 43
    f338:	79 f0       	breq	.+30     	; 0xf358 <vfprintf+0xa4>
    f33a:	38 f4       	brcc	.+14     	; 0xf34a <vfprintf+0x96>
    f33c:	80 32       	cpi	r24, 0x20	; 32
    f33e:	79 f0       	breq	.+30     	; 0xf35e <vfprintf+0xaa>
    f340:	83 32       	cpi	r24, 0x23	; 35
    f342:	a1 f4       	brne	.+40     	; 0xf36c <vfprintf+0xb8>
    f344:	23 2d       	mov	r18, r3
    f346:	20 61       	ori	r18, 0x10	; 16
    f348:	1d c0       	rjmp	.+58     	; 0xf384 <vfprintf+0xd0>
    f34a:	8d 32       	cpi	r24, 0x2D	; 45
    f34c:	61 f0       	breq	.+24     	; 0xf366 <vfprintf+0xb2>
    f34e:	80 33       	cpi	r24, 0x30	; 48
    f350:	69 f4       	brne	.+26     	; 0xf36c <vfprintf+0xb8>
    f352:	23 2d       	mov	r18, r3
    f354:	21 60       	ori	r18, 0x01	; 1
    f356:	16 c0       	rjmp	.+44     	; 0xf384 <vfprintf+0xd0>
    f358:	83 2d       	mov	r24, r3
    f35a:	82 60       	ori	r24, 0x02	; 2
    f35c:	38 2e       	mov	r3, r24
    f35e:	e3 2d       	mov	r30, r3
    f360:	e4 60       	ori	r30, 0x04	; 4
    f362:	3e 2e       	mov	r3, r30
    f364:	2a c0       	rjmp	.+84     	; 0xf3ba <vfprintf+0x106>
    f366:	f3 2d       	mov	r31, r3
    f368:	f8 60       	ori	r31, 0x08	; 8
    f36a:	1d c0       	rjmp	.+58     	; 0xf3a6 <vfprintf+0xf2>
    f36c:	37 fc       	sbrc	r3, 7
    f36e:	2d c0       	rjmp	.+90     	; 0xf3ca <vfprintf+0x116>
    f370:	20 ed       	ldi	r18, 0xD0	; 208
    f372:	28 0f       	add	r18, r24
    f374:	2a 30       	cpi	r18, 0x0A	; 10
    f376:	40 f0       	brcs	.+16     	; 0xf388 <vfprintf+0xd4>
    f378:	8e 32       	cpi	r24, 0x2E	; 46
    f37a:	b9 f4       	brne	.+46     	; 0xf3aa <vfprintf+0xf6>
    f37c:	36 fc       	sbrc	r3, 6
    f37e:	75 c1       	rjmp	.+746    	; 0xf66a <vfprintf+0x3b6>
    f380:	23 2d       	mov	r18, r3
    f382:	20 64       	ori	r18, 0x40	; 64
    f384:	32 2e       	mov	r3, r18
    f386:	19 c0       	rjmp	.+50     	; 0xf3ba <vfprintf+0x106>
    f388:	36 fe       	sbrs	r3, 6
    f38a:	06 c0       	rjmp	.+12     	; 0xf398 <vfprintf+0xe4>
    f38c:	8a e0       	ldi	r24, 0x0A	; 10
    f38e:	98 9e       	mul	r9, r24
    f390:	20 0d       	add	r18, r0
    f392:	11 24       	eor	r1, r1
    f394:	92 2e       	mov	r9, r18
    f396:	11 c0       	rjmp	.+34     	; 0xf3ba <vfprintf+0x106>
    f398:	ea e0       	ldi	r30, 0x0A	; 10
    f39a:	2e 9e       	mul	r2, r30
    f39c:	20 0d       	add	r18, r0
    f39e:	11 24       	eor	r1, r1
    f3a0:	22 2e       	mov	r2, r18
    f3a2:	f3 2d       	mov	r31, r3
    f3a4:	f0 62       	ori	r31, 0x20	; 32
    f3a6:	3f 2e       	mov	r3, r31
    f3a8:	08 c0       	rjmp	.+16     	; 0xf3ba <vfprintf+0x106>
    f3aa:	8c 36       	cpi	r24, 0x6C	; 108
    f3ac:	21 f4       	brne	.+8      	; 0xf3b6 <vfprintf+0x102>
    f3ae:	83 2d       	mov	r24, r3
    f3b0:	80 68       	ori	r24, 0x80	; 128
    f3b2:	38 2e       	mov	r3, r24
    f3b4:	02 c0       	rjmp	.+4      	; 0xf3ba <vfprintf+0x106>
    f3b6:	88 36       	cpi	r24, 0x68	; 104
    f3b8:	41 f4       	brne	.+16     	; 0xf3ca <vfprintf+0x116>
    f3ba:	f7 01       	movw	r30, r14
    f3bc:	93 fd       	sbrc	r25, 3
    f3be:	85 91       	lpm	r24, Z+
    f3c0:	93 ff       	sbrs	r25, 3
    f3c2:	81 91       	ld	r24, Z+
    f3c4:	7f 01       	movw	r14, r30
    f3c6:	81 11       	cpse	r24, r1
    f3c8:	b3 cf       	rjmp	.-154    	; 0xf330 <vfprintf+0x7c>
    f3ca:	98 2f       	mov	r25, r24
    f3cc:	9f 7d       	andi	r25, 0xDF	; 223
    f3ce:	95 54       	subi	r25, 0x45	; 69
    f3d0:	93 30       	cpi	r25, 0x03	; 3
    f3d2:	28 f4       	brcc	.+10     	; 0xf3de <vfprintf+0x12a>
    f3d4:	0c 5f       	subi	r16, 0xFC	; 252
    f3d6:	1f 4f       	sbci	r17, 0xFF	; 255
    f3d8:	9f e3       	ldi	r25, 0x3F	; 63
    f3da:	99 83       	std	Y+1, r25	; 0x01
    f3dc:	0d c0       	rjmp	.+26     	; 0xf3f8 <vfprintf+0x144>
    f3de:	83 36       	cpi	r24, 0x63	; 99
    f3e0:	31 f0       	breq	.+12     	; 0xf3ee <vfprintf+0x13a>
    f3e2:	83 37       	cpi	r24, 0x73	; 115
    f3e4:	71 f0       	breq	.+28     	; 0xf402 <vfprintf+0x14e>
    f3e6:	83 35       	cpi	r24, 0x53	; 83
    f3e8:	09 f0       	breq	.+2      	; 0xf3ec <vfprintf+0x138>
    f3ea:	55 c0       	rjmp	.+170    	; 0xf496 <vfprintf+0x1e2>
    f3ec:	20 c0       	rjmp	.+64     	; 0xf42e <vfprintf+0x17a>
    f3ee:	f8 01       	movw	r30, r16
    f3f0:	80 81       	ld	r24, Z
    f3f2:	89 83       	std	Y+1, r24	; 0x01
    f3f4:	0e 5f       	subi	r16, 0xFE	; 254
    f3f6:	1f 4f       	sbci	r17, 0xFF	; 255
    f3f8:	88 24       	eor	r8, r8
    f3fa:	83 94       	inc	r8
    f3fc:	91 2c       	mov	r9, r1
    f3fe:	53 01       	movw	r10, r6
    f400:	12 c0       	rjmp	.+36     	; 0xf426 <vfprintf+0x172>
    f402:	28 01       	movw	r4, r16
    f404:	f2 e0       	ldi	r31, 0x02	; 2
    f406:	4f 0e       	add	r4, r31
    f408:	51 1c       	adc	r5, r1
    f40a:	f8 01       	movw	r30, r16
    f40c:	a0 80       	ld	r10, Z
    f40e:	b1 80       	ldd	r11, Z+1	; 0x01
    f410:	36 fe       	sbrs	r3, 6
    f412:	03 c0       	rjmp	.+6      	; 0xf41a <vfprintf+0x166>
    f414:	69 2d       	mov	r22, r9
    f416:	70 e0       	ldi	r23, 0x00	; 0
    f418:	02 c0       	rjmp	.+4      	; 0xf41e <vfprintf+0x16a>
    f41a:	6f ef       	ldi	r22, 0xFF	; 255
    f41c:	7f ef       	ldi	r23, 0xFF	; 255
    f41e:	c5 01       	movw	r24, r10
    f420:	21 d4       	rcall	.+2114   	; 0xfc64 <strnlen>
    f422:	4c 01       	movw	r8, r24
    f424:	82 01       	movw	r16, r4
    f426:	f3 2d       	mov	r31, r3
    f428:	ff 77       	andi	r31, 0x7F	; 127
    f42a:	3f 2e       	mov	r3, r31
    f42c:	15 c0       	rjmp	.+42     	; 0xf458 <vfprintf+0x1a4>
    f42e:	28 01       	movw	r4, r16
    f430:	22 e0       	ldi	r18, 0x02	; 2
    f432:	42 0e       	add	r4, r18
    f434:	51 1c       	adc	r5, r1
    f436:	f8 01       	movw	r30, r16
    f438:	a0 80       	ld	r10, Z
    f43a:	b1 80       	ldd	r11, Z+1	; 0x01
    f43c:	36 fe       	sbrs	r3, 6
    f43e:	03 c0       	rjmp	.+6      	; 0xf446 <vfprintf+0x192>
    f440:	69 2d       	mov	r22, r9
    f442:	70 e0       	ldi	r23, 0x00	; 0
    f444:	02 c0       	rjmp	.+4      	; 0xf44a <vfprintf+0x196>
    f446:	6f ef       	ldi	r22, 0xFF	; 255
    f448:	7f ef       	ldi	r23, 0xFF	; 255
    f44a:	c5 01       	movw	r24, r10
    f44c:	00 d4       	rcall	.+2048   	; 0xfc4e <strnlen_P>
    f44e:	4c 01       	movw	r8, r24
    f450:	f3 2d       	mov	r31, r3
    f452:	f0 68       	ori	r31, 0x80	; 128
    f454:	3f 2e       	mov	r3, r31
    f456:	82 01       	movw	r16, r4
    f458:	33 fc       	sbrc	r3, 3
    f45a:	19 c0       	rjmp	.+50     	; 0xf48e <vfprintf+0x1da>
    f45c:	82 2d       	mov	r24, r2
    f45e:	90 e0       	ldi	r25, 0x00	; 0
    f460:	88 16       	cp	r8, r24
    f462:	99 06       	cpc	r9, r25
    f464:	a0 f4       	brcc	.+40     	; 0xf48e <vfprintf+0x1da>
    f466:	b6 01       	movw	r22, r12
    f468:	80 e2       	ldi	r24, 0x20	; 32
    f46a:	90 e0       	ldi	r25, 0x00	; 0
    f46c:	44 d4       	rcall	.+2184   	; 0xfcf6 <fputc>
    f46e:	2a 94       	dec	r2
    f470:	f5 cf       	rjmp	.-22     	; 0xf45c <vfprintf+0x1a8>
    f472:	f5 01       	movw	r30, r10
    f474:	37 fc       	sbrc	r3, 7
    f476:	85 91       	lpm	r24, Z+
    f478:	37 fe       	sbrs	r3, 7
    f47a:	81 91       	ld	r24, Z+
    f47c:	5f 01       	movw	r10, r30
    f47e:	b6 01       	movw	r22, r12
    f480:	90 e0       	ldi	r25, 0x00	; 0
    f482:	39 d4       	rcall	.+2162   	; 0xfcf6 <fputc>
    f484:	21 10       	cpse	r2, r1
    f486:	2a 94       	dec	r2
    f488:	21 e0       	ldi	r18, 0x01	; 1
    f48a:	82 1a       	sub	r8, r18
    f48c:	91 08       	sbc	r9, r1
    f48e:	81 14       	cp	r8, r1
    f490:	91 04       	cpc	r9, r1
    f492:	79 f7       	brne	.-34     	; 0xf472 <vfprintf+0x1be>
    f494:	e1 c0       	rjmp	.+450    	; 0xf658 <vfprintf+0x3a4>
    f496:	84 36       	cpi	r24, 0x64	; 100
    f498:	11 f0       	breq	.+4      	; 0xf49e <vfprintf+0x1ea>
    f49a:	89 36       	cpi	r24, 0x69	; 105
    f49c:	39 f5       	brne	.+78     	; 0xf4ec <vfprintf+0x238>
    f49e:	f8 01       	movw	r30, r16
    f4a0:	37 fe       	sbrs	r3, 7
    f4a2:	07 c0       	rjmp	.+14     	; 0xf4b2 <vfprintf+0x1fe>
    f4a4:	60 81       	ld	r22, Z
    f4a6:	71 81       	ldd	r23, Z+1	; 0x01
    f4a8:	82 81       	ldd	r24, Z+2	; 0x02
    f4aa:	93 81       	ldd	r25, Z+3	; 0x03
    f4ac:	0c 5f       	subi	r16, 0xFC	; 252
    f4ae:	1f 4f       	sbci	r17, 0xFF	; 255
    f4b0:	08 c0       	rjmp	.+16     	; 0xf4c2 <vfprintf+0x20e>
    f4b2:	60 81       	ld	r22, Z
    f4b4:	71 81       	ldd	r23, Z+1	; 0x01
    f4b6:	07 2e       	mov	r0, r23
    f4b8:	00 0c       	add	r0, r0
    f4ba:	88 0b       	sbc	r24, r24
    f4bc:	99 0b       	sbc	r25, r25
    f4be:	0e 5f       	subi	r16, 0xFE	; 254
    f4c0:	1f 4f       	sbci	r17, 0xFF	; 255
    f4c2:	f3 2d       	mov	r31, r3
    f4c4:	ff 76       	andi	r31, 0x6F	; 111
    f4c6:	3f 2e       	mov	r3, r31
    f4c8:	97 ff       	sbrs	r25, 7
    f4ca:	09 c0       	rjmp	.+18     	; 0xf4de <vfprintf+0x22a>
    f4cc:	90 95       	com	r25
    f4ce:	80 95       	com	r24
    f4d0:	70 95       	com	r23
    f4d2:	61 95       	neg	r22
    f4d4:	7f 4f       	sbci	r23, 0xFF	; 255
    f4d6:	8f 4f       	sbci	r24, 0xFF	; 255
    f4d8:	9f 4f       	sbci	r25, 0xFF	; 255
    f4da:	f0 68       	ori	r31, 0x80	; 128
    f4dc:	3f 2e       	mov	r3, r31
    f4de:	2a e0       	ldi	r18, 0x0A	; 10
    f4e0:	30 e0       	ldi	r19, 0x00	; 0
    f4e2:	a3 01       	movw	r20, r6
    f4e4:	5d d4       	rcall	.+2234   	; 0xfda0 <__ultoa_invert>
    f4e6:	88 2e       	mov	r8, r24
    f4e8:	86 18       	sub	r8, r6
    f4ea:	44 c0       	rjmp	.+136    	; 0xf574 <vfprintf+0x2c0>
    f4ec:	85 37       	cpi	r24, 0x75	; 117
    f4ee:	31 f4       	brne	.+12     	; 0xf4fc <vfprintf+0x248>
    f4f0:	23 2d       	mov	r18, r3
    f4f2:	2f 7e       	andi	r18, 0xEF	; 239
    f4f4:	b2 2e       	mov	r11, r18
    f4f6:	2a e0       	ldi	r18, 0x0A	; 10
    f4f8:	30 e0       	ldi	r19, 0x00	; 0
    f4fa:	25 c0       	rjmp	.+74     	; 0xf546 <vfprintf+0x292>
    f4fc:	93 2d       	mov	r25, r3
    f4fe:	99 7f       	andi	r25, 0xF9	; 249
    f500:	b9 2e       	mov	r11, r25
    f502:	8f 36       	cpi	r24, 0x6F	; 111
    f504:	c1 f0       	breq	.+48     	; 0xf536 <vfprintf+0x282>
    f506:	18 f4       	brcc	.+6      	; 0xf50e <vfprintf+0x25a>
    f508:	88 35       	cpi	r24, 0x58	; 88
    f50a:	79 f0       	breq	.+30     	; 0xf52a <vfprintf+0x276>
    f50c:	ae c0       	rjmp	.+348    	; 0xf66a <vfprintf+0x3b6>
    f50e:	80 37       	cpi	r24, 0x70	; 112
    f510:	19 f0       	breq	.+6      	; 0xf518 <vfprintf+0x264>
    f512:	88 37       	cpi	r24, 0x78	; 120
    f514:	21 f0       	breq	.+8      	; 0xf51e <vfprintf+0x26a>
    f516:	a9 c0       	rjmp	.+338    	; 0xf66a <vfprintf+0x3b6>
    f518:	e9 2f       	mov	r30, r25
    f51a:	e0 61       	ori	r30, 0x10	; 16
    f51c:	be 2e       	mov	r11, r30
    f51e:	b4 fe       	sbrs	r11, 4
    f520:	0d c0       	rjmp	.+26     	; 0xf53c <vfprintf+0x288>
    f522:	fb 2d       	mov	r31, r11
    f524:	f4 60       	ori	r31, 0x04	; 4
    f526:	bf 2e       	mov	r11, r31
    f528:	09 c0       	rjmp	.+18     	; 0xf53c <vfprintf+0x288>
    f52a:	34 fe       	sbrs	r3, 4
    f52c:	0a c0       	rjmp	.+20     	; 0xf542 <vfprintf+0x28e>
    f52e:	29 2f       	mov	r18, r25
    f530:	26 60       	ori	r18, 0x06	; 6
    f532:	b2 2e       	mov	r11, r18
    f534:	06 c0       	rjmp	.+12     	; 0xf542 <vfprintf+0x28e>
    f536:	28 e0       	ldi	r18, 0x08	; 8
    f538:	30 e0       	ldi	r19, 0x00	; 0
    f53a:	05 c0       	rjmp	.+10     	; 0xf546 <vfprintf+0x292>
    f53c:	20 e1       	ldi	r18, 0x10	; 16
    f53e:	30 e0       	ldi	r19, 0x00	; 0
    f540:	02 c0       	rjmp	.+4      	; 0xf546 <vfprintf+0x292>
    f542:	20 e1       	ldi	r18, 0x10	; 16
    f544:	32 e0       	ldi	r19, 0x02	; 2
    f546:	f8 01       	movw	r30, r16
    f548:	b7 fe       	sbrs	r11, 7
    f54a:	07 c0       	rjmp	.+14     	; 0xf55a <vfprintf+0x2a6>
    f54c:	60 81       	ld	r22, Z
    f54e:	71 81       	ldd	r23, Z+1	; 0x01
    f550:	82 81       	ldd	r24, Z+2	; 0x02
    f552:	93 81       	ldd	r25, Z+3	; 0x03
    f554:	0c 5f       	subi	r16, 0xFC	; 252
    f556:	1f 4f       	sbci	r17, 0xFF	; 255
    f558:	06 c0       	rjmp	.+12     	; 0xf566 <vfprintf+0x2b2>
    f55a:	60 81       	ld	r22, Z
    f55c:	71 81       	ldd	r23, Z+1	; 0x01
    f55e:	80 e0       	ldi	r24, 0x00	; 0
    f560:	90 e0       	ldi	r25, 0x00	; 0
    f562:	0e 5f       	subi	r16, 0xFE	; 254
    f564:	1f 4f       	sbci	r17, 0xFF	; 255
    f566:	a3 01       	movw	r20, r6
    f568:	1b d4       	rcall	.+2102   	; 0xfda0 <__ultoa_invert>
    f56a:	88 2e       	mov	r8, r24
    f56c:	86 18       	sub	r8, r6
    f56e:	fb 2d       	mov	r31, r11
    f570:	ff 77       	andi	r31, 0x7F	; 127
    f572:	3f 2e       	mov	r3, r31
    f574:	36 fe       	sbrs	r3, 6
    f576:	0d c0       	rjmp	.+26     	; 0xf592 <vfprintf+0x2de>
    f578:	23 2d       	mov	r18, r3
    f57a:	2e 7f       	andi	r18, 0xFE	; 254
    f57c:	a2 2e       	mov	r10, r18
    f57e:	89 14       	cp	r8, r9
    f580:	58 f4       	brcc	.+22     	; 0xf598 <vfprintf+0x2e4>
    f582:	34 fe       	sbrs	r3, 4
    f584:	0b c0       	rjmp	.+22     	; 0xf59c <vfprintf+0x2e8>
    f586:	32 fc       	sbrc	r3, 2
    f588:	09 c0       	rjmp	.+18     	; 0xf59c <vfprintf+0x2e8>
    f58a:	83 2d       	mov	r24, r3
    f58c:	8e 7e       	andi	r24, 0xEE	; 238
    f58e:	a8 2e       	mov	r10, r24
    f590:	05 c0       	rjmp	.+10     	; 0xf59c <vfprintf+0x2e8>
    f592:	b8 2c       	mov	r11, r8
    f594:	a3 2c       	mov	r10, r3
    f596:	03 c0       	rjmp	.+6      	; 0xf59e <vfprintf+0x2ea>
    f598:	b8 2c       	mov	r11, r8
    f59a:	01 c0       	rjmp	.+2      	; 0xf59e <vfprintf+0x2ea>
    f59c:	b9 2c       	mov	r11, r9
    f59e:	a4 fe       	sbrs	r10, 4
    f5a0:	0f c0       	rjmp	.+30     	; 0xf5c0 <vfprintf+0x30c>
    f5a2:	fe 01       	movw	r30, r28
    f5a4:	e8 0d       	add	r30, r8
    f5a6:	f1 1d       	adc	r31, r1
    f5a8:	80 81       	ld	r24, Z
    f5aa:	80 33       	cpi	r24, 0x30	; 48
    f5ac:	21 f4       	brne	.+8      	; 0xf5b6 <vfprintf+0x302>
    f5ae:	9a 2d       	mov	r25, r10
    f5b0:	99 7e       	andi	r25, 0xE9	; 233
    f5b2:	a9 2e       	mov	r10, r25
    f5b4:	09 c0       	rjmp	.+18     	; 0xf5c8 <vfprintf+0x314>
    f5b6:	a2 fe       	sbrs	r10, 2
    f5b8:	06 c0       	rjmp	.+12     	; 0xf5c6 <vfprintf+0x312>
    f5ba:	b3 94       	inc	r11
    f5bc:	b3 94       	inc	r11
    f5be:	04 c0       	rjmp	.+8      	; 0xf5c8 <vfprintf+0x314>
    f5c0:	8a 2d       	mov	r24, r10
    f5c2:	86 78       	andi	r24, 0x86	; 134
    f5c4:	09 f0       	breq	.+2      	; 0xf5c8 <vfprintf+0x314>
    f5c6:	b3 94       	inc	r11
    f5c8:	a3 fc       	sbrc	r10, 3
    f5ca:	10 c0       	rjmp	.+32     	; 0xf5ec <vfprintf+0x338>
    f5cc:	a0 fe       	sbrs	r10, 0
    f5ce:	06 c0       	rjmp	.+12     	; 0xf5dc <vfprintf+0x328>
    f5d0:	b2 14       	cp	r11, r2
    f5d2:	80 f4       	brcc	.+32     	; 0xf5f4 <vfprintf+0x340>
    f5d4:	28 0c       	add	r2, r8
    f5d6:	92 2c       	mov	r9, r2
    f5d8:	9b 18       	sub	r9, r11
    f5da:	0d c0       	rjmp	.+26     	; 0xf5f6 <vfprintf+0x342>
    f5dc:	b2 14       	cp	r11, r2
    f5de:	58 f4       	brcc	.+22     	; 0xf5f6 <vfprintf+0x342>
    f5e0:	b6 01       	movw	r22, r12
    f5e2:	80 e2       	ldi	r24, 0x20	; 32
    f5e4:	90 e0       	ldi	r25, 0x00	; 0
    f5e6:	87 d3       	rcall	.+1806   	; 0xfcf6 <fputc>
    f5e8:	b3 94       	inc	r11
    f5ea:	f8 cf       	rjmp	.-16     	; 0xf5dc <vfprintf+0x328>
    f5ec:	b2 14       	cp	r11, r2
    f5ee:	18 f4       	brcc	.+6      	; 0xf5f6 <vfprintf+0x342>
    f5f0:	2b 18       	sub	r2, r11
    f5f2:	02 c0       	rjmp	.+4      	; 0xf5f8 <vfprintf+0x344>
    f5f4:	98 2c       	mov	r9, r8
    f5f6:	21 2c       	mov	r2, r1
    f5f8:	a4 fe       	sbrs	r10, 4
    f5fa:	0f c0       	rjmp	.+30     	; 0xf61a <vfprintf+0x366>
    f5fc:	b6 01       	movw	r22, r12
    f5fe:	80 e3       	ldi	r24, 0x30	; 48
    f600:	90 e0       	ldi	r25, 0x00	; 0
    f602:	79 d3       	rcall	.+1778   	; 0xfcf6 <fputc>
    f604:	a2 fe       	sbrs	r10, 2
    f606:	16 c0       	rjmp	.+44     	; 0xf634 <vfprintf+0x380>
    f608:	a1 fc       	sbrc	r10, 1
    f60a:	03 c0       	rjmp	.+6      	; 0xf612 <vfprintf+0x35e>
    f60c:	88 e7       	ldi	r24, 0x78	; 120
    f60e:	90 e0       	ldi	r25, 0x00	; 0
    f610:	02 c0       	rjmp	.+4      	; 0xf616 <vfprintf+0x362>
    f612:	88 e5       	ldi	r24, 0x58	; 88
    f614:	90 e0       	ldi	r25, 0x00	; 0
    f616:	b6 01       	movw	r22, r12
    f618:	0c c0       	rjmp	.+24     	; 0xf632 <vfprintf+0x37e>
    f61a:	8a 2d       	mov	r24, r10
    f61c:	86 78       	andi	r24, 0x86	; 134
    f61e:	51 f0       	breq	.+20     	; 0xf634 <vfprintf+0x380>
    f620:	a1 fe       	sbrs	r10, 1
    f622:	02 c0       	rjmp	.+4      	; 0xf628 <vfprintf+0x374>
    f624:	8b e2       	ldi	r24, 0x2B	; 43
    f626:	01 c0       	rjmp	.+2      	; 0xf62a <vfprintf+0x376>
    f628:	80 e2       	ldi	r24, 0x20	; 32
    f62a:	a7 fc       	sbrc	r10, 7
    f62c:	8d e2       	ldi	r24, 0x2D	; 45
    f62e:	b6 01       	movw	r22, r12
    f630:	90 e0       	ldi	r25, 0x00	; 0
    f632:	61 d3       	rcall	.+1730   	; 0xfcf6 <fputc>
    f634:	89 14       	cp	r8, r9
    f636:	30 f4       	brcc	.+12     	; 0xf644 <vfprintf+0x390>
    f638:	b6 01       	movw	r22, r12
    f63a:	80 e3       	ldi	r24, 0x30	; 48
    f63c:	90 e0       	ldi	r25, 0x00	; 0
    f63e:	5b d3       	rcall	.+1718   	; 0xfcf6 <fputc>
    f640:	9a 94       	dec	r9
    f642:	f8 cf       	rjmp	.-16     	; 0xf634 <vfprintf+0x380>
    f644:	8a 94       	dec	r8
    f646:	f3 01       	movw	r30, r6
    f648:	e8 0d       	add	r30, r8
    f64a:	f1 1d       	adc	r31, r1
    f64c:	80 81       	ld	r24, Z
    f64e:	b6 01       	movw	r22, r12
    f650:	90 e0       	ldi	r25, 0x00	; 0
    f652:	51 d3       	rcall	.+1698   	; 0xfcf6 <fputc>
    f654:	81 10       	cpse	r8, r1
    f656:	f6 cf       	rjmp	.-20     	; 0xf644 <vfprintf+0x390>
    f658:	22 20       	and	r2, r2
    f65a:	09 f4       	brne	.+2      	; 0xf65e <vfprintf+0x3aa>
    f65c:	4e ce       	rjmp	.-868    	; 0xf2fa <vfprintf+0x46>
    f65e:	b6 01       	movw	r22, r12
    f660:	80 e2       	ldi	r24, 0x20	; 32
    f662:	90 e0       	ldi	r25, 0x00	; 0
    f664:	48 d3       	rcall	.+1680   	; 0xfcf6 <fputc>
    f666:	2a 94       	dec	r2
    f668:	f7 cf       	rjmp	.-18     	; 0xf658 <vfprintf+0x3a4>
    f66a:	f6 01       	movw	r30, r12
    f66c:	86 81       	ldd	r24, Z+6	; 0x06
    f66e:	97 81       	ldd	r25, Z+7	; 0x07
    f670:	02 c0       	rjmp	.+4      	; 0xf676 <vfprintf+0x3c2>
    f672:	8f ef       	ldi	r24, 0xFF	; 255
    f674:	9f ef       	ldi	r25, 0xFF	; 255
    f676:	2b 96       	adiw	r28, 0x0b	; 11
    f678:	cd bf       	out	0x3d, r28	; 61
    f67a:	de bf       	out	0x3e, r29	; 62
    f67c:	df 91       	pop	r29
    f67e:	cf 91       	pop	r28
    f680:	1f 91       	pop	r17
    f682:	0f 91       	pop	r16
    f684:	ff 90       	pop	r15
    f686:	ef 90       	pop	r14
    f688:	df 90       	pop	r13
    f68a:	cf 90       	pop	r12
    f68c:	bf 90       	pop	r11
    f68e:	af 90       	pop	r10
    f690:	9f 90       	pop	r9
    f692:	8f 90       	pop	r8
    f694:	7f 90       	pop	r7
    f696:	6f 90       	pop	r6
    f698:	5f 90       	pop	r5
    f69a:	4f 90       	pop	r4
    f69c:	3f 90       	pop	r3
    f69e:	2f 90       	pop	r2
    f6a0:	08 95       	ret

0000f6a2 <putval>:
    f6a2:	20 fd       	sbrc	r18, 0
    f6a4:	09 c0       	rjmp	.+18     	; 0xf6b8 <putval+0x16>
    f6a6:	fc 01       	movw	r30, r24
    f6a8:	23 fd       	sbrc	r18, 3
    f6aa:	05 c0       	rjmp	.+10     	; 0xf6b6 <putval+0x14>
    f6ac:	22 ff       	sbrs	r18, 2
    f6ae:	02 c0       	rjmp	.+4      	; 0xf6b4 <putval+0x12>
    f6b0:	73 83       	std	Z+3, r23	; 0x03
    f6b2:	62 83       	std	Z+2, r22	; 0x02
    f6b4:	51 83       	std	Z+1, r21	; 0x01
    f6b6:	40 83       	st	Z, r20
    f6b8:	08 95       	ret

0000f6ba <mulacc>:
    f6ba:	44 fd       	sbrc	r20, 4
    f6bc:	17 c0       	rjmp	.+46     	; 0xf6ec <mulacc+0x32>
    f6be:	46 fd       	sbrc	r20, 6
    f6c0:	17 c0       	rjmp	.+46     	; 0xf6f0 <mulacc+0x36>
    f6c2:	ab 01       	movw	r20, r22
    f6c4:	bc 01       	movw	r22, r24
    f6c6:	da 01       	movw	r26, r20
    f6c8:	fb 01       	movw	r30, r22
    f6ca:	aa 0f       	add	r26, r26
    f6cc:	bb 1f       	adc	r27, r27
    f6ce:	ee 1f       	adc	r30, r30
    f6d0:	ff 1f       	adc	r31, r31
    f6d2:	10 94       	com	r1
    f6d4:	d1 f7       	brne	.-12     	; 0xf6ca <mulacc+0x10>
    f6d6:	4a 0f       	add	r20, r26
    f6d8:	5b 1f       	adc	r21, r27
    f6da:	6e 1f       	adc	r22, r30
    f6dc:	7f 1f       	adc	r23, r31
    f6de:	cb 01       	movw	r24, r22
    f6e0:	ba 01       	movw	r22, r20
    f6e2:	66 0f       	add	r22, r22
    f6e4:	77 1f       	adc	r23, r23
    f6e6:	88 1f       	adc	r24, r24
    f6e8:	99 1f       	adc	r25, r25
    f6ea:	09 c0       	rjmp	.+18     	; 0xf6fe <mulacc+0x44>
    f6ec:	33 e0       	ldi	r19, 0x03	; 3
    f6ee:	01 c0       	rjmp	.+2      	; 0xf6f2 <mulacc+0x38>
    f6f0:	34 e0       	ldi	r19, 0x04	; 4
    f6f2:	66 0f       	add	r22, r22
    f6f4:	77 1f       	adc	r23, r23
    f6f6:	88 1f       	adc	r24, r24
    f6f8:	99 1f       	adc	r25, r25
    f6fa:	31 50       	subi	r19, 0x01	; 1
    f6fc:	d1 f7       	brne	.-12     	; 0xf6f2 <mulacc+0x38>
    f6fe:	62 0f       	add	r22, r18
    f700:	71 1d       	adc	r23, r1
    f702:	81 1d       	adc	r24, r1
    f704:	91 1d       	adc	r25, r1
    f706:	08 95       	ret

0000f708 <skip_spaces>:
    f708:	0f 93       	push	r16
    f70a:	1f 93       	push	r17
    f70c:	cf 93       	push	r28
    f70e:	df 93       	push	r29
    f710:	8c 01       	movw	r16, r24
    f712:	c8 01       	movw	r24, r16
    f714:	b2 d2       	rcall	.+1380   	; 0xfc7a <fgetc>
    f716:	ec 01       	movw	r28, r24
    f718:	97 fd       	sbrc	r25, 7
    f71a:	06 c0       	rjmp	.+12     	; 0xf728 <skip_spaces+0x20>
    f71c:	85 d2       	rcall	.+1290   	; 0xfc28 <isspace>
    f71e:	89 2b       	or	r24, r25
    f720:	c1 f7       	brne	.-16     	; 0xf712 <skip_spaces+0xa>
    f722:	b8 01       	movw	r22, r16
    f724:	ce 01       	movw	r24, r28
    f726:	23 d3       	rcall	.+1606   	; 0xfd6e <ungetc>
    f728:	ce 01       	movw	r24, r28
    f72a:	df 91       	pop	r29
    f72c:	cf 91       	pop	r28
    f72e:	1f 91       	pop	r17
    f730:	0f 91       	pop	r16
    f732:	08 95       	ret

0000f734 <conv_int>:
    f734:	8f 92       	push	r8
    f736:	9f 92       	push	r9
    f738:	af 92       	push	r10
    f73a:	bf 92       	push	r11
    f73c:	ef 92       	push	r14
    f73e:	ff 92       	push	r15
    f740:	0f 93       	push	r16
    f742:	1f 93       	push	r17
    f744:	cf 93       	push	r28
    f746:	df 93       	push	r29
    f748:	8c 01       	movw	r16, r24
    f74a:	d6 2f       	mov	r29, r22
    f74c:	7a 01       	movw	r14, r20
    f74e:	b2 2e       	mov	r11, r18
    f750:	94 d2       	rcall	.+1320   	; 0xfc7a <fgetc>
    f752:	9c 01       	movw	r18, r24
    f754:	33 27       	eor	r19, r19
    f756:	2b 32       	cpi	r18, 0x2B	; 43
    f758:	31 05       	cpc	r19, r1
    f75a:	31 f0       	breq	.+12     	; 0xf768 <conv_int+0x34>
    f75c:	2d 32       	cpi	r18, 0x2D	; 45
    f75e:	31 05       	cpc	r19, r1
    f760:	59 f4       	brne	.+22     	; 0xf778 <conv_int+0x44>
    f762:	8b 2d       	mov	r24, r11
    f764:	80 68       	ori	r24, 0x80	; 128
    f766:	b8 2e       	mov	r11, r24
    f768:	d1 50       	subi	r29, 0x01	; 1
    f76a:	11 f4       	brne	.+4      	; 0xf770 <conv_int+0x3c>
    f76c:	80 e0       	ldi	r24, 0x00	; 0
    f76e:	61 c0       	rjmp	.+194    	; 0xf832 <conv_int+0xfe>
    f770:	c8 01       	movw	r24, r16
    f772:	83 d2       	rcall	.+1286   	; 0xfc7a <fgetc>
    f774:	97 fd       	sbrc	r25, 7
    f776:	fa cf       	rjmp	.-12     	; 0xf76c <conv_int+0x38>
    f778:	cb 2d       	mov	r28, r11
    f77a:	cd 7f       	andi	r28, 0xFD	; 253
    f77c:	2b 2d       	mov	r18, r11
    f77e:	20 73       	andi	r18, 0x30	; 48
    f780:	f9 f4       	brne	.+62     	; 0xf7c0 <conv_int+0x8c>
    f782:	80 33       	cpi	r24, 0x30	; 48
    f784:	e9 f4       	brne	.+58     	; 0xf7c0 <conv_int+0x8c>
    f786:	aa 24       	eor	r10, r10
    f788:	aa 94       	dec	r10
    f78a:	ad 0e       	add	r10, r29
    f78c:	09 f4       	brne	.+2      	; 0xf790 <conv_int+0x5c>
    f78e:	3e c0       	rjmp	.+124    	; 0xf80c <conv_int+0xd8>
    f790:	c8 01       	movw	r24, r16
    f792:	73 d2       	rcall	.+1254   	; 0xfc7a <fgetc>
    f794:	97 fd       	sbrc	r25, 7
    f796:	3a c0       	rjmp	.+116    	; 0xf80c <conv_int+0xd8>
    f798:	9c 01       	movw	r18, r24
    f79a:	2f 7d       	andi	r18, 0xDF	; 223
    f79c:	33 27       	eor	r19, r19
    f79e:	28 35       	cpi	r18, 0x58	; 88
    f7a0:	31 05       	cpc	r19, r1
    f7a2:	41 f4       	brne	.+16     	; 0xf7b4 <conv_int+0x80>
    f7a4:	c2 64       	ori	r28, 0x42	; 66
    f7a6:	d2 50       	subi	r29, 0x02	; 2
    f7a8:	89 f1       	breq	.+98     	; 0xf80c <conv_int+0xd8>
    f7aa:	c8 01       	movw	r24, r16
    f7ac:	66 d2       	rcall	.+1228   	; 0xfc7a <fgetc>
    f7ae:	97 ff       	sbrs	r25, 7
    f7b0:	07 c0       	rjmp	.+14     	; 0xf7c0 <conv_int+0x8c>
    f7b2:	2c c0       	rjmp	.+88     	; 0xf80c <conv_int+0xd8>
    f7b4:	b6 fe       	sbrs	r11, 6
    f7b6:	02 c0       	rjmp	.+4      	; 0xf7bc <conv_int+0x88>
    f7b8:	c2 60       	ori	r28, 0x02	; 2
    f7ba:	01 c0       	rjmp	.+2      	; 0xf7be <conv_int+0x8a>
    f7bc:	c2 61       	ori	r28, 0x12	; 18
    f7be:	da 2d       	mov	r29, r10
    f7c0:	81 2c       	mov	r8, r1
    f7c2:	91 2c       	mov	r9, r1
    f7c4:	54 01       	movw	r10, r8
    f7c6:	20 ed       	ldi	r18, 0xD0	; 208
    f7c8:	28 0f       	add	r18, r24
    f7ca:	28 30       	cpi	r18, 0x08	; 8
    f7cc:	78 f0       	brcs	.+30     	; 0xf7ec <conv_int+0xb8>
    f7ce:	c4 ff       	sbrs	r28, 4
    f7d0:	03 c0       	rjmp	.+6      	; 0xf7d8 <conv_int+0xa4>
    f7d2:	b8 01       	movw	r22, r16
    f7d4:	cc d2       	rcall	.+1432   	; 0xfd6e <ungetc>
    f7d6:	17 c0       	rjmp	.+46     	; 0xf806 <conv_int+0xd2>
    f7d8:	2a 30       	cpi	r18, 0x0A	; 10
    f7da:	40 f0       	brcs	.+16     	; 0xf7ec <conv_int+0xb8>
    f7dc:	c6 ff       	sbrs	r28, 6
    f7de:	f9 cf       	rjmp	.-14     	; 0xf7d2 <conv_int+0x9e>
    f7e0:	2f 7d       	andi	r18, 0xDF	; 223
    f7e2:	3f ee       	ldi	r19, 0xEF	; 239
    f7e4:	32 0f       	add	r19, r18
    f7e6:	36 30       	cpi	r19, 0x06	; 6
    f7e8:	a0 f7       	brcc	.-24     	; 0xf7d2 <conv_int+0x9e>
    f7ea:	27 50       	subi	r18, 0x07	; 7
    f7ec:	4c 2f       	mov	r20, r28
    f7ee:	c5 01       	movw	r24, r10
    f7f0:	b4 01       	movw	r22, r8
    f7f2:	63 df       	rcall	.-314    	; 0xf6ba <mulacc>
    f7f4:	4b 01       	movw	r8, r22
    f7f6:	5c 01       	movw	r10, r24
    f7f8:	c2 60       	ori	r28, 0x02	; 2
    f7fa:	d1 50       	subi	r29, 0x01	; 1
    f7fc:	51 f0       	breq	.+20     	; 0xf812 <conv_int+0xde>
    f7fe:	c8 01       	movw	r24, r16
    f800:	3c d2       	rcall	.+1144   	; 0xfc7a <fgetc>
    f802:	97 ff       	sbrs	r25, 7
    f804:	e0 cf       	rjmp	.-64     	; 0xf7c6 <conv_int+0x92>
    f806:	c1 fd       	sbrc	r28, 1
    f808:	04 c0       	rjmp	.+8      	; 0xf812 <conv_int+0xde>
    f80a:	b0 cf       	rjmp	.-160    	; 0xf76c <conv_int+0x38>
    f80c:	81 2c       	mov	r8, r1
    f80e:	91 2c       	mov	r9, r1
    f810:	54 01       	movw	r10, r8
    f812:	c7 ff       	sbrs	r28, 7
    f814:	08 c0       	rjmp	.+16     	; 0xf826 <conv_int+0xf2>
    f816:	b0 94       	com	r11
    f818:	a0 94       	com	r10
    f81a:	90 94       	com	r9
    f81c:	80 94       	com	r8
    f81e:	81 1c       	adc	r8, r1
    f820:	91 1c       	adc	r9, r1
    f822:	a1 1c       	adc	r10, r1
    f824:	b1 1c       	adc	r11, r1
    f826:	2c 2f       	mov	r18, r28
    f828:	b5 01       	movw	r22, r10
    f82a:	a4 01       	movw	r20, r8
    f82c:	c7 01       	movw	r24, r14
    f82e:	39 df       	rcall	.-398    	; 0xf6a2 <putval>
    f830:	81 e0       	ldi	r24, 0x01	; 1
    f832:	df 91       	pop	r29
    f834:	cf 91       	pop	r28
    f836:	1f 91       	pop	r17
    f838:	0f 91       	pop	r16
    f83a:	ff 90       	pop	r15
    f83c:	ef 90       	pop	r14
    f83e:	bf 90       	pop	r11
    f840:	af 90       	pop	r10
    f842:	9f 90       	pop	r9
    f844:	8f 90       	pop	r8
    f846:	08 95       	ret

0000f848 <conv_brk>:
    f848:	5f 92       	push	r5
    f84a:	6f 92       	push	r6
    f84c:	7f 92       	push	r7
    f84e:	8f 92       	push	r8
    f850:	9f 92       	push	r9
    f852:	af 92       	push	r10
    f854:	bf 92       	push	r11
    f856:	cf 92       	push	r12
    f858:	df 92       	push	r13
    f85a:	ef 92       	push	r14
    f85c:	ff 92       	push	r15
    f85e:	0f 93       	push	r16
    f860:	1f 93       	push	r17
    f862:	cf 93       	push	r28
    f864:	df 93       	push	r29
    f866:	cd b7       	in	r28, 0x3d	; 61
    f868:	de b7       	in	r29, 0x3e	; 62
    f86a:	a0 97       	sbiw	r28, 0x20	; 32
    f86c:	cd bf       	out	0x3d, r28	; 61
    f86e:	de bf       	out	0x3e, r29	; 62
    f870:	5c 01       	movw	r10, r24
    f872:	96 2e       	mov	r9, r22
    f874:	7a 01       	movw	r14, r20
    f876:	f9 01       	movw	r30, r18
    f878:	8e 01       	movw	r16, r28
    f87a:	0f 5f       	subi	r16, 0xFF	; 255
    f87c:	1f 4f       	sbci	r17, 0xFF	; 255
    f87e:	68 01       	movw	r12, r16
    f880:	80 e2       	ldi	r24, 0x20	; 32
    f882:	d8 01       	movw	r26, r16
    f884:	1d 92       	st	X+, r1
    f886:	8a 95       	dec	r24
    f888:	e9 f7       	brne	.-6      	; 0xf884 <conv_brk+0x3c>
    f88a:	d5 01       	movw	r26, r10
    f88c:	13 96       	adiw	r26, 0x03	; 3
    f88e:	8c 90       	ld	r8, X
    f890:	80 e0       	ldi	r24, 0x00	; 0
    f892:	90 e0       	ldi	r25, 0x00	; 0
    f894:	61 2c       	mov	r6, r1
    f896:	71 2c       	mov	r7, r1
    f898:	30 e0       	ldi	r19, 0x00	; 0
    f89a:	61 e0       	ldi	r22, 0x01	; 1
    f89c:	70 e0       	ldi	r23, 0x00	; 0
    f89e:	83 fc       	sbrc	r8, 3
    f8a0:	25 91       	lpm	r18, Z+
    f8a2:	83 fe       	sbrs	r8, 3
    f8a4:	21 91       	ld	r18, Z+
    f8a6:	8f 01       	movw	r16, r30
    f8a8:	52 2e       	mov	r5, r18
    f8aa:	21 11       	cpse	r18, r1
    f8ac:	03 c0       	rjmp	.+6      	; 0xf8b4 <conv_brk+0x6c>
    f8ae:	80 e0       	ldi	r24, 0x00	; 0
    f8b0:	90 e0       	ldi	r25, 0x00	; 0
    f8b2:	90 c0       	rjmp	.+288    	; 0xf9d4 <conv_brk+0x18c>
    f8b4:	2e 35       	cpi	r18, 0x5E	; 94
    f8b6:	11 f4       	brne	.+4      	; 0xf8bc <conv_brk+0x74>
    f8b8:	00 97       	sbiw	r24, 0x00	; 0
    f8ba:	51 f1       	breq	.+84     	; 0xf910 <conv_brk+0xc8>
    f8bc:	43 2f       	mov	r20, r19
    f8be:	50 e0       	ldi	r21, 0x00	; 0
    f8c0:	48 17       	cp	r20, r24
    f8c2:	59 07       	cpc	r21, r25
    f8c4:	3c f4       	brge	.+14     	; 0xf8d4 <conv_brk+0x8c>
    f8c6:	2d 35       	cpi	r18, 0x5D	; 93
    f8c8:	59 f1       	breq	.+86     	; 0xf920 <conv_brk+0xd8>
    f8ca:	2d 32       	cpi	r18, 0x2D	; 45
    f8cc:	19 f4       	brne	.+6      	; 0xf8d4 <conv_brk+0x8c>
    f8ce:	77 20       	and	r7, r7
    f8d0:	09 f1       	breq	.+66     	; 0xf914 <conv_brk+0xcc>
    f8d2:	03 c0       	rjmp	.+6      	; 0xf8da <conv_brk+0x92>
    f8d4:	77 20       	and	r7, r7
    f8d6:	09 f4       	brne	.+2      	; 0xf8da <conv_brk+0x92>
    f8d8:	68 c0       	rjmp	.+208    	; 0xf9aa <conv_brk+0x162>
    f8da:	45 2d       	mov	r20, r5
    f8dc:	46 95       	lsr	r20
    f8de:	46 95       	lsr	r20
    f8e0:	46 95       	lsr	r20
    f8e2:	d6 01       	movw	r26, r12
    f8e4:	a4 0f       	add	r26, r20
    f8e6:	b1 1d       	adc	r27, r1
    f8e8:	45 2d       	mov	r20, r5
    f8ea:	47 70       	andi	r20, 0x07	; 7
    f8ec:	8b 01       	movw	r16, r22
    f8ee:	02 c0       	rjmp	.+4      	; 0xf8f4 <conv_brk+0xac>
    f8f0:	00 0f       	add	r16, r16
    f8f2:	11 1f       	adc	r17, r17
    f8f4:	4a 95       	dec	r20
    f8f6:	e2 f7       	brpl	.-8      	; 0xf8f0 <conv_brk+0xa8>
    f8f8:	a8 01       	movw	r20, r16
    f8fa:	5c 91       	ld	r21, X
    f8fc:	45 2b       	or	r20, r21
    f8fe:	4c 93       	st	X, r20
    f900:	65 14       	cp	r6, r5
    f902:	59 f0       	breq	.+22     	; 0xf91a <conv_brk+0xd2>
    f904:	56 14       	cp	r5, r6
    f906:	10 f4       	brcc	.+4      	; 0xf90c <conv_brk+0xc4>
    f908:	53 94       	inc	r5
    f90a:	e7 cf       	rjmp	.-50     	; 0xf8da <conv_brk+0x92>
    f90c:	5a 94       	dec	r5
    f90e:	e5 cf       	rjmp	.-54     	; 0xf8da <conv_brk+0x92>
    f910:	31 e0       	ldi	r19, 0x01	; 1
    f912:	04 c0       	rjmp	.+8      	; 0xf91c <conv_brk+0xd4>
    f914:	77 24       	eor	r7, r7
    f916:	73 94       	inc	r7
    f918:	01 c0       	rjmp	.+2      	; 0xf91c <conv_brk+0xd4>
    f91a:	71 2c       	mov	r7, r1
    f91c:	01 96       	adiw	r24, 0x01	; 1
    f91e:	bf cf       	rjmp	.-130    	; 0xf89e <conv_brk+0x56>
    f920:	77 20       	and	r7, r7
    f922:	19 f0       	breq	.+6      	; 0xf92a <conv_brk+0xe2>
    f924:	8e 81       	ldd	r24, Y+6	; 0x06
    f926:	80 62       	ori	r24, 0x20	; 32
    f928:	8e 83       	std	Y+6, r24	; 0x06
    f92a:	31 11       	cpse	r19, r1
    f92c:	03 c0       	rjmp	.+6      	; 0xf934 <conv_brk+0xec>
    f92e:	88 24       	eor	r8, r8
    f930:	83 94       	inc	r8
    f932:	17 c0       	rjmp	.+46     	; 0xf962 <conv_brk+0x11a>
    f934:	f6 01       	movw	r30, r12
    f936:	9e 01       	movw	r18, r28
    f938:	2f 5d       	subi	r18, 0xDF	; 223
    f93a:	3f 4f       	sbci	r19, 0xFF	; 255
    f93c:	80 81       	ld	r24, Z
    f93e:	80 95       	com	r24
    f940:	81 93       	st	Z+, r24
    f942:	2e 17       	cp	r18, r30
    f944:	3f 07       	cpc	r19, r31
    f946:	d1 f7       	brne	.-12     	; 0xf93c <conv_brk+0xf4>
    f948:	f2 cf       	rjmp	.-28     	; 0xf92e <conv_brk+0xe6>
    f94a:	e1 14       	cp	r14, r1
    f94c:	f1 04       	cpc	r15, r1
    f94e:	29 f0       	breq	.+10     	; 0xf95a <conv_brk+0x112>
    f950:	d7 01       	movw	r26, r14
    f952:	8c 93       	st	X, r24
    f954:	f7 01       	movw	r30, r14
    f956:	31 96       	adiw	r30, 0x01	; 1
    f958:	7f 01       	movw	r14, r30
    f95a:	9a 94       	dec	r9
    f95c:	81 2c       	mov	r8, r1
    f95e:	99 20       	and	r9, r9
    f960:	e9 f0       	breq	.+58     	; 0xf99c <conv_brk+0x154>
    f962:	c5 01       	movw	r24, r10
    f964:	8a d1       	rcall	.+788    	; 0xfc7a <fgetc>
    f966:	97 fd       	sbrc	r25, 7
    f968:	17 c0       	rjmp	.+46     	; 0xf998 <conv_brk+0x150>
    f96a:	fc 01       	movw	r30, r24
    f96c:	ff 27       	eor	r31, r31
    f96e:	23 e0       	ldi	r18, 0x03	; 3
    f970:	f5 95       	asr	r31
    f972:	e7 95       	ror	r30
    f974:	2a 95       	dec	r18
    f976:	e1 f7       	brne	.-8      	; 0xf970 <conv_brk+0x128>
    f978:	ec 0d       	add	r30, r12
    f97a:	fd 1d       	adc	r31, r13
    f97c:	20 81       	ld	r18, Z
    f97e:	30 e0       	ldi	r19, 0x00	; 0
    f980:	ac 01       	movw	r20, r24
    f982:	47 70       	andi	r20, 0x07	; 7
    f984:	55 27       	eor	r21, r21
    f986:	02 c0       	rjmp	.+4      	; 0xf98c <conv_brk+0x144>
    f988:	35 95       	asr	r19
    f98a:	27 95       	ror	r18
    f98c:	4a 95       	dec	r20
    f98e:	e2 f7       	brpl	.-8      	; 0xf988 <conv_brk+0x140>
    f990:	20 fd       	sbrc	r18, 0
    f992:	db cf       	rjmp	.-74     	; 0xf94a <conv_brk+0x102>
    f994:	b5 01       	movw	r22, r10
    f996:	eb d1       	rcall	.+982    	; 0xfd6e <ungetc>
    f998:	81 10       	cpse	r8, r1
    f99a:	89 cf       	rjmp	.-238    	; 0xf8ae <conv_brk+0x66>
    f99c:	e1 14       	cp	r14, r1
    f99e:	f1 04       	cpc	r15, r1
    f9a0:	11 f0       	breq	.+4      	; 0xf9a6 <conv_brk+0x15e>
    f9a2:	d7 01       	movw	r26, r14
    f9a4:	1c 92       	st	X, r1
    f9a6:	c8 01       	movw	r24, r16
    f9a8:	15 c0       	rjmp	.+42     	; 0xf9d4 <conv_brk+0x18c>
    f9aa:	42 2f       	mov	r20, r18
    f9ac:	46 95       	lsr	r20
    f9ae:	46 95       	lsr	r20
    f9b0:	46 95       	lsr	r20
    f9b2:	d6 01       	movw	r26, r12
    f9b4:	a4 0f       	add	r26, r20
    f9b6:	b1 1d       	adc	r27, r1
    f9b8:	42 2f       	mov	r20, r18
    f9ba:	47 70       	andi	r20, 0x07	; 7
    f9bc:	8b 01       	movw	r16, r22
    f9be:	02 c0       	rjmp	.+4      	; 0xf9c4 <conv_brk+0x17c>
    f9c0:	00 0f       	add	r16, r16
    f9c2:	11 1f       	adc	r17, r17
    f9c4:	4a 95       	dec	r20
    f9c6:	e2 f7       	brpl	.-8      	; 0xf9c0 <conv_brk+0x178>
    f9c8:	a8 01       	movw	r20, r16
    f9ca:	5c 91       	ld	r21, X
    f9cc:	45 2b       	or	r20, r21
    f9ce:	4c 93       	st	X, r20
    f9d0:	62 2e       	mov	r6, r18
    f9d2:	a4 cf       	rjmp	.-184    	; 0xf91c <conv_brk+0xd4>
    f9d4:	a0 96       	adiw	r28, 0x20	; 32
    f9d6:	cd bf       	out	0x3d, r28	; 61
    f9d8:	de bf       	out	0x3e, r29	; 62
    f9da:	df 91       	pop	r29
    f9dc:	cf 91       	pop	r28
    f9de:	1f 91       	pop	r17
    f9e0:	0f 91       	pop	r16
    f9e2:	ff 90       	pop	r15
    f9e4:	ef 90       	pop	r14
    f9e6:	df 90       	pop	r13
    f9e8:	cf 90       	pop	r12
    f9ea:	bf 90       	pop	r11
    f9ec:	af 90       	pop	r10
    f9ee:	9f 90       	pop	r9
    f9f0:	8f 90       	pop	r8
    f9f2:	7f 90       	pop	r7
    f9f4:	6f 90       	pop	r6
    f9f6:	5f 90       	pop	r5
    f9f8:	08 95       	ret

0000f9fa <vfscanf>:
    f9fa:	5f 92       	push	r5
    f9fc:	6f 92       	push	r6
    f9fe:	7f 92       	push	r7
    fa00:	8f 92       	push	r8
    fa02:	9f 92       	push	r9
    fa04:	af 92       	push	r10
    fa06:	bf 92       	push	r11
    fa08:	cf 92       	push	r12
    fa0a:	df 92       	push	r13
    fa0c:	ef 92       	push	r14
    fa0e:	ff 92       	push	r15
    fa10:	0f 93       	push	r16
    fa12:	1f 93       	push	r17
    fa14:	cf 93       	push	r28
    fa16:	df 93       	push	r29
    fa18:	6c 01       	movw	r12, r24
    fa1a:	eb 01       	movw	r28, r22
    fa1c:	5a 01       	movw	r10, r20
    fa1e:	fc 01       	movw	r30, r24
    fa20:	16 82       	std	Z+6, r1	; 0x06
    fa22:	17 82       	std	Z+7, r1	; 0x07
    fa24:	51 2c       	mov	r5, r1
    fa26:	f6 01       	movw	r30, r12
    fa28:	e3 80       	ldd	r14, Z+3	; 0x03
    fa2a:	fe 01       	movw	r30, r28
    fa2c:	e3 fc       	sbrc	r14, 3
    fa2e:	85 91       	lpm	r24, Z+
    fa30:	e3 fe       	sbrs	r14, 3
    fa32:	81 91       	ld	r24, Z+
    fa34:	18 2f       	mov	r17, r24
    fa36:	ef 01       	movw	r28, r30
    fa38:	88 23       	and	r24, r24
    fa3a:	09 f4       	brne	.+2      	; 0xfa3e <vfscanf+0x44>
    fa3c:	e0 c0       	rjmp	.+448    	; 0xfbfe <vfscanf+0x204>
    fa3e:	90 e0       	ldi	r25, 0x00	; 0
    fa40:	f3 d0       	rcall	.+486    	; 0xfc28 <isspace>
    fa42:	89 2b       	or	r24, r25
    fa44:	19 f0       	breq	.+6      	; 0xfa4c <vfscanf+0x52>
    fa46:	c6 01       	movw	r24, r12
    fa48:	5f de       	rcall	.-834    	; 0xf708 <skip_spaces>
    fa4a:	ed cf       	rjmp	.-38     	; 0xfa26 <vfscanf+0x2c>
    fa4c:	15 32       	cpi	r17, 0x25	; 37
    fa4e:	41 f4       	brne	.+16     	; 0xfa60 <vfscanf+0x66>
    fa50:	fe 01       	movw	r30, r28
    fa52:	e3 fc       	sbrc	r14, 3
    fa54:	15 91       	lpm	r17, Z+
    fa56:	e3 fe       	sbrs	r14, 3
    fa58:	11 91       	ld	r17, Z+
    fa5a:	ef 01       	movw	r28, r30
    fa5c:	15 32       	cpi	r17, 0x25	; 37
    fa5e:	71 f4       	brne	.+28     	; 0xfa7c <vfscanf+0x82>
    fa60:	c6 01       	movw	r24, r12
    fa62:	0b d1       	rcall	.+534    	; 0xfc7a <fgetc>
    fa64:	97 fd       	sbrc	r25, 7
    fa66:	c9 c0       	rjmp	.+402    	; 0xfbfa <vfscanf+0x200>
    fa68:	41 2f       	mov	r20, r17
    fa6a:	50 e0       	ldi	r21, 0x00	; 0
    fa6c:	9c 01       	movw	r18, r24
    fa6e:	33 27       	eor	r19, r19
    fa70:	24 17       	cp	r18, r20
    fa72:	35 07       	cpc	r19, r21
    fa74:	c1 f2       	breq	.-80     	; 0xfa26 <vfscanf+0x2c>
    fa76:	b6 01       	movw	r22, r12
    fa78:	7a d1       	rcall	.+756    	; 0xfd6e <ungetc>
    fa7a:	c1 c0       	rjmp	.+386    	; 0xfbfe <vfscanf+0x204>
    fa7c:	1a 32       	cpi	r17, 0x2A	; 42
    fa7e:	39 f4       	brne	.+14     	; 0xfa8e <vfscanf+0x94>
    fa80:	e3 fc       	sbrc	r14, 3
    fa82:	15 91       	lpm	r17, Z+
    fa84:	e3 fe       	sbrs	r14, 3
    fa86:	11 91       	ld	r17, Z+
    fa88:	ef 01       	movw	r28, r30
    fa8a:	01 e0       	ldi	r16, 0x01	; 1
    fa8c:	01 c0       	rjmp	.+2      	; 0xfa90 <vfscanf+0x96>
    fa8e:	00 e0       	ldi	r16, 0x00	; 0
    fa90:	f1 2c       	mov	r15, r1
    fa92:	20 ed       	ldi	r18, 0xD0	; 208
    fa94:	21 0f       	add	r18, r17
    fa96:	2a 30       	cpi	r18, 0x0A	; 10
    fa98:	78 f4       	brcc	.+30     	; 0xfab8 <vfscanf+0xbe>
    fa9a:	02 60       	ori	r16, 0x02	; 2
    fa9c:	6f 2d       	mov	r22, r15
    fa9e:	70 e0       	ldi	r23, 0x00	; 0
    faa0:	80 e0       	ldi	r24, 0x00	; 0
    faa2:	90 e0       	ldi	r25, 0x00	; 0
    faa4:	40 e2       	ldi	r20, 0x20	; 32
    faa6:	09 de       	rcall	.-1006   	; 0xf6ba <mulacc>
    faa8:	f6 2e       	mov	r15, r22
    faaa:	fe 01       	movw	r30, r28
    faac:	e3 fc       	sbrc	r14, 3
    faae:	15 91       	lpm	r17, Z+
    fab0:	e3 fe       	sbrs	r14, 3
    fab2:	11 91       	ld	r17, Z+
    fab4:	ef 01       	movw	r28, r30
    fab6:	ed cf       	rjmp	.-38     	; 0xfa92 <vfscanf+0x98>
    fab8:	01 ff       	sbrs	r16, 1
    faba:	03 c0       	rjmp	.+6      	; 0xfac2 <vfscanf+0xc8>
    fabc:	f1 10       	cpse	r15, r1
    fabe:	03 c0       	rjmp	.+6      	; 0xfac6 <vfscanf+0xcc>
    fac0:	9e c0       	rjmp	.+316    	; 0xfbfe <vfscanf+0x204>
    fac2:	ff 24       	eor	r15, r15
    fac4:	fa 94       	dec	r15
    fac6:	18 36       	cpi	r17, 0x68	; 104
    fac8:	19 f0       	breq	.+6      	; 0xfad0 <vfscanf+0xd6>
    faca:	1c 36       	cpi	r17, 0x6C	; 108
    facc:	51 f0       	breq	.+20     	; 0xfae2 <vfscanf+0xe8>
    face:	10 c0       	rjmp	.+32     	; 0xfaf0 <vfscanf+0xf6>
    fad0:	fe 01       	movw	r30, r28
    fad2:	e3 fc       	sbrc	r14, 3
    fad4:	15 91       	lpm	r17, Z+
    fad6:	e3 fe       	sbrs	r14, 3
    fad8:	11 91       	ld	r17, Z+
    fada:	ef 01       	movw	r28, r30
    fadc:	18 36       	cpi	r17, 0x68	; 104
    fade:	41 f4       	brne	.+16     	; 0xfaf0 <vfscanf+0xf6>
    fae0:	08 60       	ori	r16, 0x08	; 8
    fae2:	04 60       	ori	r16, 0x04	; 4
    fae4:	fe 01       	movw	r30, r28
    fae6:	e3 fc       	sbrc	r14, 3
    fae8:	15 91       	lpm	r17, Z+
    faea:	e3 fe       	sbrs	r14, 3
    faec:	11 91       	ld	r17, Z+
    faee:	ef 01       	movw	r28, r30
    faf0:	11 23       	and	r17, r17
    faf2:	09 f4       	brne	.+2      	; 0xfaf6 <vfscanf+0xfc>
    faf4:	84 c0       	rjmp	.+264    	; 0xfbfe <vfscanf+0x204>
    faf6:	61 2f       	mov	r22, r17
    faf8:	70 e0       	ldi	r23, 0x00	; 0
    fafa:	8c ef       	ldi	r24, 0xFC	; 252
    fafc:	91 e0       	ldi	r25, 0x01	; 1
    fafe:	9c d0       	rcall	.+312    	; 0xfc38 <strchr_P>
    fb00:	89 2b       	or	r24, r25
    fb02:	09 f4       	brne	.+2      	; 0xfb06 <vfscanf+0x10c>
    fb04:	7c c0       	rjmp	.+248    	; 0xfbfe <vfscanf+0x204>
    fb06:	00 fd       	sbrc	r16, 0
    fb08:	07 c0       	rjmp	.+14     	; 0xfb18 <vfscanf+0x11e>
    fb0a:	f5 01       	movw	r30, r10
    fb0c:	80 80       	ld	r8, Z
    fb0e:	91 80       	ldd	r9, Z+1	; 0x01
    fb10:	c5 01       	movw	r24, r10
    fb12:	02 96       	adiw	r24, 0x02	; 2
    fb14:	5c 01       	movw	r10, r24
    fb16:	02 c0       	rjmp	.+4      	; 0xfb1c <vfscanf+0x122>
    fb18:	81 2c       	mov	r8, r1
    fb1a:	91 2c       	mov	r9, r1
    fb1c:	1e 36       	cpi	r17, 0x6E	; 110
    fb1e:	49 f4       	brne	.+18     	; 0xfb32 <vfscanf+0x138>
    fb20:	f6 01       	movw	r30, r12
    fb22:	46 81       	ldd	r20, Z+6	; 0x06
    fb24:	57 81       	ldd	r21, Z+7	; 0x07
    fb26:	60 e0       	ldi	r22, 0x00	; 0
    fb28:	70 e0       	ldi	r23, 0x00	; 0
    fb2a:	20 2f       	mov	r18, r16
    fb2c:	c4 01       	movw	r24, r8
    fb2e:	b9 dd       	rcall	.-1166   	; 0xf6a2 <putval>
    fb30:	7a cf       	rjmp	.-268    	; 0xfa26 <vfscanf+0x2c>
    fb32:	13 36       	cpi	r17, 0x63	; 99
    fb34:	a1 f4       	brne	.+40     	; 0xfb5e <vfscanf+0x164>
    fb36:	01 fd       	sbrc	r16, 1
    fb38:	02 c0       	rjmp	.+4      	; 0xfb3e <vfscanf+0x144>
    fb3a:	ff 24       	eor	r15, r15
    fb3c:	f3 94       	inc	r15
    fb3e:	c6 01       	movw	r24, r12
    fb40:	9c d0       	rcall	.+312    	; 0xfc7a <fgetc>
    fb42:	97 fd       	sbrc	r25, 7
    fb44:	5a c0       	rjmp	.+180    	; 0xfbfa <vfscanf+0x200>
    fb46:	81 14       	cp	r8, r1
    fb48:	91 04       	cpc	r9, r1
    fb4a:	29 f0       	breq	.+10     	; 0xfb56 <vfscanf+0x15c>
    fb4c:	f4 01       	movw	r30, r8
    fb4e:	80 83       	st	Z, r24
    fb50:	c4 01       	movw	r24, r8
    fb52:	01 96       	adiw	r24, 0x01	; 1
    fb54:	4c 01       	movw	r8, r24
    fb56:	fa 94       	dec	r15
    fb58:	f1 10       	cpse	r15, r1
    fb5a:	f1 cf       	rjmp	.-30     	; 0xfb3e <vfscanf+0x144>
    fb5c:	4a c0       	rjmp	.+148    	; 0xfbf2 <vfscanf+0x1f8>
    fb5e:	1b 35       	cpi	r17, 0x5B	; 91
    fb60:	51 f4       	brne	.+20     	; 0xfb76 <vfscanf+0x17c>
    fb62:	9e 01       	movw	r18, r28
    fb64:	a4 01       	movw	r20, r8
    fb66:	6f 2d       	mov	r22, r15
    fb68:	c6 01       	movw	r24, r12
    fb6a:	6e de       	rcall	.-804    	; 0xf848 <conv_brk>
    fb6c:	ec 01       	movw	r28, r24
    fb6e:	89 2b       	or	r24, r25
    fb70:	09 f0       	breq	.+2      	; 0xfb74 <vfscanf+0x17a>
    fb72:	3f c0       	rjmp	.+126    	; 0xfbf2 <vfscanf+0x1f8>
    fb74:	39 c0       	rjmp	.+114    	; 0xfbe8 <vfscanf+0x1ee>
    fb76:	c6 01       	movw	r24, r12
    fb78:	c7 dd       	rcall	.-1138   	; 0xf708 <skip_spaces>
    fb7a:	97 fd       	sbrc	r25, 7
    fb7c:	3e c0       	rjmp	.+124    	; 0xfbfa <vfscanf+0x200>
    fb7e:	1f 36       	cpi	r17, 0x6F	; 111
    fb80:	49 f1       	breq	.+82     	; 0xfbd4 <vfscanf+0x1da>
    fb82:	28 f4       	brcc	.+10     	; 0xfb8e <vfscanf+0x194>
    fb84:	14 36       	cpi	r17, 0x64	; 100
    fb86:	21 f1       	breq	.+72     	; 0xfbd0 <vfscanf+0x1d6>
    fb88:	19 36       	cpi	r17, 0x69	; 105
    fb8a:	39 f1       	breq	.+78     	; 0xfbda <vfscanf+0x1e0>
    fb8c:	25 c0       	rjmp	.+74     	; 0xfbd8 <vfscanf+0x1de>
    fb8e:	13 37       	cpi	r17, 0x73	; 115
    fb90:	71 f0       	breq	.+28     	; 0xfbae <vfscanf+0x1b4>
    fb92:	15 37       	cpi	r17, 0x75	; 117
    fb94:	e9 f0       	breq	.+58     	; 0xfbd0 <vfscanf+0x1d6>
    fb96:	20 c0       	rjmp	.+64     	; 0xfbd8 <vfscanf+0x1de>
    fb98:	81 14       	cp	r8, r1
    fb9a:	91 04       	cpc	r9, r1
    fb9c:	29 f0       	breq	.+10     	; 0xfba8 <vfscanf+0x1ae>
    fb9e:	f4 01       	movw	r30, r8
    fba0:	60 82       	st	Z, r6
    fba2:	c4 01       	movw	r24, r8
    fba4:	01 96       	adiw	r24, 0x01	; 1
    fba6:	4c 01       	movw	r8, r24
    fba8:	fa 94       	dec	r15
    fbaa:	ff 20       	and	r15, r15
    fbac:	59 f0       	breq	.+22     	; 0xfbc4 <vfscanf+0x1ca>
    fbae:	c6 01       	movw	r24, r12
    fbb0:	64 d0       	rcall	.+200    	; 0xfc7a <fgetc>
    fbb2:	3c 01       	movw	r6, r24
    fbb4:	97 fd       	sbrc	r25, 7
    fbb6:	06 c0       	rjmp	.+12     	; 0xfbc4 <vfscanf+0x1ca>
    fbb8:	37 d0       	rcall	.+110    	; 0xfc28 <isspace>
    fbba:	89 2b       	or	r24, r25
    fbbc:	69 f3       	breq	.-38     	; 0xfb98 <vfscanf+0x19e>
    fbbe:	b6 01       	movw	r22, r12
    fbc0:	c3 01       	movw	r24, r6
    fbc2:	d5 d0       	rcall	.+426    	; 0xfd6e <ungetc>
    fbc4:	81 14       	cp	r8, r1
    fbc6:	91 04       	cpc	r9, r1
    fbc8:	a1 f0       	breq	.+40     	; 0xfbf2 <vfscanf+0x1f8>
    fbca:	f4 01       	movw	r30, r8
    fbcc:	10 82       	st	Z, r1
    fbce:	11 c0       	rjmp	.+34     	; 0xfbf2 <vfscanf+0x1f8>
    fbd0:	00 62       	ori	r16, 0x20	; 32
    fbd2:	03 c0       	rjmp	.+6      	; 0xfbda <vfscanf+0x1e0>
    fbd4:	00 61       	ori	r16, 0x10	; 16
    fbd6:	01 c0       	rjmp	.+2      	; 0xfbda <vfscanf+0x1e0>
    fbd8:	00 64       	ori	r16, 0x40	; 64
    fbda:	20 2f       	mov	r18, r16
    fbdc:	a4 01       	movw	r20, r8
    fbde:	6f 2d       	mov	r22, r15
    fbe0:	c6 01       	movw	r24, r12
    fbe2:	a8 dd       	rcall	.-1200   	; 0xf734 <conv_int>
    fbe4:	81 11       	cpse	r24, r1
    fbe6:	05 c0       	rjmp	.+10     	; 0xfbf2 <vfscanf+0x1f8>
    fbe8:	f6 01       	movw	r30, r12
    fbea:	83 81       	ldd	r24, Z+3	; 0x03
    fbec:	80 73       	andi	r24, 0x30	; 48
    fbee:	29 f4       	brne	.+10     	; 0xfbfa <vfscanf+0x200>
    fbf0:	06 c0       	rjmp	.+12     	; 0xfbfe <vfscanf+0x204>
    fbf2:	00 fd       	sbrc	r16, 0
    fbf4:	18 cf       	rjmp	.-464    	; 0xfa26 <vfscanf+0x2c>
    fbf6:	53 94       	inc	r5
    fbf8:	16 cf       	rjmp	.-468    	; 0xfa26 <vfscanf+0x2c>
    fbfa:	55 20       	and	r5, r5
    fbfc:	19 f0       	breq	.+6      	; 0xfc04 <vfscanf+0x20a>
    fbfe:	85 2d       	mov	r24, r5
    fc00:	90 e0       	ldi	r25, 0x00	; 0
    fc02:	02 c0       	rjmp	.+4      	; 0xfc08 <vfscanf+0x20e>
    fc04:	8f ef       	ldi	r24, 0xFF	; 255
    fc06:	9f ef       	ldi	r25, 0xFF	; 255
    fc08:	df 91       	pop	r29
    fc0a:	cf 91       	pop	r28
    fc0c:	1f 91       	pop	r17
    fc0e:	0f 91       	pop	r16
    fc10:	ff 90       	pop	r15
    fc12:	ef 90       	pop	r14
    fc14:	df 90       	pop	r13
    fc16:	cf 90       	pop	r12
    fc18:	bf 90       	pop	r11
    fc1a:	af 90       	pop	r10
    fc1c:	9f 90       	pop	r9
    fc1e:	8f 90       	pop	r8
    fc20:	7f 90       	pop	r7
    fc22:	6f 90       	pop	r6
    fc24:	5f 90       	pop	r5
    fc26:	08 95       	ret

0000fc28 <isspace>:
    fc28:	91 11       	cpse	r25, r1
    fc2a:	18 c1       	rjmp	.+560    	; 0xfe5c <__ctype_isfalse>
    fc2c:	80 32       	cpi	r24, 0x20	; 32
    fc2e:	19 f0       	breq	.+6      	; 0xfc36 <isspace+0xe>
    fc30:	89 50       	subi	r24, 0x09	; 9
    fc32:	85 50       	subi	r24, 0x05	; 5
    fc34:	d0 f7       	brcc	.-12     	; 0xfc2a <isspace+0x2>
    fc36:	08 95       	ret

0000fc38 <strchr_P>:
    fc38:	fc 01       	movw	r30, r24
    fc3a:	05 90       	lpm	r0, Z+
    fc3c:	06 16       	cp	r0, r22
    fc3e:	21 f0       	breq	.+8      	; 0xfc48 <strchr_P+0x10>
    fc40:	00 20       	and	r0, r0
    fc42:	d9 f7       	brne	.-10     	; 0xfc3a <strchr_P+0x2>
    fc44:	c0 01       	movw	r24, r0
    fc46:	08 95       	ret
    fc48:	31 97       	sbiw	r30, 0x01	; 1
    fc4a:	cf 01       	movw	r24, r30
    fc4c:	08 95       	ret

0000fc4e <strnlen_P>:
    fc4e:	fc 01       	movw	r30, r24
    fc50:	05 90       	lpm	r0, Z+
    fc52:	61 50       	subi	r22, 0x01	; 1
    fc54:	70 40       	sbci	r23, 0x00	; 0
    fc56:	01 10       	cpse	r0, r1
    fc58:	d8 f7       	brcc	.-10     	; 0xfc50 <strnlen_P+0x2>
    fc5a:	80 95       	com	r24
    fc5c:	90 95       	com	r25
    fc5e:	8e 0f       	add	r24, r30
    fc60:	9f 1f       	adc	r25, r31
    fc62:	08 95       	ret

0000fc64 <strnlen>:
    fc64:	fc 01       	movw	r30, r24
    fc66:	61 50       	subi	r22, 0x01	; 1
    fc68:	70 40       	sbci	r23, 0x00	; 0
    fc6a:	01 90       	ld	r0, Z+
    fc6c:	01 10       	cpse	r0, r1
    fc6e:	d8 f7       	brcc	.-10     	; 0xfc66 <strnlen+0x2>
    fc70:	80 95       	com	r24
    fc72:	90 95       	com	r25
    fc74:	8e 0f       	add	r24, r30
    fc76:	9f 1f       	adc	r25, r31
    fc78:	08 95       	ret

0000fc7a <fgetc>:
    fc7a:	cf 93       	push	r28
    fc7c:	df 93       	push	r29
    fc7e:	ec 01       	movw	r28, r24
    fc80:	2b 81       	ldd	r18, Y+3	; 0x03
    fc82:	20 ff       	sbrs	r18, 0
    fc84:	33 c0       	rjmp	.+102    	; 0xfcec <fgetc+0x72>
    fc86:	26 ff       	sbrs	r18, 6
    fc88:	0a c0       	rjmp	.+20     	; 0xfc9e <fgetc+0x24>
    fc8a:	2f 7b       	andi	r18, 0xBF	; 191
    fc8c:	2b 83       	std	Y+3, r18	; 0x03
    fc8e:	8e 81       	ldd	r24, Y+6	; 0x06
    fc90:	9f 81       	ldd	r25, Y+7	; 0x07
    fc92:	01 96       	adiw	r24, 0x01	; 1
    fc94:	8e 83       	std	Y+6, r24	; 0x06
    fc96:	9f 83       	std	Y+7, r25	; 0x07
    fc98:	8a 81       	ldd	r24, Y+2	; 0x02
    fc9a:	90 e0       	ldi	r25, 0x00	; 0
    fc9c:	29 c0       	rjmp	.+82     	; 0xfcf0 <fgetc+0x76>
    fc9e:	22 ff       	sbrs	r18, 2
    fca0:	0f c0       	rjmp	.+30     	; 0xfcc0 <fgetc+0x46>
    fca2:	e8 81       	ld	r30, Y
    fca4:	f9 81       	ldd	r31, Y+1	; 0x01
    fca6:	80 81       	ld	r24, Z
    fca8:	08 2e       	mov	r0, r24
    fcaa:	00 0c       	add	r0, r0
    fcac:	99 0b       	sbc	r25, r25
    fcae:	00 97       	sbiw	r24, 0x00	; 0
    fcb0:	19 f4       	brne	.+6      	; 0xfcb8 <fgetc+0x3e>
    fcb2:	20 62       	ori	r18, 0x20	; 32
    fcb4:	2b 83       	std	Y+3, r18	; 0x03
    fcb6:	1a c0       	rjmp	.+52     	; 0xfcec <fgetc+0x72>
    fcb8:	31 96       	adiw	r30, 0x01	; 1
    fcba:	e8 83       	st	Y, r30
    fcbc:	f9 83       	std	Y+1, r31	; 0x01
    fcbe:	0e c0       	rjmp	.+28     	; 0xfcdc <fgetc+0x62>
    fcc0:	ea 85       	ldd	r30, Y+10	; 0x0a
    fcc2:	fb 85       	ldd	r31, Y+11	; 0x0b
    fcc4:	19 95       	eicall
    fcc6:	97 ff       	sbrs	r25, 7
    fcc8:	09 c0       	rjmp	.+18     	; 0xfcdc <fgetc+0x62>
    fcca:	2b 81       	ldd	r18, Y+3	; 0x03
    fccc:	01 96       	adiw	r24, 0x01	; 1
    fcce:	11 f0       	breq	.+4      	; 0xfcd4 <fgetc+0x5a>
    fcd0:	80 e2       	ldi	r24, 0x20	; 32
    fcd2:	01 c0       	rjmp	.+2      	; 0xfcd6 <fgetc+0x5c>
    fcd4:	80 e1       	ldi	r24, 0x10	; 16
    fcd6:	82 2b       	or	r24, r18
    fcd8:	8b 83       	std	Y+3, r24	; 0x03
    fcda:	08 c0       	rjmp	.+16     	; 0xfcec <fgetc+0x72>
    fcdc:	2e 81       	ldd	r18, Y+6	; 0x06
    fcde:	3f 81       	ldd	r19, Y+7	; 0x07
    fce0:	2f 5f       	subi	r18, 0xFF	; 255
    fce2:	3f 4f       	sbci	r19, 0xFF	; 255
    fce4:	2e 83       	std	Y+6, r18	; 0x06
    fce6:	3f 83       	std	Y+7, r19	; 0x07
    fce8:	99 27       	eor	r25, r25
    fcea:	02 c0       	rjmp	.+4      	; 0xfcf0 <fgetc+0x76>
    fcec:	8f ef       	ldi	r24, 0xFF	; 255
    fcee:	9f ef       	ldi	r25, 0xFF	; 255
    fcf0:	df 91       	pop	r29
    fcf2:	cf 91       	pop	r28
    fcf4:	08 95       	ret

0000fcf6 <fputc>:
    fcf6:	0f 93       	push	r16
    fcf8:	1f 93       	push	r17
    fcfa:	cf 93       	push	r28
    fcfc:	df 93       	push	r29
    fcfe:	fb 01       	movw	r30, r22
    fd00:	23 81       	ldd	r18, Z+3	; 0x03
    fd02:	21 fd       	sbrc	r18, 1
    fd04:	03 c0       	rjmp	.+6      	; 0xfd0c <fputc+0x16>
    fd06:	8f ef       	ldi	r24, 0xFF	; 255
    fd08:	9f ef       	ldi	r25, 0xFF	; 255
    fd0a:	2c c0       	rjmp	.+88     	; 0xfd64 <fputc+0x6e>
    fd0c:	22 ff       	sbrs	r18, 2
    fd0e:	16 c0       	rjmp	.+44     	; 0xfd3c <fputc+0x46>
    fd10:	46 81       	ldd	r20, Z+6	; 0x06
    fd12:	57 81       	ldd	r21, Z+7	; 0x07
    fd14:	24 81       	ldd	r18, Z+4	; 0x04
    fd16:	35 81       	ldd	r19, Z+5	; 0x05
    fd18:	42 17       	cp	r20, r18
    fd1a:	53 07       	cpc	r21, r19
    fd1c:	44 f4       	brge	.+16     	; 0xfd2e <fputc+0x38>
    fd1e:	a0 81       	ld	r26, Z
    fd20:	b1 81       	ldd	r27, Z+1	; 0x01
    fd22:	9d 01       	movw	r18, r26
    fd24:	2f 5f       	subi	r18, 0xFF	; 255
    fd26:	3f 4f       	sbci	r19, 0xFF	; 255
    fd28:	20 83       	st	Z, r18
    fd2a:	31 83       	std	Z+1, r19	; 0x01
    fd2c:	8c 93       	st	X, r24
    fd2e:	26 81       	ldd	r18, Z+6	; 0x06
    fd30:	37 81       	ldd	r19, Z+7	; 0x07
    fd32:	2f 5f       	subi	r18, 0xFF	; 255
    fd34:	3f 4f       	sbci	r19, 0xFF	; 255
    fd36:	26 83       	std	Z+6, r18	; 0x06
    fd38:	37 83       	std	Z+7, r19	; 0x07
    fd3a:	14 c0       	rjmp	.+40     	; 0xfd64 <fputc+0x6e>
    fd3c:	8b 01       	movw	r16, r22
    fd3e:	ec 01       	movw	r28, r24
    fd40:	fb 01       	movw	r30, r22
    fd42:	00 84       	ldd	r0, Z+8	; 0x08
    fd44:	f1 85       	ldd	r31, Z+9	; 0x09
    fd46:	e0 2d       	mov	r30, r0
    fd48:	19 95       	eicall
    fd4a:	89 2b       	or	r24, r25
    fd4c:	e1 f6       	brne	.-72     	; 0xfd06 <fputc+0x10>
    fd4e:	d8 01       	movw	r26, r16
    fd50:	16 96       	adiw	r26, 0x06	; 6
    fd52:	8d 91       	ld	r24, X+
    fd54:	9c 91       	ld	r25, X
    fd56:	17 97       	sbiw	r26, 0x07	; 7
    fd58:	01 96       	adiw	r24, 0x01	; 1
    fd5a:	16 96       	adiw	r26, 0x06	; 6
    fd5c:	8d 93       	st	X+, r24
    fd5e:	9c 93       	st	X, r25
    fd60:	17 97       	sbiw	r26, 0x07	; 7
    fd62:	ce 01       	movw	r24, r28
    fd64:	df 91       	pop	r29
    fd66:	cf 91       	pop	r28
    fd68:	1f 91       	pop	r17
    fd6a:	0f 91       	pop	r16
    fd6c:	08 95       	ret

0000fd6e <ungetc>:
    fd6e:	fb 01       	movw	r30, r22
    fd70:	23 81       	ldd	r18, Z+3	; 0x03
    fd72:	20 ff       	sbrs	r18, 0
    fd74:	12 c0       	rjmp	.+36     	; 0xfd9a <ungetc+0x2c>
    fd76:	26 fd       	sbrc	r18, 6
    fd78:	10 c0       	rjmp	.+32     	; 0xfd9a <ungetc+0x2c>
    fd7a:	8f 3f       	cpi	r24, 0xFF	; 255
    fd7c:	3f ef       	ldi	r19, 0xFF	; 255
    fd7e:	93 07       	cpc	r25, r19
    fd80:	61 f0       	breq	.+24     	; 0xfd9a <ungetc+0x2c>
    fd82:	82 83       	std	Z+2, r24	; 0x02
    fd84:	2f 7d       	andi	r18, 0xDF	; 223
    fd86:	20 64       	ori	r18, 0x40	; 64
    fd88:	23 83       	std	Z+3, r18	; 0x03
    fd8a:	26 81       	ldd	r18, Z+6	; 0x06
    fd8c:	37 81       	ldd	r19, Z+7	; 0x07
    fd8e:	21 50       	subi	r18, 0x01	; 1
    fd90:	31 09       	sbc	r19, r1
    fd92:	26 83       	std	Z+6, r18	; 0x06
    fd94:	37 83       	std	Z+7, r19	; 0x07
    fd96:	99 27       	eor	r25, r25
    fd98:	08 95       	ret
    fd9a:	8f ef       	ldi	r24, 0xFF	; 255
    fd9c:	9f ef       	ldi	r25, 0xFF	; 255
    fd9e:	08 95       	ret

0000fda0 <__ultoa_invert>:
    fda0:	fa 01       	movw	r30, r20
    fda2:	aa 27       	eor	r26, r26
    fda4:	28 30       	cpi	r18, 0x08	; 8
    fda6:	51 f1       	breq	.+84     	; 0xfdfc <__ultoa_invert+0x5c>
    fda8:	20 31       	cpi	r18, 0x10	; 16
    fdaa:	81 f1       	breq	.+96     	; 0xfe0c <__ultoa_invert+0x6c>
    fdac:	e8 94       	clt
    fdae:	6f 93       	push	r22
    fdb0:	6e 7f       	andi	r22, 0xFE	; 254
    fdb2:	6e 5f       	subi	r22, 0xFE	; 254
    fdb4:	7f 4f       	sbci	r23, 0xFF	; 255
    fdb6:	8f 4f       	sbci	r24, 0xFF	; 255
    fdb8:	9f 4f       	sbci	r25, 0xFF	; 255
    fdba:	af 4f       	sbci	r26, 0xFF	; 255
    fdbc:	b1 e0       	ldi	r27, 0x01	; 1
    fdbe:	3e d0       	rcall	.+124    	; 0xfe3c <__ultoa_invert+0x9c>
    fdc0:	b4 e0       	ldi	r27, 0x04	; 4
    fdc2:	3c d0       	rcall	.+120    	; 0xfe3c <__ultoa_invert+0x9c>
    fdc4:	67 0f       	add	r22, r23
    fdc6:	78 1f       	adc	r23, r24
    fdc8:	89 1f       	adc	r24, r25
    fdca:	9a 1f       	adc	r25, r26
    fdcc:	a1 1d       	adc	r26, r1
    fdce:	68 0f       	add	r22, r24
    fdd0:	79 1f       	adc	r23, r25
    fdd2:	8a 1f       	adc	r24, r26
    fdd4:	91 1d       	adc	r25, r1
    fdd6:	a1 1d       	adc	r26, r1
    fdd8:	6a 0f       	add	r22, r26
    fdda:	71 1d       	adc	r23, r1
    fddc:	81 1d       	adc	r24, r1
    fdde:	91 1d       	adc	r25, r1
    fde0:	a1 1d       	adc	r26, r1
    fde2:	20 d0       	rcall	.+64     	; 0xfe24 <__ultoa_invert+0x84>
    fde4:	09 f4       	brne	.+2      	; 0xfde8 <__ultoa_invert+0x48>
    fde6:	68 94       	set
    fde8:	3f 91       	pop	r19
    fdea:	2a e0       	ldi	r18, 0x0A	; 10
    fdec:	26 9f       	mul	r18, r22
    fdee:	11 24       	eor	r1, r1
    fdf0:	30 19       	sub	r19, r0
    fdf2:	30 5d       	subi	r19, 0xD0	; 208
    fdf4:	31 93       	st	Z+, r19
    fdf6:	de f6       	brtc	.-74     	; 0xfdae <__ultoa_invert+0xe>
    fdf8:	cf 01       	movw	r24, r30
    fdfa:	08 95       	ret
    fdfc:	46 2f       	mov	r20, r22
    fdfe:	47 70       	andi	r20, 0x07	; 7
    fe00:	40 5d       	subi	r20, 0xD0	; 208
    fe02:	41 93       	st	Z+, r20
    fe04:	b3 e0       	ldi	r27, 0x03	; 3
    fe06:	0f d0       	rcall	.+30     	; 0xfe26 <__ultoa_invert+0x86>
    fe08:	c9 f7       	brne	.-14     	; 0xfdfc <__ultoa_invert+0x5c>
    fe0a:	f6 cf       	rjmp	.-20     	; 0xfdf8 <__ultoa_invert+0x58>
    fe0c:	46 2f       	mov	r20, r22
    fe0e:	4f 70       	andi	r20, 0x0F	; 15
    fe10:	40 5d       	subi	r20, 0xD0	; 208
    fe12:	4a 33       	cpi	r20, 0x3A	; 58
    fe14:	18 f0       	brcs	.+6      	; 0xfe1c <__ultoa_invert+0x7c>
    fe16:	49 5d       	subi	r20, 0xD9	; 217
    fe18:	31 fd       	sbrc	r19, 1
    fe1a:	40 52       	subi	r20, 0x20	; 32
    fe1c:	41 93       	st	Z+, r20
    fe1e:	02 d0       	rcall	.+4      	; 0xfe24 <__ultoa_invert+0x84>
    fe20:	a9 f7       	brne	.-22     	; 0xfe0c <__ultoa_invert+0x6c>
    fe22:	ea cf       	rjmp	.-44     	; 0xfdf8 <__ultoa_invert+0x58>
    fe24:	b4 e0       	ldi	r27, 0x04	; 4
    fe26:	a6 95       	lsr	r26
    fe28:	97 95       	ror	r25
    fe2a:	87 95       	ror	r24
    fe2c:	77 95       	ror	r23
    fe2e:	67 95       	ror	r22
    fe30:	ba 95       	dec	r27
    fe32:	c9 f7       	brne	.-14     	; 0xfe26 <__ultoa_invert+0x86>
    fe34:	00 97       	sbiw	r24, 0x00	; 0
    fe36:	61 05       	cpc	r22, r1
    fe38:	71 05       	cpc	r23, r1
    fe3a:	08 95       	ret
    fe3c:	9b 01       	movw	r18, r22
    fe3e:	ac 01       	movw	r20, r24
    fe40:	0a 2e       	mov	r0, r26
    fe42:	06 94       	lsr	r0
    fe44:	57 95       	ror	r21
    fe46:	47 95       	ror	r20
    fe48:	37 95       	ror	r19
    fe4a:	27 95       	ror	r18
    fe4c:	ba 95       	dec	r27
    fe4e:	c9 f7       	brne	.-14     	; 0xfe42 <__ultoa_invert+0xa2>
    fe50:	62 0f       	add	r22, r18
    fe52:	73 1f       	adc	r23, r19
    fe54:	84 1f       	adc	r24, r20
    fe56:	95 1f       	adc	r25, r21
    fe58:	a0 1d       	adc	r26, r0
    fe5a:	08 95       	ret

0000fe5c <__ctype_isfalse>:
    fe5c:	99 27       	eor	r25, r25
    fe5e:	88 27       	eor	r24, r24

0000fe60 <__ctype_istrue>:
    fe60:	08 95       	ret

0000fe62 <eeprom_read_byte>:
    fe62:	03 d0       	rcall	.+6      	; 0xfe6a <eeprom_mapen>
    fe64:	80 81       	ld	r24, Z
    fe66:	99 27       	eor	r25, r25
    fe68:	08 95       	ret

0000fe6a <eeprom_mapen>:
    fe6a:	e0 ec       	ldi	r30, 0xC0	; 192
    fe6c:	f1 e0       	ldi	r31, 0x01	; 1
    fe6e:	37 85       	ldd	r19, Z+15	; 0x0f
    fe70:	37 fd       	sbrc	r19, 7
    fe72:	fd cf       	rjmp	.-6      	; 0xfe6e <eeprom_mapen+0x4>
    fe74:	34 85       	ldd	r19, Z+12	; 0x0c
    fe76:	38 60       	ori	r19, 0x08	; 8
    fe78:	34 87       	std	Z+12, r19	; 0x0c
    fe7a:	fc 01       	movw	r30, r24
    fe7c:	e0 50       	subi	r30, 0x00	; 0
    fe7e:	f0 4f       	sbci	r31, 0xF0	; 240
    fe80:	08 95       	ret

0000fe82 <eeprom_update_byte>:
    fe82:	26 2f       	mov	r18, r22

0000fe84 <eeprom_update_r18>:
    fe84:	f2 df       	rcall	.-28     	; 0xfe6a <eeprom_mapen>
    fe86:	00 80       	ld	r0, Z
    fe88:	02 16       	cp	r0, r18
    fe8a:	11 f0       	breq	.+4      	; 0xfe90 <eeprom_update_r18+0xc>
    fe8c:	08 d0       	rcall	.+16     	; 0xfe9e <eeprom_write_r18>
    fe8e:	01 97       	sbiw	r24, 0x01	; 1
    fe90:	01 97       	sbiw	r24, 0x01	; 1
    fe92:	08 95       	ret

0000fe94 <eeprom_update_word>:
    fe94:	01 96       	adiw	r24, 0x01	; 1
    fe96:	27 2f       	mov	r18, r23
    fe98:	f5 df       	rcall	.-22     	; 0xfe84 <eeprom_update_r18>
    fe9a:	f3 cf       	rjmp	.-26     	; 0xfe82 <eeprom_update_byte>

0000fe9c <eeprom_write_byte>:
    fe9c:	26 2f       	mov	r18, r22

0000fe9e <eeprom_write_r18>:
    fe9e:	e0 ec       	ldi	r30, 0xC0	; 192
    fea0:	f1 e0       	ldi	r31, 0x01	; 1
    fea2:	37 85       	ldd	r19, Z+15	; 0x0f
    fea4:	37 fd       	sbrc	r19, 7
    fea6:	fd cf       	rjmp	.-6      	; 0xfea2 <eeprom_write_r18+0x4>
    fea8:	34 85       	ldd	r19, Z+12	; 0x0c
    feaa:	37 7f       	andi	r19, 0xF7	; 247
    feac:	34 87       	std	Z+12, r19	; 0x0c
    feae:	37 85       	ldd	r19, Z+15	; 0x0f
    feb0:	31 ff       	sbrs	r19, 1
    feb2:	09 c0       	rjmp	.+18     	; 0xfec6 <eeprom_write_r18+0x28>
    feb4:	36 e3       	ldi	r19, 0x36	; 54
    feb6:	32 87       	std	Z+10, r19	; 0x0a
    feb8:	38 ed       	ldi	r19, 0xD8	; 216
    feba:	34 bf       	out	0x34, r19	; 52
    febc:	31 e0       	ldi	r19, 0x01	; 1
    febe:	33 87       	std	Z+11, r19	; 0x0b
    fec0:	37 85       	ldd	r19, Z+15	; 0x0f
    fec2:	37 fd       	sbrc	r19, 7
    fec4:	fd cf       	rjmp	.-6      	; 0xfec0 <eeprom_write_r18+0x22>
    fec6:	33 e3       	ldi	r19, 0x33	; 51
    fec8:	32 87       	std	Z+10, r19	; 0x0a
    feca:	80 83       	st	Z, r24
    fecc:	91 83       	std	Z+1, r25	; 0x01
    fece:	12 82       	std	Z+2, r1	; 0x02
    fed0:	24 83       	std	Z+4, r18	; 0x04
    fed2:	25 e3       	ldi	r18, 0x35	; 53
    fed4:	22 87       	std	Z+10, r18	; 0x0a
    fed6:	28 ed       	ldi	r18, 0xD8	; 216
    fed8:	31 e0       	ldi	r19, 0x01	; 1
    feda:	24 bf       	out	0x34, r18	; 52
    fedc:	33 87       	std	Z+11, r19	; 0x0b
    fede:	01 96       	adiw	r24, 0x01	; 1
    fee0:	08 95       	ret

0000fee2 <__divmodsi4>:
    fee2:	05 2e       	mov	r0, r21
    fee4:	97 fb       	bst	r25, 7
    fee6:	16 f4       	brtc	.+4      	; 0xfeec <__divmodsi4+0xa>
    fee8:	00 94       	com	r0
    feea:	0f d0       	rcall	.+30     	; 0xff0a <__negsi2>
    feec:	57 fd       	sbrc	r21, 7
    feee:	05 d0       	rcall	.+10     	; 0xfefa <__divmodsi4_neg2>
    fef0:	14 d0       	rcall	.+40     	; 0xff1a <__udivmodsi4>
    fef2:	07 fc       	sbrc	r0, 7
    fef4:	02 d0       	rcall	.+4      	; 0xfefa <__divmodsi4_neg2>
    fef6:	46 f4       	brtc	.+16     	; 0xff08 <__divmodsi4_exit>
    fef8:	08 c0       	rjmp	.+16     	; 0xff0a <__negsi2>

0000fefa <__divmodsi4_neg2>:
    fefa:	50 95       	com	r21
    fefc:	40 95       	com	r20
    fefe:	30 95       	com	r19
    ff00:	21 95       	neg	r18
    ff02:	3f 4f       	sbci	r19, 0xFF	; 255
    ff04:	4f 4f       	sbci	r20, 0xFF	; 255
    ff06:	5f 4f       	sbci	r21, 0xFF	; 255

0000ff08 <__divmodsi4_exit>:
    ff08:	08 95       	ret

0000ff0a <__negsi2>:
    ff0a:	90 95       	com	r25
    ff0c:	80 95       	com	r24
    ff0e:	70 95       	com	r23
    ff10:	61 95       	neg	r22
    ff12:	7f 4f       	sbci	r23, 0xFF	; 255
    ff14:	8f 4f       	sbci	r24, 0xFF	; 255
    ff16:	9f 4f       	sbci	r25, 0xFF	; 255
    ff18:	08 95       	ret

0000ff1a <__udivmodsi4>:
    ff1a:	a1 e2       	ldi	r26, 0x21	; 33
    ff1c:	1a 2e       	mov	r1, r26
    ff1e:	aa 1b       	sub	r26, r26
    ff20:	bb 1b       	sub	r27, r27
    ff22:	fd 01       	movw	r30, r26
    ff24:	0d c0       	rjmp	.+26     	; 0xff40 <__udivmodsi4_ep>

0000ff26 <__udivmodsi4_loop>:
    ff26:	aa 1f       	adc	r26, r26
    ff28:	bb 1f       	adc	r27, r27
    ff2a:	ee 1f       	adc	r30, r30
    ff2c:	ff 1f       	adc	r31, r31
    ff2e:	a2 17       	cp	r26, r18
    ff30:	b3 07       	cpc	r27, r19
    ff32:	e4 07       	cpc	r30, r20
    ff34:	f5 07       	cpc	r31, r21
    ff36:	20 f0       	brcs	.+8      	; 0xff40 <__udivmodsi4_ep>
    ff38:	a2 1b       	sub	r26, r18
    ff3a:	b3 0b       	sbc	r27, r19
    ff3c:	e4 0b       	sbc	r30, r20
    ff3e:	f5 0b       	sbc	r31, r21

0000ff40 <__udivmodsi4_ep>:
    ff40:	66 1f       	adc	r22, r22
    ff42:	77 1f       	adc	r23, r23
    ff44:	88 1f       	adc	r24, r24
    ff46:	99 1f       	adc	r25, r25
    ff48:	1a 94       	dec	r1
    ff4a:	69 f7       	brne	.-38     	; 0xff26 <__udivmodsi4_loop>
    ff4c:	60 95       	com	r22
    ff4e:	70 95       	com	r23
    ff50:	80 95       	com	r24
    ff52:	90 95       	com	r25
    ff54:	9b 01       	movw	r18, r22
    ff56:	ac 01       	movw	r20, r24
    ff58:	bd 01       	movw	r22, r26
    ff5a:	cf 01       	movw	r24, r30
    ff5c:	08 95       	ret

0000ff5e <_exit>:
    ff5e:	f8 94       	cli

0000ff60 <__stop_program>:
    ff60:	ff cf       	rjmp	.-2      	; 0xff60 <__stop_program>
